function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function children(element) {
    return Array.from(element.childNodes);
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const viewBoxes = {
  M: "0 0 36 36",
  L: "0 0 48 48",
};

/* src/123.svelte generated by Svelte v3.24.1 */

function create_fragment(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.517 17.128c-.122 0-.17-.049-.17-.171v-2.416c0-.146 0-.244.146-.244l1.217-.011c1.709 0 2.636-.512 2.636-1.635\n    0-1.074-.9-1.782-2.685-1.782a7.513 7.513 0 0 0-3.612.928c-.146.073-.17 0-.17-.1V9.283c0-.147-.025-.2.122-.269a9.02\n    9.02 0 0 1 4.246-.951c3.222 0 5.223 1.61 5.223 4.149a3.459 3.459 0 0 1-2.148 3.2 3.877 3.877 0 0 1 2.9 3.807c0\n    3.125-2.88 4.784-6.248 4.784a8.8 8.8 0 0 1-4.174-.806c-.146-.048-.146-.194-.146-.316v-2.64c0-.1.122-.146.22-.1a8.336\n    8.336 0 0 0 3.978 1.025c2.2 0 3.051-.9 3.051-2.05 0-1.294-.928-2-2.954-2zM4.616 11.27a20.7 20.7 0 0\n    1-2.582.67c-.167.024-.215-.024-.215-.168V9.69c0-.119.024-.191.167-.215a15.37 15.37 0 0 0 3.092-1.22.884.884 0 0 1\n    .407-.12h2.353c.12 0 .144.072.144.167l-.006 12.813h2.14c.167 0 .215.072.239.216l.006\n    2.406c.024.191-.048.263-.191.263H2.327c-.167 0-.215-.072-.191-.215l-.006-2.454a.229.229 0 0 1\n    .263-.216h2.218zM12.014 24c-.168 0-.192-.072-.192-.215v-1.723a.34.34 0 0 1 .12-.311 58.939 58.939 0 0 0\n    4.5-4.045c1.89-1.842 2.713-3.033 2.713-4.373 0-1.507-1.23-2.39-3.048-2.39A8.593 8.593 0 0 0 12.253\n    12c-.144.072-.239.024-.239-.143V9.484a.271.271 0 0 1 .143-.287A9.108 9.108 0 0 1 16.9 8c3.518 0 5.183 2.1 5.332\n    4.771.12 2.163-.869 3.809-2.472 5.46a37.052 37.052 0 0 1-3.04 2.929c1.652 0 5.053-.045 6.465-.045.168 0\n    .191.048.168.216l-.714 2.478a.238.238 0 0 1-.264.191z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "123" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class _123 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/3DMaterials.svelte generated by Svelte v3.24.1 */

function create_fragment$1(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M11.493 27.963a.216.216 0 0 0-.283-.268c-.734.287-1.852.613-2.335.131-1.524-1.526 1.487-7.762\n    6.491-12.766s11.3-7.816 12.758-6.36a1.089 1.089 0 0 1 .253 1.011.219.219 0 0 0 .281.249 9.057 9.057 0 0 1\n    1.495-.326.421.421 0 0 0 .367-.379 2.248 2.248 0 0 0-.5-1.895L30 7.347v-.006A15.952 15.952 0 1 0 7.156\n    29.58a.784.784 0 0 0 .125.1l.01.012a2.087 2.087 0 0 0 1.532.529 6.5 6.5 0 0 0 2.014-.4.456.456 0 0 0 .3-.361 11.427\n    11.427 0 0 1 .356-1.497z");
			attr(path1, "d", "M33.5 14.729c-.293-1.771-.939-2.959-2.509-2.959-2.69 0-7.007 2.719-11 6.927-4.736 5-7.466 10.4-6.638 13.144a2.742\n    2.742 0 0 0 2.458 1.887 14.425 14.425 0 0 0 2.217.172 14.944 14.944 0 0 0 11-4.744A15.958 15.958 0 0 0 33.5 14.729z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "3DMaterials" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class _3DMaterials extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ABC.svelte generated by Svelte v3.24.1 */

function create_fragment$2(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M4.936 20.484l-1.1 3.322a.235.235 0 0 1-.259.194H.988c-.172 0-.216-.086-.172-.237 1.143-3.236 2.976-8.543\n    4.335-12.275a3.813 3.813 0 0 0 .216-1.337.136.136 0 0 1 .151-.151h3.473a.162.162 0 0 1 .173.108c1.575 4.336 3.3\n    9.276 4.9 13.676.064.151.021.216-.13.216h-2.85a.193.193 0 0 1-.216-.151L9.66 20.484zm4.055-2.459C8.56 16.558 7.7\n    14.1 7.265 12.545h-.021c-.324 1.467-1.1 3.732-1.661 5.48z");
			attr(path1, "d", "M14.045 10.257c0-.15.022-.193.129-.214.943-.022 2.743-.043 4.565-.043 4.436 0 5.379 1.95 5.379 3.686a3.1 3.1 0 0\n    1-2.036 3v.043a3.309 3.309 0 0 1 2.572 3.236c0 2.658-2.294 4.029-6.194 4.029-1.65.022-3.386-.021-4.265-.043a.17.17 0\n    0 1-.15-.193zm2.979 5.379h1.865c1.714 0 2.25-.707 2.25-1.628 0-1.158-.772-1.629-2.422-1.629-.836\n    0-1.5.021-1.693.043zm0 5.937c.236 0 .729.042 1.608.042 1.8 0 2.871-.471 2.871-1.8\n    0-1.114-.686-1.757-2.593-1.757h-1.886zM32.752 10a7.959 7.959 0 0 1 2.946.439c.1.063.126.1.126.251v2.21c0\n    .189-.1.189-.188.147a7.061 7.061 0 0 0-2.779-.523 4.175 4.175 0 0 0-4.535 4.43c0 3.427 2.466 4.388 4.514 4.388a8.49\n    8.49 0 0 0 2.925-.5c.1-.042.167 0 .167.125v2.152c0 .147-.021.23-.167.293a8.621 8.621 0 0 1-3.448.588c-3.74\n    0-7.041-2.069-7.041-6.958 0-3.991 2.928-7.042 7.48-7.042z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ABC" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ABC extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AEMScreens.svelte generated by Svelte v3.24.1 */

function create_fragment$3(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12 2H2a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zm0 20H2V4h10zM23.798 9.34a3.34 3.34 0 1 1\n    3.34 3.34 3.34 3.34 0 0 1-3.34-3.34zM32 18.702v6.088a.922.922 0 0 1-.91.934h-.908l-.91 9.342a.922.922 0 0\n    1-.908.934h-2.728a.922.922 0 0 1-.909-.934l-.909-9.342h-.909A.922.922 0 0 1 22 24.79v-6.088a4.901 4.901 0 0 1\n    4.833-4.967h.334A4.901 4.901 0 0 1 32 18.702zM36 3v12a1 1 0 0 1-1 1h-1.239a7.488 7.488 0 0\n    0-1.44-2H34V4H18v10h3.66a7.455 7.455 0 0 0-1.415 2H17a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AEMScreens" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AEMScreens extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Actions.svelte generated by Svelte v3.24.1 */

function create_fragment$4(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M25.535 21.338l-3.208 3.211 8.785 8.784a1.363 1.363 0 0 0 1.929 0l1.28-1.28a1.363 1.363 0 0 0 0-1.929zM6.658\n    19.531l1.452-1.452c.533-.533-.022-1.288-.022-1.288l1.492-1.438a1.363 1.363 0 0 0 1.92-.013l.811-.811 1.562 1.561\n    3.209-3.209-1.565-1.561.528-.529a1.363 1.363 0 0 0 0-1.929l-.64-.64s1.885-2.116 2.28-2.512c1.665-1.664 5.351-.591\n    5.521-1.443s-8.183-4.012-12.757.561L5.69 9.588a1.363 1.363 0 0 0 0 1.932l.322.31L4.6 13.3a.907.907 0 0\n    0-1.3-.035l-1.456 1.452a.682.682 0 0 0 0 .964l3.849 3.85a.681.681 0 0 0 .965 0zM11.041 30.523c-1.574.566-3.541\n    1.277-4.9 1.763l1.754-4.9zm18.2-26.366l-22.38 22.38a1.127 1.127 0 0 0-.264.413l-2.124 5.864a.84.84 0 0 0 1.1\n    1.109l5.894-2.1a1.127 1.127 0 0 0 .42-.267l22.375-22.4a.957.957 0 0 0 .087-1.346l-3.764-3.744a.957.957 0 0\n    0-1.344.091z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Actions" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Actions extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AdDisplay.svelte generated by Svelte v3.24.1 */

function create_fragment$5(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M22 8h8v14h-8z");
			attr(path1, "d", "M35 2H1a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h13v5a1 1 0 0 1-1 1h-2a.979.979 0 0 0-1 1v1h16v-1a1 1 0 0 0-1-1h-2a1 1 0 0\n    1-1-1v-5h13a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-3 22H4V6h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AdDisplay" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AdDisplay extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AdPrint.svelte generated by Svelte v3.24.1 */

function create_fragment$6(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 6H5a1 1 0 0 0-1 1v20a1 1 0 0 1-2 0V10.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V27a3 3 0 0 0 3 3h28a3 3 0 0 0\n    3-3V7a1 1 0 0 0-1-1zm-2 22H6V8h26v19a1 1 0 0 1-1 1z");
			attr(path1, "d", "M22 10h8v16h-8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AdPrint" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AdPrint extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Add.svelte generated by Svelte v3.24.1 */

function create_fragment$7(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29 16h-9V7a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v9H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h9v9a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1v-9h9a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Add" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Add extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AddCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$8(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm10 17a1 1 0 0 1-1 1h-7v7a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-7H9a1 1 0 0\n    1-1-1v-2a1 1 0 0 1 1-1h7V9a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v7h7a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AddCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AddCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AddTo.svelte generated by Svelte v3.24.1 */

function create_fragment$9(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 12V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h7v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V13a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AddTo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AddTo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AddToSelection.svelte generated by Svelte v3.24.1 */

function create_fragment$a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24.16 5.443l1.028-1.777a15.947 15.947 0 0 0-5.4-1.606v2.066a13.883 13.883 0 0 1 4.372 1.317zM29.53\n    10.066l1.8-1.035a16.133 16.133 0 0 0-3.852-3.97L26.44 6.849a14.066 14.066 0 0 1 3.09 3.217zM31.933 16.663H34a15.91\n    15.91 0 0 0-1.379-5.291L30.83 12.4a13.9 13.9 0 0 1 1.103 4.263zM31.933 19.337a13.9 13.9 0 0 1-1.1 4.258l1.791\n    1.032A15.91 15.91 0 0 0 34 19.337zM26.44 29.151l1.033 1.788a16.131 16.131 0 0 0 3.852-3.97l-1.8-1.035a14.066 14.066\n    0 0 1-3.085 3.217zM19.785 31.874v2.066a15.947 15.947 0 0 0 5.4-1.606l-1.025-1.777a13.883 13.883 0 0 1-4.375\n    1.317zM12.538 30.894l-1.028 1.777A15.993 15.993 0 0 0 17.107 34v-2.045a13.937 13.937 0 0 1-4.569-1.061zM6.739\n    26.293l-1.8 1.035a16.132 16.132 0 0 0 4.214 4.062l1.026-1.775a14.071 14.071 0 0 1-3.44-3.322zM4.067 19.337H2a15.9\n    15.9 0 0 0 1.574 5.694L5.365 24a13.889 13.889 0 0 1-1.298-4.663zM5.365 12l-1.791-1.031A15.9 15.9 0 0 0 2\n    16.663h2.067A13.889 13.889 0 0 1 5.365 12zM10.184 6.384L9.158 4.609a16.132 16.132 0 0 0-4.214 4.062l1.8 1.035a14.073\n    14.073 0 0 1 3.44-3.322zM17.107 4.045V2a15.99 15.99 0 0 0-5.6 1.329l1.027 1.777a13.937 13.937 0 0 1 4.573-1.061zM28\n    19a1 1 0 0 1-1 1h-7v7a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-7H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h7V9a1 1 0 0 1 1-1h2a1 1 0 0\n    1 1 1v7h7a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AddToSelection" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AddToSelection extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Airplane.svelte generated by Svelte v3.24.1 */

function create_fragment$b(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.254.34l-.655.129a9.579 9.579 0 0 0-4.939 2.628L22.238 9.52 3.12 4.305a2 2 0 0 0-1.94.516L0 6l16.558 9.2-2.96\n    2.96a8.47 8.47 0 0 0-.874 1.024l-3.344 4.62L1 23.429l-1 1 6.368 3.537-2.024 2.796a.64.64 0 0 0\n    .894.894l2.796-2.024L11.57 36l1-1-.375-8.38 4.62-3.344a8.47 8.47 0 0 0 1.024-.874l2.96-2.96L30 36l1.18-1.18a2 2 0 0\n    0 .515-1.94L26.48 13.762l6.421-6.422a9.583 9.583 0 0 0 2.63-4.94l.127-.654A1.198 1.198 0 0 0 34.254.341z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Airplane" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Airplane extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Alert.svelte generated by Svelte v3.24.1 */

function create_fragment$c(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M17.127 2.579L.4 32.512A1 1 0 0 0 1.272 34h33.456a1 1 0 0 0 .872-1.488L18.873 2.579a1 1 0 0 0-1.746 0zM20\n    29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-12a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Alert" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Alert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlertAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$d(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27a12.39 12.39 0 0 1 .219-2.278h-1.136a.405.405 0 0 1-.4-.405v-2.433a.406.406 0 0 1 .4-.406h2.237a12.322\n    12.322 0 0 1 6.909-6.078L15.708 2.482a.811.811 0 0 0-1.416 0L.725 26.76a.811.811 0 0 0 .708 1.207h13.316A12.37 12.37\n    0 0 1 14.7 27zM13.378 9.718a.406.406 0 0 1 .4-.406h2.434a.406.406 0 0 1 .405.406v9.733a.405.405 0 0\n    1-.405.405h-2.429a.405.405 0 0 1-.4-.405z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlertAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlertAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlertCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$e(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27a12.39 12.39 0 0 1 .219-2.278h-1.136a.405.405 0 0 1-.4-.405v-2.433a.406.406 0 0 1 .4-.406h2.237a12.322\n    12.322 0 0 1 6.909-6.078L15.708 2.482a.811.811 0 0 0-1.416 0L.725 26.76a.811.811 0 0 0 .708 1.207h13.316A12.37 12.37\n    0 0 1 14.7 27zM13.378 9.718a.406.406 0 0 1 .4-.406h2.434a.406.406 0 0 1 .405.406v9.733a.405.405 0 0\n    1-.405.405h-2.429a.405.405 0 0 1-.4-.405z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.037-1.037a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.703-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlertCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlertCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlertCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M15.691 25.772a2.268 2.268 0 0 1 2.232-2.304q.084 0 .168.004a2.232 2.232 0 0 1 2.4 2.3 2.181 2.181 0 0 1-2.4\n    2.234 2.182 2.182 0 0 1-2.4-2.234zm4.434-16.977a.416.416 0 0 1 .2.367v2.082c0 2.8-.567 7.96-.667 8.962 0\n    .1-.033.199-.234.199h-2.666a.221.221 0 0 1-.234-.2c-.066-.933-.6-6.06-.6-8.861V9.26a.355.355 0 0 1 .167-.366 5.766\n    5.766 0 0 1 2-.4 6.55 6.55 0 0 1 2.034.3zM35 18A17 17 0 1 1 18 1a17 17 0 0 1 17 17zm-3.65 0A13.35 13.35 0 1 0 18\n    31.35 13.35 13.35 0 0 0 31.35 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlertCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlertCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlertCircleFilled.svelte generated by Svelte v3.24.1 */

function create_fragment$g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-2.6 4.775a.711.711 0 0 1 .337-.675 6.246 6.246 0 0 1 2.225-.458 6.861\n    6.861 0 0 1 2.232.344.777.777 0 0 1 .4.687v2.45c0 2.885-.577 10.891-.683 11.947a.527.527 0 0 1-.587.52H16.6a.568.568\n    0 0 1-.578-.473c-.1-1.364-.622-9.1-.622-11.891zM18 28.85a2.574 2.574 0 0 1-2.8-2.631 2.66 2.66 0 0 1 2.8-2.7 2.632\n    2.632 0 0 1 2.8 2.7A2.574 2.574 0 0 1 18 28.85z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlertCircleFilled" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlertCircleFilled extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Algorithm.svelte generated by Svelte v3.24.1 */

function create_fragment$h(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 25.4h-.019l-3.335-5.478A3.588 3.588 0 0 0 25 13.9a3.53 3.53 0 0 0-.936.139l-3.418-5.615a3.6 3.6 0 1 0-5.292\n    0l-3.418 5.615A3.53 3.53 0 0 0 11 13.9a3.588 3.588 0 0 0-2.646 6.024L5.019 25.4H5A3.6 3.6 0 1 0 8.442 30h6.116a3.578\n    3.578 0 0 0 6.884 0h6.116A3.593 3.593 0 1 0 31 25.4zM27.558 28h-6.116a3.584 3.584 0 0 0-1.142-1.75l3.431-5.392A3.571\n    3.571 0 0 0 25 21.1a3.53 3.53 0 0 0 .936-.139l3.07 5.044A3.593 3.593 0 0 0 27.558 28zM18 9.6a3.543 3.543 0 0 0\n    .937-.139l3.417 5.615a3.617 3.617 0 0 0-.618.924h-7.472a3.6 3.6 0 0 0-.618-.924l3.417-5.615A3.543 3.543 0 0 0 18\n    9.6zM14.55 18h6.9a3.564 3.564 0 0 0 .678 1.65l-3.687 5.794A3.56 3.56 0 0 0 18 25.4a3.56 3.56 0 0\n    0-.441.044l-3.687-5.794A3.564 3.564 0 0 0 14.55 18zm-4.486 2.961A3.53 3.53 0 0 0 11 21.1a3.571 3.571 0 0 0\n    1.27-.242l3.43 5.392A3.584 3.584 0 0 0 14.558 28H8.442a3.593 3.593 0 0 0-1.448-2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Algorithm" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Algorithm extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Alias.svelte generated by Svelte v3.24.1 */

function create_fragment$i(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.241 2H12.8a.8.8 0 0 0-.8.806.785.785 0 0 0 .236.56l3.5 3.5a57.07 57.07 0 0 0-5.442 9.691 29.236 29.236 0 0\n    0-2.174 8.486c-.082.853-.12 1.7-.12 2.536a29.888 29.888 0 0 0 .576 5.753.827.827 0 0 0 1.618.023l.006-.023a25.346\n    25.346 0 0 1 2.594-6.919 22.717 22.717 0 0 1 4.3-5.429 48.574 48.574 0 0 1 7.33-5.429l4.209 4.209a.785.785 0 0 0\n    .56.236.8.8 0 0 0 .807-.8V2.759A.807.807 0 0 0 29.241 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Alias" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Alias extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlignBottom.svelte generated by Svelte v3.24.1 */

function create_fragment$j(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 26);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 10);
			attr(rect0, "x", rect0_x_value = 6);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 16);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 10);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 36);
			attr(rect2, "y", rect2_y_value = 32);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlignBottom" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlignBottom extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlignCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$k(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29 20H18v-4h7a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1h-7V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V6H9a1 1 0 0 0-1 1v8a1 1 0\n    0 0 1 1h7v4H5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h11v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V30h11a1 1 0 0 0 1-1v-8a1 1 0 0\n    0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlignCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlignCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlignLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$l(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 36);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect1, "height", rect1_height_value = 10);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 26);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 20);
			attr(rect2, "height", rect2_height_value = 10);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 16);
			attr(rect2, "x", rect2_x_value = 6);
			attr(rect2, "y", rect2_y_value = 6);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlignLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlignLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlignMiddle.svelte generated by Svelte v3.24.1 */

function create_fragment$m(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.5 16H30V9a1 1 0 0 0-1-1h-8a1 1 0 0 0-1 1v7h-4V5a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v11H.5a.5.5 0 0 0-.5.5v1a.5.5 0\n    0 0 .5.5H6v11a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V18h4v7a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-7h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0\n    0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlignMiddle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlignMiddle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlignRight.svelte generated by Svelte v3.24.1 */

function create_fragment$n(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 36);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 32);
			attr(rect1, "height", rect1_height_value = 10);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 26);
			attr(rect1, "x", rect1_x_value = 4);
			attr(rect1, "y", rect1_y_value = 20);
			attr(rect2, "height", rect2_height_value = 10);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 16);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 6);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlignRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlignRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlignTop.svelte generated by Svelte v3.24.1 */

function create_fragment$o(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 36);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 26);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 10);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 6);
			attr(rect2, "height", rect2_height_value = 16);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 10);
			attr(rect2, "x", rect2_x_value = 20);
			attr(rect2, "y", rect2_y_value = 6);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AlignTop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AlignTop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Amusementpark.svelte generated by Svelte v3.24.1 */

function create_fragment$p(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.371 22a10.71 10.71 0 0 0-6.969 3.093C17.804 20.944 14.02 16 7.896 16a12.449 12.449 0 0 0-5.285 1.266 1.001\n    1.001 0 0 0-.611.922V33.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V18.854a9.847 9.847 0 0 1 2-.648V33.5a.5.5 0 0 0\n    .5.5h3a.5.5 0 0 0 .5-.5V18.287a9.497 9.497 0 0 1 2 .761V33.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V22.082c.683.682 1.35\n    1.398 2 2.14V33.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-4.805a19.68 19.68 0 0 0 2 1.778V33.5a.5.5 0 0 0 .5.5h3a.5.5 0\n    0 0 .5-.5v-1.537a5.035 5.035 0 0 0 2-.17V33.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-6.646C34 23.995 31.212 22 28.371\n    22zm3.634 4.915A3.313 3.313 0 0 1 28.452 30c-1.414 0-2.645-.103-5.722-3.418A9.369 9.369 0 0 1 28.361 24c1.805 0\n    3.644 1.179 3.644 2.915zM35.993 13a2 2 0 0 1-2 2 1.86 1.86 0 0 1-.19-.039 10.912 10.912 0 0 1-1.095 3.183 1.959\n    1.959 0 0 1 1.092 2.689A9.1 9.1 0 0 0 29.58 19.1a8.95 8.95 0 0 0 2.37-5.601h-6.66a.5.5 0 0 1 0-1h6.659a8.92 8.92 0 0\n    0-2.267-5.477l-4.71 4.71a.5.5 0 0 1-.707-.707l4.71-4.71A8.92 8.92 0 0 0 23.5 4.05v6.659a.5.5 0 0 1-1 0V4.05a8.92\n    8.92 0 0 0-5.476 2.266l4.71 4.71a.5.5 0 1 1-.707.707l-4.71-4.71A8.92 8.92 0 0 0 14.05 12.5h6.659a.5.5 0 0 1 0\n    1H14.05c.027.332.046.665.1.989a14.108 14.108 0 0 0-5.138-1.395c-.001-.033-.019-.06-.019-.094a2 2 0 0 1 2-2 1.949\n    1.949 0 0 1 1.13.395c.03-.203.053-.409.094-.608a10.89 10.89 0 0 1 1.8-4.078A1.973 1.973 0 0 1 12.993 5a2 2 0 0 1 2-2\n    1.974 1.974 0 0 1 1.711 1.026 10.885 10.885 0 0 1 4.326-1.844c-.006-.063-.037-.117-.037-.182a2 2 0 0 1 4 0 1.88 1.88\n    0 0 1-.039.192 10.925 10.925 0 0 1 4.343 1.812A1.972 1.972 0 0 1 30.993 3a2 2 0 0 1 2 2 1.972 1.972 0 0 1-1.004\n    1.696 10.924 10.924 0 0 1 1.812 4.343 1.878 1.878 0 0 1 .192-.039 2 2 0 0 1 2 2zm-7.58 6.12l-4.147-4.146a.5.5 0 0 1\n    .707-.707l4.146 4.145a.5.5 0 1 1-.707.707zM23 21.464a.501.501 0 0 1-.5-.5V15.29a.5.5 0 0 1 1 0v5.674a.501.501 0 0\n    1-.5.5zm-4.92-3.045a.5.5 0 0 1-.353-.854l3.3-3.3a.5.5 0 0 1 .707.708l-3.3 3.3a.5.5 0 0 1-.354.146z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Amusementpark" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Amusementpark extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Anchor.svelte generated by Svelte v3.24.1 */

function create_fragment$q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.932 25.271L30 19.829l-4.1 5.442a.386.386 0 0 0 .252.629h2.5a11.062 11.062 0 0 1-8.7\n    3.9V17.212l2.08-.071a.718.718 0 0 0 .67-.759v-1.517a.718.718 0 0 0-.67-.759l-2.08.07-.024-2.119A5.925 5.925 0 0 0 23\n    7.16a5.165 5.165 0 0 0-4.989-5.2A5.289 5.289 0 0 0 13 7.275a5.663 5.663 0 0 0 3 4.782v2.049h-2.007a.718.718 0 0\n    0-.67.759v1.517a.718.718 0 0 0 .67.759H16v12.587A10.846 10.846 0 0 1 7.35 25.9H9.7a.387.387 0 0 0 .252-.629L6\n    19.829l-3.932 5.442a.386.386 0 0 0 .252.629h1.941c1.932 5.3 7.629 7.939 13.75 7.939S29.807 31.2 31.739\n    25.9h1.941a.386.386 0 0 0 .252-.629zM15.344 7.123a2.783 2.783 0 0 1 2.667-2.656 2.66 2.66 0 0 1 2.645 2.541 2.873\n    2.873 0 0 1-2.645 2.771 2.783 2.783 0 0 1-2.667-2.656z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Anchor" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Anchor extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AnchorSelect.svelte generated by Svelte v3.24.1 */

function create_fragment$r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 6l18 18H18l-8 8zM8.5 2.054a.5.5 0 0 0-.5.5v32.78a.5.5 0 0 0 .5.5.49.49 0 0 0 .35-.147L18.524 26h13a.5.5 0 0 0\n    .354-.854L8.854 2.2a.49.49 0 0 0-.354-.146z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AnchorSelect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AnchorSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Annotate.svelte generated by Svelte v3.24.1 */

function create_fragment$s(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24 32v-7a1 1 0 0 1 1-1h7a1.161 1.161 0 0 1-.254.854l-6.892 6.892A1.161 1.161 0 0 1 24 32z");
			attr(path1, "d", "M31 4H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h17v-8a2 2 0 0 1 2-2h8V5a1 1 0 0 0-1-1zM18\n    24h-8v-2h8zm8-6H10v-2h16zm0-6H10v-2h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Annotate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Annotate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AnnotatePen.svelte generated by Svelte v3.24.1 */

function create_fragment$t(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.023 4.36A.967.967 0 0 0 27.98 3a.963.963 0 0 0-1.362-.044 1.561 1.561 0 0 0-.118.144l-.011-.014-8.74\n    8.736.012.016a.721.721 0 0 0-.145.119.993.993 0 1 0 1.524 1.258l.013.013 8.739-8.737-.015-.014a.813.813 0 0 0\n    .146-.117zM29.8 5.883c-.72.721-9.537 9.645-9.588 9.7a2.214 2.214 0 0 1-2.362.029l-.767-.725L6.286 25.474a1.5 1.5 0 0\n    0-.327.48L4.088 32.36a.375.375 0 0 0 .5.491l6.428-1.951a1.5 1.5 0 0 0 .46-.313L33.06 9.079zM30.814 4.172l3.106\n    2.956a2.78 2.78 0 0 0-.807-3.228 3.3 3.3 0 0 0-3.22-1.06c-.179.064.065.3.138.375s.735.861.783.957zM3.723\n    27.486c-3.053-9.059.3-16.932 8.726-21.509 1.269-.69.268-2.706-1.01-2.012C2.19 8.992-1.077 17.405 2.286 27.5c1.437\n    4.314 1.437-.014 1.437-.014z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AnnotatePen" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AnnotatePen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Answer.svelte generated by Svelte v3.24.1 */

function create_fragment$u(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h11l3.536 6.839a.5.5 0 0 0 .928 0L22 28h11a1 1 0 0 0 1-1V3a1 1 0 0\n    0-1-1zM15.534 5.575a.306.306 0 0 1 .189-.336A7.962 7.962 0 0 1 18 4.873a9.1 9.1 0 0 1 2.311.274.366.366 0 0 1\n    .227.336v2.2c0 2.567-.643 9.216-.756 10.133 0 .092-.04.184-.266.184h-3.035a.24.24 0 0\n    1-.265-.184c-.075-.855-.682-7.475-.682-10.041zM18 24.729a2.519 2.519 0 0 1-2.7-2.661 2.624 2.624 0 0 1 2.7-2.739\n    2.582 2.582 0 0 1 2.7 2.739 2.52 2.52 0 0 1-2.7 2.661z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Answer" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Answer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AnswerFavorite.svelte generated by Svelte v3.24.1 */

function create_fragment$v(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24.215 23.5l2.312-4.737a.5.5 0 0 1 .9 0l2.353 4.716 5.22.736a.5.5 0 0 1 .281.851l-3.759 3.7.914 5.191a.5.5 0 0\n    1-.723.531l-4.677-2.433-4.654 2.473a.5.5 0 0 1-.731-.528l.868-5.2-3.79-3.662a.5.5 0 0 1 .271-.856z");
			attr(path1, "d", "M33 2H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h11l3.536 6.839a.5.5 0 0 0 .928\n    0l.007-.013.054-.323.775-4.642-4.842-4.679a1.989 1.989 0 0 1 .886-3.354A2.59 2.59 0 0 1 18 19.329a2.535 2.535 0 0 1\n    2.518 1.693l1.694-.254 2.954-6.051a2 2 0 0 1 3.586-.015l3.007 6.025 2.241.315V3a1 1 0 0 0-1-1zM20.534 7.683c0\n    2.567-.643 9.216-.757 10.133 0 .092-.039.184-.264.184h-3.032a.24.24 0 0\n    1-.265-.184c-.075-.855-.682-7.475-.682-10.041v-2.2a.306.306 0 0 1 .189-.336A7.962 7.962 0 0 1 18 4.873a9.114 9.114 0\n    0 1 2.312.274.367.367 0 0 1 .226.336z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AnswerFavorite" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AnswerFavorite extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/App.svelte generated by Svelte v3.24.1 */

function create_fragment$w(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M32 2H4a2 2 0 0 0-2 2v28a2 2 0 0 0 2 2h28a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zM18 30.2A12.2 12.2 0 1 1 30.2 18 12.2\n    12.2 0 0 1 18 30.2z");
			attr(path1, "d", "M15.591 20.484l-1.1 3.322a.234.234 0 0 1-.259.194h-2.589c-.172 0-.215-.086-.172-.237 1.143-3.236 2.977-8.543\n    4.336-12.275a3.849 3.849 0 0 0 .215-1.337.136.136 0 0 1 .151-.151h3.473a.162.162 0 0 1 .173.108c1.575 4.336 3.3\n    9.276 4.9 13.676.064.151.021.216-.13.216h-2.85a.193.193 0 0\n    1-.216-.151l-1.208-3.365zm4.055-2.459c-.431-1.467-1.294-3.926-1.725-5.48H17.9c-.324 1.467-1.1 3.732-1.661 5.48z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "App" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class App extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AppRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$x(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27 33.435a6.212 6.212 0 0 1-4.771-2.123L24.537 29H18v6.55l2.504-2.509A8.745 8.745 0 0 0 27 36a9.298 9.298 0 0 0\n    9-9h-2.28A6.889 6.889 0 0 1 27 33.435zm6.558-12.477A9.215 9.215 0 0 0 27 18a9.298 9.298 0 0 0-9 9h2.28A6.889 6.889 0\n    0 1 27 20.565a6.283 6.283 0 0 1 4.871 2.117L29.601 25H36v-6.535zm-17.327-5.287c-.538 0-.75\n    0-1.027-.016v-3.781c.18-.017.636-.033 1.206-.033 1.5 0 2.347.7 2.347 1.89 0 1.483-1.158 1.94-2.526\n    1.94zm-9.264-3.88c.326 1.142 1.092 3.407 1.435 4.484H5.55c.488-1.484 1.14-3.391 1.401-4.483zm20.89 1.94a1.689 1.689\n    0 0 1-.53 1.286c-.11-.003-.216-.017-.327-.017a12.004 12.004 0 0 0-2.696.315v-3.441c.179-.017.635-.033 1.205-.033 1.5\n    0 2.347.7 2.347 1.89zM15 27a12.003 12.003 0 0 1 7.331-11.058V10.31c0-.082.033-.131.115-.131.619-.016 1.825-.048\n    3.015-.048 3.162 0 4.335 1.76 4.335 3.553a3.83 3.83 0 0 1-.319 1.576 11.882 11.882 0 0 1 2.523.843v-8.88A7.222 7.222\n    0 0 0 24.778 0H7.222A7.222 7.222 0 0 0 0 7.222v17.556A7.222 7.222 0 0 0 7.222 32h8.88A11.936 11.936 0 0 1 15\n    27zm-3.143-6.13H10.03a.163.163 0 0 1-.162-.098l-.946-2.722H5.028l-.897 2.69a.162.162 0 0 1-.18.13h-1.63c-.097\n    0-.13-.048-.113-.163l3.358-9.551a2.485 2.485 0 0 0 .146-.88c0-.065.033-.114.098-.114h2.266c.081 0\n    .097.016.114.098l3.765 10.463c.016.099 0 .148-.098.148zm1.375-.114V10.31c0-.082.032-.131.114-.131.62-.016 1.826-.048\n    3.015-.048 3.162 0 4.335 1.76 4.335 3.553 0 2.592-2.004 3.716-4.465 3.716h-1.027v3.342c0\n    .08-.032.13-.13.13h-1.712c-.082 0-.13-.033-.13-.115z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AppRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AppRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AppleFiles.svelte generated by Svelte v3.24.1 */

function create_fragment$y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31.66 8H17.709a2.347 2.347 0 0 1-1.3-.393L11.59 4.393A2.343 2.343 0 0 0 10.292 4H4.34A2.34 2.34 0 0 0 2\n    6.34v21.32A2.34 2.34 0 0 0 4.34 30h27.32A2.34 2.34 0 0 0 34 27.66V10.34A2.34 2.34 0 0 0 31.66 8zM4 11.5A1.5 1.5 0 0\n    1 5.5 10h25a1.5 1.5 0 0 1 1.5 1.5v.5H4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AppleFiles" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AppleFiles extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ApplicationDelivery.svelte generated by Svelte v3.24.1 */

function create_fragment$z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9.9 26.469a3.2 3.2 0 0 1 .31-.469H3a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h22a1 1 0 0 1 1 1v7.028a2.868 2.868 0 0 1\n    2-.386V3a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v22a3 3 0 0 0 3 3h6.683a3.225 3.225 0 0 1 .217-1.531z");
			attr(path1, "d", "M34.08 17.905l-2.242.939a9.35 9.35 0 0 0-2.691-2.695l.924-2.258a.862.862 0 0 0-.472-1.125l-1.712-.7a.863.863 0 0\n    0-1.126.471l-.924 2.258a9.33 9.33 0 0 0-3.808.034l-.94-2.243a.862.862 0 0 0-1.13-.462l-1.592.667a.863.863 0 0 0-.463\n    1.129l.94 2.243a9.338 9.338 0 0 0-2.695 2.691l-2.257-.924a.862.862 0 0 0-1.126.471l-.7 1.713a.862.862 0 0 0 .471\n    1.125l2.258.925a9.312 9.312 0 0 0 .034 3.808l-2.243.94a.863.863 0 0 0-.462 1.13l.667 1.592a.862.862 0 0 0\n    1.13.462l2.242-.939a9.325 9.325 0 0 0 2.691 2.7l-.924 2.257a.862.862 0 0 0 .472 1.126l1.712.7a.863.863 0 0 0\n    1.126-.471l.924-2.258a9.329 9.329 0 0 0 3.808-.033l.94 2.242a.863.863 0 0 0 1.13.462l1.592-.667a.863.863 0 0 0\n    .463-1.13l-.94-2.242a9.313 9.313 0 0 0 2.7-2.691l2.257.924a.862.862 0 0 0 1.126-.472l.7-1.712a.862.862 0 0\n    0-.471-1.125l-2.257-.925a9.33 9.33 0 0 0-.035-3.808l2.243-.94a.863.863 0 0 0 .462-1.13l-.667-1.592a.862.862 0 0\n    0-1.135-.467zm-6.9 4.761a3.453 3.453 0 1 1-4.518-1.85 3.451 3.451 0 0 1 4.522 1.85z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ApplicationDelivery" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ApplicationDelivery extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ApproveReject.svelte generated by Svelte v3.24.1 */

function create_fragment$A(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24 12a12 12 0 0 0-12 12 11.831 11.831 0 0 0 12 11.8A11.662 11.662 0 0 0 35.8 24 11.831 11.831 0 0 0 24 12zm7.242\n    7.907l-7.224 9.434a1.206 1.206 0 0 1-.875.461h-.073a1.2 1.2 0 0 1-.849-.351l-4.837-4.847a1.2 1.2 0 0 1\n    0-1.7l1.327-1.325a1.2 1.2 0 0 1 1.7 0l2.4 2.4L27.89 17.3a1.2 1.2 0 0 1 1.686-.21l1.455 1.133a1.2 1.2 0 0 1 .211\n    1.684z");
			attr(path1, "d", "M11.521 14H5a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h11.26a15.9 15.9 0 0 1 7.055-1.965A11.818 11.818 0 0 0 12 .2 11.662\n    11.662 0 0 0 .2 12a11.819 11.819 0 0 0 7.834 11.315A15.921 15.921 0 0 1 11.521 14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ApproveReject" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ApproveReject extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Apps.svelte generated by Svelte v3.24.1 */

function create_fragment$B(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let rect8;
	let rect8_height_value;
	let rect8_rx_value;
	let rect8_ry_value;
	let rect8_width_value;
	let rect8_x_value;
	let rect8_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			rect8 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 6);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 6);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 2);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 26);
			attr(rect2, "y", rect2_y_value = 2);
			attr(rect3, "height", rect3_height_value = 6);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 6);
			attr(rect3, "x", rect3_x_value = 2);
			attr(rect3, "y", rect3_y_value = 14);
			attr(rect4, "height", rect4_height_value = 6);
			attr(rect4, "rx", rect4_rx_value = 1);
			attr(rect4, "ry", rect4_ry_value = 1);
			attr(rect4, "width", rect4_width_value = 6);
			attr(rect4, "x", rect4_x_value = 14);
			attr(rect4, "y", rect4_y_value = 14);
			attr(rect5, "height", rect5_height_value = 6);
			attr(rect5, "rx", rect5_rx_value = 1);
			attr(rect5, "ry", rect5_ry_value = 1);
			attr(rect5, "width", rect5_width_value = 6);
			attr(rect5, "x", rect5_x_value = 26);
			attr(rect5, "y", rect5_y_value = 14);
			attr(rect6, "height", rect6_height_value = 6);
			attr(rect6, "rx", rect6_rx_value = 1);
			attr(rect6, "ry", rect6_ry_value = 1);
			attr(rect6, "width", rect6_width_value = 6);
			attr(rect6, "x", rect6_x_value = 2);
			attr(rect6, "y", rect6_y_value = 26);
			attr(rect7, "height", rect7_height_value = 6);
			attr(rect7, "rx", rect7_rx_value = 1);
			attr(rect7, "ry", rect7_ry_value = 1);
			attr(rect7, "width", rect7_width_value = 6);
			attr(rect7, "x", rect7_x_value = 14);
			attr(rect7, "y", rect7_y_value = 26);
			attr(rect8, "height", rect8_height_value = 6);
			attr(rect8, "rx", rect8_rx_value = 1);
			attr(rect8, "ry", rect8_ry_value = 1);
			attr(rect8, "width", rect8_width_value = 6);
			attr(rect8, "x", rect8_x_value = 26);
			attr(rect8, "y", rect8_y_value = 26);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, rect8);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Apps" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Apps extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Archive.svelte generated by Svelte v3.24.1 */

function create_fragment$C(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 6);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 36);
			attr(rect, "y", rect_y_value = 4);
			attr(path, "d", "M2 12v19a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V12zm21 12H13a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v4a1 1 0 0\n    1-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Archive" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Archive extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArchiveRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$D(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_y_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(rect, "height", rect_height_value = 6);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "y", rect_y_value = 2);
			attr(path0, "d", "M27 18.1a8.85 8.85 0 1 0 0 17.7 8.85 8.85 0 0 0 0-17.7zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5z");
			attr(path1, "d", "M16.893 20H11a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v.769a12.109 12.109 0 0 1 8-.685V10H2v15a1 1 0 0 0 1\n    1h11.75a12.216 12.216 0 0 1 2.143-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ArchiveRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ArchiveRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowDown.svelte generated by Svelte v3.24.1 */

function create_fragment$E(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 20V3a1 1 0 0 0-1-1H13a1 1 0 0 0-1 1v17H5.007a.5.5 0 0 0-.354.854L18 34.2l13.346-13.346a.5.5 0 0 0-.353-.854z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ArrowDown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ArrowDown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$F(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 12h17a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H16v6.993a.5.5 0 0 1-.854.354L1.8 18 15.146 4.654a.5.5 0 0 1 .854.353z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ArrowLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ArrowLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowRight.svelte generated by Svelte v3.24.1 */

function create_fragment$G(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20 12H3a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h17v6.993a.5.5 0 0 0 .854.354L34.2 18 20.854 4.654a.5.5 0 0 0-.854.353z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ArrowRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ArrowRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowUp.svelte generated by Svelte v3.24.1 */

function create_fragment$H(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 16v17a1 1 0 0 1-1 1H13a1 1 0 0 1-1-1V16H5.007a.5.5 0 0 1-.354-.854L18 1.8l13.346 13.346a.5.5 0 0 1-.354.854z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ArrowUp" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ArrowUp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowUpRight.svelte generated by Svelte v3.24.1 */

function create_fragment$I(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26.2 18.284L12.181 32.3a1 1 0 0 1-1.414 0L3.7 25.233a1 1 0 0 1 0-1.414L17.716 9.8l-4.944-4.946A.5.5 0 0 1 13.125\n    4H32v18.875a.5.5 0 0 1-.854.353z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ArrowUpRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ArrowUpRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Artboard.svelte generated by Svelte v3.24.1 */

function create_fragment$J(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M8 9v24a1 1 0 0 0 1 1h24a1 1 0 0 0 1-1V14.914a1 1 0 0 0-.293-.707l-5.914-5.914A1 1 0 0 0 27.086 8H9a1 1 0 0 0-1\n    1zm24 23H10V10h16v5a1 1 0 0 0 1 1h5zM8 0h2v6H8zM0 8h6v2H0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Artboard" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Artboard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Article.svelte generated by Svelte v3.24.1 */

function create_fragment$K(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 10h10v2H20zM20 18h10v2H20zM6 22h12v2H6zM20 14h10v2H20zM20 22h10v2H20zM6 10h12v10H6z");
			attr(path1, "d", "M33 4H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM4 28V6h28v22z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Article" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Article extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Asset.svelte generated by Svelte v3.24.1 */

function create_fragment$L(ctx) {
	let svg;
	let path0;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			circle = svg_element("circle");
			path1 = svg_element("path");
			attr(path0, "d", "M14 16v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V16a2 2 0 0 0-2-2H16a2 2 0 0 0-2 2zm4 3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5zm0 7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h1a.5.5 0\n    0 1 .5.5zm0 7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5zm16-14a.5.5 0 0\n    1-.5.5h-1a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5zm0 7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3a.5.5 0\n    0 1 .5-.5h1a.5.5 0 0 1 .5.5zm0 7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5zM29.5\n    26h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5z");
			attr(circle, "cx", circle_cx_value = 25);
			attr(circle, "cy", circle_cy_value = 9);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path1, "d", "M12 12.343l-.728-.728a2 2 0 0 0-2.828 0L2 18.059V4h28v8h2V3a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, circle);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Asset" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Asset extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$M(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M18.189 7.906A1.806 1.806 0 1 0 16.383 6.1a1.806 1.806 0 0 0 1.806 1.806z");
			attr(path1, "d", "M10 10.2a3.447 3.447 0 0 0-2.1-1.375c-1.845 0-5.9 5.588-5.9 5.588V2h22v6h2V1a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v18a1 1\n    0 0 0 1 1h9z");
			attr(path2, "d", "M15.059 30H14.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h.256a12.2 12.2 0 0 1 .659-3H14.5a.5.5 0 0 1-.5-.5v-3a.5.5 0\n    0 1 .5-.5h1a.5.5 0 0 1 .5.5v2.12a12.218 12.218 0 0 1 14-6.436V12.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v3a.488.488 0 0\n    1-.127.307A12.268 12.268 0 0 1 34 16.993V12a2 2 0 0 0-2-2H14a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h1.721a12.114 12.114 0 0\n    1-.662-2zM14 12.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5z");
			attr(path3, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.037-1.037a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.703-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$M, create_fragment$M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetsAdded.svelte generated by Svelte v3.24.1 */

function create_fragment$N(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 24H4V4h28v11.624a12.045 12.045 0 0 1 2 1.458V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11a11.975\n    11.975 0 0 1 .181-2z");
			attr(path1, "d", "M26 16.05A9.95 9.95 0 1 0 35.95 26 9.95 9.95 0 0 0 26 16.05zm6 11.45a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0\n    1-.5.5h-3a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5H24v-3.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1\n    .5.5V24h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetsAdded" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetsAdded extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetsDownloaded.svelte generated by Svelte v3.24.1 */

function create_fragment$O(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 24H4V4h28v11.624a12.045 12.045 0 0 1 2 1.458V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11a11.975\n    11.975 0 0 1 .181-2z");
			attr(path1, "d", "M26 16.05A9.95 9.95 0 1 0 35.95 26 9.95 9.95 0 0 0 26 16.05zm-.17 16.181l-5.39-5.364a.5.5 0 0 1\n    .339-.867H24v-5.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5V26h3.221a.5.5 0 0 1 .339.867l-5.39 5.364a.25.25 0 0 1-.34 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetsDownloaded" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetsDownloaded extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$O, create_fragment$O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetsExpired.svelte generated by Svelte v3.24.1 */

function create_fragment$P(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.895 34.782l-11.18-20.007a.819.819 0 0 0-1.429 0L12.105 34.782A.819.819 0 0 0 12.82 36h22.36a.819.819 0 0 0\n    .715-1.218zm-10.527-1.974a.456.456 0 0 1-.456.456h-1.824a.456.456 0 0 1-.456-.456v-1.825a.456.456 0 0 1\n    .456-.456h1.824a.456.456 0 0 1 .456.456zm0-4.56a.456.456 0 0 1-.456.456h-1.824a.456.456 0 0\n    1-.456-.456v-8.21a.456.456 0 0 1 .456-.456h1.824a.456.456 0 0 1 .456.456z");
			attr(path1, "d", "M12.968 26h1.754l1.117-2H4V4h28v19.712l1.25 2.237A.986.986 0 0 0 34 25V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0\n    0 1 1h9.968z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetsExpired" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetsExpired extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$P, create_fragment$P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetsLinkedPublished.svelte generated by Svelte v3.24.1 */

function create_fragment$Q(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20.689 28.358l7.745 4.317a.7.7 0 0 0 .938-.312L34.9 18.6zM18 29.182v6.34a.426.426 0 0 0\n    .7.325l4.535-3.857zM7.662 24H4V4h28v10.506l2-.611V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h7.737z");
			attr(path1, "d", "M33.949 17.052l-21.921 6.742a.349.349 0 0 0-.056.647l6.064 2.966zM14.474 8.015h-.725a6.758 6.758 0 0\n    0-3.367.97A5.311 5.311 0 0 0 8.234 11.5a4.227 4.227 0 0 0-.156 2.4 5.187 5.187 0 0 0 2.534 3.252 9.092 9.092 0 0 0\n    4.616.831l1.588-.105-1.456-1.83a9.815 9.815 0 0 1-2.787-.231 3.569 3.569 0 0 1-2.309-1.612 2.637 2.637 0 0 1\n    .072-2.552 3.985 3.985 0 0 1 3.2-1.615c.111-.008.74-.014.852-.017a4.937 4.937 0 0 1 2.42.488 3.018 3.018 0 0 1 1.644\n    2.172 1.552 1.552 0 0 0 .178.71.982.982 0 0 0 .376.288 2.962 2.962 0 0 0 1.435.307 4.887 4.887 0 0 0-1.621-4.423\n    6.542 6.542 0 0 0-4.346-1.548z");
			attr(path2, "d", "M21.567 18.011h.725a6.758 6.758 0 0 0 3.367-.97 5.311 5.311 0 0 0 2.149-2.511 4.227 4.227 0 0 0 .156-2.4 5.187\n    5.187 0 0 0-2.534-3.26 9.092 9.092 0 0 0-4.616-.831l-1.588.105 1.456 1.83a9.815 9.815 0 0 1 2.787.231 3.569 3.569 0\n    0 1 2.309 1.612 2.637 2.637 0 0 1-.072 2.552 3.985 3.985 0 0 1-3.2 1.615c-.111.008-.74.014-.852.017a4.937 4.937 0 0\n    1-2.42-.488 3.018 3.018 0 0 1-1.644-2.172 1.552 1.552 0 0 0-.178-.71.982.982 0 0 0-.376-.288 2.962 2.962 0 0\n    0-1.435-.307 4.887 4.887 0 0 0 1.621 4.423 6.542 6.542 0 0 0 4.345 1.552z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetsLinkedPublished" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetsLinkedPublished extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetsModified.svelte generated by Svelte v3.24.1 */

function create_fragment$R(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M13.014 25.941L14.955 24H4V4h28v5.982a3.189 3.189 0 0 1 1.023.688l.977.977V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1\n    0 0 0 1 1h9.968c.017-.018.032-.041.046-.059z");
			attr(path1, "d", "M35.645 16.685l-4.323-4.323a.911.911 0 0 0-.65-.265h-.029a1.028 1.028 0 0 0-.7.3L14.711 27.639a.748.748 0 0\n    0-.188.316l-2.443 7.34c-.085.282.344.638.587.638a.206.206 0 0 0 .046 0c.207-.048 6.26-2.118 7.344-2.444a.735.735 0 0\n    0 .311-.187L35.6 18.059a1.031 1.031 0 0 0 .3-.662.916.916 0 0 0-.255-.712zM14.039 33.973l1.978-5.519 3.54\n    3.531c-1.621.487-4.118 1.57-5.518 1.988z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetsModified" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetsModified extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$R, create_fragment$R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AssetsPublished.svelte generated by Svelte v3.24.1 */

function create_fragment$S(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M19.237 26.8l9.084 5.063a.819.819 0 0 0 1.1-.366l6.485-16.146zM16.083 27.763V35.2a.5.5 0 0 0\n    .824.381l5.32-4.525zM7.662 24H4V4h28v7.8l1.96-.611H34V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h8.667z");
			attr(path1, "d", "M34.791 13.535L9.078 21.444a.409.409 0 0 0-.066.759l7.114 3.479z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AssetsPublished" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AssetsPublished extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$S, create_fragment$S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Asterisk.svelte generated by Svelte v3.24.1 */

function create_fragment$T(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.585 29.5c.249.25.417.584 0 .917l-5.167 3.334c-.417.25-.583.083-.751-.334l-6.416-11.169L8.833\n    31.5c-.083.166-.333.332-.582 0l-4-4.168c-.417-.25-.334-.5 0-.749l9.5-7.918L2.917 14.58c-.168\n    0-.417-.332-.251-.749L5.5 8.164A.438.438 0 0 1 6.25 8l9.5 6.167L16.335 2a.439.439 0 0 1 .5-.5l6.917.916c.417 0\n    .5.167.417.584l-3.251 11.914 11-3.333c.249-.167.5-.167.666.333l1.084 6.167c.083.416 0 .583-.334.583l-11.5.917z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Asterisk" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Asterisk extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$T, create_fragment$T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/At.svelte generated by Svelte v3.24.1 */

function create_fragment$U(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24.194 25.154c2.1-.429 6.515-2.615 6.515-9.387 0-7.2-4.844-11.53-11.53-11.53-7.587 0-13.759 5.1-13.759 14.4 0\n    6.472 2.914 10.93 8.015 13.545a.408.408 0 0 1 .214.385l-.085 2.833c0 .215-.043.215-.215.172A17.33 17.33 0 0 1 2.162\n    18.81c0-10.115 7.03-17.4 17.145-17.4 8.059 0 14.531 5.229 14.531 14.1 0 8.7-6.387 12.945-13.673 12.945-5.658\n    0-9.559-3.172-9.559-9.3A9.729 9.729 0 0 1 20.593 9.08a11.411 11.411 0 0 1\n    4.287.686c.171.043.214.086.214.257zm-2.272-13.116a5.746 5.746 0 0 0-1.757-.214c-3.944 0-6.43 3.129-6.43 7.072 0\n    3.729 1.972 6.687 6.087 6.687a5.285 5.285 0 0 0 1.328-.129z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "At" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class At extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$U, create_fragment$U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Attach.svelte generated by Svelte v3.24.1 */

function create_fragment$V(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16.207 31.557a6.64 6.64 0 0 1-4.728 1.97h-.106a6.976 6.976 0 0 1-4.827-2.075 6.764 6.764 0 0\n    1-.1-9.661l17.779-17.8a4.874 4.874 0 0 1 3.133-1.479 3.72 3.72 0 0 1 3.042 1.12A3.537 3.537 0 0 1 31.517 6.7a5.74\n    5.74 0 0 1-1.584 3L18.072 21.541c-.764.765-1.483 1.315-2.3.5s-.176-1.569.526-2.271c.267-.267 8.248-8.238\n    9.673-9.659a.732.732 0 0 0 .014-1.021l-.675-.718a.735.735 0 0 0-1.056-.015L14.3 18.344a3.632 3.632 0 0 0-.072\n    5.469c2.661 2.66 5.683-.591 5.683-.591L31.7 11.466c2.508-2.5 3.47-6.6.472-9.6A6.227 6.227 0 0 0 27.589 0a7.275 7.275\n    0 0 0-5.132 2.227L4.76 19.9A9.433 9.433 0 0 0 18.1 33.24l15.405-15.4a.735.735 0 0 0 0-1.038l-.75-.751a.735.735 0 0\n    0-1.039 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Attach" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Attach extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$V, create_fragment$V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AttachmentExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$W(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M15.77 22.036c-.821-.82-.176-1.569.526-2.271.267-.267 8.248-8.238 9.673-9.659a.731.731 0 0 0\n    .013-1.021l-.674-.718a.734.734 0 0 0-1.056-.015L14.3 18.344a3.631 3.631 0 0 0-.071 5.469 3.876 3.876 0 0 0 .778.6\n    12.161 12.161 0 0 1 .787-2.358z");
			attr(path1, "d", "M15.706 31.97a6.6 6.6 0 0 1-4.227 1.557h-.106a6.972 6.972 0 0 1-4.826-2.075 6.765 6.765 0 0\n    1-.106-9.661l17.78-17.8a4.874 4.874 0 0 1 3.133-1.479A3.723 3.723 0 0 1 30.4 3.631 3.54 3.54 0 0 1 31.517 6.7a5.732\n    5.732 0 0 1-1.584 3l-5.348 5.34a12.237 12.237 0 0 1 3.7-.172l3.411-3.4c2.509-2.5 3.471-6.6.473-9.6A6.227 6.227 0 0 0\n    27.59 0a7.274 7.274 0 0 0-5.133 2.227L4.76 19.9a9.415 9.415 0 0 0 12.191 14.278 12.231 12.231 0 0 1-1.245-2.208z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.929 6.929 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AttachmentExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AttachmentExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Attributes.svelte generated by Svelte v3.24.1 */

function create_fragment$X(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.25 5.634V3a1 1 0 0 1 1-1h1.5a1 1 0 0 1 1 1v1H24v2H9.756a11.028 11.028 0 0 0 .869 4H22a2 2 0 0 1-2\n    2h-8.214a7.636 7.636 0 0 0 2.628 2.219l1.358.682-3.827 1.921-.011.006A13.187 13.187 0 0 1 6.25 5.634zm17.817\n    13.5l-.012.006-3.826 1.92 1.357.681A7.675 7.675 0 0 1 24.247 24H16a2 2 0 0 0-2 2h11.394a11.048 11.048 0 0 1 .851\n    4H12v2h14.25v1a1 1 0 0 0 1 1h1.5a1 1 0 0 0 1-1v-2.678a13.189 13.189 0 0 0-5.683-11.193zM28.75 2h-1.5a1 1 0 0 0-1\n    1v2.634c0 3.793-1.83 7.163-4.664 8.586l-8.742 4.389c-4.006 2.012-6.594 6.61-6.594 11.713V33a1 1 0 0 0 1 1h1.5a1 1 0\n    0 0 1-1v-2.678c0-3.792 1.83-7.162 4.664-8.586l8.742-4.388c4.006-2.012 6.594-6.61 6.594-11.714V3a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Attributes" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Attributes extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$X, create_fragment$X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Audio.svelte generated by Svelte v3.24.1 */

function create_fragment$Y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 3.417a1 1 0 0 0-1.268-.965l-16 4.447a1 1 0 0 0-.732.964v16.55a6.628 6.628 0 0 0-6.144.057c-3.113 1.515-4.687\n    4.7-3.515 7.1s4.646 3.136 7.759 1.62a6.434 6.434 0 0 0 3.9-5.333V12.824l14-4v11.589a6.628 6.628 0 0\n    0-6.144.057c-3.113 1.515-4.687 4.7-3.515 7.1s4.646 3.132 7.759 1.616a6.427 6.427 0 0 0 3.9-5.353V3.417z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Audio" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Audio extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/AutomatedSegment.svelte generated by Svelte v3.24.1 */

function create_fragment$Z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.514 14.337l.078 2.248a1.834 1.834 0 0 0 .939 1.533l1.963 1.1-2.248.078a1.834 1.834 0 0 0-1.533.939l-1.1\n    1.963-.079-2.248a1.83 1.83 0 0 0-.939-1.533l-1.961-1.095 2.248-.079a1.83 1.83 0 0 0 1.538-.943zM6.8 1.044l.113\n    3.134a2.556 2.556 0 0 0 1.3 2.137l2.736 1.532-3.126.113a2.553 2.553 0 0 0-2.137 1.305L4.154 12l-.113-3.133A2.553\n    2.553 0 0 0 2.736 6.73L0 5.2l3.133-.114A2.552 2.552 0 0 0 5.27 3.78zM26 9.565A1.565 1.565 0 0 0 24.435\n    8H14v1.129a1.48 1.48 0 0 1-1.366 1.562l-4.6.181a1.207 1.207 0 0 0-1.024.655L6 13.5v18.94A1.565 1.565 0 0 0 7.565\n    34h16.87A1.565 1.565 0 0 0 26 32.435zM8 14h5.5v2H8zm0 4h9v2H8zm0 4h10.75v2H8zm16 6H8v-2h16zM28.274 0l.3 2.229a1.83\n    1.83 0 0 0 1.085 1.434l2.06.9-2.229.3a1.834 1.834 0 0 0-1.434 1.085L27.155 8l-.3-2.229a1.834 1.834 0 0\n    0-1.085-1.434l-2.059-.9 2.23-.3a1.83 1.83 0 0 0 1.436-1.077z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "AutomatedSegment" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class AutomatedSegment extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Back.svelte generated by Svelte v3.24.1 */

function create_fragment$_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 10V5.207a.5.5 0 0 0-.854-.354L0 14l9.146 9.146a.5.5 0 0 0 .854-.353V18h16v13a1 1 0 0 0 1 1h6a1 1 0 0 0\n    1-1V16a6 6 0 0 0-6-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Back" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Back extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$_, create_fragment$_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Back30Seconds.svelte generated by Svelte v3.24.1 */

function create_fragment$$(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M24.031 2.675L25.853.854A.49.49 0 0 0 26 .5a.5.5 0 0 0-.5-.5h-5.053A.5.5 0 0 0 20 .447V5.5a.5.5 0 0 0\n    .5.5.494.494 0 0 0 .35-.147l1.58-1.58a14.44 14.44 0 0 1-1.93 27.994.6.6 0 0 0-.5.585V33.9a.408.408 0 0 0 .463.4\n    16.471 16.471 0 0 0 3.568-31.625z");
			attr(path1, "d", "M27.773 17.968c0-3.259-.986-6.968-4.931-6.968-3.216 0-4.995 2.98-4.995 6.968 0 3.923 1.479 7.032 5.016 7.032\n    3.602 0 4.91-3.43 4.91-7.032zM20.44 17.9c0-3.281.987-4.717 2.359-4.717 1.587 0 2.4 1.5 2.4 4.759 0 3.131-.707\n    4.824-2.337 4.824S20.44 20.948 20.44 17.9zM15.5 32.267a14.481 14.481 0 0 1 0-28.534.6.6 0 0 0 .5-.585V2.1a.408.408 0\n    0 0-.463-.4 16.487 16.487 0 0 0 0 32.608A.408.408 0 0 0 16 33.9v-1.048a.6.6 0 0 0-.5-.585z");
			attr(path2, "d", "M14.052 17.475a3.114 3.114 0 0 0 1.761-2.852c0-2.165-1.529-3.623-4.025-3.623a6.385 6.385 0 0\n    0-3.271.836c-.117.064-.1.107-.1.215v1.972c0 .086.019.128.136.086a5.1 5.1 0 0 1 2.786-.815c1.471 0 2.187.665 2.187\n    1.672 0 1.072-.812 1.587-2.225 1.587h-.968c-.1 0-.116.064-.116.193V18.7c0 .107.039.15.135.15h1.123c1.664 0 2.516.643\n    2.516 1.908 0 1.093-.716 1.951-2.516 1.951a5.806 5.806 0 0 1-3.078-.9.111.111 0 0 0-.173.085v2.123c0\n    .107.019.236.116.278a6.239 6.239 0 0 0 3.215.705c2.652 0 4.839-1.479 4.839-4.181a3.315 3.315 0 0 0-2.342-3.344z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Back30Seconds" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Back30Seconds extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BackAndroid.svelte generated by Svelte v3.24.1 */

function create_fragment$10(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.5 16.08h-28l9.94-9.94a.967.967 0 0 0 0-1.4l-.7-.72a1.027 1.027 0 0 0-1.42 0L2.48 16.88a1.027 1.027 0 0 0 0\n    1.42l12.78 13.68a1.027 1.027 0 0 0 1.42 0l.7-.7a1.027 1.027 0 0 0 0-1.42L7.52 19H35.5a.5.5 0 0 0 .5-.5v-1.92a.5.5 0\n    0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$10($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BackAndroid" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BackAndroid extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Beaker.svelte generated by Svelte v3.24.1 */

function create_fragment$11(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.072 31.759L24 14V4h1a1 1 0 0 0 1-1V1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h1v10L2.928 31.759A3 3 0 0\n    0 5.659 36h24.682a3 3 0 0 0 2.731-4.241zM8.727 24.364L14 14.454V4h8v10.455l2.636 4.909z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$11($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Beaker" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Beaker extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$11, create_fragment$11, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BeakerCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$12(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.128a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.004z");
			attr(path1, "d", "M14.7 27a12.229 12.229 0 0 1 1.34-5.563l-9.312 2.927L12 14.453V4h8v10.454l.98 1.825a12.231 12.231 0 0 1\n    1.77-.81L22 14V4h1a1 1 0 0 0 1-1V1a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h1v10L.928 31.759A3 3 0 0 0 3.659\n    36h14.977a12.252 12.252 0 0 1-3.936-9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$12($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BeakerCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BeakerCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BeakerShare.svelte generated by Svelte v3.24.1 */

function create_fragment$13(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M12 35V23a2.976 2.976 0 0 1 .031-.3l-5.3 1.667L12 14.453V4h8v9.45l2-2.218V4h1a1 1 0 0 0 1-1V1a1 1 0 0 0-1-1H9a1 1\n    0 0 0-1 1v2a1 1 0 0 0 1 1h1v10L.928 31.759A3 3 0 0 0 3.659 36h8.525A2.972 2.972 0 0 1 12 35z");
			attr(path1, "d", "M29.722 18.331L24 12l-5.708 6.331A1 1 0 0 0 19.035 20H22v7.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V20h2.979a1 1 0 0\n    0 .743-1.669z");
			attr(path2, "d", "M30 22v10H18V22h-3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V23a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$13($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BeakerShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BeakerShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$13, create_fragment$13, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Bell.svelte generated by Svelte v3.24.1 */

function create_fragment$14(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 36a4.406 4.406 0 0 0 4-4h-8a4.406 4.406 0 0 0 4 4zM27.143 11.385c0-3.437-3.206-4.891-7.143-5.268V3a1.079\n    1.079 0 0 0-1.143-1h-1.714A1.079 1.079 0 0 0 16 3v3.117c-3.937.377-7.143 1.831-7.143 5.268C8.857 26.8 4 26.111 4\n    28.154V30h28v-1.846C32 26 27.143 26.8 27.143 11.385z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$14($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Bell" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Bell extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$14, create_fragment$14, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BidRule.svelte generated by Svelte v3.24.1 */

function create_fragment$15(ctx) {
	let svg;
	let path0;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M18 12l6-6 5.999 6-6 6z");
			attr(rect0, "height", rect0_height_value = 3.155);
			attr(rect0, "rx", rect0_rx_value = 0.789);
			attr(rect0, "ry", rect0_ry_value = 0.789);
			attr(rect0, "transform", "rotate(-44.995 30.008 18.01)");
			attr(rect0, "width", rect0_width_value = 12.619);
			attr(rect0, "x", rect0_x_value = 23.7);
			attr(rect0, "y", rect0_y_value = 16.432);
			attr(rect1, "height", rect1_height_value = 3.155);
			attr(rect1, "rx", rect1_rx_value = 0.789);
			attr(rect1, "ry", rect1_ry_value = 0.789);
			attr(rect1, "transform", "rotate(-44.995 18.023 6.023)");
			attr(rect1, "width", rect1_width_value = 12.619);
			attr(rect1, "x", rect1_x_value = 11.713);
			attr(rect1, "y", rect1_y_value = 4.445);
			attr(path1, "d", "M4.06 34.06l-2.12-2.12a1.5 1.5 0 0 1 0-2.122L18 15l3 3L6.182 34.06a1.5 1.5 0 0 1-2.122 0zM34 30v-1a1 1 0 0\n    0-1-1H23a1 1 0 0 0-1 1v1h-1.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h15a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$15($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BidRule" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BidRule extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$15, create_fragment$15, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BidRuleAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$16(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 3.155);
			attr(rect, "rx", rect_rx_value = 0.789);
			attr(rect, "ry", rect_ry_value = 0.789);
			attr(rect, "transform", "rotate(-44.995 18.023 6.023)");
			attr(rect, "width", rect_width_value = 12.619);
			attr(rect, "x", rect_x_value = 11.713);
			attr(rect, "y", rect_y_value = 4.445);
			attr(path, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5zM33.61 16.639l1.418-1.418a.789.789 0 0 0 0-1.116l-1.115-1.115a.789.789 0 0 0-1.116 0l-2.237 2.238a12.207 12.207\n    0 0 1 3.05 1.411zM27 14.7c.1 0 .189.012.286.014L30 12l-6-6-6 6 3.844 3.844A12.231 12.231 0 0 1 27 14.7zM19.938\n    16.938L18 15 1.939 29.818a1.5 1.5 0 0 0 0 2.122l2.122 2.12a1.5 1.5 0 0 0 2.121 0l8.761-9.5a12.305 12.305 0 0 1\n    4.995-7.622z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$16($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BidRuleAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BidRuleAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$16, create_fragment$16, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Blower.svelte generated by Svelte v3.24.1 */

function create_fragment$17(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.828 7.341a6.329 6.329 0 0 0-6.4-1.957c-2.4.569-5.88 4.132-7.275 6.814-.053 0-.1-.016-.156-.016a5.754 5.754 0\n    0 0-2.629.655c1-3.959 3.853-7.267-.2-10.1C10.931.465 6.342 4.172 6.342 4.172a6.328 6.328 0 0 0-1.958 6.4c.569 2.4\n    4.132 5.88 6.814 7.275 0 .054-.016.1-.016.157a5.754 5.754 0 0 0 .655 2.629c-3.959-1-7.267-3.852-10.1.2-2.27 3.244\n    1.436 7.832 1.436 7.832a6.328 6.328 0 0 0 6.4 1.958c2.4-.569 5.88-4.132 7.275-6.814.053 0 .1.016.156.016a5.754 5.754\n    0 0 0 2.629-.655c-1 3.959-3.852 7.266.2 10.1 3.244 2.271 7.833-1.436 7.833-1.436a6.328 6.328 0 0 0\n    1.958-6.4c-.569-2.4-4.132-5.88-6.814-7.275 0-.054.016-.1.016-.157a5.754 5.754 0 0 0-.655-2.629c3.959 1 7.267 3.852\n    10.1-.2 2.263-3.243-1.443-7.832-1.443-7.832zM17 21a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$17($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Blower" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Blower extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$17, create_fragment$17, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Blur.svelte generated by Svelte v3.24.1 */

function create_fragment$18(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14.909.347C16.261 9.619 7.182 16.871 7.182 24.3c0 5.548 4.843 10.046 10.818 10.046s10.818-4.5\n    10.818-10.046c0-7.667-11.494-15.743-13.909-23.953z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$18($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Blur" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Blur extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$18, create_fragment$18, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Book.svelte generated by Svelte v3.24.1 */

function create_fragment$19(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M19.782 28H9.995a4 4 0 0 1 0-8h10.523a1 1 0 0 0 .8-.4l11.1-14.8a.5.5 0 0 0-.4-.8H16.025a1 1 0 0 0-.8.4L3.522\n    19.328A7.981 7.981 0 0 0 9.969 32h10.549a1 1 0 0 0 .8-.4l11.1-14.8a.5.5 0 0 0-.4-.8h-3.236z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$19($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Book" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Book extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Bookmark.svelte generated by Svelte v3.24.1 */

function create_fragment$1a(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.071 34.724L13 31.373l-2.071 3.351a.5.5 0 0 1-.929-.257V24h6v10.467a.5.5 0 0 1-.929.257z");
			attr(path1, "d", "M8 27.443A3.987 3.987 0 0 1 9.995 20h10.523a1 1 0 0 0 .8-.4l11.1-14.8a.5.5 0 0 0-.4-.8H16.025a1 1 0 0\n    0-.8.4L3.522 19.328h.008A7.942 7.942 0 0 0 8 31.716zM32.018 16h-3.236l-9 12H18v4h2.518a1 1 0 0 0\n    .8-.4l11.1-14.8a.5.5 0 0 0-.4-.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Bookmark" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Bookmark extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BookmarkSingle.svelte generated by Svelte v3.24.1 */

function create_fragment$1b(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.062 26.394l9.375 9.376c.311.316.561.2.561-.252V3a1 1 0 0 0-1-1H9.012a1 1 0 0 0-1 1L8 35.551c0\n    .457.262.578.586.281z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BookmarkSingle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BookmarkSingle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BookmarkSingleOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$1c(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26 4v27.5l-6.522-6.523-1.412-1.411-1.416 1.411L10 31.6 10.011 4zm1-2H9.012a1 1 0 0 0-1 1L8 35.551c0\n    .288.1.443.263.443a.517.517 0 0 0 .323-.162l9.476-9.438 9.375 9.376a.488.488 0 0 0 .318.177c.147 0\n    .243-.152.243-.429V3A1 1 0 0 0 27 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BookmarkSingleOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BookmarkSingleOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BookmarkSmall.svelte generated by Svelte v3.24.1 */

function create_fragment$1d(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.022 23.848l6.122 5.988a.5.5 0 0 0 .542.106.5.5 0 0 0 .314-.454V7a1 1 0 0 0-1-1H11a1 1 0 0 0-1\n    1v22.506a.523.523 0 0 0 .306.456.481.481 0 0 0 .542-.1z");
			attr(path1, "d", "M17.022 23.848l6.122 5.988a.5.5 0 0 0 .542.106.5.5 0 0 0 .314-.454V7a1 1 0 0 0-1-1H11a1 1 0 0 0-1\n    1v22.506a.523.523 0 0 0 .306.456.481.481 0 0 0 .542-.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BookmarkSmall" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BookmarkSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BookmarkSmallOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$1e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M22 8v17.914l-3.58-3.5-1.4-1.364-1.4 1.36L12 25.944V8h10m1-2H11a1 1 0 0 0-1 1v22.506a.523.523 0 0 0\n    .306.456.421.421 0 0 0 .2.044.511.511 0 0 0 .352-.148l6.174-6.01 6.122 5.988a.5.5 0 0 0 .352.144.472.472 0 0 0\n    .2-.038.5.5 0 0 0 .294-.454V7a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BookmarkSmallOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BookmarkSmallOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Boolean.svelte generated by Svelte v3.24.1 */

function create_fragment$1f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 8.5a9.5 9.5 0 0 1 0 19H12a9.5 9.5 0 0 1 0-19zM24 6H12a12 12 0 0 0 0 24h12a12 12 0 0 0 0-24zm0 6a6 6 0 1 1-6 6\n    6.007 6.007 0 0 1 6-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Boolean" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Boolean extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Border.svelte generated by Svelte v3.24.1 */

function create_fragment$1g(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M4 5v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1zm26 25H6V6h24z");
			attr(path1, "d", "M8 8v20h20V8zm18 18H10V10h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Border" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Border extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Box.svelte generated by Svelte v3.24.1 */

function create_fragment$1h(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16.4 35.594L2.823 28.051A1.6 1.6 0 0 1 2 26.652V13.194l14.4 8zM33.177 28.051L19.6 35.594v-14.4l14.4-8v13.458a1.6\n    1.6 0 0 1-.823 1.399zM24.637 3.717L18.762.535a1.6 1.6 0 0 0-1.524 0L2.592 8.468a.825.825 0 0 0 0 1.451l5.529\n    2.995zM33.408 8.468L27.97 5.523l-16.515 9.2L18 18.265l15.408-8.346a.825.825 0 0 0 0-1.451z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Box" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Box extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BoxAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$1i(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.408 8.469l-5.437-2.947-16.516 9.2L18 18.265l.852-.461a12.255 12.255 0 0 1 4.905-2.657l9.651-5.228a.824.824 0\n    0 0 0-1.45zm-3 6.72A12.233 12.233 0 0 1 34 16.893v-3.7zM2.592 9.919l5.529 3 16.516-9.2L18.762.535a1.6 1.6 0 0\n    0-1.523 0L2.592 8.469a.824.824 0 0 0 0 1.45zM16.213 21.09L2 13.193v13.459a1.6 1.6 0 0 0 .823 1.4L16.4\n    35.594v-2.376a12.259 12.259 0 0 1-.187-12.128zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0\n    1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1\n    .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BoxAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BoxAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BoxExport.svelte generated by Svelte v3.24.1 */

function create_fragment$1j(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M21.285 4.2l-5.563-3.017a1.515 1.515 0 0 0-1.443 0L.409 8.7a.781.781 0 0 0 0 1.373L5.645 12.9zM29.591\n    8.7l-5.149-2.794L8.8 14.615l6.2 3.357 14.591-7.9a.781.781 0 0 0 0-1.372zM14 20.971L0 13.193v13.459a1.6 1.6 0 0 0\n    .823 1.4L14 35.371zM28 24v-3.328a.5.5 0 0 1 .866-.341L36 28l-7.134 7.669a.5.5 0 0 1-.866-.341V32h-5a1 1 0 0\n    1-1-1v-6a1 1 0 0 1 1-1z");
			attr(path1, "d", "M27 18h3v-4.807l-14 7.778v14.4l4-2.222V23a1 1 0 0 1 1-1h5v-3a1 1 0 0 1 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BoxExport" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BoxExport extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BoxImport.svelte generated by Svelte v3.24.1 */

function create_fragment$1k(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.285 4.2l-5.563-3.017a1.515 1.515 0 0 0-1.443 0L6.409 8.7a.781.781 0 0 0 0 1.373l5.236 2.827zM35.591\n    8.7l-5.149-2.794L14.8 14.615l6.2 3.357 14.591-7.9a.781.781 0 0 0 0-1.372zM22 20.971v14.4l13.177-7.32a1.6 1.6 0 0 0\n    .823-1.4V13.193zM6 13.193v2.664L17.646 27.5a.5.5 0 0 1 0 .707l-3.762 3.762L20 35.371v-14.4z");
			attr(path1, "d", "M6 24v-3.328a.5.5 0 0 1 .866-.341L14 28l-7.134 7.669A.5.5 0 0 1 6 35.328V32H1a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BoxImport" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BoxImport extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Brackets.svelte generated by Svelte v3.24.1 */

function create_fragment$1l(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12.884 30.784a.726.726 0 0 0-.727-.727h-1.472a.7.7 0 0\n    1-.728-.667v-7.754c0-1.7-2.814-3.651-2.814-3.651s2.814-1.885 2.814-3.621v-7.8a.687.687 0 0 1\n    .715-.656h1.485a.727.727 0 0 0 .727-.728V2.727A.727.727 0 0 0 12.157 2h-.7a5.511 5.511 0 0 0-5.441 5.845c.013\n    2.807.027 5.752.027 6.642 0 1.19-1.569 2.305-2.677 2.943a.635.635 0 0 0-.007 1.123c1.108.653 2.684 1.783 2.684\n    2.93v6.7A5.51 5.51 0 0 0 11.486 34h.671a.727.727 0 0 0 .727-.727zM23.111 30.784a.727.727 0 0 1 .727-.727h1.472a.7.7\n    0 0 0 .728-.667v-7.754c0-1.7 2.814-3.651 2.814-3.651s-2.814-1.888-2.814-3.621v-7.8a.687.687 0 0\n    0-.715-.656h-1.485a.728.728 0 0 1-.727-.728V2.727A.728.728 0 0 1 23.838 2h.7a5.508 5.508 0 0 1 5.44 5.845 2258.09\n    2258.09 0 0 0-.027 6.642c0 1.19 1.569 2.305 2.676 2.943a.635.635 0 0 1 .008 1.123c-1.108.653-2.684 1.783-2.684\n    2.93v6.7A5.507 5.507 0 0 1 24.509 34h-.671a.728.728 0 0 1-.727-.727z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Brackets" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Brackets extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BracketsSquare.svelte generated by Svelte v3.24.1 */

function create_fragment$1m(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M23 2v3h3v26h-3v3h6a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM6 3v30a1 1 0 0 0 1 1h6v-3h-3V5h3V2H7a1 1 0 0 0-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BracketsSquare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BracketsSquare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Branch1.svelte generated by Svelte v3.24.1 */

function create_fragment$1n(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28 18a5.962 5.962 0 0 0-4.608 2.2l-9.552-4.867a6.067 6.067 0 1 0-1.346 2.6l9.622 4.9A6 6 0 1 0 28 18zm0 9a3 3 0\n    1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Branch1" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Branch1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Branch2.svelte generated by Svelte v3.24.1 */

function create_fragment$1o(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28 22a5.962 5.962 0 0 0-4.608 2.2l-9.552-4.867a5.618 5.618 0 0 0 0-2.664l9.552-4.869a5.908 5.908 0 1\n    0-1.275-2.641l-9.622 4.9a6.015 6.015 0 0 0-.908-.846l-.008-.006a5.987 5.987 0 0\n    0-.989-.6c-.037-.018-.07-.041-.106-.058a5.965 5.965 0 0 0-.994-.343c-.073-.019-.141-.05-.214-.067a6 6 0 1 0 0\n    11.715c.074-.016.141-.048.214-.067a5.965 5.965 0 0 0 .994-.343c.037-.017.07-.04.106-.058a5.987 5.987 0 0 0\n    .989-.6l.008-.006a6.015 6.015 0 0 0 .908-.846l9.622 4.9A6 6 0 1 0 28 22zm0-17a3 3 0 1 1-3 3 3 3 0 0 1 3-3zm0 26a3 3\n    0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Branch2" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Branch2 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Branch3.svelte generated by Svelte v3.24.1 */

function create_fragment$1p(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14 28a5.962 5.962 0 0 0-2.2-4.608l4.868-9.552a5.622 5.622 0 0 0 2.665 0l4.867 9.552a5.908 5.908 0 1 0\n    2.641-1.275l-4.9-9.622a6.015 6.015 0 0 0 .846-.908l.006-.008a5.987 5.987 0 0 0\n    .6-.989c.018-.037.041-.07.058-.106a5.965 5.965 0 0 0 .343-.994c.019-.073.05-.141.067-.214a6 6 0 1 0-11.715\n    0c.016.074.048.141.067.214a5.965 5.965 0 0 0 .343.994c.017.037.04.07.058.106a5.987 5.987 0 0 0 .6.989l.006.008a6.015\n    6.015 0 0 0 .846.908l-4.9 9.622A6 6 0 1 0 14 28zm17 0a3 3 0 1 1-3-3 3 3 0 0 1 3 3zM5 28a3 3 0 1 1 3 3 3 3 0 0 1-3-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Branch3" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Branch3 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BranchCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$1q(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			attr(circle0, "cx", circle0_cx_value = 24);
			attr(circle0, "cy", circle0_cy_value = 24);
			attr(circle0, "r", circle0_r_value = 2);
			attr(circle1, "cx", circle1_cx_value = 24);
			attr(circle1, "cy", circle1_cy_value = 12);
			attr(circle1, "r", circle1_r_value = 2);
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-3.8 16a4.2 4.2 0 0 1-.069.683l6.527 2.8a4.425 4.425 0 1 1-.79\n    1.837l-6.528-2.8a4.2 4.2 0 1 1 0-5.04l6.528-2.8a4.219 4.219 0 1 1 .791 1.837l-6.528 2.8A4.2 4.2 0 0 1 14.2 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BranchCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BranchCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BreadcrumbNavigation.svelte generated by Svelte v3.24.1 */

function create_fragment$1r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.999 18l-8.022 9.469a1.5 1.5 0 0 1-1.144.53h-4.226a.5.5 0 0 1-.382-.823L30 18l-7.774-9.177A.5.5 0 0 1 22.607\n    8h4.226a1.5 1.5 0 0 1 1.144.53zm-10 0l-8.021 9.469a1.5 1.5 0 0 1-1.145.53H1.001a1 1 0 0 1-1-1L0 9a1 1 0 0 1\n    1-1h15.833a1.5 1.5 0 0 1 1.145.53zM7.501 18A2.5 2.5 0 1 0 5 20.5 2.5 2.5 0 0 0 7.5 18zm6.5 0a2.5 2.5 0 1 0-2.5\n    2.5A2.5 2.5 0 0 0 14 18zm6.5 0a2.5 2.5 0 1 0-2.5 2.5 2.5 2.5 0 0 0 2.5-2.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BreadcrumbNavigation" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BreadcrumbNavigation extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Breakdown.svelte generated by Svelte v3.24.1 */

function create_fragment$1s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 7V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h5v25a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-2a1 1 0 0\n    0-1-1H12v-4h19a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H12v-4h19a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H12V8h19a1 1 0 0 0 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Breakdown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Breakdown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BreakdownAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$1t(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.084 30H10v-4h4.75a12.214 12.214 0 0 1 1.018-4H10v-4h8.636A12.168 12.168 0 0 1 30 15.084V15a1 1 0 0\n    0-1-1H10V8h19a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h5v25a1 1 0 0 0 1 1h9.893a12.226 12.226 0\n    0 1-1.809-4z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BreakdownAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BreakdownAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Briefcase.svelte generated by Svelte v3.24.1 */

function create_fragment$1u(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20 18v3.287a.75.75 0 0 1-.75.75L16.75 22a.75.75 0 0 1-.75-.75V18H0v13a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V18zM35\n    10h-9V6a2 2 0 0 0-2-2H12a2 2 0 0 0-2 2v4H1a1 1 0 0 0-1 1v5h16v-1.361a.75.75 0 0 1 .75-.75l2.5.037a.75.75 0 0 1\n    .75.75V16h16v-5a1 1 0 0 0-1-1zM13 7h10v3H13z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Briefcase" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Briefcase extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Browse.svelte generated by Svelte v3.24.1 */

function create_fragment$1v(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.087 20.17S29.206 7.832 28.442 5.813c-.729-1.926-1.669-3.729-3.729-3.729-2.31 0-3.511 1.674-3.729\n    3.729-.063.59-.2 2.474-.361 4.23h-5.249c-.2-2.131-.349-4.134-.358-4.23-.181-2.093-1.016-3.73-3.729-3.73-2.06 0-2.91\n    1.84-3.729 3.729C6.9 7.322.764 20.447.764 20.447h.014a8.2 8.2 0 1 0 15.73\n    3.263c0-.252-.015-1.466-.038-1.712h3.058c-.022.246-.038 1.461-.038 1.712a8.2 8.2 0 1 0 15.6-3.542zM8.3 29.082a5.37\n    5.37 0 1 1 5.37-5.37 5.37 5.37 0 0 1-5.37 5.37zm19.392 0a5.37 5.37 0 1 1 5.37-5.37 5.37 5.37 0 0 1-5.362 5.37z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Browse" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Browse extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Brush.svelte generated by Svelte v3.24.1 */

function create_fragment$1w(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12.509 21.03a4.921 4.921 0 0 0-4.195 1.2 12.935 12.935 0 0 0-2.679 4.782c-.463 1.94-.9 3.772-3.36 4.772a.6.6 0 0\n    0-.341.712.9.9 0 0 0 .645.658 23.76 23.76 0 0 0 1.977.4c2.607.409 7.48.738 10.806-1.652 1.238-.848 2.837-2.982\n    2.822-4.546a6.813 6.813 0 0 0-5.675-6.326zM19.9 24.1c7.235-8.227 16.422-19.535 14.016-21.941S21.546 10.976 14.38\n    18.83a10.051 10.051 0 0 1 5.52 5.27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Brush" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Brush extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Bug.svelte generated by Svelte v3.24.1 */

function create_fragment$1x(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26.194 7.242A9.8 9.8 0 0 0 18 3a9.8 9.8 0 0 0-8.194 4.242A11.943 11.943 0 0 0 18 10.5a11.943 11.943 0 0 0\n    8.194-3.258zM5.216 6.392L2.548 7.726a18.1 18.1 0 0 0 4.581 5.114A27.459 27.459 0 0 0 6.118 18H0v3h6.045a13.6 13.6 0\n    0 0 2.5 6.363 15.078 15.078 0 0 0-4.5 6.16l2.7 1.35a12.052 12.052 0 0 1 3.774-5.2 11.571 11.571 0 0 0 5.981\n    3.185V13.5A14.982 14.982 0 0 1 5.216 6.392zM36 21v-3h-6.118a27.459 27.459 0 0 0-1.011-5.16 18.1 18.1 0 0 0\n    4.581-5.114l-2.668-1.334A14.982 14.982 0 0 1 19.5 13.5v19.358a11.571 11.571 0 0 0 5.979-3.185 12.052 12.052 0 0 1\n    3.774 5.2l2.7-1.35a15.078 15.078 0 0 0-4.5-6.16A13.6 13.6 0 0 0 29.955 21z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Bug" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Bug extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Building.svelte generated by Svelte v3.24.1 */

function create_fragment$1y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h11V22h6v12h11a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM12\n    26H6v-4h6zm0-8H6v-4h6zm0-8H6V6h6zm10 8h-6v-4h6zm0-8h-6V6h6zm10 16h-6v-4h6zm0-8h-6v-4h6zm0-8h-6V6h6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Building" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Building extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/BulkEditUsers.svelte generated by Svelte v3.24.1 */

function create_fragment$1z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24.524 33.968a.586.586 0 0 0 .252-.151L35.5 22.994a.835.835 0 0 0 .246-.537.738.738 0 0\n    0-.213-.577l-3.406-3.5a.732.732 0 0 0-.527-.215h-.022a.837.837 0 0 0-.565.247L20.19 29.229a.612.612 0 0\n    0-.153.256l-1.928 5.9c-.069.229.28.517.476.517a.247.247 0 0 0 .036 0c.17-.044 5.025-1.67\n    5.903-1.934zm-3.365-3.988l2.87 2.864c-1.314.395-3.295 1.229-4.431 1.568zM9.705 19.809c-8.367.728-9.673 6.45-9.673\n    8.706 0 .251.029 3.238.048 3.485h16.287l1.018-3.016a3.253 3.253 0 0 1 .824-1.34l6.613-6.612a13.69 13.69 0 0\n    0-4.566-1.215 1.437 1.437 0 0 1-1.244-1.443v-2.083a1.444 1.444 0 0 1 .366-.93 11 11 0 0 0\n    2.5-6.866c0-5.2-2.756-8.1-6.919-8.1s-7 3.018-7 8.1a11.124 11.124 0 0 0 2.622 6.866 1.441 1.441 0 0 1\n    .368.93v2.074a1.432 1.432 0 0 1-1.244 1.444z");
			attr(path1, "d", "M26.557 14.35a12.153 12.153 0 0 0 1.868-6.4c0-4.357-2.569-7.55-6.451-7.55-.232 0-.444.042-.668.062a10.93 10.93 0\n    0 1 2.975 8.037 13.463 13.463 0 0 1-2.869 8.172v.876a14.944 14.944 0 0 1 5.188\n    1.705l1.555-1.552c-.256-.046-.509-.1-.781-.124a1.342 1.342 0 0 1-1.16-1.346v-1.014a1.528 1.528 0 0 1 .343-.866z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "BulkEditUsers" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class BulkEditUsers extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Button.svelte generated by Svelte v3.24.1 */

function create_fragment$1A(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M26 8H10a10 10 0 0 0 0 20h16a10 10 0 0 0 0-20zm0 18.1H10a8.1 8.1 0 0 1 0-16.2h16a8.1 8.1 0 0 1 0 16.2z");
			attr(path1, "d", "M26 12.1H10a5.9 5.9 0 0 0 0 11.8h16a5.9 5.9 0 0 0 0-11.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Button" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CCLibrary.svelte generated by Svelte v3.24.1 */

function create_fragment$1B(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 6h-3V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h3v3a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM4\n    28V4h24v2H7a1 1 0 0 0-1 1v21zm28 4H8V8h14v14l4-3 4 3V8h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CCLibrary" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CCLibrary extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Calculator.svelte generated by Svelte v3.24.1 */

function create_fragment$1C(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29 2H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h24a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM10 29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0\n    0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm6 12a.5.5 0 0\n    1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0\n    0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm6\n    12a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0\n    0 1 .5.5zm6 12a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-12a.5.5 0 0\n    1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-8a.5.5 0 0 1-.5.5h-21a.5.5 0 0 1-.5-.5v-5a.5.5 0\n    0 1 .5-.5h21a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Calculator" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Calculator extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Calendar.svelte generated by Svelte v3.24.1 */

function create_fragment$1D(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 6h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H10V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v3H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h32a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 26H2V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h4z");
			attr(path1, "d", "M6 12h4v4H6zM12 12h4v4h-4zM18 12h4v4h-4zM24 12h4v4h-4zM6 18h4v4H6zM12 18h4v4h-4zM18 18h4v4h-4zM24 18h4v4h-4zM6\n    24h4v4H6zM12 24h4v4h-4zM18 24h4v4h-4zM24 24h4v4h-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Calendar" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Calendar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CalendarAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$1E(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M6 12h4v4H6zM12 12h4v4h-4zM18 12h4v4h-4zM6 18h4v4H6zM12 18h4v4h-4zM6 24h4v4H6zM14.7 27a12.274 12.274 0 0 1\n    .384-3H12v4h2.75c-.026-.33-.05-.662-.05-1zM27 14.7c.338 0 .669.024 1 .05V12h-4v3.084a12.284 12.284 0 0 1 3-.384z");
			attr(path1, "d", "M15.769 32H2V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h4v7.769a12.26 12.26 0 0 1\n    2 1.124V7a1 1 0 0 0-1-1h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H10V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v3H1a1 1 0 0 0-1\n    1v26a1 1 0 0 0 1 1h15.893a12.283 12.283 0 0 1-1.124-2z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CalendarAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CalendarAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CalendarLocked.svelte generated by Svelte v3.24.1 */

function create_fragment$1F(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.161 24.048h-1.244v-1.477C33.917 17.837 30.372 14 26 14s-7.917 3.837-7.917 8.571v1.477h-1.291a.826.826 0 0\n    0-.792.857v10.238a.826.826 0 0 0 .792.857h18.369a.826.826 0 0 0 .791-.857V24.905a.825.825 0 0\n    0-.791-.857zm-13.244-1.477c0-2.84 1.46-5.143 4.083-5.143s4.083 2.3 4.083 5.143v1.477h-8.166zm5.666\n    8.762v1.81a.826.826 0 0 1-.791.857h-1.584a.826.826 0 0 1-.791-.857v-1.81a2.652 2.652 0 0 1-.792-1.9 2.382 2.382 0 1\n    1 4.75 0 2.652 2.652 0 0 1-.792 1.9z");
			attr(path1, "d", "M13.467 25a2.963 2.963 0 0 1 .179-1H4V6h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h10v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V6h4v5.74a9.822 9.822 0 0 1 2 1.292V5a1 1 0 0 0-1-1h-5V1a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V1a1 1 0 0 0-1-1H9a1\n    1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v20a1 1 0 0 0 1 1h10.467z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CalendarLocked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CalendarLocked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CalendarUnlocked.svelte generated by Svelte v3.24.1 */

function create_fragment$1G(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35 24H21.917v-3.429c0-2.84 1.459-5.143 4.083-5.143a3.825 3.825 0 0 1 3.676 2.744.5.5 0 0 0\n    .664.307l2.474-1.06a.513.513 0 0 0 .269-.676A7.879 7.879 0 0 0 26 12c-4.372 0-7.917 3.837-7.917 8.571V24H17a1 1 0 0\n    0-1 1v10a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V25a1 1 0 0 0-1-1zm-7.417 7.333v1.81a.826.826 0 0 1-.791.857h-1.584a.826.826\n    0 0 1-.791-.857v-1.81a2.652 2.652 0 0 1-.792-1.9 2.382 2.382 0 1 1 4.75 0 2.652 2.652 0 0 1-.792 1.9z");
			attr(path1, "d", "M13.467 25a2.963 2.963 0 0 1 .179-1H4V6h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h10v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V6h4v3.74a9.822 9.822 0 0 1 2 1.292V5a1 1 0 0 0-1-1h-5V1a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V1a1 1 0 0 0-1-1H9a1\n    1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v20a1 1 0 0 0 1 1h10.467z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CalendarUnlocked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CalendarUnlocked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CallCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$1H(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31.091 14h-1.455A11.823 11.823 0 0 0 18 2 11.823 11.823 0 0 0 6.364 14H4.909A2.956 2.956 0 0 0 2 17v6a2.956\n    2.956 0 0 0 2.909 3h4.364V14H9.2A8.941 8.941 0 0 1 18 4.925 8.941 8.941 0 0 1 26.8 14h-.073v11.338a10.183 10.183 0 0\n    1-6.211 4.8A3.115 3.115 0 0 0 18 29c-1.607 0-2.909 1.007-2.909 2.25S16.393 33.5 18 33.5a2.788 2.788 0 0 0\n    2.859-1.869A11.682 11.682 0 0 0 28.055 26h3.036A2.956 2.956 0 0 0 34 23v-6a2.956 2.956 0 0 0-2.909-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CallCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CallCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Camera.svelte generated by Svelte v3.24.1 */

function create_fragment$1I(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 12a6 6 0 1 0 6 6 6.007 6.007 0 0 0-6-6z");
			attr(path1, "d", "M33 8h-6.05L23.6 4.326A1 1 0 0 0 22.859 4h-9.718a1 1 0 0 0-.739.326L9.05 8H3a1 1 0 0 0-1 1v20a1 1 0 0 0 1 1h30a1\n    1 0 0 0 1-1V9a1 1 0 0 0-1-1zM18 26.2a8.2 8.2 0 1 1 8.2-8.2 8.2 8.2 0 0 1-8.2 8.2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Camera" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Camera extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CameraFlip.svelte generated by Svelte v3.24.1 */

function create_fragment$1J(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 8h-7.05L22.6 4.326A1 1 0 0 0 21.859 4h-9.718a1 1 0 0 0-.739.326L8.05 8H1a1 1 0 0 0-1 1v20a1 1 0 0 0 1 1h32a1\n    1 0 0 0 1-1V9a1 1 0 0 0-1-1zM17 26.2a8.141 8.141 0 0 1-5.782-2.418l-1.365 1.365A.5.5 0 0 1 9 24.793V20.5a.5.5 0 0 1\n    .5-.5h4.293a.5.5 0 0 1 .353.854l-1.364 1.364A5.907 5.907 0 0 0 17 24a5.985 5.985 0 0 0 5.51-3.688.5.5 0 0 1\n    .455-.312h1.291a.5.5 0 0 1 .48.643A8.178 8.178 0 0 1 17 26.2zm8-10.7a.5.5 0 0 1-.5.5h-4.293a.5.5 0 0\n    1-.354-.853l1.365-1.365A5.907 5.907 0 0 0 17 12a5.986 5.986 0 0 0-5.51 3.688.5.5 0 0 1-.455.312H9.744a.5.5 0 0\n    1-.48-.642 8.148 8.148 0 0 1 13.518-3.14l1.364-1.364a.5.5 0 0 1 .854.353z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CameraFlip" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CameraFlip extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CameraRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$1K(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.8 26.862a12.346 12.346 0 0 1 .525-2.835 8.2 8.2 0 1 1 9.854-8.186c.271-.021.541-.042.816-.042a11.213 11.213 0\n    0 1 6.435 2.14l.57-.576V7a1 1 0 0 0-1-1h-6.05L23.6 2.326A1 1 0 0 0 22.859 2h-9.718a1 1 0 0 0-.739.326L9.05 6H3a1 1 0\n    0 0-1 1v20a1 1 0 0 0 1 1h12.733z");
			attr(path1, "d", "M23.975 16.247c0-.084.025-.163.025-.247a6 6 0 1 0-6.8 5.919 11.413 11.413 0 0 1 6.775-5.672zM27 33.363a6.143\n    6.143 0 0 1-4.718-2.1l2.282-2.287H18.1v6.477l2.476-2.481A8.648 8.648 0 0 0 27 35.9a9.2 9.2 0 0 0\n    8.9-8.9h-2.255A6.812 6.812 0 0 1 27 33.363zM33.485 21.026A9.112 9.112 0 0 0 27 18.1a9.2 9.2 0 0 0-8.9\n    8.9h2.255A6.812 6.812 0 0 1 27 20.636a6.214 6.214 0 0 1 4.817 2.093l-2.245 2.293H35.9V18.56z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CameraRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CameraRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Campaign.svelte generated by Svelte v3.24.1 */

function create_fragment$1L(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 4.3);
			attr(path, "d", "M6.227 20.311H2A16.172 16.172 0 0 0 15.688 34v-4.227a12.007 12.007 0 0 1-9.461-9.462zM29.773 20.311a12.007 12.007\n    0 0 1-9.461 9.462V34A16.172 16.172 0 0 0 34 20.311zM15.688 6.228V2A16.171 16.171 0 0 0 2 15.688h4.228a12 12 0 0 1\n    9.46-9.46zM29.772 15.688H34A16.171 16.171 0 0 0 20.312 2v4.228a12 12 0 0 1 9.46 9.46z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Campaign" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Campaign extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CampaignAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$1M(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.227 20.311H2A16.172 16.172 0 0 0 15.688 34v-4.228a12.006 12.006 0 0 1-9.461-9.461zM15.688 6.228V2A16.172\n    16.172 0 0 0 2 15.688h4.228a12.005 12.005 0 0 1 9.46-9.46zM29.772 15.688H34A16.172 16.172 0 0 0 20.312\n    2v4.228a12.005 12.005 0 0 1 9.46 9.46zM15.9 21.73a12.329 12.329 0 0 1 5.83-5.83 4.286 4.286 0 1 0-5.83 5.83zM27\n    18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CampaignAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CampaignAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CampaignClose.svelte generated by Svelte v3.24.1 */

function create_fragment$1N(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4.227 20.311H0A16.172 16.172 0 0 0 13.688 34v-4.228a12.006 12.006 0 0 1-9.461-9.461zM13.688 6.228V2A16.172\n    16.172 0 0 0 0 15.688h4.228a12.005 12.005 0 0 1 9.46-9.46zM27.772 15.688H32A16.172 16.172 0 0 0 18.312\n    2v4.228a12.005 12.005 0 0 1 9.46 9.46zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826 12.267a.5.5 0 0 1\n    0 .707l-1.752 1.752a.5.5 0 0 1-.707 0L27 29.459l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0 0 1 0-.707L24.541\n    27l-3.367-3.367a.5.5 0 0 1 0-.707l1.752-1.752a.5.5 0 0 1 .707 0L27 24.541l3.367-3.367a.5.5 0 0 1 .707 0l1.752\n    1.752a.5.5 0 0 1 0 .707L29.459 27zM20.112 16.809a4.289 4.289 0 1 0-4.465 5.455 12.344 12.344 0 0 1 4.465-5.455z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CampaignClose" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CampaignClose extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CampaignDelete.svelte generated by Svelte v3.24.1 */

function create_fragment$1O(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4.227 20.311H0A16.172 16.172 0 0 0 13.688 34v-4.228a12.006 12.006 0 0 1-9.461-9.461zM13.688 6.228V2A16.172\n    16.172 0 0 0 0 15.688h4.228a12.005 12.005 0 0 1 9.46-9.46zM27.772 15.688H32A16.172 16.172 0 0 0 18.312\n    2v4.228a12.005 12.005 0 0 1 9.46 9.46zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0\n    1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5zM20.112 16.809a4.289 4.289 0 1 0-4.465 5.455 12.344\n    12.344 0 0 1 4.465-5.455z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CampaignDelete" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CampaignDelete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CampaignEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$1P(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 16);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 4.3);
			attr(path, "d", "M4.227 20.311H0A16.172 16.172 0 0 0 13.688 34v-4.228a12.006 12.006 0 0 1-9.461-9.461zM13.688 6.228V2A16.172\n    16.172 0 0 0 0 15.688h4.228a12.005 12.005 0 0 1 9.46-9.46zM27.772 15.688H32A16.172 16.172 0 0 0 18.312\n    2v4.228a12.005 12.005 0 0 1 9.46 9.46zM35.738 21.764l-3.506-3.506a.738.738 0 0 0-.527-.215h-.023a.833.833 0 0\n    0-.564.247L20.929 28.48a.607.607 0 0 0-.153.256l-2.66 6.63c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039\n    5.756-2.4 6.634-2.661a.6.6 0 0 0 .252-.151l10.19-10.19a.836.836 0 0 0 .246-.537.743.743 0 0 0-.213-.58zm-10.97\n    10.33c-1.314.4-3.928 1.862-5.063 2.2l2.195-5.062z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CampaignEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CampaignEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Cancel.svelte generated by Svelte v3.24.1 */

function create_fragment$1Q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm12 16a11.943 11.943 0 0 1-2.219 6.953L11.047 8.219A12 12 0 0 1 30 18zM6\n    18a11.945 11.945 0 0 1 2.219-6.953l16.734 16.735A12 12 0 0 1 6 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Cancel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Cancel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Capitals.svelte generated by Svelte v3.24.1 */

function create_fragment$1R(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M15 8a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2h-2v12h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H5a1 1 0 0\n    1-1-1v-2a1 1 0 0 1 1-1h1V12H4v2a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1zM33 8a1 1 0 0 1 1 1v5a1 1 0 0 1-1\n    1h-2a1 1 0 0 1-1-1v-2h-2v12h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1V12h-2v2a1 1 0 0 1-1\n    1h-2a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Capitals" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Capitals extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Captcha.svelte generated by Svelte v3.24.1 */

function create_fragment$1S(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.518 15.2a4.727 4.727 0 0 0 3.361-4.451c0-3.042-2.177-5.25-6.179-5.25a10.73 10.73 0 0 0-5.122 1.249.279.279 0\n    0 0-.128.288v2.048c0 .128.033.159.193.1A8.663 8.663 0 0 1 25.252 7.9c2.817 0 4 1.376 4 3.168 0 2.049-1.729\n    3.138-4.546 3.138h-1.182c-.16 0-.192.1-.192.224v2.016c0 .128.064.192.224.192H24.9c3.169 0 5.282 1.153 5.282 3.714 0\n    2.018-1.408 3.745-4.865 3.745a14.236 14.236 0 0 1-4.994-1.308 7.585 7.585 0 0 0\n    .661-3.08c0-4.711-3.473-6.384-6.448-6.384A12.605 12.605 0 0 0 9 14.784V3.25a.75.75 0 0 0-.752-.75h-1.49a.747.747 0 0\n    0-.6.3L3.3 5.09a1.494 1.494 0 0 0-.3.9v.248a.75.75 0 0 0 .75.75H6v14.25a.75.75 0 0 0 .75.75h1.5a.75.75 0 0 0\n    .75-.75v-3.683a10.539 10.539 0 0 1 5.032-1.508c2.547 0 4.1 1.245 4.1 3.753 0 1.925-.939 3.795-3.8 6.955A49.073\n    49.073 0 0 1 9.2 31.794a.5.5 0 0 0-.169.419v1.418c0 .322.212.369.338.369H21.15c.237 0\n    .312-.085.4-.3l.47-1.951a.27.27 0 0 0-.035-.243.357.357 0 0 0-.3-.1h-4.347c-2.418 0-2.914 0-3.864.062a30.5 30.5 0 0\n    0 3.718-4.025c.747-.917 1.391-1.748 1.939-2.55a16.646 16.646 0 0 0 6.217 1.61c4.322 0 7.555-2.208 7.555-6.146a5.222\n    5.222 0 0 0-4.385-5.157z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Captcha" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Captcha extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Car.svelte generated by Svelte v3.24.1 */

function create_fragment$1T(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.291 17.288l-.792-.79-3.46-8.074A4 4 0 0 0 25.362 6H10.638A4 4 0 0 0 6.96 8.424L3.5 16.5l-.793.793A2.412 2.412\n    0 0 0 2 19V33a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-5h24v5a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V18.996a2.412 2.412 0 0\n    0-.709-1.708zM9.26 9.41a1.498 1.498 0 0 1 1.379-.909h14.724a1.498 1.498 0 0 1 1.38.91L29.565 16H6.434zM8 25a3 3 0 1\n    1 3-3 3 3 0 0 1-3 3zm20 0a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Car" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Car extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Card.svelte generated by Svelte v3.24.1 */

function create_fragment$1U(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 2H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM12 29.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0\n    1-.5-.5v-1a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5zm18 0a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h13a.5.5\n    0 0 1 .5.5zm0-7.5H6V4h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Card" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Channel.svelte generated by Svelte v3.24.1 */

function create_fragment$1V(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.375 15.125a2.864 2.864 0 0 0-2.475 1.437h-4.545a7.466 7.466 0 0 0-2.67-4.376l2.62-4.979a2.879 2.879 0 1\n    0-2.545-1.336l-2.619 4.977A7.4 7.4 0 0 0 18 10.5a7.4 7.4 0 0 0-2.141.348L13.24 5.871a2.864 2.864 0 0 0-2.427-4.4\n    2.87 2.87 0 0 0-.113 5.736l2.62 4.979a7.466 7.466 0 0 0-2.67 4.376H6.1a2.875 2.875 0 1 0 0 2.876h4.544a7.466 7.466 0\n    0 0 2.67 4.376L10.7 28.793a2.881 2.881 0 1 0 2.545 1.336l2.619-4.977A7.4 7.4 0 0 0 18 25.5a7.4 7.4 0 0 0\n    2.141-.348l2.619 4.977a2.865 2.865 0 0 0 2.427 4.4 2.87 2.87 0 0 0 .118-5.738l-2.62-4.979a7.466 7.466 0 0 0\n    2.67-4.376H29.9a2.87 2.87 0 1 0 2.476-4.313zM18 22.575A4.575 4.575 0 1 1 22.575 18 4.575 4.575 0 0 1 18 22.575z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Channel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Channel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Chat.svelte generated by Svelte v3.24.1 */

function create_fragment$1W(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M19 14a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H9.586a1 1 0 0 0-.707.293L6 31.171V29a1 1 0 0 0-1-1H3a1 1 0 0 1-1-1V15a1 1 0\n    0 1 1-1zM3 12a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h1v4.793a.5.5 0 0 0 .854.353L10 30h9a3 3 0 0 0 3-3V15a3 3 0 0 0-3-3z");
			attr(path1, "d", "M24 14.6a4.6 4.6 0 0 0-4.6-4.6H12V5a3 3 0 0 1 3-3h18a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3h-3v4.793a.5.5 0 0\n    1-.854.353L24 20z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Chat" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Chat extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1W, create_fragment$1W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChatAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$1X(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.75 28H9.586a1 1 0 0 0-.707.293L6 31.171V29a1 1 0 0 0-1-1H3a1 1 0 0 1-1-1V15a1 1 0 0 1 1-1h16a1 1 0 0 1 1\n    1v1.893a12.26 12.26 0 0 1 2-1.124V15a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h1v4.793a.5.5 0 0 0 .854.354L10\n    30h5.084a12.221 12.221 0 0 1-.334-2z");
			attr(path1, "d", "M24 14.6v.484A12.209 12.209 0 0 1 35.693 18.3 2.972 2.972 0 0 0 36 17V5a3 3 0 0 0-3-3H15a3 3 0 0 0-3 3v5h7.4a4.6\n    4.6 0 0 1 4.6 4.6zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0\n    1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1\n    .5.5V26h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChatAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChatAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1X, create_fragment$1X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CheckPause.svelte generated by Svelte v3.24.1 */

function create_fragment$1Y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M23.1 15.343l6.391-8.215a1 1 0 0 0-.175-1.4l-1.459-1.136a1 1 0 0 0-1.4.175L12.822 22.283l-6.647-6.612a1 1 0 0\n    0-1.414 0L3.437 17a1 1 0 0 0 0 1.415l8.926 8.9a1 1 0 0 0 1.5-.093l.888-1.142A12.294 12.294 0 0 1 23.1 15.343z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-1 13.474h-2.632v-9.148H26zm4.632 0H28v-9.148h2.632z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CheckPause" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CheckPause extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1Y, create_fragment$1Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Checkmark.svelte generated by Svelte v3.24.1 */

function create_fragment$1Z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31.312 7.725l-1.455-1.133a1 1 0 0 0-1.4.175L14.822 24.283l-6.647-6.612a1 1 0 0 0-1.414 0L5.436 19a1 1 0 0 0 0\n    1.414l8.926 8.9a1 1 0 0 0 1.5-.093L31.487 9.128a1 1 0 0 0-.175-1.403z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Checkmark" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Checkmark extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CheckmarkCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$1_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm10.666 9.08L16.018 27.341a1.206 1.206 0 0 1-.875.461h-.073a1.2 1.2 0 0\n    1-.849-.351l-7.785-7.793a1.2 1.2 0 0 1 0-1.7l1.326-1.325a1.2 1.2 0 0 1 1.7 0l5.338 5.349L25.314 8.473A1.2 1.2 0 0 1\n    27 8.263L28.455 9.4a1.2 1.2 0 0 1 .211 1.68z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CheckmarkCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CheckmarkCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1_, create_fragment$1_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CheckmarkCircleOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$1$(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.1 2.2A15.9 15.9 0 1 0 34 18.1 15.9 15.9 0 0 0 18.1 2.2zm0 29.812A13.912 13.912 0 1 1 32.012 18.1 13.912\n    13.912 0 0 1 18.1 32.012zm8.981-19.377L16.21 26.611a1 1 0 0 1-1.496.092l-6.157-6.131a1 1 0 0 1 0-1.415l1.325-1.325a1\n    1 0 0 1 1.414 0l3.878 3.844 8.875-11.402a1 1 0 0 1 1.403-.175l1.455 1.133a1 1 0 0 1 .175 1.403z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CheckmarkCircleOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CheckmarkCircleOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1$, create_fragment$1$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronDoubleLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$20(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M6 18a1.988 1.988 0 0 0 .585 1.409l7.983 7.98a2 2 0 1 0 2.871-2.772l-.049-.049L10.819 18l6.572-6.57a2 2 0 0\n    0-2.773-2.87l-.049.049-7.983 7.98A1.988 1.988 0 0 0 6 18z");
			attr(path1, "d", "M18 18a1.988 1.988 0 0 0 .585 1.409l7.983 7.98a2 2 0 1 0 2.871-2.772l-.049-.049L22.819 18l6.572-6.57a2 2 0 0\n    0-2.773-2.87l-.049.049-7.983 7.98A1.988 1.988 0 0 0 18 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$20($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronDoubleLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronDoubleLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$20, create_fragment$20, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronDoubleRight.svelte generated by Svelte v3.24.1 */

function create_fragment$21(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M30 18a1.988 1.988 0 0 1-.585 1.409l-7.983 7.98a2 2 0 1 1-2.871-2.772l.049-.049L25.181 18l-6.572-6.57a2 2 0 0 1\n    2.773-2.87l.049.049 7.983 7.98A1.988 1.988 0 0 1 30 18z");
			attr(path1, "d", "M18 18a1.988 1.988 0 0 1-.585 1.409l-7.983 7.98a2 2 0 1 1-2.872-2.77l.049-.049L13.181 18l-6.572-6.57a2 2 0 0 1\n    2.774-2.87l.049.049 7.983 7.98A1.988 1.988 0 0 1 18 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$21($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronDoubleRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronDoubleRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$21, create_fragment$21, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronDown.svelte generated by Svelte v3.24.1 */

function create_fragment$22(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M8 14.02a2 2 0 0 1 3.411-1.411l6.578 6.572 6.578-6.572a2 2 0 0 1 2.874 2.773l-.049.049-7.992 7.984a2 2 0 0\n    1-2.825 0l-7.989-7.983A1.989 1.989 0 0 1 8 14.02z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$22($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronDown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronDown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$22, create_fragment$22, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$23(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12 18a1.988 1.988 0 0 0 .585 1.409l7.983 7.98a2 2 0 1 0 2.871-2.772l-.049-.049L16.819 18l6.572-6.57a2 2 0 0\n    0-2.773-2.87l-.049.049-7.983 7.98A1.988 1.988 0 0 0 12 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$23($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$23, create_fragment$23, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronRight.svelte generated by Svelte v3.24.1 */

function create_fragment$24(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 18a1.988 1.988 0 0 1-.585 1.409l-7.983 7.98a2 2 0 1 1-2.871-2.772l.049-.049L19.181 18l-6.572-6.57a2 2 0 0 1\n    2.773-2.87l.049.049 7.983 7.98A1.988 1.988 0 0 1 24 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$24($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$24, create_fragment$24, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronUp.svelte generated by Svelte v3.24.1 */

function create_fragment$25(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28 21.98a2 2 0 0 1-3.411 1.411l-6.578-6.572-6.578 6.572a2 2 0 0 1-2.874-2.773l.049-.049 7.992-7.984a2 2 0 0 1\n    2.825 0l7.989 7.983A1.989 1.989 0 0 1 28 21.98z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$25($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronUp" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronUp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$25, create_fragment$25, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronUpDown.svelte generated by Svelte v3.24.1 */

function create_fragment$26(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M28 11.98a2 2 0 0 1-3.411 1.411l-6.577-6.573-6.578 6.572a2 2 0 0 1-2.874-2.773l.049-.049L16.6 2.585a2 2 0 0 1\n    2.825 0l7.989 7.983A1.989 1.989 0 0 1 28 11.98z");
			attr(path1, "d", "M8 24.02a2 2 0 0 1 3.411-1.411l6.578 6.572 6.578-6.572a2 2 0 0 1 2.874 2.773l-.049.049-7.992 7.983a2 2 0 0\n    1-2.825 0l-7.989-7.983A1.989 1.989 0 0 1 8 24.02z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$26($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ChevronUpDown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ChevronUpDown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$26, create_fragment$26, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Circle.svelte generated by Svelte v3.24.1 */

function create_fragment$27(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 16);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$27($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Circle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Circle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$27, create_fragment$27, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ClassicGridView.svelte generated by Svelte v3.24.1 */

function create_fragment$28(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 14);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 14);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 14);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 14);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 2);
			attr(rect2, "height", rect2_height_value = 14);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 14);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 20);
			attr(rect3, "height", rect3_height_value = 14);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 14);
			attr(rect3, "x", rect3_x_value = 20);
			attr(rect3, "y", rect3_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$28($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ClassicGridView" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ClassicGridView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$28, create_fragment$28, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Clock.svelte generated by Svelte v3.24.1 */

function create_fragment$29(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm0 30a14 14 0 1 1 14-14 14 14 0 0 1-14 14z");
			attr(path1, "d", "M20 16.086V7a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v10.586a1 1 0 0 0 .293.707L21.9 23.9a1 1 0 0 0 1.415 0l1.335-1.336a1 1\n    0 0 0 0-1.414l-4.357-4.358a1 1 0 0 1-.293-.706z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$29($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Clock" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Clock extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$29, create_fragment$29, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ClockCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$2a(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M14 16.086V7a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v10.586a1 1 0 0 1-.293.707L12.1 23.9a1 1 0 0 1-1.414 0L9.35 22.565a1 1\n    0 0 1 0-1.414l4.358-4.358a1 1 0 0 0 .292-.707z");
			attr(path1, "d", "M15.763 31.988A14 14 0 1 1 29.669 15a12.185 12.185 0 0 1 2.143.68A15.992 15.992 0 1 0 16 34c.29 0\n    .573-.028.86-.044a12.309 12.309 0 0 1-1.097-1.968z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ClockCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ClockCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2a, create_fragment$2a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CloneStamp.svelte generated by Svelte v3.24.1 */

function create_fragment$2b(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M20.647 21.62a29.989 29.989 0 0 1-.771-5.178 9.971 9.971 0 0 1 .612-2.945 5.755 5.755 0 0 0 3.631-5.748 6.111\n    6.111 0 1 0-12.222 0 5.748 5.748 0 0 0 3.611 5.744 10.467 10.467 0 0 1 .622 2.949 31.39 31.39 0 0 1-.777\n    5.179c-2.923.148-10 1.767-12.48 2.351A1.146 1.146 0 0 0 2 25.1v3.729A1.153 1.153 0 0 0 3.146 30h29.711A1.154 1.154 0\n    0 0 34 28.836V25.1a1.146 1.146 0 0 0-.873-1.131c-2.476-.581-9.554-2.2-12.48-2.349z");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 28);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 32);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CloneStamp" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CloneStamp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2b, create_fragment$2b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Close.svelte generated by Svelte v3.24.1 */

function create_fragment$2c(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26.485 6.686L18 15.172 9.515 6.686a1 1 0 0 0-1.414 0L6.686 8.1a1 1 0 0 0 0 1.414L15.172 18l-8.486 8.485a1 1 0 0\n    0 0 1.414L8.1 29.314a1 1 0 0 0 1.414 0L18 20.828l8.485 8.486a1 1 0 0 0 1.414 0l1.415-1.414a1 1 0 0 0 0-1.414L20.828\n    18l8.486-8.485a1 1 0 0 0 0-1.414L27.9 6.686a1 1 0 0 0-1.415 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Close" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Close extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2c, create_fragment$2c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CloseCaptions.svelte generated by Svelte v3.24.1 */

function create_fragment$2d(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31.5 6h-27A4.5 4.5 0 0 0 0 10.5v15A4.5 4.5 0 0 0 4.5 30h27a4.5 4.5 0 0 0 4.5-4.5v-15A4.5 4.5 0 0 0 31.5\n    6zm-14.837 7.612a.809.809 0 0 1-.37.715l-.323.2-.459-.183a5.96 5.96 0 0 0-2.342-.376 3.721 3.721 0 0 0-4.02 4 3.817\n    3.817 0 0 0 4.061 4.042 6.586 6.586 0 0 0 2.279-.308l.311-.102.381.163a.787.787 0 0 1 .361.691v1.812a.935.935 0 0\n    1-.57.9 9.648 9.648 0 0 1-3.065.416c-4.657 0-7.667-2.961-7.667-7.544 0-4.55 3.2-7.606 7.972-7.606a7.566 7.566 0 0 1\n    2.922.4.908.908 0 0 1 .531.848zm13.5 0a.809.809 0 0 1-.37.715l-.323.2-.459-.183a5.96 5.96 0 0 0-2.342-.376 3.721\n    3.721 0 0 0-4.02 4 3.817 3.817 0 0 0 4.061 4.042 6.586 6.586 0 0 0 2.279-.308l.311-.102.381.163a.787.787 0 0 1\n    .361.691v1.812a.935.935 0 0 1-.57.9 9.648 9.648 0 0 1-3.065.416c-4.657 0-7.667-2.961-7.667-7.544 0-4.55 3.205-7.606\n    7.972-7.606a7.566 7.566 0 0 1 2.922.4.908.908 0 0 1 .531.848z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CloseCaptions" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CloseCaptions extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2d, create_fragment$2d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CloseCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$2e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.314 6.686a16 16 0 1 0 0 22.627 16 16 0 0 0 0-22.627zm-2.687 18.527l-1.414 1.414a1.2 1.2 0 0 1-1.7 0L18\n    21.111l-5.516 5.516a1.2 1.2 0 0 1-1.7 0l-1.409-1.415a1.2 1.2 0 0 1 0-1.7L14.889 18l-5.514-5.516a1.2 1.2 0 0 1\n    0-1.7l1.414-1.414a1.2 1.2 0 0 1 1.7 0L18 14.888l5.516-5.515a1.2 1.2 0 0 1 1.7 0l1.414 1.414a1.2 1.2 0 0 1 0\n    1.7L21.111 18l5.516 5.516a1.2 1.2 0 0 1 0 1.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CloseCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CloseCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2e, create_fragment$2e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Cloud.svelte generated by Svelte v3.24.1 */

function create_fragment$2f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.571 28.715a6.429 6.429 0 1 0 0-12.857 6.497 6.497 0 0 0-.725.04 8.144 8.144 0 1 0-15.922-3.235 6.862 6.862 0\n    0 0-8.407 8.394 3.857 3.857 0 1 0-.66 7.658z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Cloud" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Cloud extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2f, create_fragment$2f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CloudDisconnected.svelte generated by Svelte v3.24.1 */

function create_fragment$2g(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.688 14.026Q27.348 14 27 14a9.001 9.001 0 0 0-7.484 14H3.718A3.92 3.92 0 0 1 0 23.854c0-1.73 1.792-4.261\n    4.092-4.261a4.815 4.815 0 0 1-.134-1.577 6.254 6.254 0 0 1 6.399-6.075 7.743 7.743 0 0 1 2.098.291c.936-3.166\n    3.622-6.17 7.607-6.17a7.296 7.296 0 0 1 7.641 7.57c0 .133-.005.264-.015.394z");
			attr(path1, "d", "M26.969 15.813a7.25 7.25 0 1 0 7.25 7.25 7.255 7.255 0 0 0-7.25-7.25zm3.87 9.915a.92.92 0 0 1-.65 1.57.925.925 0\n    0 1-.65-.27L27.111 24.6l-2.426 2.427a.919.919 0 0 1-1.57-.65.914.914 0 0 1 .27-.65l2.426-2.427-2.393-2.418a.818.818\n    0 0 1-.307-.589 1.007 1.007 0 0 1 .957-.982.925.925 0 0 1 .65.27l2.393 2.419 2.393-2.419a.925.925 0 0 1 .65-.27\n    1.007 1.007 0 0 1 .957.982.818.818 0 0 1-.306.589L28.412 23.3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CloudDisconnected" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CloudDisconnected extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2g, create_fragment$2g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CloudError.svelte generated by Svelte v3.24.1 */

function create_fragment$2h(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.688 14.026Q27.348 14 27 14a9.001 9.001 0 0 0-7.484 14H3.718A3.92 3.92 0 0 1 0 23.854c0-1.73 1.792-4.261\n    4.092-4.261a4.815 4.815 0 0 1-.134-1.577 6.254 6.254 0 0 1 6.399-6.075 7.743 7.743 0 0 1 2.098.291c.936-3.166\n    3.622-6.17 7.607-6.17a7.296 7.296 0 0 1 7.641 7.57c0 .133-.005.264-.015.394z");
			attr(path1, "d", "M26.969 15.813a7.25 7.25 0 1 0 7.25 7.25 7.255 7.255 0 0 0-7.25-7.25zm-1.076 2.462c0-.053.15-.137.26-.178a2.27\n    2.27 0 0 1 .824-.088 2.877 2.877 0 0 1 .87.087c.113.042.276.138.276.18v1.386a43.029 43.029 0 0 1-.366 4.778c0\n    .041-.028.247-.163.247H26.42c-.09 0-.146-.194-.167-.247-.045-.38-.36-3.27-.36-4.778zm1.17 10.1a1.238 1.238 0 1 1\n    1.238-1.239 1.239 1.239 0 0 1-1.238 1.239z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CloudError" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CloudError extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2h, create_fragment$2h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CloudOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$2i(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20.5 6.714a6.788 6.788 0 0 1 6.538 8.606 5.492 5.492 0 0 1 .605-.034 5.357 5.357 0 0 1 0 10.714H6.214a3.215\n    3.215 0 0 1 0-6.429h.359v-1.428a5.718 5.718 0 0 1 7.2-5.519 6.788 6.788 0 0 1 6.727-5.91zm0-2a8.811 8.811 0 0\n    0-8.233 5.715 7.724 7.724 0 0 0-7.69 7.406A5.214 5.214 0 0 0 6.214 28h21.429a7.357 7.357 0 0 0 1.643-14.529A8.8 8.8\n    0 0 0 20.5 4.714z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CloudOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CloudOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2i, create_fragment$2i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Code.svelte generated by Svelte v3.24.1 */

function create_fragment$2j(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.493 19.061l-8.193 8.32a1 1 0 0 1-1.425 0l-.893-.907a1.006 1.006 0 0 1 0-1.4L31.943 18l-6.959-7.071a1.006\n    1.006 0 0 1 0-1.4l.893-.907a1 1 0 0 1 1.425 0l8.191 8.32a1.523 1.523 0 0 1 0 2.119zM.507 16.939L8.7 8.619a1 1 0 0 1\n    1.425 0l.893.907a1.006 1.006 0 0 1 0 1.4L4.057 18l6.959 7.071a1.006 1.006 0 0 1 0 1.4l-.893.907a1 1 0 0 1-1.425\n    0L.507 19.061a1.523 1.523 0 0 1 0-2.122zM15.489 29.687h-1.144a1 1 0 0 1-.966-1.259l6.192-23.041a1 1 0 0 1\n    .966-.741h1.105a1 1 0 0 1 .966 1.254l-6.153 23.046a1 1 0 0 1-.966.741z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Code" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Code extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2j, create_fragment$2j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Collection.svelte generated by Svelte v3.24.1 */

function create_fragment$2k(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 4H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM12 28H4V18h8zm0-12H4V6h8zm10\n    12h-8V18h8zm0-12h-8V6h8zm10 12h-8V18h8zm0-12h-8V6h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Collection" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Collection extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2k, create_fragment$2k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CollectionAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$2l(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.1 25a8.9 8.9 0 1 0 8.9-8.9 8.9 8.9 0 0 0-8.9 8.9zm3.9-.5a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0\n    1 .5.5V24h3.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V26h-3.5a.5.5 0 0 1-.5-.5z");
			attr(path1, "d", "M15.084 28H14V18h2.893a12.368 12.368 0 0 1 1.743-2H14V6h8v7.769a12.2 12.2 0 0 1 2-.685V6h8v7.769a12.274 12.274 0\n    0 1 2 1.124V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h12.769a12.2 12.2 0 0 1-.685-2zM12\n    28H4V18h8zm0-12H4V6h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CollectionAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CollectionAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2l, create_fragment$2l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CollectionAddTo.svelte generated by Svelte v3.24.1 */

function create_fragment$2m(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 28h-6V18h6v-2h-6V6h8v8h2V6h8v8h2V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h17zm-8\n    0H4V18h8zm0-12H4V6h8z");
			attr(path1, "d", "M35.394 25.051l-3.837-3.837 4.3-4.363A.5.5 0 0 0 35.5 16H22v13.494a.5.5 0 0 0 .854.358l4.33-4.265 3.837 3.837a1 1\n    0 0 0 1.414 0l2.96-2.959a1 1 0 0 0-.001-1.414z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CollectionAddTo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CollectionAddTo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2m, create_fragment$2m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CollectionCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$2n(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.084 28H14V18h2.893a12.368 12.368 0 0 1 1.743-2H14V6h8v7.769a12.2 12.2 0 0 1 2-.685V6h8v7.769a12.274 12.274 0\n    0 1 2 1.124V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h12.769a12.2 12.2 0 0 1-.685-2zM12\n    28H4V18h8zm0-12H4V6h8z");
			attr(path1, "d", "M27 16.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CollectionCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CollectionCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2n, create_fragment$2n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CollectionEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$2o(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.9 28.046c.006-.016.016-.03.022-.046H14V18h8v6.582l2-2V18h4.582l1.118-1.123a2.856 2.856 0 0 1\n    1.978-.833h.023a2.724 2.724 0 0 1 1.941.8L34 17.2V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h15.115zM24\n    6h8v10h-8zM14 6h8v10h-8zm-2 22H4V18h8zm0-12H4V6h8z");
			attr(path1, "d", "M35.738 21.764l-3.506-3.506a.738.738 0 0 0-.527-.215h-.023a.833.833 0 0 0-.564.247L20.929 28.48a.607.607 0 0\n    0-.153.256l-2.66 6.63c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039 5.756-2.4 6.634-2.661a.6.6 0 0 0\n    .252-.151l10.19-10.19a.836.836 0 0 0 .246-.537.743.743 0 0 0-.213-.58zm-10.97 10.33c-1.314.4-3.928 1.862-5.063\n    2.2l2.195-5.062z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CollectionEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CollectionEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2o, create_fragment$2o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CollectionExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$2p(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.084 28H14V18h2.893a12.368 12.368 0 0 1 1.743-2H14V6h8v7.769a12.2 12.2 0 0 1 2-.685V6h8v7.769a12.274 12.274 0\n    0 1 2 1.124V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h12.769a12.2 12.2 0 0 1-.685-2zM12\n    28H4V18h8zm0-12H4V6h8z");
			attr(path1, "d", "M27 16.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 25a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 25zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CollectionExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CollectionExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2p, create_fragment$2p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CollectionLink.svelte generated by Svelte v3.24.1 */

function create_fragment$2q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.136 28H14V18h8v1.208l1.937-1.937L25.207 16H24V6h8v7.063a7.552 7.552 0 0 1 2 .428V5a1 1 0 0 0-1-1H3a1 1 0 0\n    0-1 1v24a1 1 0 0 0 1 1h12.065a7.664 7.664 0 0 1 .071-2zM14 6h8v10h-8zm-2 22H4V18h8zm0-12H4V6h8z");
			attr(path1, "d", "M25.548 25.421a2.165 2.165 0 0 0 .421.611 2.19 2.19 0 0 0 3.094 0l3.609-3.609a2.188 2.188 0 0\n    0-3.094-3.094l-.819.819a5.85 5.85 0 0 0-2.649-.448l1.921-1.921a4.375 4.375 0 0 1 6.187 6.187l-3.609 3.609a4.351\n    4.351 0 0 1-6.656-.562zm-2.157-3l-3.609 3.609a4.375 4.375 0 0 0 6.187 6.187L27.89 30.3a5.851 5.851 0 0\n    1-2.649-.445l-.819.819a2.188 2.188 0 0 1-3.094-3.094l3.609-3.609a2.19 2.19 0 0 1 3.094 0 2.157 2.157 0 0 1\n    .421.611l1.6-1.6a4.351 4.351 0 0 0-6.656-.562z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CollectionLink" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CollectionLink extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2q, create_fragment$2q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColorFill.svelte generated by Svelte v3.24.1 */

function create_fragment$2r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.727 23.672a64.346 64.346 0 0 0-1.306-6.632c-.624-2.436-2.919-2.98-5.34-3.308l-8.107-8.107a1 1 0 0 0-1.415\n    0l-2.424 2.43 4.872 4.872a1.5 1.5 0 1 1-2.121 2.121l-4.872-4.872L1.856 21.334a1 1 0 0 0 0 1.415l10.753 10.739a1 1 0\n    0 0 1.414 0l15.571-15.594a1 1 0 0 0 .015-1.4.38.38 0 0 1 .566.149c.5.938.69 2.8-.528 5.574-.377.86-1.388 2.148-1.388\n    3.256a2.516 2.516 0 0 0 2.779 2.8c1.642.001 2.995-1.54 2.689-4.601zM15.131 8.05L9.4 2.317a1.5 1.5 0 0 0-2.124\n    2.121l5.733 5.733z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColorFill" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColorFill extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2r, create_fragment$2r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColorPalette.svelte generated by Svelte v3.24.1 */

function create_fragment$2s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M23.614 6.145c-4.371-.7-9.006 0-9.648 2.092a2.292 2.292 0 0 0 1.294 2.908c1.152.647 2.6 2.673 1.139 4.541a2.829\n    2.829 0 0 1-3.125 1.126c-3.748-.947-7.893-2.882-11.285.345C-1.1 20.1.158 24.466 3.154 26.842a23.4 23.4 0 0 0 14.513\n    5.274C27.253 32.116 35.8 26.465 35.8 19c0-7.558-7.168-12.057-12.186-12.855zM8.694 27.453a3.8 3.8 0 1 1 3.8-3.8 3.8\n    3.8 0 0 1-3.8 3.8zM27.98 11.419a2.5 2.5 0 1 1-2.5 2.5 2.5 2.5 0 0 1 2.5-2.5zm-10.7 18.14A3.561 3.561 0 1 1 20.837\n    26a3.56 3.56 0 0 1-3.559 3.559zm7.79-1.5a3.005 3.005 0 1 1 3-3 3.005 3.005 0 0 1-3.002 3.004zM30 22.56a2.675 2.675 0\n    1 1 2.674-2.675A2.674 2.674 0 0 1 30 22.56z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColorPalette" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColorPalette extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2s, create_fragment$2s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColorWheel.svelte generated by Svelte v3.24.1 */

function create_fragment$2t(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			attr(path0, "d", "M32 18a13.953 13.953 0 0 0-4.114-9.9L18 18z");
			attr(path1, "d", "M18 18l9.919 9.869A13.956 13.956 0 0 0 32 18z");
			attr(path2, "d", "M18 18v14a13.955 13.955 0 0 0 9.874-4.087z");
			attr(path3, "d", "M18 32V18l-9.9 9.889A13.96 13.96 0 0 0 18 32z");
			attr(path4, "d", "M18 18H4a13.959 13.959 0 0 0 4.1 9.889z");
			attr(path5, "d", "M18 18L8.09 8.122A13.953 13.953 0 0 0 4 18z");
			attr(path6, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm0 30A13.991 13.991 0 0 1 8.07 8.144L17.939 18V4H18a14 14 0 0 1 0 28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
			append(svg, path5);
			append(svg, path6);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColorWheel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColorWheel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2t, create_fragment$2t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColumnSettings.svelte generated by Svelte v3.24.1 */

function create_fragment$2u(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10 34H3a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h7zM17.42 30.937a3.613 3.613 0 0 1-2.22-3.33v-1.214a3.612 3.612 0 0 1\n    2.22-3.33 3.614 3.614 0 0 1 .775-3.948l.918-.919a3.584 3.584 0 0 1 2.552-1.057c.114 0\n    .223.023.334.033V2H14v32h3.546a3.627 3.627 0 0 1-.126-3.063zM26.393 15.2h1.214a3.613 3.613 0 0 1 3.329 2.219 3.545\n    3.545 0 0 1 3.064.144V3a1 1 0 0 0-1-1h-7v13.26a3.423 3.423 0 0 1 .393-.06z");
			attr(path1, "d", "M35.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.145 6.145 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.145\n    6.145 0 0 0-2.178.9l-1.513-1.513a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.513a6.142 6.142 0 0\n    0-.9 2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.131a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM27 30.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColumnSettings" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColumnSettings extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2u, create_fragment$2u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColumnTwoA.svelte generated by Svelte v3.24.1 */

function create_fragment$2v(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 2H20v32h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zM16 2H4a2 2 0 0 0-2 2v28a2 2 0 0 0 2 2h12z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColumnTwoA" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColumnTwoA extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2v, create_fragment$2v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColumnTwoB.svelte generated by Svelte v3.24.1 */

function create_fragment$2w(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 2h-6v32h6a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zM22 2H4a2 2 0 0 0-2 2v28a2 2 0 0 0 2 2h18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColumnTwoB" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColumnTwoB extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2w, create_fragment$2w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ColumnTwoC.svelte generated by Svelte v3.24.1 */

function create_fragment$2x(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 2H14v32h18a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zM10 2H4a2 2 0 0 0-2 2v28a2 2 0 0 0 2 2h6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ColumnTwoC" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ColumnTwoC extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2x, create_fragment$2x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Comment.svelte generated by Svelte v3.24.1 */

function create_fragment$2y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6 4a4 4 0 0 0-4 4v14a4 4 0 0 0 4 4h2v8.793a.5.5 0 0 0 .854.353L18 26h12a4 4 0 0 0 4-4V8a4 4 0 0 0-4-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Comment" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Comment extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2y, create_fragment$2y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Compare.svelte generated by Svelte v3.24.1 */

function create_fragment$2z(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M35.191 32.143L30.646 27.6a9.066 9.066 0 1 0-3.046 3.046l4.545 4.545a2.044 2.044 0 0 0 3.048 0 2.195 2.195 0 0\n    0-.002-3.048zM17.412 22.98a5.568 5.568 0 1 1 5.568 5.567 5.568 5.568 0 0 1-5.568-5.567z");
			attr(path1, "d", "M11.6 23A11.4 11.4 0 0 1 20 12.012V11a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h18a.948.948 0 0 0\n    .5-.155A11.4 11.4 0 0 1 11.6 23z");
			attr(path2, "d", "M22 9v2.65c.33-.029.662-.05 1-.05a11.334 11.334 0 0 1 5 1.167V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v5h13a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Compare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Compare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2z, create_fragment$2z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Compass.svelte generated by Svelte v3.24.1 */

function create_fragment$2A(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M1.5 19.5H3a1.455 1.455 0 0 0 .149-.03A14.824 14.824 0 0 0 4.835 25L6.7 22.237A12.049 12.049 0 0 1 22.182\n    6.684l2.775-1.873a14.818 14.818 0 0 0-5.487-1.662A1.455 1.455 0 0 0 19.5 3V1.5a1.5 1.5 0 0 0-3 0V3a1.455 1.455 0 0 0\n    .03.149A14.927 14.927 0 0 0 3.149 16.53 1.455 1.455 0 0 0 3 16.5H1.5a1.5 1.5 0 0 0 0 3zM34.5 16.5H33a1.455 1.455 0 0\n    0-.149.03 14.828 14.828 0 0 0-1.662-5.488l-1.873 2.775A12.049 12.049 0 0 1 13.764 29.3L11 31.165a14.824 14.824 0 0 0\n    5.534 1.686A1.455 1.455 0 0 0 16.5 33v1.5a1.5 1.5 0 0 0 3 0V33a1.455 1.455 0 0 0-.03-.149A14.927 14.927 0 0 0 32.851\n    19.47a1.455 1.455 0 0 0 .149.03h1.5a1.5 1.5 0 0 0 0-3zM14.707 15.745L3.173 32.827l17.082-11.534a4.516 4.516 0 0 0\n    1.211-1.211L33 3 15.918 14.534a4.516 4.516 0 0 0-1.211 1.211zm3.3 4.973a2.726 2.726 0 1 1 2.726-2.726 2.727 2.727 0\n    0 1-2.725 2.726z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Compass" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Compass extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2A, create_fragment$2A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Condition.svelte generated by Svelte v3.24.1 */

function create_fragment$2B(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.828 25l4.88-4.879a1 1 0 0 0 0-1.414l-1.415-1.414a1 1 0 0 0-1.414 0L25 22.172l-4.879-4.88a1 1 0 0 0-1.414\n    0l-1.414 1.415a1 1 0 0 0 0 1.414L22.172 25l-4.88 4.879a1 1 0 0 0 0 1.414l1.415 1.414a1 1 0 0 0 1.414 0L25\n    27.828l4.879 4.879a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414zM21.448 3.428L19.8 2.295a1 1 0 0 0-1.39.257L9.684\n    15.24l-4.657-4.657a1 1 0 0 0-1.414 0L2.2 11.997a1 1 0 0 0 0 1.414l7.207 7.207a1 1 0 0 0 1.53-.14l10.768-15.66a1 1 0\n    0 0-.257-1.39z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Condition" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Condition extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2B, create_fragment$2B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ConfidenceFour.svelte generated by Svelte v3.24.1 */

function create_fragment$2C(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 8);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 26);
			attr(rect1, "height", rect1_height_value = 16);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 10);
			attr(rect1, "y", rect1_y_value = 18);
			attr(rect2, "height", rect2_height_value = 24);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 18);
			attr(rect2, "y", rect2_y_value = 10);
			attr(rect3, "height", rect3_height_value = 32);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 6);
			attr(rect3, "x", rect3_x_value = 26);
			attr(rect3, "y", rect3_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ConfidenceFour" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ConfidenceFour extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2C, create_fragment$2C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ConfidenceOne.svelte generated by Svelte v3.24.1 */

function create_fragment$2D(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 6);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 26);
			attr(path, "d", "M16 33a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1zM24 33a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1zM32\n    33a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ConfidenceOne" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ConfidenceOne extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2D, create_fragment$2D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ConfidenceThree.svelte generated by Svelte v3.24.1 */

function create_fragment$2E(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 8);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 26);
			attr(rect1, "height", rect1_height_value = 16);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 10);
			attr(rect1, "y", rect1_y_value = 18);
			attr(rect2, "height", rect2_height_value = 24);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 18);
			attr(rect2, "y", rect2_y_value = 10);
			attr(path, "d", "M32 33a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ConfidenceThree" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ConfidenceThree extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2E, create_fragment$2E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ConfidenceTwo.svelte generated by Svelte v3.24.1 */

function create_fragment$2F(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 8);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 26);
			attr(rect1, "height", rect1_height_value = 16);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 10);
			attr(rect1, "y", rect1_y_value = 18);
			attr(path, "d", "M32 33a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1zM24 33a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ConfidenceTwo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ConfidenceTwo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2F, create_fragment$2F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Contrast.svelte generated by Svelte v3.24.1 */

function create_fragment$2G(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 2.1A15.9 15.9 0 1 0 33.9 18 15.9 15.9 0 0 0 18 2.1zm0 29.813A13.913 13.913 0 1 1 31.913 18 13.912 13.912 0 0\n    1 18 31.913z");
			attr(path1, "d", "M18 6.2v23.6a11.8 11.8 0 0 0 0-23.6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Contrast" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Contrast extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2G, create_fragment$2G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ConversionFunnel.svelte generated by Svelte v3.24.1 */

function create_fragment$2H(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 24v11a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V24zm11.975 4.2l-5.053 6.738a.375.375 0 0 1-.565.04L12.7 31.326a.375.375\n    0 0 1 0-.53l1.6-1.596a.375.375 0 0 1 .53 0l1.512 1.512 3.233-4.312a.375.375 0 0 1 .525-.075l1.8 1.35a.375.375 0 0 1\n    .075.525zM29 12H5l4.167 10h15.666L29 12zM33.25 0H.75a.5.5 0 0 0-.462.692L4.167 10h25.666L33.712.692A.5.5 0 0 0 33.25\n    0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ConversionFunnel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ConversionFunnel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2H, create_fragment$2H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Copy.svelte generated by Svelte v3.24.1 */

function create_fragment$2I(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let rect8;
	let rect8_height_value;
	let rect8_rx_value;
	let rect8_ry_value;
	let rect8_width_value;
	let rect8_x_value;
	let rect8_y_value;
	let rect9;
	let rect9_height_value;
	let rect9_rx_value;
	let rect9_ry_value;
	let rect9_width_value;
	let rect9_x_value;
	let rect9_y_value;
	let rect10;
	let rect10_height_value;
	let rect10_rx_value;
	let rect10_ry_value;
	let rect10_width_value;
	let rect10_x_value;
	let rect10_y_value;
	let rect11;
	let rect11_height_value;
	let rect11_rx_value;
	let rect11_ry_value;
	let rect11_width_value;
	let rect11_x_value;
	let rect11_y_value;
	let rect12;
	let rect12_height_value;
	let rect12_rx_value;
	let rect12_ry_value;
	let rect12_width_value;
	let rect12_x_value;
	let rect12_y_value;
	let rect13;
	let rect13_height_value;
	let rect13_rx_value;
	let rect13_ry_value;
	let rect13_width_value;
	let rect13_x_value;
	let rect13_y_value;
	let rect14;
	let rect14_height_value;
	let rect14_rx_value;
	let rect14_ry_value;
	let rect14_width_value;
	let rect14_x_value;
	let rect14_y_value;
	let rect15;
	let rect15_height_value;
	let rect15_rx_value;
	let rect15_ry_value;
	let rect15_width_value;
	let rect15_x_value;
	let rect15_y_value;
	let rect16;
	let rect16_height_value;
	let rect16_rx_value;
	let rect16_ry_value;
	let rect16_width_value;
	let rect16_x_value;
	let rect16_y_value;
	let rect17;
	let rect17_height_value;
	let rect17_rx_value;
	let rect17_ry_value;
	let rect17_width_value;
	let rect17_x_value;
	let rect17_y_value;
	let rect18;
	let rect18_height_value;
	let rect18_rx_value;
	let rect18_ry_value;
	let rect18_width_value;
	let rect18_x_value;
	let rect18_y_value;
	let rect19;
	let rect19_height_value;
	let rect19_rx_value;
	let rect19_ry_value;
	let rect19_width_value;
	let rect19_x_value;
	let rect19_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			rect8 = svg_element("rect");
			rect9 = svg_element("rect");
			rect10 = svg_element("rect");
			rect11 = svg_element("rect");
			rect12 = svg_element("rect");
			rect13 = svg_element("rect");
			rect14 = svg_element("rect");
			rect15 = svg_element("rect");
			rect16 = svg_element("rect");
			rect17 = svg_element("rect");
			rect18 = svg_element("rect");
			rect19 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 32);
			attr(rect0, "y", rect0_y_value = 22);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 32);
			attr(rect1, "y", rect1_y_value = 18);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 32);
			attr(rect2, "y", rect2_y_value = 14);
			attr(rect3, "height", rect3_height_value = 2);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 32);
			attr(rect3, "y", rect3_y_value = 10);
			attr(rect4, "height", rect4_height_value = 2);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 32);
			attr(rect4, "y", rect4_y_value = 6);
			attr(rect5, "height", rect5_height_value = 2);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 2);
			attr(rect5, "x", rect5_x_value = 32);
			attr(rect5, "y", rect5_y_value = 2);
			attr(rect6, "height", rect6_height_value = 2);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 28);
			attr(rect6, "y", rect6_y_value = 2);
			attr(rect7, "height", rect7_height_value = 2);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 2);
			attr(rect7, "x", rect7_x_value = 24);
			attr(rect7, "y", rect7_y_value = 2);
			attr(rect8, "height", rect8_height_value = 2);
			attr(rect8, "rx", rect8_rx_value = 0.5);
			attr(rect8, "ry", rect8_ry_value = 0.5);
			attr(rect8, "width", rect8_width_value = 2);
			attr(rect8, "x", rect8_x_value = 20);
			attr(rect8, "y", rect8_y_value = 2);
			attr(rect9, "height", rect9_height_value = 2);
			attr(rect9, "rx", rect9_rx_value = 0.5);
			attr(rect9, "ry", rect9_ry_value = 0.5);
			attr(rect9, "width", rect9_width_value = 2);
			attr(rect9, "x", rect9_x_value = 16);
			attr(rect9, "y", rect9_y_value = 2);
			attr(rect10, "height", rect10_height_value = 2);
			attr(rect10, "rx", rect10_rx_value = 0.5);
			attr(rect10, "ry", rect10_ry_value = 0.5);
			attr(rect10, "width", rect10_width_value = 2);
			attr(rect10, "x", rect10_x_value = 12);
			attr(rect10, "y", rect10_y_value = 2);
			attr(rect11, "height", rect11_height_value = 2);
			attr(rect11, "rx", rect11_rx_value = 0.5);
			attr(rect11, "ry", rect11_ry_value = 0.5);
			attr(rect11, "width", rect11_width_value = 2);
			attr(rect11, "x", rect11_x_value = 12);
			attr(rect11, "y", rect11_y_value = 6);
			attr(rect12, "height", rect12_height_value = 2);
			attr(rect12, "rx", rect12_rx_value = 0.5);
			attr(rect12, "ry", rect12_ry_value = 0.5);
			attr(rect12, "width", rect12_width_value = 2);
			attr(rect12, "x", rect12_x_value = 12);
			attr(rect12, "y", rect12_y_value = 10);
			attr(rect13, "height", rect13_height_value = 2);
			attr(rect13, "rx", rect13_rx_value = 0.5);
			attr(rect13, "ry", rect13_ry_value = 0.5);
			attr(rect13, "width", rect13_width_value = 2);
			attr(rect13, "x", rect13_x_value = 12);
			attr(rect13, "y", rect13_y_value = 14);
			attr(rect14, "height", rect14_height_value = 2);
			attr(rect14, "rx", rect14_rx_value = 0.5);
			attr(rect14, "ry", rect14_ry_value = 0.5);
			attr(rect14, "width", rect14_width_value = 2);
			attr(rect14, "x", rect14_x_value = 12);
			attr(rect14, "y", rect14_y_value = 18);
			attr(rect15, "height", rect15_height_value = 2);
			attr(rect15, "rx", rect15_rx_value = 0.5);
			attr(rect15, "ry", rect15_ry_value = 0.5);
			attr(rect15, "width", rect15_width_value = 2);
			attr(rect15, "x", rect15_x_value = 12);
			attr(rect15, "y", rect15_y_value = 22);
			attr(rect16, "height", rect16_height_value = 2);
			attr(rect16, "rx", rect16_rx_value = 0.5);
			attr(rect16, "ry", rect16_ry_value = 0.5);
			attr(rect16, "width", rect16_width_value = 2);
			attr(rect16, "x", rect16_x_value = 16);
			attr(rect16, "y", rect16_y_value = 22);
			attr(rect17, "height", rect17_height_value = 2);
			attr(rect17, "rx", rect17_rx_value = 0.5);
			attr(rect17, "ry", rect17_ry_value = 0.5);
			attr(rect17, "width", rect17_width_value = 2);
			attr(rect17, "x", rect17_x_value = 20);
			attr(rect17, "y", rect17_y_value = 22);
			attr(rect18, "height", rect18_height_value = 2);
			attr(rect18, "rx", rect18_rx_value = 0.5);
			attr(rect18, "ry", rect18_ry_value = 0.5);
			attr(rect18, "width", rect18_width_value = 2);
			attr(rect18, "x", rect18_x_value = 24);
			attr(rect18, "y", rect18_y_value = 22);
			attr(rect19, "height", rect19_height_value = 2);
			attr(rect19, "rx", rect19_rx_value = 0.5);
			attr(rect19, "ry", rect19_ry_value = 0.5);
			attr(rect19, "width", rect19_width_value = 2);
			attr(rect19, "x", rect19_x_value = 28);
			attr(rect19, "y", rect19_y_value = 22);
			attr(path, "d", "M10 12H3a1 1 0 0 0-1 1v20a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1v-7H11a1 1 0 0 1-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, rect8);
			append(svg, rect9);
			append(svg, rect10);
			append(svg, rect11);
			append(svg, rect12);
			append(svg, rect13);
			append(svg, rect14);
			append(svg, rect15);
			append(svg, rect16);
			append(svg, rect17);
			append(svg, rect18);
			append(svg, rect19);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Copy" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Copy extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2I, create_fragment$2I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CoverImage.svelte generated by Svelte v3.24.1 */

function create_fragment$2J(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 23.8);
			attr(circle, "cy", circle_cy_value = 12.6);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path0, "d", "M34.875 4H1.125A1.068 1.068 0 0 0 0 5v22a1.068 1.068 0 0 0 1.125 1h2.4a13.248 13.248 0 0 1 3.24-1.088 11.565\n    11.565 0 0 1-2.131-6.469c0-.046.01-.086.01-.131C3.152 22.2 2 24 2 24V6h32v16a15.164 15.164 0 0 0-6.182-2c-2.463\n    0-4.647 2.785-7.019 3.7a11.691 11.691 0 0 1-1.55 3.242A13.647 13.647 0 0 1 22.383 28h12.492A1.068 1.068 0 0 0 36\n    27V5a1.068 1.068 0 0 0-1.125-1z");
			attr(path1, "d", "M24 34.038a3.12 3.12 0 0 0-1.048-2.353 10.109 10.109 0 0 0-5.738-2.234 1.144 1.144 0 0 1-.99-1.148v-1.658a1.114\n    1.114 0 0 1 .276-.721 8.747 8.747 0 0 0 2.007-5.481C18.507 16.31 16.315 14 13 14s-5.567 2.4-5.567 6.443a8.853 8.853\n    0 0 0 2.1 5.485 1.106 1.106 0 0 1 .273.717V28.3a1.138 1.138 0 0 1-.993 1.148 9.693 9.693 0 0 0-5.809 2.232A3.125\n    3.125 0 0 0 2 34v2h22z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CoverImage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CoverImage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2J, create_fragment$2J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CreditCard.svelte generated by Svelte v3.24.1 */

function create_fragment$2K(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M2 32.512A1.488 1.488 0 0 0 3.488 34h26.778a1.488 1.488 0 0 0 1.488-1.488V30H2zM30.065 19.026c-2.341 1.174-10.486\n    4.954-10.789 5.095a6.419 6.419 0 0 1-2.646.6 4.686 4.686 0 0 1-4.378-2.82 5.272 5.272 0 0 1 1.163-5.757H3.488A1.488\n    1.488 0 0 0 2 17.635v8.926h29.754v-8.73a8.22 8.22 0 0 1-1.689 1.195z");
			attr(path1, "d", "M11.5 13.172s.265-1.214.791-3.135c.358-1.31 4.972-7.053 6.739-7.642 1.743-.582 11.51-1.125 11.51-1.125L35\n    9.05s-3.936 6.15-6.266 7.315-10.754 5.077-10.754 5.077-2.194\n    1.061-3.016-.761c-.625-1.385.788-2.662.788-2.662s3.218-2.232 4.461-3.211c.9-.713\n    1.861-2.133.586-3.408s-2.575-.012-3.251.574-1.338 1.2-1.338 1.2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CreditCard" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CreditCard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2K, create_fragment$2K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Crop.svelte generated by Svelte v3.24.1 */

function create_fragment$2L(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24 22h4V9a1 1 0 0 0-1-1H14v4h10z");
			attr(path1, "d", "M12 24V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v5H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h5v15a1 1 0 0 0 1 1h15v5a1 1 0 0 0 1\n    1h2a1 1 0 0 0 1-1v-5h5a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Crop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Crop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2L, create_fragment$2L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CropLightning.svelte generated by Svelte v3.24.1 */

function create_fragment$2M(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 27a10.962 10.962 0 0 1 .416-3H12V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v5H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h5v15a1 1 0\n    0 0 1 1h7.046c-.03-.329-.046-.663-.046-1zM24 16.416A10.962 10.962 0 0 1 27 16c.337 0 .671.016 1 .046V9a1 1 0 0\n    0-1-1H14v4h10zM27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm4.081 9.748l-5.927 6.778a.613.613 0 0\n    1-1.027-.642l2-4.749-2.827-1.214a1.059 1.059 0 0 1-.379-1.67l5.928-6.777a.613.613 0 0 1 1.026.642l-2 4.749 2.825\n    1.214a1.058 1.058 0 0 1 .381 1.669z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CropLightning" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CropLightning extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2M, create_fragment$2M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/CropRotate.svelte generated by Svelte v3.24.1 */

function create_fragment$2N(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M23 21h3V10.5a.5.5 0 0 0-.5-.5H16v3h7z");
			attr(path1, "d", "M28.5 23H13V6.5a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 0-.5.5V10H6.5a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5H10v12.5a.5.5 0 0 0\n    .5.5H23v3.5a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5V26h2.5a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5zM28.264 3h-.23V.5a.5.5 0\n    0 0-.5-.5.493.493 0 0 0-.35.147l-4.037 3.537a.5.5 0 0 0 0 .632l4.034 3.537a.493.493 0 0 0 .35.147.5.5 0 0 0\n    .5-.5V4.958h.23a3.786 3.786 0 0 1 3.781 3.892v.827a.325.325 0 0 0 .326.326h1.3A.326.326 0 0 0 34 9.674v-.827A5.74\n    5.74 0 0 0 28.264 3zM8.819 28.147a.493.493 0 0 0-.35-.147.5.5 0 0 0-.5.5v2.541h-.23a3.786 3.786 0 0\n    1-3.781-3.892v-.827A.325.325 0 0 0 3.629 26h-1.3a.326.326 0 0 0-.329.326v.827A5.74 5.74 0 0 0 7.736 33h.23v2.5a.5.5\n    0 0 0 .5.5.493.493 0 0 0 .35-.147l4.034-3.537a.5.5 0 0 0 0-.632z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "CropRotate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class CropRotate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2N, create_fragment$2N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Crosshairs.svelte generated by Svelte v3.24.1 */

function create_fragment$2O(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 15.8a2.2 2.2 0 1 0 2.2 2.2 2.2 2.2 0 0 0-2.2-2.2z");
			attr(path1, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm2 29.552V24h-4v7.552A13.7 13.7 0 0 1 4.448 20H12v-4H4.448A13.7 13.7 0 0\n    1 16 4.448V12h4V4.448A13.7 13.7 0 0 1 31.552 16H24v4h7.552A13.7 13.7 0 0 1 20 31.552z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Crosshairs" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Crosshairs extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2O, create_fragment$2O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Curate.svelte generated by Svelte v3.24.1 */

function create_fragment$2P(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 4H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-1 26H2v-6h9.663a3.477 3.477 0 0 0 6.674\n    0h1.326a3.477 3.477 0 0 0 6.674 0H34zm0-8h-7.663a3.477 3.477 0 0 0-6.674 0h-1.326a3.477 3.477 0 0 0-6.674\n    0H2v-8h1.663a3.477 3.477 0 0 0 6.674 0h1.326a3.477 3.477 0 0 0 6.674 0h7.326a3.477 3.477 0 0 0 6.674\n    0H34zm0-10h-1.663a3.477 3.477 0 0 0-6.674 0h-7.326a3.477 3.477 0 0 0-6.674 0h-1.326a3.477 3.477 0 0 0-6.674\n    0H2V6h32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Curate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Curate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2P, create_fragment$2P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Cut.svelte generated by Svelte v3.24.1 */

function create_fragment$2Q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.912 22.12c0-.007.035-.028.026-.028a8.481 8.481 0 0\n    1-7.138-4.018c-.017-.028-.046-.047-.065-.074.019-.027.048-.046.065-.074a8.481 8.481 0 0 1 7.142-4.018c.009\n    0-.023-.021-.026-.028a5.917 5.917 0 1 0-3.93-1.588l-6.47 3.444-12.6-6.7a4 4 0 0 0-3.8.023L.822 10.313 15.26 18 .822\n    25.687l2.292 1.255a4 4 0 0 0 3.8.023l12.6-6.7 6.47 3.444a5.892 5.892 0 1 0 3.93-1.588zm.367-18.038a3.933 3.933 0 1\n    1-4.2 3.641 3.932 3.932 0 0 1 4.2-3.641zm0 27.836a3.933 3.933 0 1 1 3.641-4.2 3.933 3.933 0 0 1-3.641 4.2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Cut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Cut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2Q, create_fragment$2Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Dashboard.svelte generated by Svelte v3.24.1 */

function create_fragment$2R(ctx) {
	let svg;
	let path0;
	let path1;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			attr(path0, "d", "M7.324 28.053a13.27 13.27 0 0 1-2.656-7.794A13.483 13.483 0 0 1 17.612 6.741a13.331 13.331 0 0 1 11.064\n    21.312.725.725 0 0 0 .1 1l.931.775a.733.733 0 0 0 1.048-.107 16 16 0 1 0-25.515 0 .729.729 0 0 0\n    1.045.107l.932-.776a.724.724 0 0 0 .107-.999z");
			attr(path1, "d", "M20.839 23.526a2.909 2.909 0 1 1-3.474-2.2c.748-.167 5.534-6.2 6.146-5.845.673.39-2.855 7.225-2.672 8.045z");
			attr(circle0, "cx", circle0_cx_value = 7.818);
			attr(circle0, "cy", circle0_cy_value = 20.069);
			attr(circle0, "r", circle0_r_value = 1.6);
			attr(circle1, "cx", circle1_cx_value = 10.727);
			attr(circle1, "cy", circle1_cy_value = 12.796);
			attr(circle1, "r", circle1_r_value = 1.6);
			attr(circle2, "cx", circle2_cx_value = 25.273);
			attr(circle2, "cy", circle2_cy_value = 12.796);
			attr(circle2, "r", circle2_r_value = 1.455);
			attr(circle3, "cx", circle3_cx_value = 18);
			attr(circle3, "cy", circle3_cy_value = 9.887);
			attr(circle3, "r", circle3_r_value = 1.455);
			attr(circle4, "cx", circle4_cx_value = 28.182);
			attr(circle4, "cy", circle4_cy_value = 20.069);
			attr(circle4, "r", circle4_r_value = 1.455);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Dashboard" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Dashboard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2R, create_fragment$2R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Data.svelte generated by Svelte v3.24.1 */

function create_fragment$2S(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M18 24.275c-4.936 0-14.212-1.169-16-4V29c0 2.761 7.163 5 16 5s16-2.239 16-5v-8.73c-2.447 3.095-11.064 4.005-16\n    4.005z");
			attr(path1, "d", "M18 14.275c-4.936 0-14.212-1.169-16-4.005V17c0 2.761 7.163 5 16 5s16-2.239 16-5v-6.73c-2.447 3.095-11.064\n    4.005-16 4.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Data" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Data extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2S, create_fragment$2S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$2T(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm4.9 10.4h-3.4v3.4a.5.5 0 0 1-.5.5h-2a.5.5 0 0\n    1-.5-.5v-3.4h-3.4a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5h3.4v-3.4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v3.4h3.4a.5.5 0 0\n    1 .5.5v2a.5.5 0 0 1-.5.5zM15 27a11.972 11.972 0 0 1 .347-2.82C10.288 23.856 3.5 22.653 2 20.27V29c0 2.683 6.769\n    4.866 15.258 4.988A11.932 11.932 0 0 1 15 27z");
			attr(path1, "d", "M27 15a11.924 11.924 0 0 1 6.961 2.238A1.5 1.5 0 0 0 34 17v-6.73c-2.447 3.1-11.064 4-16 4s-14.212-1.168-16-4V17c0\n    2.562 6.171 4.671 14.12 4.963A11.989 11.989 0 0 1 27 15z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2T, create_fragment$2T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataBook.svelte generated by Svelte v3.24.1 */

function create_fragment$2U(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path, "d", "M10.6 29.766a10.425 10.425 0 0 1 1.819-5.55l.209-.281C8.117 23.408 3.245 22.244 2 20.27V29c0 2.029 3.874 3.771\n    9.429 4.555a9.315 9.315 0 0 1-.829-3.789zM34 12.8v-2.53a9.226 9.226 0 0 1-4.529 2.53zM19.729\n    14.39c.044-.058.1-.1.149-.156-.665.027-1.3.041-1.877.041-4.936 0-14.212-1.168-16-4V17c0 2.349 5.191 4.314 12.179\n    4.851zM27.656 32.883h-7.935a2.922 2.922 0 0 1-3.113-3.117 2.927 2.927 0 0 1 3.113-3.116h8.509a.779.779 0 0 0\n    .623-.312l6.831-9.714a.39.39 0 0 0-.311-.624H22.911a.779.779 0 0 0-.623.312l-7.3 9.814A6.219 6.219 0 0 0 20.01\n    36h8.22a.779.779 0 0 0 .623-.312l6.831-9.714a.39.39 0 0 0-.312-.623h-2.521z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataBook" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataBook extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2U, create_fragment$2U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$2V(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M14.7 27a12.3 12.3 0 0 1 .342-2.84C10.02 23.808 3.473 22.605 2 20.27V29c0 2.643 6.568 4.8 14.879 4.982A12.235\n    12.235 0 0 1 14.7 27zM27 14.7a12.236 12.236 0 0 1 7 2.193V10.27c-2.447 3.095-11.064 4-16 4s-14.212-1.169-16-4V17c0\n    2.527 6 4.61 13.794 4.947A12.293 12.293 0 0 1 27 14.7z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2V, create_fragment$2V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataCorrelated.svelte generated by Svelte v3.24.1 */

function create_fragment$2W(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M26 14c0-.4-.021-.8-.06-1.188A9.995 9.995 0 0 0 12.812 25.94c.391.039.787.06 1.188.06a12 12 0 0 0 12-12z");
			attr(path1, "d", "M10 22a12 12 0 0 1 15.482-11.482 12 12 0 1 0-14.964 14.964A11.989 11.989 0 0 1 10 22zM25.482 10.518a11.907 11.907\n    0 0 1 .458 2.294A10 10 0 1 1 12.812 25.94a11.907 11.907 0 0 1-2.294-.458 12 12 0 1 0 14.964-14.964z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataCorrelated" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataCorrelated extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2W, create_fragment$2W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataDownload.svelte generated by Svelte v3.24.1 */

function create_fragment$2X(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M10.777 25.179a2.422 2.422 0 0 1-.628-1.6C6.461 22.956 3.018 21.884 2 20.27V29c0 2.761 7.164 5 16 5 .277 0\n    .547-.009.821-.013zM33 13v5.727A2.36 2.36 0 0 0 34 17v-6.73c-.973 1.23-2.926 2.11-5.229 2.73zM12.63\n    21H17v-6.74c-5.094-.142-13.327-1.335-15-3.99V17c0 1.992 3.736 3.707 9.13 4.51a2.437 2.437 0 0 1 1.5-.51z");
			attr(path1, "d", "M35.146 24.854a.5.5 0 0 0-.353-.854H30v-8H20v8h-4.793a.5.5 0 0 0-.353.854L25 36z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataDownload" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataDownload extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2X, create_fragment$2X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$2Y(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path, "d", "M17.776 27.622a3.822 3.822 0 0 1 .891-1.4l2.025-2.026c-.965.055-1.881.083-2.692.083-4.936\n    0-14.212-1.168-16-4V29c0 2.467 5.726 4.513 13.249 4.921zM23.154 21.73l5.7-5.7a4.018 4.018 0 0 1\n    2.689-1.183h.164a3.91 3.91 0 0 1 2.293.742V10.27c-2.447 3.095-11.064 4-16 4s-14.212-1.168-16-4V17c0 2.761 7.164 5 16\n    5a48.811 48.811 0 0 0 5.154-.27zM35.738 21.764l-3.506-3.506a.738.738 0 0 0-.527-.215h-.023a.833.833 0 0\n    0-.564.247L20.929 28.48a.607.607 0 0 0-.153.256l-2.66 6.63c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039\n    5.756-2.4 6.634-2.661a.6.6 0 0 0 .252-.151l10.19-10.19a.836.836 0 0 0 .246-.537.743.743 0 0 0-.213-.58zm-10.97\n    10.33c-1.314.4-3.928 1.862-5.063 2.2l2.195-5.062z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2Y, create_fragment$2Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataMapping.svelte generated by Svelte v3.24.1 */

function create_fragment$2Z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 18.5a3.496 3.496 0 0 0-2.95 1.617l-5.087-1.454A6.072 6.072 0 0 0 24 18a5.994 5.994 0 0\n    0-2.75-5.043l2.349-5.48A3.54 3.54 0 0 0 24 7.5a3.5 3.5 0 1 0-2.24-.812l-2.35 5.48a5.993 5.993 0 0 0-4.885.943L7.079\n    5.665A3.498 3.498 0 1 0 5.665 7.08l7.446 7.446a5.995 5.995 0 0 0-.273 6.533L6.914 26.07a3.498 3.498 0 1 0 1.293\n    1.527l5.924-5.013a5.998 5.998 0 0 0 5.868 1.074l2.998 5.397a3.5 3.5 0 1 0 1.749-.973l-2.999-5.398a6.02 6.02 0 0 0\n    1.668-2.097l5.086 1.454A3.5 3.5 0 1 0 32 18.5zM24 2a2 2 0 1 1-2 2 2 2 0 0 1 2-2zM4 6a2 2 0 1 1 2-2 2 2 0 0 1-2 2zm1\n    25a2 2 0 1 1 2-2 2 2 0 0 1-2 2zm20.5-1.5a2 2 0 1 1-2 2 2 2 0 0 1 2-2zM32 24a2 2 0 1 1 2-2 2 2 0 0 1-2 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataMapping" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataMapping extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2Z, create_fragment$2Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$2_(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M14.8 30.2v-3.3a9.618 9.618 0 0 1 .116-1.1 13.076 13.076 0 0 1 .371-1.624C10.233 23.846 3.5 22.644 2 20.27V29c0\n    2.419 5.5 4.436 12.8 4.9zM27 14.8a12.115 12.115 0 0 1 6.3 1.85l.415-.424.285-.292V10.27c-2.447 3.095-11.064 4-16\n    4s-14.212-1.168-16-4V17c0 2.56 6.158 4.667 14.094 4.961A12.173 12.173 0 0 1 27 14.8zM27 33.435a6.212 6.212 0 0\n    1-4.771-2.123L24.537 29H18v6.55l2.5-2.509A8.744 8.744 0 0 0 27 36a9.3 9.3 0 0 0 9-9h-2.28A6.889 6.889 0 0 1 27\n    33.435z");
			attr(path1, "d", "M33.558 20.958A9.215 9.215 0 0 0 27 18a9.3 9.3 0 0 0-9 9h2.28A6.889 6.889 0 0 1 27 20.565a6.283 6.283 0 0 1 4.871\n    2.116L29.6 25H36v-6.535z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2_, create_fragment$2_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$2$(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M14.7 27a12.292 12.292 0 0 1 .342-2.84C10.02 23.808 3.473 22.605 2 20.27V29c0 2.643 6.568 4.8 14.879 4.982A12.236\n    12.236 0 0 1 14.7 27zM27 14.7a12.234 12.234 0 0 1 7 2.193V10.27c-2.447 3.095-11.064 4-16 4s-14.212-1.168-16-4V17c0\n    2.527 6 4.61 13.794 4.947A12.293 12.293 0 0 1 27 14.7z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2$, create_fragment$2$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataSettings.svelte generated by Svelte v3.24.1 */

function create_fragment$30(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M15 27a11.972 11.972 0 0 1 .347-2.82C10.288 23.856 3.5 22.653 2 20.27V29c0 2.683 6.769 4.866 15.258 4.988A11.932\n    11.932 0 0 1 15 27zM27 15a11.924 11.924 0 0 1 6.961 2.238A1.5 1.5 0 0 0 34 17v-6.73c-2.447 3.1-11.064 4-16\n    4s-14.212-1.168-16-4V17c0 2.562 6.171 4.671 14.12 4.963A11.989 11.989 0 0 1 27 15z");
			attr(path1, "d", "M35.193 25.786h-2.125a6.125 6.125 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.147 6.147 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.147\n    6.147 0 0 0-2.178.9L22.1 20.319a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.508 1.513a6.125 6.125 0 0 0-.9\n    2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.125 6.125 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.147 6.147 0 0 0 2.178.9V35.2a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.132a6.147 6.147 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.125 6.125 0 0 0 .9-2.179h2.13a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.607-.607zM27 30.164A3.164 3.164 0 1 1 30.164 27 3.165 3.165 0 0 1 27 30.164z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$30($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataSettings" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataSettings extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$30, create_fragment$30, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataUnavailable.svelte generated by Svelte v3.24.1 */

function create_fragment$31(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M14.7 27a12.3 12.3 0 0 1 .342-2.84C10.02 23.808 3.473 22.605 2 20.27V29c0 2.643 6.568 4.8 14.879 4.982A12.236\n    12.236 0 0 1 14.7 27zM27 14.7a12.234 12.234 0 0 1 7 2.192V10.27c-2.447 3.095-11.064 4-16 4s-14.212-1.168-16-4V17c0\n    2.527 6 4.61 13.794 4.947A12.293 12.293 0 0 1 27 14.7z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$31($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataUnavailable" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataUnavailable extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$31, create_fragment$31, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataUpload.svelte generated by Svelte v3.24.1 */

function create_fragment$32(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M17 31l-4.209-.011a2.5 2.5 0 0 1-1.852-4.179l2.517-2.786C8.729 23.548 3.321 22.366 2 20.27V29c0 2.656 6.632 4.822\n    15 4.984zM32.3 19.235C33.377 18.562 34 17.8 34 17v-6.73c-1.216 1.538-3.958 2.536-7.014 3.151zM22.456 14.063a50.39\n    50.39 0 0 1-4.456.212c-4.936 0-14.212-1.168-16-4V17c0 2.479 5.778 4.531 13.352 4.926z");
			attr(path1, "d", "M35.146 27.146a.5.5 0 0 1-.353.854H30v8H20v-8h-4.793a.5.5 0 0 1-.353-.854L25 16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$32($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataUpload" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataUpload extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$32, create_fragment$32, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DataUser.svelte generated by Svelte v3.24.1 */

function create_fragment$33(ctx) {
	let svg;
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(ellipse, "cx", ellipse_cx_value = 18);
			attr(ellipse, "cy", ellipse_cy_value = 7);
			attr(ellipse, "rx", ellipse_rx_value = 16);
			attr(ellipse, "ry", ellipse_ry_value = 5);
			attr(path0, "d", "M34 28.159V20.27a4.824 4.824 0 0 1-.867.814 9 9 0 0 1-1.557 6.188zM20.314 27.211a10.349 10.349 0 0\n    1-1.295-2.949c-.354.008-.7.013-1.02.013-4.936 0-14.212-1.169-16-4V29c0 2.282 4.9 4.2 11.588 4.8a8.4 8.4 0 0 1\n    6.727-6.589zM18.685 21.989v-.062c0-4.724 3-8.023 7.285-8.023a6.822 6.822 0 0 1 6.784 5.037A2.551 2.551 0 0 0 34\n    17v-6.73c-2.447 3.095-11.064 4-16 4s-14.212-1.169-16-4V17c0 2.761 7.163 5 16 5 .231 0 .456-.008.685-.011z");
			attr(path1, "d", "M28.677 28.542v-1.4a.966.966 0 0 1 .246-.623 7.366 7.366 0 0 0 1.675-4.6c0-3.479-1.845-5.424-4.633-5.424s-4.686\n    2.021-4.686 5.424a7.447 7.447 0 0 0 1.756 4.6.965.965 0 0 1 .246.623v1.389a.958.958 0 0 1-.836.967c-5.6.487-6.439\n    4.319-6.439 5.83L16 36h20v-.667c0-1.448-.989-5.266-6.49-5.825a.963.963 0 0 1-.833-.966z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$33($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DataUser" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DataUser extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$33, create_fragment$33, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Date.svelte generated by Svelte v3.24.1 */

function create_fragment$34(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M35 6h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h32a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 26H4V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h4z");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 8);
			attr(rect, "x", rect_x_value = 22);
			attr(rect, "y", rect_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$34($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Date" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Date extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$34, create_fragment$34, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DateInput.svelte generated by Svelte v3.24.1 */

function create_fragment$35(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M32 16.909h1.286a.721.721 0 0 0 .714-.727v-1.455a.721.721 0 0 0-.714-.727h-1.531a2.833 2.833 0 0 0-2.021.852L28\n    17.272l-1.734-2.42A2.833 2.833 0 0 0 24.245 14h-1.531a.721.721 0 0 0-.714.727v1.455a.721.721 0 0 0 .714.728H24l2\n    3.151v4.849h-3.286a.721.721 0 0 0-.714.727v1.455a.721.721 0 0 0 .714.727H26v2.121l-2 3.151h-1.286a.721.721 0 0\n    0-.714.728v1.455a.721.721 0 0 0 .714.727h1.531a2.833 2.833 0 0 0 2.021-.852L28 32.728l1.734 2.42a2.833 2.833 0 0 0\n    2.021.852h1.531a.721.721 0 0 0 .714-.727v-1.455a.721.721 0 0 0-.714-.728H32l-2-3.15v-2.122h3.286a.721.721 0 0 0\n    .714-.727v-1.455a.721.721 0 0 0-.714-.727H30V20.06z");
			attr(path1, "d", "M34 12h2V7a1 1 0 0 0-1-1h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1\n    1v26a1 1 0 0 0 1 1h17v-.182A2.717 2.717 0 0 1 20.706 32H4V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1\n    1h2a1 1 0 0 0 1-1V8h4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$35($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DateInput" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DateInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$35, create_fragment$35, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Deduplication.svelte generated by Svelte v3.24.1 */

function create_fragment$36(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let path0;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			path0 = svg_element("path");
			circle1 = svg_element("circle");
			path1 = svg_element("path");
			attr(circle0, "cx", circle0_cx_value = 7.939);
			attr(circle0, "cy", circle0_cy_value = 6.25);
			attr(circle0, "r", circle0_r_value = 3.75);
			attr(path0, "d", "M21.506 10h-8.75l4.375-7.5 4.375 7.5z");
			attr(circle1, "cx", circle1_cx_value = 11.939);
			attr(circle1, "cy", circle1_cy_value = 30.25);
			attr(circle1, "r", circle1_r_value = 3.75);
			attr(path1, "d", "M27.603 34h-8.75l4.375-7.5 4.375 7.5zM32.121 10h-8.75l4.375-7.5 4.375 7.5zM27.939 12.058h-20v1.222a1.514 1.514 0\n    0 0 .723 1.3l5.689 4.02a3.056 3.056 0 0 1 1.114 2.377v4.193a.733.733 0 0 0 .714.75H19.7a.733.733 0 0 0\n    .714-.75v-4.194a3.056 3.056 0 0 1 1.113-2.376l5.689-4.015a1.514 1.514 0 0 0 .723-1.3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, path0);
			append(svg, circle1);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$36($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Deduplication" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Deduplication extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$36, create_fragment$36, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Delegate.svelte generated by Svelte v3.24.1 */

function create_fragment$37(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.358 19.889a1.317 1.317 0 0 1-1.123-1.274V16.8a1.322 1.322 0 0 1 .3-.812A11.342 11.342 0 0 0 28.542\n    9.6c0-4.536-2.216-6.676-5.563-6.676a6.261 6.261 0 0 0-1.717.253 11.179 11.179 0 0 1 2.138 7.16 15.547 15.547 0 0\n    1-2.563 8.491v.272c7.026 1.278 10.157 5.978 10.561 9.389.021.173.034 1.342.041\n    1.507h4.5V27.2c0-1.878-1.339-6.5-8.581-7.311z");
			attr(path1, "d", "M19.267 21.781a1.476 1.476 0 0 1-1.31-1.422v-2.02a1.471 1.471 0 0 1 .328-.9 12.606 12.606 0 0 0\n    2.235-7.1c0-5.04-2.462-7.417-6.181-7.417s-6.252 2.486-6.252 7.415a12.7 12.7 0 0 0 2.344 7.1 1.457 1.457 0 0 1\n    .326.9v2.013c0 .186-.646.83-.718 1l7.039 6.97a1 1 0 0 1 .006 1.415L14.839\n    32h13.6v-1.8c0-2.081-1.186-7.487-9.172-8.419zM6.874 22.169A.5.5 0 0 0 6 22.5V26H1a1 1 0 0 0-1 1v4a1 1 0 0 0 1\n    1h5v3.5a.5.5 0 0 0 .874.332L13.4 29z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$37($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Delegate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Delegate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$37, create_fragment$37, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Delete.svelte generated by Svelte v3.24.1 */

function create_fragment$38(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31.5 6H24V4a2 2 0 0 0-2-2H12a2 2 0 0 0-2 2v2H2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h2l2.413 25.1a1 1 0 0 0 1\n    .9h18.179a1 1 0 0 0 1-.9L29.5 8h2a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM11.065 29A1 1 0 0 1 10 28.068l-1.071-16a1 1\n    0 1 1 2-.134l1.071 16A1 1 0 0 1 11.065 29zM18 28a1 1 0 0 1-2 0V12a1 1 0 0 1 2 0zm4-22H12V4h10zm2 22.068a1 1 0 1\n    1-2-.134l1.071-16a1 1 0 1 1 2 .134z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$38($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Delete" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Delete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$38, create_fragment$38, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeleteOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$39(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.491 8l-2.308 24H8.817L6.509 8zM22 2H12a2 2 0 0 0-2 2v2H2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h2l2.413 25.1a1 1\n    0 0 0 1 .9h18.179a1 1 0 0 0 1-.9L29.5 8h2a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H24V4a2 2 0 0 0-2-2zM12 6V4h10v2z");
			attr(path1, "d", "M17 29a1 1 0 0 1-1-1V12a1 1 0 0 1 2 0v16a1 1 0 0 1-1 1zM20.934 29A1 1 0 0 1 20 27.933l1.071-15.995a1 1 0 1 1 2\n    .134L22 28.068a1 1 0 0 1-1.066.932zM13.066 29A1 1 0 0 0 14 27.933l-1.075-15.995a1 1 0 1 0-2 .134l1.071 16a1 1 0 0 0\n    1.07.928z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$39($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeleteOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeleteOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$39, create_fragment$39, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Demographic.svelte generated by Svelte v3.24.1 */

function create_fragment$3a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M7.939 8.1a3.9 3.9 0 1 0-3.9-3.9 3.9 3.9 0 0 0 3.9 3.9zM17.939 8.1a3.9 3.9 0 1 0-3.9-3.9 3.9 3.9 0 0 0 3.9\n    3.9zM27.939 8.1a3.9 3.9 0 1 0-3.9-3.9 3.9 3.9 0 0 0 3.9 3.9zM28.139 10h-.4a6.136 6.136 0 0 0-4.8 1.863 6.139 6.139 0\n    0 0-4.8-1.863h-.4a6.136 6.136 0 0 0-4.8 1.863A6.139 6.139 0 0 0 8.139 10h-.4c-3.2 0-5.8 1.6-5.8 4.8V22a1 1 0 0 0 1\n    1h1l1 10a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1l1-10h2l1 10a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1l1-10h2l1 10a1 1 0 0 0 1 1h4a1 1 0 0\n    0 1-1l1-10h1a1 1 0 0 0 1-1v-7.2c0-3.2-2.597-4.8-5.8-4.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Demographic" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Demographic extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3a, create_fragment$3a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Deselect.svelte generated by Svelte v3.24.1 */

function create_fragment$3b(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M4 18h2v6H4zM6 30v-2H4v3.111a.889.889 0 0 0 .889.889H8v-2zM12 30h6v2h-6zM30 12h2v6h-2zM31.111\n    4H28v2h2v2h2V4.889A.889.889 0 0 0 31.111 4zM18 4h6v2h-6z");
			attr(rect, "height", rect_height_value = 43.854);
			attr(rect, "rx", rect_rx_value = 0.818);
			attr(rect, "ry", rect_ry_value = 0.818);
			attr(rect, "transform", "rotate(-45 18 18)");
			attr(rect, "width", rect_width_value = 2.455);
			attr(rect, "x", rect_x_value = 16.773);
			attr(rect, "y", rect_y_value = -3.927);
			attr(path1, "d", "M32 27.437V22h-2v3.437l2 2zM25.436 30H22v2h5.436l-2-2zM4 8.563V14h2v-3.437l-2-2zM10.562 6H14V4H8.562l2 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Deselect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Deselect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3b, create_fragment$3b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeselectCircular.svelte generated by Svelte v3.24.1 */

function create_fragment$3c(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 43.854);
			attr(rect, "rx", rect_rx_value = 0.818);
			attr(rect, "ry", rect_ry_value = 0.818);
			attr(rect, "transform", "rotate(-45 18 18)");
			attr(rect, "width", rect_width_value = 2.455);
			attr(rect, "x", rect_x_value = 16.772);
			attr(rect, "y", rect_y_value = -3.927);
			attr(path, "d", "M31.569 21.45a13.9 13.9 0 0 1-1.661 3.895l1.448 1.448a15.884 15.884 0 0 0 2.152-4.852zM29.1\n    9.463c.132.17.26.345.382.521l1.642-1.143q-.211-.3-.439-.6a15.985 15.985 0 0 0-3.6-3.42l-1.137 1.648A14.009 14.009 0\n    0 1 29.1 9.463zM32 17.979h2a15.927 15.927 0 0 0-1.018-5.6l-1.872.7a13.944 13.944 0 0 1 .89 4.9zM10.657 6.094a13.866\n    13.866 0 0 1 3.811-1.646l-.5-1.935A15.875 15.875 0 0 0 9.21 4.647zM22.844 4.862l.69-1.877A16.174 16.174 0 0 0 17.928\n    2l.007 2a14.166 14.166 0 0 1 4.909.862zM4.43 14.55a13.929 13.929 0 0 1 1.661-3.9L4.643 9.207a15.9 15.9 0 0 0-2.152\n    4.852zM6.9 26.537a14.79 14.79 0 0 1-.382-.521L4.88 27.159q.212.3.439.6a16.027 16.027 0 0 0 3.6\n    3.42l1.136-1.647A13.982 13.982 0 0 1 6.9 26.537zM4 18.021H2a15.927 15.927 0 0 0 1.018 5.6l1.873-.7a13.9 13.9 0 0\n    1-.891-4.9zM25.343 29.906a13.9 13.9 0 0 1-3.812 1.646l.5 1.935a15.875 15.875 0 0 0 4.754-2.134zM13.155 31.137l-.69\n    1.878a16.174 16.174 0 0 0 5.606.985l-.007-2a14.144 14.144 0 0 1-4.909-.863z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeselectCircular" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeselectCircular extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3c, create_fragment$3c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DesktopAndMobile.svelte generated by Svelte v3.24.1 */

function create_fragment$3d(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M11 30H9a.979.979 0 0 0-1 1v1h10V22H4V4h24v2h4V1a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h11v3a1 1 0 0 1-1\n    1z");
			attr(path1, "d", "M34 8H22a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2zm-7 2h2a1 1 0 0 1 0 2h-2a1 1 0 0 1\n    0-2zm1 25.1a2.1 2.1 0 1 1 2.1-2.1 2.1 2.1 0 0 1-2.1 2.1zm6-5.1H22V14h12z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DesktopAndMobile" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DesktopAndMobile extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3d, create_fragment$3d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeviceDesktop.svelte generated by Svelte v3.24.1 */

function create_fragment$3e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 2H1a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h13v3a1 1 0 0 1-1 1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-2a1\n    1 0 0 0-1-1h-2a1 1 0 0 1-1-1v-3h13a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-3 22H4V6h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeviceDesktop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeviceDesktop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3e, create_fragment$3e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeviceLaptop.svelte generated by Svelte v3.24.1 */

function create_fragment$3f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.948 30.684L32 20V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v15L.052 30.684A1.011 1.011 0 0 0 0 31a1 1 0 0 0 1 1h34a1 1 0\n    0 0 1-1 1.011 1.011 0 0 0-.052-.316zM12 30l1.333-4h9.334L24 30zm18-10H6V6h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeviceLaptop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeviceLaptop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3f, create_fragment$3f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DevicePhone.svelte generated by Svelte v3.24.1 */

function create_fragment$3g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26 0H10a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm-9 2h2a1.041 1.041 0 0 1 1 1 1.04 1.04\n    0 0 1-1 1h-2a1.023 1.023 0 0 1-1-1 1.024 1.024 0 0 1 1-1zm1 33.1a2.1 2.1 0 1 1 2.1-2.1 2.1 2.1 0 0 1-2.1\n    2.1zm8-5.1H10V6h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DevicePhone" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DevicePhone extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3g, create_fragment$3g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DevicePhoneRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$3h(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 30H8V6h16v9.347a11.6 11.6 0 0 1 2-.416V2a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2h8zM15 2h2a1.04 1.04 0\n    0 1 1 1 1.041 1.041 0 0 1-1 1h-2a1.024 1.024 0 0 1-1-1 1.024 1.024 0 0 1 1-1z");
			attr(path1, "d", "M18.4 24.451a8.882 8.882 0 0 1 15.5-3.09l1.251-1.251a.486.486 0 0 1 .349-.147.5.5 0 0 1 .5.5v5.051a.472.472 0 0\n    1-.179.334l.014.114H30.5a.5.5 0 0 1-.5-.5.486.486 0 0 1 .148-.35l1.739-1.74a6.057 6.057 0 0 0-10.6 1.436.975.975 0 0\n    1-.921.62h-1.248a.76.76 0 0 1-.718-.977zM35.6 29.511A8.882 8.882 0 0 1 20.1 32.6l-1.25 1.251a.489.489 0 0\n    1-.35.149.5.5 0 0 1-.5-.5v-5.053a.477.477 0 0 1 .179-.334c0-.037-.01-.075-.014-.113H23.5a.5.5 0 0 1 .5.5.489.489 0 0\n    1-.147.35l-1.74 1.739a6.056 6.056 0 0 0 10.6-1.436.976.976 0 0 1 .921-.619h1.251a.759.759 0 0 1 .715.977z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DevicePhoneRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DevicePhoneRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3h, create_fragment$3h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DevicePreview.svelte generated by Svelte v3.24.1 */

function create_fragment$3i(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M34 4H2a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h32a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm-4 24H4V8h26zm3-7.5a2.5 2.5 0 1 1\n    2.5-2.5 2.5 2.5 0 0 1-2.5 2.5z");
			attr(path1, "d", "M20.779 12.617A8.563 8.563 0 0 0 17 11.678c-4.951 0-9 4.929-9 6.528 0 1.713 4.262 6.116 8.964 6.116 4.74 0\n    9.036-4.4 9.036-6.116 0-1.351-2.408-4.195-5.221-5.589zM17 23.271A5.271 5.271 0 1 1 22.271 18 5.271 5.271 0 0 1 17\n    23.271z");
			attr(path2, "d", "M18.524 18.048A1.524 1.524 0 0 1 17 16.524a1.5 1.5 0 0 1 .771-1.3 2.811 2.811 0 0 0-.771-.12A2.893 2.893 0 1 0\n    19.893 18a2.7 2.7 0 0 0-.1-.683 1.5 1.5 0 0 1-1.269.731z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DevicePreview" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DevicePreview extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3i, create_fragment$3i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeviceRotateLandscape.svelte generated by Svelte v3.24.1 */

function create_fragment$3j(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.158 30H8V6h16v9.21a12.3 12.3 0 0 1 2-.354V2a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2h10.625a12.27 12.27\n    0 0 1-3.467-6zM15 2h2a1.04 1.04 0 0 1 1 1 1.04 1.04 0 0 1-1 1h-2a1.023 1.023 0 0 1-1-1 1.024 1.024 0 0 1 1-1z");
			attr(path1, "d", "M32.412 20.332l1.479-1.478a.489.489 0 0 0 .147-.35.5.5 0 0 0-.5-.5h-5.053a.5.5 0 0 0-.447.448V23.5a.5.5 0 0 0\n    .5.5.489.489 0 0 0 .35-.147l1.5-1.506a6.015 6.015 0 0 1 2.144 5.6 6.074 6.074 0 1 1-8.123-6.615.976.976 0 0 0\n    .62-.921v-1.255a.76.76 0 0 0-.974-.723 8.919 8.919 0 0 0-6.451 8.552 9.02 9.02 0 0 0 8.645 8.936 8.891 8.891 0 0 0\n    6.154-15.589z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeviceRotateLandscape" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeviceRotateLandscape extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3j, create_fragment$3j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeviceRotatePortrait.svelte generated by Svelte v3.24.1 */

function create_fragment$3k(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M36 15.084V8a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12.751a12.219 12.219 0 0 1 .333-2H6V8h24v7.085zM4\n    17a1.023 1.023 0 0 1-1 1 1.022 1.022 0 0 1-1-1v-2a1.04 1.04 0 0 1 1-1 1.041 1.041 0 0 1 1 1z");
			attr(path1, "d", "M32.375 20.332l1.478-1.479A.49.49 0 0 0 34 18.5a.5.5 0 0 0-.5-.5h-5.052a.5.5 0 0 0-.447.447V23.5a.5.5 0 0 0\n    .5.5.488.488 0 0 0 .349-.148l1.506-1.506a6.018 6.018 0 0 1 2.144 5.6 6.075 6.075 0 1 1-8.123-6.615.976.976 0 0 0\n    .62-.921v-1.255a.76.76 0 0 0-.974-.723 8.919 8.919 0 0 0-6.451 8.552 9.021 9.021 0 0 0 8.645 8.937 8.891 8.891 0 0 0\n    6.154-15.589z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeviceRotatePortrait" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeviceRotatePortrait extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3k, create_fragment$3k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeviceTV.svelte generated by Svelte v3.24.1 */

function create_fragment$3l(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 8H19.414l6.247-6.247a.971.971 0 0 0 0-1.411 1 1 0 0 0-1.416 0L18 6.586 11.776.362a.99.99 0 0\n    0-1.42-.006.971.971 0 0 0 .006 1.42L16.586 8H1a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zm-5\n    22H4V12h26zm4-1a1 1 0 0 1-2 0v-2a1 1 0 0 1 2 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeviceTV" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeviceTV extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3l, create_fragment$3l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DeviceTablet.svelte generated by Svelte v3.24.1 */

function create_fragment$3m(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34 4H2a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h32a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm-4 24H4V8h26zm3-7.5a2.5 2.5 0 1 1\n    2.5-2.5 2.5 2.5 0 0 1-2.5 2.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DeviceTablet" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DeviceTablet extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3m, create_fragment$3m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Devices.svelte generated by Svelte v3.24.1 */

function create_fragment$3n(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 22H6V6h28V4a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h16zM3 16.5A2.5 2.5 0 1 1 5.5 14 2.5 2.5 0 0 1 3\n    16.5z");
			attr(path1, "d", "M34 8H22a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2zm-7 2h2a1 1 0 0 1 0 2h-2a1 1 0 0 1\n    0-2zm1 25.1a2.1 2.1 0 1 1 2.1-2.1 2.1 2.1 0 0 1-2.1 2.1zm6-5.1H22V14h12z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Devices" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Devices extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3n, create_fragment$3n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeBottomEdge.svelte generated by Svelte v3.24.1 */

function create_fragment$3o(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6 22.926V30H.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h35a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H30v-7.074a.927.927 0 0\n    0-.926-.926H6.926a.926.926 0 0 0-.926.926zM10 5v7H.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h35a.5.5 0 0 0 .5-.5v-1a.5.5 0\n    0 0-.5-.5H26V5a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeBottomEdge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeBottomEdge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3o, create_fragment$3o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeHorizontalCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$3p(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M13 6h-3V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V6H5a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h3v5.5a.5.5 0 0 0 .5.5h1a.5.5 0\n    0 0 .5-.5V30h3a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM31 10h-3V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V10h-3a1 1 0 0 0-1\n    1v14a1 1 0 0 0 1 1h3v9.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V26h3a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeHorizontalCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeHorizontalCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3p, create_fragment$3p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeHorizontally.svelte generated by Svelte v3.24.1 */

function create_fragment$3q(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 24);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 12);
			attr(rect0, "x", rect0_x_value = 12);
			attr(rect0, "y", rect0_y_value = 6);
			attr(rect1, "height", rect1_height_value = 36);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 4);
			attr(rect2, "height", rect2_height_value = 36);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 30);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeHorizontally" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeHorizontally extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3q, create_fragment$3q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeLeftEdge.svelte generated by Svelte v3.24.1 */

function create_fragment$3r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M13.074 6H6V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v35a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V30h7.074a.926.926 0 0 0\n    .926-.926V6.926A.927.927 0 0 0 13.074 6zM31 10h-7V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v35a.5.5 0 0 0 .5.5h1a.5.5 0\n    0 0 .5-.5V26h7a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeLeftEdge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeLeftEdge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3r, create_fragment$3r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeRightEdge.svelte generated by Svelte v3.24.1 */

function create_fragment$3s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M13.5 0h-1a.5.5 0 0 0-.5.5V6H5a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h7v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V.5a.5.5 0\n    0 0-.5-.5zM31.5 0h-1a.5.5 0 0 0-.5.5V10h-7a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h7v9.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0\n    .5-.5V.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeRightEdge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeRightEdge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3s, create_fragment$3s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeSpaceHoriz.svelte generated by Svelte v3.24.1 */

function create_fragment$3t(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 24);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 10);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 10);
			attr(rect1, "height", rect1_height_value = 16);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 12);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 12);
			attr(path, "d", "M20 7.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V4h3.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H22V.5a.5.5 0 0\n    0-.5-.5h-1a.5.5 0 0 0-.5.5V2h-6V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V2H8.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0\n    .5.5H12v3.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V4h6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeSpaceHoriz" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeSpaceHoriz extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3t, create_fragment$3t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeSpaceVert.svelte generated by Svelte v3.24.1 */

function create_fragment$3u(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 10);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 10);
			attr(rect0, "y", rect0_y_value = 22);
			attr(rect1, "height", rect1_height_value = 12);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 16);
			attr(rect1, "x", rect1_x_value = 12);
			attr(rect1, "y", rect1_y_value = 4);
			attr(path, "d", "M7.5 16a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H4v-3.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V14H.5a.5.5 0 0\n    0-.5.5v1a.5.5 0 0 0 .5.5H2v6H.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H2v3.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0\n    .5-.5V24h3.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H4v-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeSpaceVert" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeSpaceVert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3u, create_fragment$3u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeTopEdge.svelte generated by Svelte v3.24.1 */

function create_fragment$3v(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M0 22.5v1a.5.5 0 0 0 .5.5H6v7a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-7h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H.5a.5.5\n    0 0 0-.5.5zM0 4.5v1a.5.5 0 0 0 .5.5H10v7a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V6h9.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0\n    0-.5-.5H.5a.5.5 0 0 0-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeTopEdge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeTopEdge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3v, create_fragment$3v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeVerticalCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$3w(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6 23v3H.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H6v3a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-3h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0\n    0 0-.5-.5H30v-3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zM10 5v3H.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H10v3a1 1 0 0 0 1 1h14a1 1\n    0 0 0 1-1v-3h9.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H26V5a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeVerticalCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeVerticalCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3w, create_fragment$3w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DistributeVertically.svelte generated by Svelte v3.24.1 */

function create_fragment$3x(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 12);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 6);
			attr(rect0, "y", rect0_y_value = 12);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 36);
			attr(rect1, "y", rect1_y_value = 30);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 36);
			attr(rect2, "y", rect2_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DistributeVertically" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DistributeVertically extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3x, create_fragment$3x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Divide.svelte generated by Svelte v3.24.1 */

function create_fragment$3y(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 16);
			attr(circle0, "cx", circle0_cx_value = 18);
			attr(circle0, "cy", circle0_cy_value = 6);
			attr(circle0, "r", circle0_r_value = 3.8);
			attr(circle1, "cx", circle1_cx_value = 18);
			attr(circle1, "cy", circle1_cy_value = 30);
			attr(circle1, "r", circle1_r_value = 3.8);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, circle0);
			append(svg, circle1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Divide" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Divide extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3y, create_fragment$3y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DividePath.svelte generated by Svelte v3.24.1 */

function create_fragment$3z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 12h12v12H12z");
			attr(path1, "d", "M10 10h14V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h5zM31 12h-5v14H12v5a1 1 0 0 0 1 1h18a1 1 0 0 0\n    1-1V13a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DividePath" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DividePath extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3z, create_fragment$3z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Document.svelte generated by Svelte v3.24.1 */

function create_fragment$3A(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 11V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V12h-9a1 1 0 0 1-1-1z");
			attr(path1, "d", "M22 2h.086a1 1 0 0 1 .707.293l6.914 6.914a1 1 0 0 1 .293.707V10h-8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Document" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Document extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3A, create_fragment$3A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DocumentFragment.svelte generated by Svelte v3.24.1 */

function create_fragment$3B(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 14.856);
			attr(circle, "cy", circle_cy_value = 13.5);
			attr(circle, "r", circle_r_value = 2);
			attr(path, "d", "M35 4H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM4 8h16v12.694a8.535 8.535 0 0\n    0-3.478-1.125c-1.653 0-2.4 2.2-4.052 2.2s-2.936-4.353-4.588-4.353C6.379 17.412 4 21.819 4 21.819zm28\n    20H4v-2h28zm0-6h-8v-2h8zm0-6h-8v-2h8zm0-6h-8V8h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DocumentFragment" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DocumentFragment extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3B, create_fragment$3B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DocumentFragmentGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$3C(ctx) {
	let svg;
	let path0;
	let path1;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			attr(path0, "d", "M35 8H5a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zM8 12h14v8.875a8.532 8.532 0 0\n    0-3.478-1.125c-1.653 0-2.4 2.2-4.052 2.2s-1.7-3.765-3.351-3.765C9.617 18.181 8 22 8 22zm24\n    16H8v-2h24zm0-8h-6v-2h6zm0-6h-6v-2h6z");
			attr(path1, "d", "M2 7a1 1 0 0 1 1-1h29V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h1z");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 16);
			attr(circle, "r", circle_r_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DocumentFragmentGroup" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DocumentFragmentGroup extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3C, create_fragment$3C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DocumentOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$3D(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20.735 2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11.265a2 2 0 0 0-.586-1.414l-7.265-7.265A2 2 0 0 0\n    20.735 2zM28 32H8V4h12.121v6.879a1 1 0 0 0 1 1H28zm-6-22V5.266L26.734 10z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DocumentOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DocumentOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3D, create_fragment$3D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DocumentRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$3E(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 0h.086a1 1 0 0 1 .706.292L27.708 7.2a1 1 0 0 1 .292.714V8h-8z");
			attr(path1, "d", "M14 27a13 13 0 0 1 13-13c.338 0 .669.025 1 .05V10h-9a1 1 0 0 1-1-1V0H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h10a12.956\n    12.956 0 0 1-1-5zM35.605 29.549a8.883 8.883 0 0 1-15.501 3.09l-1.25 1.251a.489.489 0 0 1-.35.148.5.5 0 0\n    1-.504-.501v-5a.5.5 0 0 1 .5-.5h4.999a.502.502 0 0 1 .501.504.489.489 0 0 1-.147.35l-1.74 1.74a6.057 6.057 0 0 0\n    10.597-1.436.977.977 0 0 1 .921-.62h1.25a.759.759 0 0 1 .724.974z");
			attr(path2, "d", "M18.395 24.526a8.883 8.883 0 0 1 15.501-3.091l1.25-1.25a.489.489 0 0 1 .35-.148.5.5 0 0 1 .504.5v5a.5.5 0 0\n    1-.5.5h-4.999a.502.502 0 0 1-.501-.504.489.489 0 0 1 .147-.35l1.74-1.74A6.057 6.057 0 0 0 21.29 24.88a.977.977 0 0\n    1-.921.62h-1.25a.759.759 0 0 1-.724-.974z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DocumentRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DocumentRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3E, create_fragment$3E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Dolly.svelte generated by Svelte v3.24.1 */

function create_fragment$3F(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.841 24H24L20.364 8h5.584a.375.375 0 0 0 .237-.666L18 .65 9.815 7.334a.375.375 0 0 0 .237.666h5.584L12\n    24H5.159a.75.75 0 0 0-.465 1.338L18 35.85l13.306-10.512A.75.75 0 0 0 30.841 24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Dolly" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Dolly extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3F, create_fragment$3F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Download.svelte generated by Svelte v3.24.1 */

function create_fragment$3G(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 24h-2a1 1 0 0 0-1 1v5H6v-5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1v-8a1 1 0 0 0-1-1z");
			attr(path1, "d", "M17.649 26.856a.5.5 0 0 0 .7 0l7.451-7.525a.782.782 0 0 0 .2-.526.8.8 0 0 0-.8-.8H20V3a1 1 0 0 0-1-1h-2a1 1 0 0\n    0-1 1v15h-5.2a.8.8 0 0 0-.8.8.782.782 0 0 0 .2.526z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Download" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Download extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3G, create_fragment$3G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DownloadFromCloud.svelte generated by Svelte v3.24.1 */

function create_fragment$3H(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M31 11.3a6.461 6.461 0 0 0-2.151-.118 8.345 8.345 0 0 0 0-4.407 8.024 8.024 0 0 0-5.71-5.648 8.162 8.162 0 0\n    0-10.215 6.821 6.97 6.97 0 0 0-3.361-.055 6.849 6.849 0 0 0-5.124 5.212 6.972 6.972 0 0 0 .078 3.237 3.862 3.862 0 0\n    0-4.464 4.449A4 4 0 0 0 4.064 24H16v-9a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v9h9.572A6.429 6.429 0 0 0 31 11.3z");
			attr(path1, "d", "M16 28h-4.3a.7.7 0 0 0-.7.7.685.685 0 0 0 .207.49l6.468 6.145a.5.5 0 0 0 .65 0l6.469-6.135a.688.688 0 0 0\n    .206-.49.7.7 0 0 0-.7-.7H20V24h-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DownloadFromCloud" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DownloadFromCloud extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3H, create_fragment$3H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DownloadFromCloudOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$3I(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M29.286 9.471a8.787 8.787 0 0 0-17.019-3.042 7.722 7.722 0 0 0-7.689 7.4 5.224 5.224 0 0 0-3.545 5.544A5.346\n    5.346 0 0 0 6.41 24h5.09a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H6.4a3.336 3.336 0 0 1-3.391-3.041 3.214 3.214 0 0 1\n    3.209-3.388h.359v-1.428a5.719 5.719 0 0 1 7.2-5.519 6.787 6.787 0 1 1 13.268 2.7 5.357 5.357 0 1 1 .6\n    10.68H24.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h2.9a7.517 7.517 0 0 0 7.547-6.484 7.368 7.368 0 0 0-5.661-8.049z");
			attr(path1, "d", "M22.5 29H20V15a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v14h-2.5a.5.5 0 0 0-.5.5.489.489 0 0 0 .117.317l4.519 5.023a.5.5 0 0\n    0 .728 0l4.519-5.023A.489.489 0 0 0 23 29.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DownloadFromCloudOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DownloadFromCloudOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3I, create_fragment$3I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Draft.svelte generated by Svelte v3.24.1 */

function create_fragment$3J(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2zM35.785 21.721l-3.505-3.506a.739.739 0 0 0-.527-.215h-.023a.833.833 0 0 0-.564.247L20.344\n    29.069a.608.608 0 0 0-.153.256l-2.027 6c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039 5.123-1.764\n    6-2.028a.6.6 0 0 0 .252-.151l10.824-10.829A.835.835 0 0 0 36 22.3a.743.743 0 0 0-.215-.579zm-11.6\n    10.963c-1.314.395-3.3 1.229-4.43 1.568l1.56-4.431z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h9.079l1.839-5.443a2.827 2.827 0 0 1 .752-1.207L30\n    16.127V14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Draft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Draft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3J, create_fragment$3J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/DragHandle.svelte generated by Svelte v3.24.1 */

function create_fragment$3K(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let rect8;
	let rect8_height_value;
	let rect8_rx_value;
	let rect8_ry_value;
	let rect8_width_value;
	let rect8_x_value;
	let rect8_y_value;
	let rect9;
	let rect9_height_value;
	let rect9_rx_value;
	let rect9_ry_value;
	let rect9_width_value;
	let rect9_x_value;
	let rect9_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			rect8 = svg_element("rect");
			rect9 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.75);
			attr(rect0, "ry", rect0_ry_value = 0.75);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 12);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.75);
			attr(rect1, "ry", rect1_ry_value = 0.75);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 12);
			attr(rect1, "y", rect1_y_value = 10);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.75);
			attr(rect2, "ry", rect2_ry_value = 0.75);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 12);
			attr(rect2, "y", rect2_y_value = 16);
			attr(rect3, "height", rect3_height_value = 2);
			attr(rect3, "rx", rect3_rx_value = 0.75);
			attr(rect3, "ry", rect3_ry_value = 0.75);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 12);
			attr(rect3, "y", rect3_y_value = 22);
			attr(rect4, "height", rect4_height_value = 2);
			attr(rect4, "rx", rect4_rx_value = 0.75);
			attr(rect4, "ry", rect4_ry_value = 0.75);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 12);
			attr(rect4, "y", rect4_y_value = 28);
			attr(rect5, "height", rect5_height_value = 2);
			attr(rect5, "rx", rect5_rx_value = 0.75);
			attr(rect5, "ry", rect5_ry_value = 0.75);
			attr(rect5, "width", rect5_width_value = 2);
			attr(rect5, "x", rect5_x_value = 18);
			attr(rect5, "y", rect5_y_value = 4);
			attr(rect6, "height", rect6_height_value = 2);
			attr(rect6, "rx", rect6_rx_value = 0.75);
			attr(rect6, "ry", rect6_ry_value = 0.75);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 18);
			attr(rect6, "y", rect6_y_value = 10);
			attr(rect7, "height", rect7_height_value = 2);
			attr(rect7, "rx", rect7_rx_value = 0.75);
			attr(rect7, "ry", rect7_ry_value = 0.75);
			attr(rect7, "width", rect7_width_value = 2);
			attr(rect7, "x", rect7_x_value = 18);
			attr(rect7, "y", rect7_y_value = 16);
			attr(rect8, "height", rect8_height_value = 2);
			attr(rect8, "rx", rect8_rx_value = 0.75);
			attr(rect8, "ry", rect8_ry_value = 0.75);
			attr(rect8, "width", rect8_width_value = 2);
			attr(rect8, "x", rect8_x_value = 18);
			attr(rect8, "y", rect8_y_value = 22);
			attr(rect9, "height", rect9_height_value = 2);
			attr(rect9, "rx", rect9_rx_value = 0.75);
			attr(rect9, "ry", rect9_ry_value = 0.75);
			attr(rect9, "width", rect9_width_value = 2);
			attr(rect9, "x", rect9_x_value = 18);
			attr(rect9, "y", rect9_y_value = 28);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, rect8);
			append(svg, rect9);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "DragHandle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class DragHandle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3K, create_fragment$3K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Draw.svelte generated by Svelte v3.24.1 */

function create_fragment$3L(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20.454 8L5.084 23.372a.992.992 0 0 0-.251.421L2.055 33.1c-.114.376.459.85.783.85a.311.311 0 0 0\n    .062-.006c.276-.064 7.867-2.344 9.311-2.778a.984.984 0 0 0 .415-.25L28 15.544zM11.4 29.316c-2.161.649-4.862\n    1.465-6.729 2.022l2.009-6.73zM33.567 8.2L27.8 2.432a1.215 1.215 0 0 0-.866-.353H26.9a1.372 1.372 0 0 0-.927.407l-4.1\n    4.1 7.543 7.543 4.1-4.1a1.372 1.372 0 0 0 .4-.883 1.224 1.224 0 0 0-.349-.946z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Draw" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Draw extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3L, create_fragment$3L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Dropdown.svelte generated by Svelte v3.24.1 */

function create_fragment$3M(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.5 2h-27A1.5 1.5 0 0 0 2 3.5v4.963a1.5 1.5 0 0 0 1.5 1.5h27a1.5 1.5 0 0 0 1.5-1.5V3.5A1.5 1.5 0 0 0 30.5 2zM25\n    8.764l-3.72-4.038a.432.432 0 0 1 .332-.708H28.4a.432.432 0 0 1 .332.708zM30.5 12h-27A1.5 1.5 0 0 0 2 13.5v19A1.5 1.5\n    0 0 0 3.5 34h27a1.5 1.5 0 0 0 1.5-1.5v-19a1.5 1.5 0 0 0-1.5-1.5zM6 15.75a.75.75 0 0 1 .75-.75h20.5a.75.75 0 0 1\n    .75.75v1.5a.75.75 0 0 1-.75.75H6.75a.75.75 0 0 1-.75-.75zm22 13.5a.75.75 0 0 1-.75.75H6.75a.75.75 0 0\n    1-.75-.75v-1.5a.75.75 0 0 1 .75-.75h20.5a.75.75 0 0 1 .75.75zm-2-6a.75.75 0 0 1-.75.75H6.75a.75.75 0 0\n    1-.75-.75v-1.5a.75.75 0 0 1 .75-.75h18.5a.75.75 0 0 1 .75.75z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Dropdown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Dropdown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3M, create_fragment$3M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Duplicate.svelte generated by Svelte v3.24.1 */

function create_fragment$3N(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9 8h17V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5V9a1 1 0 0 1 1-1z");
			attr(path1, "d", "M33 10H11a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1zm-4\n    13.5h-5.5V29h-3v-5.5H15v-3h5.5V15h3v5.5H29z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Duplicate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Duplicate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3N, create_fragment$3N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Edit.svelte generated by Svelte v3.24.1 */

function create_fragment$3O(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.567 8.2L27.8 2.432a1.215 1.215 0 0 0-.866-.353H26.9a1.371 1.371 0 0 0-.927.406L5.084 23.372a.99.99 0 0\n    0-.251.422L2.055 33.1c-.114.377.459.851.783.851a.251.251 0 0 0 .062-.007c.276-.063 7.866-2.344 9.311-2.778a.972.972\n    0 0 0 .414-.249l20.888-20.889a1.372 1.372 0 0 0 .4-.883 1.221 1.221 0 0 0-.346-.945zM11.4 29.316c-2.161.649-4.862\n    1.465-6.729 2.022l2.009-6.73z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Edit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Edit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3O, create_fragment$3O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EditCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$3P(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm9.7 11.918L16.449 25.167a.732.732 0 0 1-.309.185c-1.076.323-7.141\n    2.436-7.347 2.483h-.045c-.241 0-.668-.353-.583-.633l2.482-7.342a.738.738 0 0 1 .187-.313L22.082 8.3a1.019 1.019 0 0\n    1 .69-.3h.028a.905.905 0 0 1 .645.263l4.292 4.292a.911.911 0 0 1 .261.706 1.022 1.022 0 0 1-.298.657z");
			attr(path1, "d", "M10.822 25.184c1.025-.306 2.814-1.059 4-1.416l-2.592-2.585z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EditCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EditCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3P, create_fragment$3P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EditExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$3Q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27a12.217 12.217 0 0 1 14.008-12.168l4.8-4.8a1.373 1.373 0 0 0 .4-.883 1.22 1.22 0 0 0-.35-.948L27.8\n    2.432a1.215 1.215 0 0 0-.867-.353H26.9a1.37 1.37 0 0 0-.927.406L5.084 23.372a1 1 0 0 0-.251.421L2.055\n    33.1c-.114.376.459.851.783.851a.272.272 0 0 0 .061-.006c.276-.063 7.867-2.344 9.312-2.778a.984.984 0 0 0\n    .414-.249l2.207-2.207A12.4 12.4 0 0 1 14.7 27zM4.668 31.338l2.009-6.73 4.72 4.708c-2.161.649-4.862 1.465-6.729\n    2.022z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EditExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EditExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3Q, create_fragment$3Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EditIn.svelte generated by Svelte v3.24.1 */

function create_fragment$3R(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.1 30H6V6h24v7.568a3.3 3.3 0 0 1 .643-.07 3.672 3.672 0 0 1 2.525 1.036l.832.832V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1\n    1v30a1 1 0 0 0 1 1h10.772z");
			attr(path1, "d", "M35.645 20.685l-4.324-4.323a1.083 1.083 0 0 0-.678-.265 1.13 1.13 0 0 0-.7.3L18.711 27.639a.736.736 0 0\n    0-.188.315l-2.444 7.34c-.085.282.345.638.588.638a.231.231 0 0 0 .046-.005c.207-.048 6.26-2.118 7.344-2.444a.733.733\n    0 0 0 .31-.187L35.6 22.059a1.03 1.03 0 0 0 .3-.662.916.916 0 0 0-.255-.712zM18.039 33.973l1.978-5.519 3.54\n    3.531c-1.621.487-4.118 1.57-5.518 1.988z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EditIn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EditIn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3R, create_fragment$3R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EditInLight.svelte generated by Svelte v3.24.1 */

function create_fragment$3S(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.645 16.685l-4.324-4.323a.912.912 0 0 0-.65-.265h-.028a1.035 1.035 0 0 0-.7.3L14.711 27.639a.736.736 0 0\n    0-.188.315l-2.444 7.34c-.085.282.345.638.588.638a.231.231 0 0 0 .046-.005c.207-.048 6.26-2.118 7.344-2.444a.733.733\n    0 0 0 .31-.187L35.6 18.059a1.03 1.03 0 0 0 .3-.662.916.916 0 0 0-.255-.712zM14.039 33.973l1.978-5.519 3.54\n    3.531c-1.621.487-4.118 1.57-5.518 1.988zM27 2H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h9.077l.225-.678a2.7 2.7 0 0 1\n    .672-1.1L13.2 26H4V4h22v9.166l2-2V3a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EditInLight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EditInLight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3S, create_fragment$3S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Education.svelte generated by Svelte v3.24.1 */

function create_fragment$3T(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.329 24.019a1.5 1.5 0 0 0 1.342 0L30 18.354V22.5c0 3.314-5.372 7.5-12 7.5-3.589 0-7.8-2.348-10-4v-6.485z");
			attr(path1, "d", "M34.658 11.88L18.671 3.887a1.5 1.5 0 0 0-1.342 0L1.347 11.878a.753.753 0 0 0 0 1.344l2.752 1.4-.081 13.25a16.038\n    16.038 0 0 1-.58 4.173L3 33.61c-.195.932.215 1.807 1.167 1.807h1.645c.946 0 1.375-.865\n    1.188-1.792l-.424-1.537A16.011 16.011 0 0 1 6 27.834V16l10.327-3.995A1.887 1.887 0 0 1 18 11.222c.991 0 1.794.527\n    1.794 1.178s-.8 1.178-1.794 1.178c-.051 0-.094-.016-.144-.019l-9.3 3.62 8.771 4.041a1.5 1.5 0 0 0 1.337\n    0l15.99-7.995a.75.75 0 0 0 .004-1.345z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Education" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Education extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3T, create_fragment$3T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Effects.svelte generated by Svelte v3.24.1 */

function create_fragment$3U(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.534 12h-3.3c-.2 0-.243.078-.363.236L24.2\n    18.853v-.045l-2.763-6.651c-.041-.118-.081-.157-.242-.157h-9.159l.62-2.688c1.17-5.295 3.6-6.231 5.521-6.231a17.94\n    17.94 0 0 1 3 .75c.139.046.233-.046.28-.228l.608-2.648c.047-.137-.046-.273-.187-.365a15.965 15.965 0 0\n    0-3.645-.509c-4.539 0-7.815 2.567-9.359 9.46L8.254 12H3.739a.255.255 0 0 0-.282.229l-.936 2.5-.013.09c.014.018.076 0\n    .2.183h4.453C6.74 17.054 2.519 32.7 1.537 35.483c-.094.228 0 .365.186.365.375-.045 2.534.138 3.657 0\n    .233-.045.327-.091.374-.319.982-2.968 3.567-11.947 5.391-20.529h4.782c.1 0 2.038-.025 3.1-.126l2.82 5.623c-2.459\n    2.7-5.528 6.451-8.068 9.229a.152.152 0 0 0 .081.274h3.461c.2 0 4.888-5.551 6.34-7.39h.039S27.724 30 27.886\n    30h3.264c.161 0 .242-.118.161-.274-.886-1.878-3.858-6.725-4.987-9.073 2.257-2.426 6.4-6.227\n    8.331-8.379.122-.117.081-.274-.121-.274z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Effects" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Effects extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3U, create_fragment$3U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Efficient.svelte generated by Svelte v3.24.1 */

function create_fragment$3V(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M9.174 13.563a1.5 1.5 0 0 1-.55-2.9A79.163 79.163 0 0 1 18.11 7.6a60.648 60.648 0 0 1 8.59-1.33 1.5 1.5 0 0 1\n    .192 2.994 59.079 59.079 0 0 0-8.121 1.262 77.483 77.483 0 0 0-9.041 2.932 1.5 1.5 0 0 1-.556.105zM9.492 7.405a1.5\n    1.5 0 0 1-.551-2.9A77.637 77.637 0 0 1 18.11 1.6c.8-.18 1.567-.336 2.292-.473a1.5 1.5 0 0 1 .554\n    2.949c-.693.131-1.427.28-2.19.451A75.855 75.855 0 0 0 10.043 7.3a1.5 1.5 0 0 1-.551.105zM13.5 33v.879a1.5 1.5 0 0 0\n    .439 1.06l.622.622a1.5 1.5 0 0 0 1.06.439h4.758a1.5 1.5 0 0 0 1.06-.439l.622-.622a1.5 1.5 0 0 0 .439-1.06V33a1.5 1.5\n    0 0 0 1.5-1.5v-1.944a1.5 1.5 0 0 0-1.5-1.5h-9a1.5 1.5 0 0 0-1.5 1.5V31.5a1.524 1.524 0 0 0 1.5 1.5zM9.7 19.353a1.5\n    1.5 0 0 1-.551-2.9A72.608 72.608 0 0 1 18.11 13.6a60.648 60.648 0 0 1 8.59-1.33 1.5 1.5 0 0 1 .192 2.994 59.079\n    59.079 0 0 0-8.121 1.262 71.041 71.041 0 0 0-8.514 2.721 1.486 1.486 0 0 1-.557.106zM13.5 21.75V26h3v-4.25a3.7 3.7 0\n    0 0-.415-1.679c-1.072.34-2.119.7-3 1.016a.746.746 0 0 1 .415.663zM26.454 18h-3.2a3.754 3.754 0 0 0-3.75\n    3.75V26h3v-4.25a.751.751 0 0 1 .75-.75h3.2a1.5 1.5 0 0 0 0-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Efficient" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Efficient extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3V, create_fragment$3V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Ellipse.svelte generated by Svelte v3.24.1 */

function create_fragment$3W(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 5.931c8.883 0 16.11 5.414 16.11 12.069S26.883 30.069 18 30.069 1.89 24.655 1.89 18 9.117 5.931 18\n    5.931zm0-1.781C8.114 4.15.1 10.351.1 18S8.114 31.85 18 31.85 35.9 25.649 35.9 18 27.886 4.15 18 4.15z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Ellipse" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Ellipse extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3W, create_fragment$3W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Email.svelte generated by Svelte v3.24.1 */

function create_fragment$3X(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 20.188L36 6.665v-1.5A1.147 1.147 0 0 0 34.875 4H1.125A1.147 1.147 0 0 0 0 5.167v1.469zM24.779 17.963L36\n    26.367V9.541l-11.221 8.422z");
			attr(path1, "d", "M22.866 19.4l-3.576 2.694a2.172 2.172 0 0 1-2.58 0l-3.628-2.719L0 29.068v1.766A1.146 1.146 0 0 0 1.125\n    32h33.75A1.146 1.146 0 0 0 36 30.834v-1.59zM11.165 17.938L0 9.512v16.683l11.165-8.257z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Email" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Email extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3X, create_fragment$3X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailCancel.svelte generated by Svelte v3.24.1 */

function create_fragment$3Y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 18.188L36 4.665v-1.5A1.147 1.147 0 0 0 34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.469zM11.165 15.938L0\n    7.512v16.683l11.165-8.257zM14.7 27a12.244 12.244 0 0 1 2.092-6.863c-.025-.018-.057-.024-.082-.043l-3.628-2.719L0\n    27.068v1.765A1.147 1.147 0 0 0 1.125 30h13.959a12.273 12.273 0 0 1-.384-3zM27 14.7a12.253 12.253 0 0 1 9\n    3.935V7.541l-9.577 7.188c.193-.009.382-.029.577-.029zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826\n    12.267a.5.5 0 0 1 0 .707l-1.752 1.752a.5.5 0 0 1-.707 0L27 29.459l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0\n    0 1 0-.707L24.541 27l-3.367-3.367a.5.5 0 0 1 0-.707l1.752-1.752a.5.5 0 0 1 .707 0L27 24.541l3.367-3.367a.5.5 0 0 1\n    .707 0l1.752 1.752a.5.5 0 0 1 0 .707L29.459 27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailCancel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailCancel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3Y, create_fragment$3Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$3Z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 18.188L36 4.665v-1.5A1.146 1.146 0 0 0 34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.468zM11.165 15.938L0\n    7.511v16.684l11.165-8.257zM14.7 27a12.24 12.24 0 0 1 2.092-6.863c-.026-.018-.057-.024-.082-.043l-3.628-2.719L0\n    27.068v1.765A1.147 1.147 0 0 0 1.125 30h13.959a12.272 12.272 0 0 1-.384-3zM27 14.7a12.253 12.253 0 0 1 9\n    3.936V7.541l-9.577 7.188c.193-.009.382-.029.577-.029zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338\n    14.312l-4.128-4.127a.5.5 0 0 1 0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043\n    1.043a.5.5 0 0 1 0 .707l-7.5 7.5a.5.5 0 0 1-.702-.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3Z, create_fragment$3Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$3_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777zM18 18.188L36 4.665v-1.5A1.147 1.147 0 0 0\n    34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.469zM11.165 15.938L0 7.512v16.683l11.165-8.257zM14.7 27a12.244 12.244 0 0\n    1 2.092-6.863c-.025-.018-.057-.024-.082-.043l-3.628-2.719L0 27.068v1.765A1.147 1.147 0 0 0 1.125 30h13.959a12.273\n    12.273 0 0 1-.384-3zM27 14.7a12.253 12.253 0 0 1 9 3.935V7.541l-9.577 7.188c.193-.009.382-.029.577-.029z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3_, create_fragment$3_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailExcludeOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$3$(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v25.666A1.147 1.147 0 0 0 1.125 30h14.784a11.411 11.411 0 0\n    1-.359-2H2v-2.392l11.165-8.358 3.635 2.725a1.967 1.967 0 0 0 .852.344 11.485 11.485 0 0 1 7.222-4.619L34\n    8.835v9.055a11.561 11.561 0 0 1 2 1.963V3.167A1.147 1.147 0 0 0 34.875 2zM2 23.107V8.881L11.5 16zm16-4.732L2\n    6.38V4h32v2.334z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM27 34a6.966 6.966 0 0 1-5.525-11.252l9.777 9.777A6.935\n    6.935 0 0 1 27 34zm5.525-2.748l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailExcludeOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailExcludeOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3$, create_fragment$3$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailGear.svelte generated by Svelte v3.24.1 */

function create_fragment$40(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M11.165 15.938L0 7.511v16.684l11.165-8.257zM34.925 24.678H32.61a6.69 6.69 0 0 0-.977-2.373l1.648-1.648a.661.661 0\n    0 0 0-.935l-1-1a.661.661 0 0 0-.935 0L29.7 20.368a6.693 6.693 0 0 0-2.373-.978v-2.314a.661.661 0 0\n    0-.661-.661h-1.327a.661.661 0 0 0-.661.661v2.315a6.692 6.692 0 0 0-2.373.978l-1.648-1.649a.661.661 0 0 0-.935 0l-1\n    1a.661.661 0 0 0 0 .935l1.648 1.648a6.69 6.69 0 0 0-.977 2.373h-2.317a.661.661 0 0 0-.661.661v1.322a.661.661 0 0 0\n    .661.661h2.315a6.69 6.69 0 0 0 .977 2.373l-1.648 1.651a.661.661 0 0 0 0 .935l1 1a.661.661 0 0 0 .935\n    0l1.648-1.648a6.692 6.692 0 0 0 2.373.977v2.315a.661.661 0 0 0 .661.661h1.322a.661.661 0 0 0 .661-.661V32.61a6.693\n    6.693 0 0 0 2.373-.977l1.648 1.648a.661.661 0 0 0 .935 0l1-1a.661.661 0 0 0 0-.935L31.632 29.7a6.69 6.69 0 0 0\n    .977-2.373h2.315a.661.661 0 0 0 .661-.661v-1.327a.661.661 0 0 0-.66-.661zM26 29.6a3.6 3.6 0 1 1 3.6-3.6 3.6 3.6 0 0\n    1-3.6 3.6z");
			attr(path1, "d", "M16.953 29.72a3.065 3.065 0 0 1-2.94-3.059v-1.322a3.065 3.065 0 0 1 2.938-3.059 3.044 3.044 0 0 1-.826-2.091\n    3.114 3.114 0 0 1 .049-.5l-3.092-2.317L0 27.068v1.765A1.147 1.147 0 0 0 1.125 30h15.649a2.888 2.888 0 0 1\n    .179-.28zM18.025 17.022a3.039 3.039 0 0 1 2.164-.9 3.013 3.013 0 0 1 .443.084L36 4.665v-1.5A1.147 1.147 0 0 0 34.875\n    2H1.125A1.147 1.147 0 0 0 0 3.167v1.468L17.351 17.7zM29.721 16.952a3.061 3.061 0 0 1 4.25.064l1.008 1.008a3.071\n    3.071 0 0 1 .072 4.256 3.02 3.02 0 0 1 .949.206V7.541l-8.714 6.54a3.066 3.066 0 0 1 2.435 2.871zM11.165 15.938L0\n    7.511v16.684l11.165-8.257z");
			attr(path2, "d", "M34.925 24.678H32.61a6.69 6.69 0 0 0-.977-2.373l1.648-1.648a.661.661 0 0 0 0-.935l-1-1a.661.661 0 0 0-.935 0L29.7\n    20.368a6.693 6.693 0 0 0-2.373-.978v-2.314a.661.661 0 0 0-.661-.661h-1.327a.661.661 0 0 0-.661.661v2.315a6.692 6.692\n    0 0 0-2.373.978l-1.648-1.649a.661.661 0 0 0-.935 0l-1 1a.661.661 0 0 0 0 .935l1.648 1.648a6.69 6.69 0 0 0-.977\n    2.373h-2.317a.661.661 0 0 0-.661.661v1.322a.661.661 0 0 0 .661.661h2.315a6.69 6.69 0 0 0 .977 2.373l-1.648\n    1.651a.661.661 0 0 0 0 .935l1 1a.661.661 0 0 0 .935 0l1.648-1.648a6.692 6.692 0 0 0 2.373.977v2.315a.661.661 0 0 0\n    .661.661h1.322a.661.661 0 0 0 .661-.661V32.61a6.693 6.693 0 0 0 2.373-.977l1.648 1.648a.661.661 0 0 0 .935\n    0l1-1a.661.661 0 0 0 0-.935L31.632 29.7a6.69 6.69 0 0 0 .977-2.373h2.315a.661.661 0 0 0 .661-.661v-1.327a.661.661 0\n    0 0-.66-.661zM26 29.6a3.6 3.6 0 1 1 3.6-3.6 3.6 3.6 0 0 1-3.6 3.6z");
			attr(path3, "d", "M16.953 29.72a3.065 3.065 0 0 1-2.94-3.059v-1.322a3.065 3.065 0 0 1 2.938-3.059 3.044 3.044 0 0 1-.826-2.091\n    3.114 3.114 0 0 1 .049-.5l-3.092-2.317L0 27.068v1.765A1.147 1.147 0 0 0 1.125 30h15.649a2.888 2.888 0 0 1\n    .179-.28zM18.025 17.022a3.039 3.039 0 0 1 2.164-.9 3.013 3.013 0 0 1 .443.084L36 4.665v-1.5A1.147 1.147 0 0 0 34.875\n    2H1.125A1.147 1.147 0 0 0 0 3.167v1.468L17.351 17.7zM29.721 16.952a3.061 3.061 0 0 1 4.25.064l1.008 1.008a3.071\n    3.071 0 0 1 .072 4.256 3.02 3.02 0 0 1 .949.206V7.541l-8.714 6.54a3.066 3.066 0 0 1 2.435 2.871z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$40($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailGear" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailGear extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$40, create_fragment$40, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailGearOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$41(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M34.925 24.678H32.61a6.69 6.69 0 0 0-.977-2.373l1.648-1.648a.661.661 0 0 0 0-.935l-1-1a.661.661 0 0 0-.935 0L29.7\n    20.368a6.693 6.693 0 0 0-2.373-.978v-2.314a.661.661 0 0 0-.661-.661h-1.327a.661.661 0 0 0-.661.661v2.315a6.692 6.692\n    0 0 0-2.373.978l-1.648-1.649a.661.661 0 0 0-.935 0l-1 1a.661.661 0 0 0 0 .935l1.648 1.648a6.69 6.69 0 0 0-.977\n    2.373h-2.317a.661.661 0 0 0-.661.661v1.322a.661.661 0 0 0 .661.661h2.315a6.69 6.69 0 0 0 .977 2.373l-1.648\n    1.651a.661.661 0 0 0 0 .935l1 1a.661.661 0 0 0 .935 0l1.648-1.648a6.692 6.692 0 0 0 2.373.977v2.315a.661.661 0 0 0\n    .661.661h1.322a.661.661 0 0 0 .661-.661V32.61a6.693 6.693 0 0 0 2.373-.977l1.648 1.648a.661.661 0 0 0 .935\n    0l1-1a.661.661 0 0 0 0-.935L31.632 29.7a6.69 6.69 0 0 0 .977-2.373h2.315a.661.661 0 0 0 .661-.661v-1.327a.661.661 0\n    0 0-.66-.661zM26 29.6a3.6 3.6 0 1 1 3.6-3.6 3.6 3.6 0 0 1-3.6 3.6z");
			attr(path1, "d", "M17.259 30H2v-2.392l11.165-8.358 3.635 2.725a1.973 1.973 0 0 0 .735.326l-.231-.231a2.638 2.638 0 0 1-.621-2.682L2\n    8.38V6h32v2.334l-8.08 6.081h.741a2.617 2.617 0 0 1 1.7.661L34 10.835v6.779l.7.7a2.665 2.665 0 0 1 0\n    3.762l-.607.607h.838a2.626 2.626 0 0 1 1.069.232V5.167A1.147 1.147 0 0 0 34.875 4H1.125A1.147 1.147 0 0 0 0\n    5.167v25.666A1.147 1.147 0 0 0 1.125 32h15.439a2.62 2.62 0 0 1 .695-2zM2 10.881L11.5 18 2 25.107z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$41($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailGearOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailGearOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$41, create_fragment$41, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailKey.svelte generated by Svelte v3.24.1 */

function create_fragment$42(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M11.165 17.938L0 9.511v16.684l11.165-8.257zM35.445 35.533v-2.887h-3.763v-1.084h3.763v-2.237a.467.467 0 0\n    0-.467-.467h-3.3v-5.927a5.546 5.546 0 0 0 2.283-1.359 5.607 5.607 0 1 0-7.93 0 5.542 5.542 0 0 0 2.313\n    1.367v12.126a.935.935 0 0 0 .935.935h5.695a.467.467 0 0 0 .471-.467zm-4.123-17.462a1.869 1.869 0 1 1 0-2.643 1.869\n    1.869 0 0 1 0 2.643z");
			attr(path1, "d", "M22.178 19.921l-2.888 2.173a2.171 2.171 0 0 1-2.58 0l-3.628-2.719L0 29.068v1.765A1.147 1.147 0 0 0 1.125\n    32h24.822v-7.3a8.153 8.153 0 0 1-3.769-4.779z");
			attr(path2, "d", "M30 9.423a8.135 8.135 0 0 1 1.974.267L36 6.665v-1.5A1.147 1.147 0 0 0 34.875 4H1.125A1.147 1.147 0 0 0 0\n    5.167v1.468l18 13.553 3.839-2.888A8.176 8.176 0 0 1 30 9.423z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$42($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailKey" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailKey extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$42, create_fragment$42, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailKeyOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$43(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M25.947 30H2v-2.392l11.165-8.358 3.635 2.725a2 2 0 0 0 2.4 0l3.088-2.325a7.977 7.977 0 0\n    1-.3-2.043c0-.087.022-.169.025-.255L18 20.375 2 8.38V6h32v2.334L31.959 9.87a7.94 7.94 0 0 1 3.7\n    2.075c.127.127.221.277.338.411V5.167A1.147 1.147 0 0 0 34.875 4H1.125A1.147 1.147 0 0 0 0 5.167v25.666A1.147 1.147 0\n    0 0 1.125 32h24.822zM2 10.881L11.5 18 2 25.107z");
			attr(path1, "d", "M35.445 35.533v-2.887h-3.763v-1.084h3.763v-2.237a.467.467 0 0 0-.467-.467h-3.3v-5.927a5.546 5.546 0 0 0\n    2.283-1.359 5.607 5.607 0 1 0-7.93 0 5.542 5.542 0 0 0 2.313 1.367v12.126a.935.935 0 0 0 .935.935h5.695a.467.467 0 0\n    0 .471-.467zm-4.123-17.462a1.869 1.869 0 1 1 0-2.643 1.869 1.869 0 0 1 0 2.643z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$43($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailKeyOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailKeyOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$43, create_fragment$43, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailLightning.svelte generated by Svelte v3.24.1 */

function create_fragment$44(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.313 6.686a16 16 0 1 0-17.355 26.132L16.9 20H11l4-12h9l-5 8h7L12.473 33a15.991 15.991 0 0 0 16.84-26.314z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$44($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailLightning" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailLightning extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$44, create_fragment$44, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailNotification.svelte generated by Svelte v3.24.1 */

function create_fragment$45(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20.576 28.545c.375-.381 1.254-1.27 1.254-5.854a4.825 4.825 0 0 1 2.47-4.215L22.866 17.4l-3.576 2.694a2.171 2.171\n    0 0 1-2.58 0l-3.628-2.719L0 27.068v1.765A1.147 1.147 0 0 0 1.125 30h18.48a4.107 4.107 0 0 1 .971-1.455zM25.931\n    16.825a3.17 3.17 0 0 1 2.641-1.425h.855a3.156 3.156 0 0 1 3.121 2.547A4.957 4.957 0 0 1 36 21.463V7.541l-11.221\n    8.422z");
			attr(path1, "d", "M36 4.665v-1.5A1.147 1.147 0 0 0 34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.468l18 13.553zM0\n    7.511v16.683l11.165-8.256L0 7.511zM36 31.077c0-1.077-2.429-.677-2.429-8.385\n    0-1.718-1.6-2.446-3.571-2.634V18.5a.539.539 0 0 0-.572-.5h-.857a.539.539 0 0\n    0-.572.5v1.558c-1.968.188-3.571.916-3.571 2.634C24.429 30.4 22 30.055 22 31.077v.844h4.667v.3a2.333 2.333 0 0 0\n    4.667 0v-.3H36z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$45($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailNotification" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailNotification extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$45, create_fragment$45, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$46(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 4H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-1 2v1.506L18 19.741 2 7.506V6zm0\n    4.023v15.9l-10.4-7.95zm-21.6 7.95L2 25.923v-15.9zM2 30v-1.56l12.042-9.208 2.743 2.1a2 2 0 0 0 2.43 0l2.743-2.1L34\n    28.44V30z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$46($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$46, create_fragment$46, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$47(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 18.188L36 4.665v-1.5A1.147 1.147 0 0 0 34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.469zM11.165 15.938L0\n    7.512v16.683l11.165-8.257zM14.7 27a12.244 12.244 0 0 1 2.092-6.863c-.025-.018-.057-.024-.082-.043l-3.628-2.719L0\n    27.068v1.765A1.147 1.147 0 0 0 1.125 30h13.959a12.273 12.273 0 0 1-.384-3zM27 33.435a6.212 6.212 0 0\n    1-4.771-2.123L24.537 29H18v6.55l2.5-2.509A8.744 8.744 0 0 0 27 36a9.3 9.3 0 0 0 9-9h-2.28A6.889 6.889 0 0 1 27\n    33.435zM33.558 20.958A9.215 9.215 0 0 0 27 18a9.3 9.3 0 0 0-9 9h2.28A6.889 6.889 0 0 1 27 20.565a6.283 6.283 0 0 1\n    4.871 2.116L29.6 25H36v-6.535zM36 14.216V7.541l-9.577 7.188c.192-.009.382-.029.577-.029a12.152 12.152 0 0 1 6.548\n    1.928z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$47($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$47, create_fragment$47, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EmailSchedule.svelte generated by Svelte v3.24.1 */

function create_fragment$48(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.468l18 13.553L36 4.665v-1.5A1.147 1.147 0 0 0 34.875 2zM0\n    7.511v16.684l11.165-8.257L0 7.511zM16.71 20.094l-3.628-2.719L0 27.068v1.765A1.147 1.147 0 0 0 1.125 30h13.959a12.191\n    12.191 0 0 1 1.708-9.863c-.025-.018-.057-.024-.082-.043zM27 14.7a12.253 12.253 0 0 1 9 3.935V7.541l-9.577\n    7.188c.193-.009.382-.029.577-.029zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM27 34a7 7 0 0\n    1-1-13.929v7.136a.674.674 0 0 0 .2.476l2.9 2.9a.673.673 0 0 0 .953 0l.9-.9a.674.674 0 0 0\n    0-.953l-2.054-2.054a.675.675 0 0 1-.2-.476v-5.993A7 7 0 0 1 27 34z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$48($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EmailSchedule" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EmailSchedule extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$48, create_fragment$48, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Engagement.svelte generated by Svelte v3.24.1 */

function create_fragment$49(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M8.2 26.542c.042.079.183.283.4.589a54.031 54.031 0 0 1 5 8.869H30c1.086-2.954 2.925-8.647 1.637-10.548a4.334\n    4.334 0 0 0-2.456-1.236 7.9 7.9 0 0 1-.589-.649 3.36 3.36 0 0 0-1.979-1.236 6.772 6.772 0 0 0-1.108-.017 1.377 1.377\n    0 0 1-1.331-.728 3.128 3.128 0 0\n    0-1.812-1.108c-.769-.124-1.173.391-1.656.359-.4-.174-.515-1.416-.515-1.416v-8.377a2.071 2.071 0 1 0-4.105\n    0V22.1a9.733 9.733 0 0 1-.727 3.705c-.114.224-.576.835-.816 1.173a14.139 14.139 0 0 1-3.361-3.6 5.514 5.514 0 0\n    0-2.52-2.436 1.545 1.545 0 0 0-1.716.225c-1.4.86-.234 2.833.788 4.572.172.298.337.57.466.803z");
			attr(path1, "d", "M18 1.5a9.744 9.744 0 0 0-5.25 17.957V16.6a7.5 7.5 0 1 1 10.5 0v2.858A9.744 9.744 0 0 0 18 1.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$49($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Engagement" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Engagement extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$49, create_fragment$49, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Erase.svelte generated by Svelte v3.24.1 */

function create_fragment$4a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.613 28.132a1 1 0 0 0 1.414 0l13.562-13.561a1 1 0 0 0 0-1.414L22.275 1.843a1 1 0 0 0-1.414 0L7.3 15.4a1 1 0 0\n    0 0 1.414l.707.707-6.3 6.3a2 2 0 0 0 0 2.829l6.505 6.5a2.8 2.8 0 0 0 1.921.85H33.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0\n    0-.5-.5H13.331l4.575-4.575zM10.9 31.607a1 1 0 0 1-1.414 0l-6.368-6.364 6.3-6.3 7.071 7.071z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Erase" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Erase extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4a, create_fragment$4a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Event.svelte generated by Svelte v3.24.1 */

function create_fragment$4b(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.5 10.054a.494.494 0 0 0-.5.5v24.782a.494.494 0 0 0 .846.354L26.51 28h9c.445 0 .479-.726.225-.98L18.846\n    10.2a.489.489 0 0 0-.346-.146z");
			attr(path1, "d", "M13.991 30H5.997V6H30v8l4 4V2H2v32h11.991v-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Event" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Event extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4b, create_fragment$4b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EventExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$4c(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.935 6.935 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777zM18.7 17.944l-9.842-9.8A.488.488 0 0 0 8.5\n    8a.5.5 0 0 0-.5.5v22.782a.5.5 0 0 0 .5.5.489.489 0 0 0 .35-.148L14 24.656l.928.007a12.263 12.263 0 0 1 3.772-6.719z");
			attr(path1, "d", "M4 4h16v12.892a12.234 12.234 0 0 1 4-1.808V0H0v24h6v-4H4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EventExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EventExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4c, create_fragment$4c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/EventShare.svelte generated by Svelte v3.24.1 */

function create_fragment$4d(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M4 4h16v8l1.739 1.739L24 11.232V0H0v24h6v-4H4V4z");
			attr(path1, "d", "M18.384 17.626l-9.53-9.479A.491.491 0 0 0 8.5 8a.5.5 0 0 0-.5.5v22.782a.5.5 0 0 0 .5.5.491.491 0 0 0 .35-.148L14\n    24.656V22a2 2 0 0 1 2-2h2.233a2.976 2.976 0 0 1 .151-2.374zM31.722 18.331L26 12l-5.708 6.331A1 1 0 0 0 21.035\n    20H24v7.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V20h2.979a1 1 0 0 0 .743-1.669z");
			attr(path2, "d", "M32 22v10H20V22h-3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V23a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "EventShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class EventShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4d, create_fragment$4d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Events.svelte generated by Svelte v3.24.1 */

function create_fragment$4e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.615 28.135a.461.461 0 0 1-.461.465l-8.769.015-6.6 7.249a.452.452 0 0 1-.323.136.461.461 0 0\n    1-.462-.462V12.462a.461.461 0 0 1 .465-.462.452.452 0 0 1 .323.136l15.691 15.676a.451.451 0 0 1 .136.323zm-21.629\n    1.592l2.872-5.008a.457.457 0 0 0-.188-.617l-1.181-.677a.456.456 0 0 0-.627.15l-2.871 5.008a.457.457 0 0 0\n    .188.617l1.18.677a.456.456 0 0 0 .627-.15zM24.452 7.89l2.871-5.008a.456.456 0 0 0-.187-.617l-1.181-.677a.456.456 0 0\n    0-.627.15l-2.871 5.008a.456.456 0 0 0 .187.617l1.181.677a.456.456 0 0 0 .627-.15zM3.973 23.323l5.267-2.365a.457.457\n    0 0 0 .211-.609l-.558-1.242a.456.456 0 0 0-.6-.247l-5.262 2.364a.457.457 0 0 0-.211.609l.558 1.242a.456.456 0 0 0\n    .595.248zm23.734-10.209l5.267-2.364a.457.457 0 0 0 .211-.609L32.627 8.9a.456.456 0 0 0-.6-.247l-5.267 2.364a.457.457\n    0 0 0-.211.609l.558 1.242a.455.455 0 0 0 .6.246zm-25.24.571l5.65 1.183a.456.456 0 0 0 .529-.369l.279-1.332a.457.457\n    0 0 0-.336-.55l-5.651-1.183a.456.456 0 0 0-.529.369l-.279 1.332a.457.457 0 0 0 .337.55zm25.139 5.672l5.651\n    1.183a.457.457 0 0 0 .529-.369l.278-1.332a.455.455 0 0 0-.336-.55l-5.65-1.183a.456.456 0 0 0-.529.369l-.279\n    1.332a.457.457 0 0 0 .336.55zM6.924 4.633L10.8 8.911a.457.457 0 0 0 .645.013l1.008-.914a.458.458 0 0 0\n    .052-.643L8.629 3.089a.457.457 0 0 0-.645-.013l-1.009.914a.457.457 0 0 0-.051.643zM15.549.639l.621 5.74a.456.456 0 0\n    0 .514.388l1.353-.146a.455.455 0 0 0 .419-.49L17.835.392A.456.456 0 0 0 17.321 0l-1.353.149a.455.455 0 0 0-.419.49z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Events" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Events extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4e, create_fragment$4e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ExcludeOverlap.svelte generated by Svelte v3.24.1 */

function create_fragment$4f(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24 12V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h7V12z");
			attr(path1, "d", "M31 12h-7v12H12v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V13a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ExcludeOverlap" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ExcludeOverlap extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4f, create_fragment$4f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Experience.svelte generated by Svelte v3.24.1 */

function create_fragment$4g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 4H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM12 28H6V18h6zm18\n    0H14v-4h16zm0-6H14v-4h16zm0-6H6V8h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Experience" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Experience extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4g, create_fragment$4g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ExperienceAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$4h(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27.1c0-.371.023-.737.056-1.1H12v-4h3.816a12.311 12.311 0 0 1 1.15-2H12v-4h9.728A12.205 12.205 0 0 1 32\n    15.869V3a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h14.059a12.238 12.238 0 0 1-.359-2.9zM4 6h24v8H4zm6\n    20H4V16h6z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ExperienceAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ExperienceAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4h, create_fragment$4h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ExperienceAddTo.svelte generated by Svelte v3.24.1 */

function create_fragment$4i(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 26h-8v-4h8v-2h-8v-4h16v2h4V3a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h19zM4 6h24v8H4zm6 20H4V16h6z");
			attr(path1, "d", "M35.394 29.051l-3.837-3.837 4.3-4.363A.5.5 0 0 0 35.5 20H22v13.494a.5.5 0 0 0 .854.358l4.33-4.265 3.837 3.837a1 1\n    0 0 0 1.414 0l2.96-2.959a1 1 0 0 0-.001-1.414z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ExperienceAddTo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ExperienceAddTo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4i, create_fragment$4i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ExperienceImport.svelte generated by Svelte v3.24.1 */

function create_fragment$4j(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M6 14v-3.328a.5.5 0 0 1 .866-.341L14 18l-7.134 7.669A.5.5 0 0 1 6 25.328V22H1a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1z");
			attr(path1, "d", "M35 4H5a1 1 0 0 0-1 1v3h28v8H16v12H4v3a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-3\n    24H18v-4h14zm0-6H18v-4h14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ExperienceImport" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ExperienceImport extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4j, create_fragment$4j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ExperienceExport.svelte generated by Svelte v3.24.1 */

function create_fragment$4k(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M30 28H12v-4h7.6v-2H12v-4h7.6v-2H4V8h26V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h28a1 1 0 0 0 1-1zm-20\n    0H4V18h6z");
			attr(path1, "d", "M28 14v-3.328a.5.5 0 0 1 .866-.341L36 18l-7.134 7.669a.5.5 0 0 1-.866-.341V22h-5a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ExperienceExport" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ExperienceExport extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4k, create_fragment$4k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Exposure.svelte generated by Svelte v3.24.1 */

function create_fragment$4l(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.17 7.266a15.805 15.805 0 0 0-3.4 15.558h8.565zM24.515 3.411A15.843 15.843 0 0 0 8.786 4.94l2.643 7.966zM33.942\n    19.154c.03-.382.058-.764.058-1.154a15.951 15.951 0 0 0-6.458-12.812L21.043 9.9zM26.85 18.026l-5.006 15.482a16 16 0 0\n    0 11.448-10.862zM18.31 33.984l2.568-7.944H4.183A15.98 15.98 0 0 0 18 34c.105 0 .207-.008.31-.016z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Exposure" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Exposure extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4l, create_fragment$4l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Extension.svelte generated by Svelte v3.24.1 */

function create_fragment$4m(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 8h-2V1.215a.75.75 0 0 0-.75-.75h-1.5a.75.75 0 0 0-.75.75V8h-6V1.215a.75.75 0 0 0-.75-.75h-1.5a.75.75 0 0\n    0-.75.75V8h-2a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h.035v5.5a4.5 4.5 0 0 0 4.5 4.5H22.5v3A5.312 5.312 0 0 1 12\n    27V11.536a5.445 5.445 0 0 0-4.6-5.5 5.2 5.2 0 0 0-5.491 3.276.767.767 0 0 0 .395.995l1.289.554a.783.783 0 0 0\n    1.048-.4A2.251 2.251 0 0 1 9 11.25V27a8.287 8.287 0 0 0 16.5 0v-3h1.938a4.5 4.5 0 0 0 4.5-4.5V14H32a2 2 0 0 0\n    2-2v-2a2 2 0 0 0-2-2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Extension" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Extension extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4m, create_fragment$4m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Export.svelte generated by Svelte v3.24.1 */

function create_fragment$4n(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M25 26h-2a1 1 0 0 0-1 1v3H6V6h16v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1\n    1h22a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1z");
			attr(path1, "d", "M35.856 17.649L29.332 10.2a.787.787 0 0 0-.527-.2.8.8 0 0 0-.8.8V16H17a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h11v5.2a.8.8\n    0 0 0 .8.8.787.787 0 0 0 .527-.2l6.524-7.445a.5.5 0 0 0 0-.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Export" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Export extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4n, create_fragment$4n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ExportOriginal.svelte generated by Svelte v3.24.1 */

function create_fragment$4o(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 21v-6a1 1 0 0 1 1-1h13V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h24a1 1 0 0 0 1-1v-9H13a1 1 0 0 1-1-1z");
			attr(path1, "d", "M28 11.207V16H14.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5H28v4.793a.5.5 0 0 0 .854.353L35.913 18l-7.059-7.146a.5.5 0 0\n    0-.854.353z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ExportOriginal" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ExportOriginal extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4o, create_fragment$4o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FacebookCoverImage.svelte generated by Svelte v3.24.1 */

function create_fragment$4p(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M13.136 28.345v-1.014a.7.7 0 0 1 .177-.452 5.386 5.386 0 0 0 1.2-3.34c0-2.527-1.326-3.94-3.33-3.94s-3.368\n    1.468-3.368 3.94a5.442 5.442 0 0 0 1.265 3.34.707.707 0 0 1 .177.452v1.009a.694.694 0 0 1-.6.7C4.629 29.4 4 32.18 4\n    33.278c0 .122.014.6.023.722h14.364s.013-.6.013-.722c0-1.052-.711-3.825-4.665-4.231a.7.7 0 0 1-.599-.702z");
			attr(path1, "d", "M33 4H3a1 1 0 0 0-1 1v23.4a1.551 1.551 0 0 0 .291.9 7.336 7.336 0 0 1 3.221-2.564 8.159 8.159 0 0 1-.693-3.2\n    8.264 8.264 0 0 1 .447-2.729A12.66 12.66 0 0 0 4 21.379V8h28v15.187a6.155 6.155 0 0\n    1-4.51-2.416c-1.375-1.81-3.276-3.97-4.519-3.97-1.694 0-3.721 3.307-5.6 5.161a8.822 8.822 0 0 1 .147 1.579 8.3 8.3 0\n    0 1-.662 3.217A7.364 7.364 0 0 1 20.521 30H33a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FacebookCoverImage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FacebookCoverImage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4p, create_fragment$4p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Fast.svelte generated by Svelte v3.24.1 */

function create_fragment$4q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.909 13.432a4.729 4.729 0 0 0-1.052-.043L18.516 5.9a6.888 6.888 0 0 0 .964 4.637c.808 1.262 3.14 2.7 5.028\n    3.71a3.178 3.178 0 0 0-1.227 1.982 3.069 3.069 0 0 0 .1 1.4 13.207 13.207 0 0\n    0-5.918-4.129c-5.437-1.488-7.476-.661-8.927-.5a2.748 2.748 0 0 0 .331-1 2.784 2.784 0 1 0-2.515\n    2.417l-.283.691C3.225 20.983 7.141 24.1 9.513 25.435c.838.473 3.529 1.535 3.529 1.535l-3.605 2.611A1.849 1.849 0 0 0\n    8.868 32s3.214-1.934 6.579-3.984L20 30a2.141 2.141 0 0 0 2.645-.832l-4.766-2.638a249.35 249.35 0 0 0 4.4-2.744 8.158\n    8.158 0 0 0 3.338-3.8 4.708 4.708 0 0 0 1.161.363c2.242.368 5.551-.681 5.865-2.592s-2.491-3.957-4.734-4.325zM15.481\n    25.205l-2.995-1.655a6.876 6.876 0 0 0 1.691-2.85 52.26 52.26 0 0 0 4.773 1.994z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Fast" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Fast extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4q, create_fragment$4q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FastForward.svelte generated by Svelte v3.24.1 */

function create_fragment$4r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14.149 30.919V5.081a1 1 0 0 1 1.625-.781l16.149 12.919a1 1 0 0 1 0 1.562L15.774 31.7a1 1 0 0\n    1-1.625-.781zM12.149 9.519L5.625 4.3A1 1 0 0 0 4 5.081v25.838a1 1 0 0 0 1.625.781l6.524-5.22z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FastForward" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FastForward extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4r, create_fragment$4r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FastForwardCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$4s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-8 23.017V10.984a1 1 0 0 1 1.625-.781L14 12.1v11.8l-2.375 1.9A1 1 0 0 1\n    10 25.017zm18.4-6.236L19.625 25.8A1 1 0 0 1 18 25.017V10.984a1 1 0 0 1 1.625-.781L28.4 17.22a1 1 0 0 1 0 1.561z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FastForwardCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FastForwardCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4s, create_fragment$4s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Feature.svelte generated by Svelte v3.24.1 */

function create_fragment$4t(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2.2A15.8 15.8 0 1 0 33.8 18 15.8 15.8 0 0 0 18 2.2zm12.2 12.574l-6.726 5.392 2.274 8.308a.355.355 0 0\n    1-.237.443.351.351 0 0 1-.306-.049L18 24.144l-7.206 4.731a.355.355 0 0 1-.543-.394l2.274-8.315L5.8 14.774a.355.355 0\n    0 1 .208-.639l8.61-.408 3.05-8.063a.355.355 0 0 1 .671 0l3.05 8.063 8.61.408a.355.355 0 0 1 .348.362.351.351 0 0\n    1-.147.277z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Feature" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Feature extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4t, create_fragment$4t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Feed.svelte generated by Svelte v3.24.1 */

function create_fragment$4u(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 30H5a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h26a1 1 0 0 1 1 1v24a1 1 0 0 1-1 1zM30 6H6v6h24zm0 8H6v6h24zm0 8H6v6h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Feed" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Feed extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4u, create_fragment$4u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FeedAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$4v(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.74 28H6v-6h9.76a12.256 12.256 0 0 1 1.126-2H6v-6h24v1.069a12.216 12.216 0 0 1 2 .69V5a1 1 0 0 0-1-1H5a1 1 0 0\n    0-1 1v24a1 1 0 0 0 1 1h10.069a12.246 12.246 0 0 1-.329-2zM6 6h24v6H6z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FeedAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FeedAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4v, create_fragment$4v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FeedManagement.svelte generated by Svelte v3.24.1 */

function create_fragment$4w(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.74 28H6v-6h9.76a12.256 12.256 0 0 1 1.126-2H6v-6h24v1.069a12.216 12.216 0 0 1 2 .69V5a1 1 0 0 0-1-1H5a1 1 0 0\n    0-1 1v24a1 1 0 0 0 1 1h10.069a12.246 12.246 0 0 1-.329-2zM6 6h24v6H6z");
			attr(path1, "d", "M35.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.146 6.146 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.145\n    6.145 0 0 0-2.178.9l-1.513-1.513a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.513a6.143 6.143 0 0\n    0-.9 2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.143 6.143 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.131a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM27 30.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FeedManagement" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FeedManagement extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4w, create_fragment$4w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Feedback.svelte generated by Svelte v3.24.1 */

function create_fragment$4x(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 2H6a4 4 0 0 0-4 4v16a4 4 0 0 0 4 4h2v8.793a.5.5 0 0 0 .854.354L18 26h12a4 4 0 0 0 4-4V6a4 4 0 0 0-4-4zM8\n    17.35a3.85 3.85 0 1 1 3.85-3.85A3.85 3.85 0 0 1 8 17.35zm10 0a3.85 3.85 0 1 1 3.85-3.85A3.85 3.85 0 0 1 18 17.35zm10\n    0a3.85 3.85 0 1 1 3.85-3.85A3.85 3.85 0 0 1 28 17.35z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Feedback" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Feedback extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4x, create_fragment$4x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$4y(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M16 2v10H6L16 2z");
			attr(path1, "d", "M14.7 27A12.309 12.309 0 0 1 30 15.069V3a1 1 0 0 0-1-1H18v11a1 1 0 0 1-1 1H6v19a1 1 0 0 0 1 1h9.886a12.241 12.241\n    0 0 1-2.186-7z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4y, create_fragment$4y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileCSV.svelte generated by Svelte v3.24.1 */

function create_fragment$4z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-8.208 16.959a.727.727 0 0\n    1-.792-.723V29.9a.65.65 0 0 1 .457-.672c1.424-.25 3.136-1.268 3.136-2.631a4.332 4.332 0 1 1 5.069-4.268 8.336 8.336\n    0 0 1-7.87 8.63z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileCSV" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileCSV extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4z, create_fragment$4z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileCampaign.svelte generated by Svelte v3.24.1 */

function create_fragment$4A(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M16.5 27A10.5 10.5 0 0 1 27 16.5a10.4 10.4 0 0 1 3 .488V14H19a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1\n    1h12.225a10.424 10.424 0 0 1-2.725-7z");
			attr(path2, "d", "M19.022 26h2.762A5.307 5.307 0 0 1 26 21.784v-2.762A8.119 8.119 0 0 0 19.022 26zm13.193 0h2.762A8.119 8.119 0 0 0\n    28 19.022v2.761A5.307 5.307 0 0 1 32.216 26zm-10.431 2h-2.762A8.119 8.119 0 0 0 26 34.978v-2.762A5.307 5.307 0 0 1\n    21.784 28zM28 32.216v2.761A8.119 8.119 0 0 0 34.978 28h-2.762A5.307 5.307 0 0 1 28 32.216zM24.778 27A2.222 2.222 0 1\n    1 27 29.222 2.222 2.222 0 0 1 24.778 27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileCampaign" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileCampaign extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4A, create_fragment$4A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileChart.svelte generated by Svelte v3.24.1 */

function create_fragment$4B(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14h11v19a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h11v11a1 1 0 0 0 1 1zm.5 10h-3a.5.5 0 0 0-.5.5v5a.5.5 0\n    0 0 .5.5h3a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5zm-6 2h-3a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0\n    .5-.5v-3a.5.5 0 0 0-.5-.5zm12-6h-3a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileChart" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileChart extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4B, create_fragment$4B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileCheckedOut.svelte generated by Svelte v3.24.1 */

function create_fragment$4C(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 0h.086a1 1 0 0 1 .706.292L27.708 7.2a1 1 0 0 1 .292.714V8h-8zM27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm5\n    10.814a.5.5 0 0 1-.854.354L29.05 27.07l-4.636 4.636a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1\n    0-.707l4.636-4.636-2.097-2.096a.5.5 0 0 1 .354-.854h6.527a.287.287 0 0 1 .287.287z");
			attr(path1, "d", "M15.75 27A11.25 11.25 0 0 1 27 15.75c.338 0 .67.021 1 .05V10h-9a1 1 0 0 1-1-1V0H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1\n    1h11.933a11.184 11.184 0 0 1-1.183-5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileCheckedOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileCheckedOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4C, create_fragment$4C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileCode.svelte generated by Svelte v3.24.1 */

function create_fragment$4D(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-4.433 15.225a.257.257 0 0\n    1-.209.408h-2.744a.257.257 0 0 1-.206-.1l-3.461-4.618 3.461-4.615a.256.256 0 0 1 .206-.1h2.744a.257.257 0 0 1\n    .209.407l-3.505 4.31zm2.766 1.844h-1.866a.514.514 0 0 1-.495-.652l3.745-13.412a.515.515 0 0 1 .5-.376h1.863a.514.514\n    0 0 1 .495.652l-3.747 13.413a.514.514 0 0 1-.494.376zm7.258-1.539a.26.26 0 0 1-.206.1h-2.743a.257.257 0 0\n    1-.209-.408l3.505-4.31-3.505-4.31a.257.257 0 0 1 .209-.407h2.744a.259.259 0 0 1 .206.1l3.461 4.615z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileCode" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileCode extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4D, create_fragment$4D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileData.svelte generated by Svelte v3.24.1 */

function create_fragment$4E(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M16 2v10H6L16 2z");
			attr(path1, "d", "M20 34V17.861c0-3.3 4.666-4.8 9-4.8.332 0 .666.025 1 .043V3a1 1 0 0 0-1-1H18v11a1 1 0 0 1-1 1H6v19a1 1 0 0 0 1 1z");
			attr(path2, "d", "M29 28c-3.866 0-7-1.253-7-2.8v-4c0 1.546 3.134 3.066 7 3.066s7-1.52 7-3.066v4c0 1.547-3.134 2.8-7 2.8zm7\n    5.179v-5.158c0 1.546-3.134 2.8-7 2.8s-7-1.253-7-2.8v5.159c0 1.546 3.134 2.8 7 2.8s7-1.254\n    7-2.801zm0-15.068c0-1.546-3.195-2.626-7.061-2.626S22 16.565 22 18.111s3.134 2.8 7 2.8 7-1.253 7-2.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileData" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileData extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4E, create_fragment$4E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileEmail.svelte generated by Svelte v3.24.1 */

function create_fragment$4F(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M16 23a1 1 0 0 1 1-1h13v-8H19a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h9z");
			attr(path2, "d", "M28.208 32.25L36 26.584V35a1 1 0 0 1-1 1H19a1 1 0 0 1-1-1v-8.416l7.792 5.667a2.054 2.054 0 0 0 2.416-.001zM27\n    30.347L36 24H18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileEmail" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileEmail extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4F, create_fragment$4F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileExcel.svelte generated by Svelte v3.24.1 */

function create_fragment$4G(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm.488\n    16.525s-1.389-2.771-1.842-3.688c-.4.923-1 2.22-1.363 3.014l-.311.675H12l3.621-6.333L12.127\n    18h3.98l.389.808c.393.816.883 1.831 1.27 2.68.361-.885.748-1.715 1.154-2.582l.42-.906h3.977l-3.535 6.124 3.709 6.4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileExcel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileExcel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4G, create_fragment$4G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileFolder.svelte generated by Svelte v3.24.1 */

function create_fragment$4H(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M18 33.5V23a3 3 0 0 1 3-3h4.586a2.982 2.982 0 0 1 2.121.879L30 23.172V14H19a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1\n    1 0 0 0 1 1h11.1a2.385 2.385 0 0 1-.1-.5z");
			attr(path2, "d", "M33.5 34h-13a.5.5 0 0 1-.5-.5V26h13.5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5zM28 24l-1.707-1.707a1 1 0 0\n    0-.707-.293H21a1 1 0 0 0-1 1v1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileFolder" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileFolder extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4H, create_fragment$4H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileGear.svelte generated by Svelte v3.24.1 */

function create_fragment$4I(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.145 6.145 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.145\n    6.145 0 0 0-2.178.9l-1.513-1.513a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.513a6.142 6.142 0 0\n    0-.9 2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.131a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM27 30.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5zM16 2v10H6L16 2z");
			attr(path1, "d", "M16.5 27A10.5 10.5 0 0 1 27 16.5a10.378 10.378 0 0 1 3 .488V3a1 1 0 0 0-1-1H18v11a1 1 0 0 1-1 1H6v19a1 1 0 0 0 1\n    1h12.225a10.423 10.423 0 0 1-2.725-7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileGear" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileGear extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4I, create_fragment$4I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileGlobe.svelte generated by Svelte v3.24.1 */

function create_fragment$4J(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2zM26.157 29.272c1.1 1.641 2.773 4.159 1.887 6.418a3.075 3.075 0 0\n    1-.463-.073c-2.484-.527-6-2.931-6-6.966a7.117 7.117 0 0 1 2.893-5.706c.118 1.433-1.078 2.155-.615 3.831.541 1.974\n    1.379 1.129 2.298 2.496zm9.052-.166c-.713-.271-1.325.653-1.379-1.844a2.552 2.552 0 0 1 .738-1.771 1.361 1.361 0 0 1\n    .323-.154c-.084-.155-.179-.3-.274-.451-.017.009-.031.02-.048.027-.554.258-.63.334-.886 0a.7.7 0 0 1 .153-1.03 7.078\n    7.078 0 0 0-5.16-2.312c.9.012 1.969.677 1.423 1.74.082-.169-1.783-.571-2.037-.571-.342 0 .7-1.279.6-1.168a7.121\n    7.121 0 0 0-2.929.63c.484.313 1.023.2 1.569.338a1.328 1.328 0 0 1 .486.2 1.636 1.636 0 0 0-.486-.2c-.8-.093.39\n    2.115.344 1.821a1.02 1.02 0 0 1 2.024-.061 1.655 1.655 0 0 1-.371 1c-.624.821-.751 2.282-1.063\n    1.908-2.918-1.2-2.6.386-1.639 1.442 1.534 1.691.755.173 2.764 1.059 1.615.712 3.559.881 3.085 1.418-1.435\n    1.625-1.133 2.7-3.672 4.607.211-.006.885-.073 1.023-.1a7.206 7.206 0 0 0 5.922-6.376 1.061 1.061 0 0 1-.51-.152z");
			attr(path1, "d", "M18.591 28.643A10.062 10.062 0 0 1 30 18.673V14H19a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h13.135a10.015\n    10.015 0 0 1-1.544-5.357z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileGlobe" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileGlobe extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4J, create_fragment$4J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileHTML.svelte generated by Svelte v3.24.1 */

function create_fragment$4K(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7.888\n    16.4h-2.8v-4h-3.2v4h-2.8V19.6h2.8v4h3.2v-4h2.8zm-10.953-1.09a.257.257 0 0 1-.209.407h-2.744a.256.256 0 0\n    1-.206-.1L9.315 25l3.461-4.615a.256.256 0 0 1 .206-.1h2.744a.257.257 0 0 1 .209.407L12.43 25z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileHTML" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileHTML extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4K, create_fragment$4K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileImportant.svelte generated by Svelte v3.24.1 */

function create_fragment$4L(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-8.763-2.172a.362.362 0 0 1\n    .171-.373 5.889 5.889 0 0 1 2.035-.408 6.662 6.662 0 0 1 2.071.306.424.424 0 0 1 .2.374v2.443a78.132 78.132 0 0\n    1-.679 7.884c0 .1-.033.2-.237.2h-2.711a.224.224 0 0 1-.237-.2c-.069-.951-.612-4.931-.612-7.782zm2.206 18.6a2.635\n    2.635 0 0 1-2.9-2.7 2.739 2.739 0 0 1 2.9-2.777 2.7 2.7 0 0 1 2.9 2.777 2.635 2.635 0 0 1-2.9 2.701z");
			attr(path1, "d", "M20 2v10h10L20 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileImportant" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileImportant extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4L, create_fragment$4L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileJson.svelte generated by Svelte v3.24.1 */

function create_fragment$4M(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-2.977 3.765a.454.454 0 0\n    1-.463.445l-1.03.084a.43.43 0 0 0-.456.401v3.083a3.97 3.97 0 0 1-1.201 2.213 4.127 4.127 0 0 1 1.201\n    2.231v3.09a.44.44 0 0 0 .464.407H15.6a.454.454 0 0 1 .464.445v1.52a.454.454 0 0 1-.464.445h-.553c-2.047\n    0-3.139-1.72-3.139-3.685v-2.316a1.939 1.939 0 0 0-.957-1.79.38.38 0 0 1 .005-.686 1.913 1.913 0 0 0\n    .952-1.8c0-.543-.008-.565-.017-2.28-.01-1.97 1.085-3.669 3.139-3.669l.53-.084a.454.454 0 0 1 .462.444zm9.025\n    6.573a1.96 1.96 0 0 0-.98 1.79v2.316c0 1.964-1.07 3.685-3.116 3.685h-.597a.454.454 0 0 1-.463-.444v-1.521a.454.454 0\n    0 1 .463-.445h1.107a.44.44 0 0 0 .464-.408v-3.089a4.127 4.127 0 0 1 1.201-2.231 3.97 3.97 0 0\n    1-1.201-2.213v-3.083a.43.43 0 0 0-.456-.4h-1.083a.454.454 0 0 1-.463-.445v-1.502a.454.454 0 0 1 .463-.445h.582c2.054\n    0 3.126 1.699 3.116 3.669-.008 1.715-.017 1.737-.017 2.28a1.933 1.933 0 0 0 .975 1.8.38.38 0 0 1 .005.686z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileJson" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileJson extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4M, create_fragment$4M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileKey.svelte generated by Svelte v3.24.1 */

function create_fragment$4N(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M22.821 24.77a1.856 1.856 0 1 0 1.857 1.856 1.855 1.855 0 0 0-1.857-1.856zM19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1\n    1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm2.154 15.952a4.395 4.395 0 0 1-3.683-3.686 4.49 4.49 0 0 1 .048-1.569L15.4\n    22.509v-1.957h-2.363a.339.339 0 0 1-.338-.337v-2.362h-2.361a.338.338 0 0 1-.338-.337v-3.374a.338.338 0 0 1\n    .338-.337h1.546a.349.349 0 0 1 .239.1l7.766 7.766a4.342 4.342 0 0 1 2-.442 4.451 4.451 0 0 1 4.3 4.682 4.387 4.387 0\n    0 1-5.035 4.041z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileKey" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileKey extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4N, create_fragment$4N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileMobile.svelte generated by Svelte v3.24.1 */

function create_fragment$4O(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10 2v10H0L10 2zM33 8H19a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zm-8 2h2a1 1 0 0 1 0\n    2h-2a1 1 0 0 1 0-2zm1 23.1a2.1 2.1 0 1 1 2.1-2.1 2.1 2.1 0 0 1-2.1 2.1zm6-5.1H20V14h12z");
			attr(path1, "d", "M16 32V8.481A2.481 2.481 0 0 1 18.481 6H26V3a1 1 0 0 0-1-1H12v11a1 1 0 0 1-1 1H0v19a1 1 0 0 0 1 1h15.557A3.953\n    3.953 0 0 1 16 32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileMobile" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileMobile extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4O, create_fragment$4O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilePDF.svelte generated by Svelte v3.24.1 */

function create_fragment$4P(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M16.307 17.031c0-.763-.237-1.13-.713-1.13a.521.521 0 0 0-.5.317l-.021.05c-.382.655-.094 2.39.677 4.306a25.062\n    25.062 0 0 0 .557-3.543zm2.254 8.633l.021-.007h-.016c-.007.005-.006.006-.005.007zM8.416 30.718a.628.628 0 0 0\n    .216.612.616.616 0 0 0 .432.158c.828 0 2.153-1.411 3.5-3.722-2.42 1.008-3.99 2.124-4.148\n    2.952zm7.625-8.266c-.26.778-.454 1.541-.756 2.29-.26.626-.584 1.318-.958 2.031.641-.216 1.462-.526\n    2.152-.713.775-.206 1.376-.273 2.078-.4a14.16 14.16 0 0 1-1.61-1.8 16.617 16.617 0 0 1-.906-1.407zm6.9 3.3a10.2 10.2\n    0 0 0-3.521.122 6.493 6.493 0 0 0 2.837 1.6 1.686 1.686 0 0 0 .446.058 1.009 1.009 0 0 0\n    1.088-.713c.109-.565-.233-.939-.853-1.069zM19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0\n    1-1V14zm5.875 12.866a1.022 1.022 0 0 1-.064.353 1.61 1.61 0 0 1-1.57 1.008 7.111 7.111 0 0\n    1-4.392-2.182c-.777.137-1.5.267-2.369.5-.8.209-1.691.525-2.434.785C12.722 29.718 10.972 32 9.388 32a1.236 1.236 0 0\n    1-1.029-.389 1.305 1.305 0 0 1-.346-1.044c.209-1.2 2.073-2.383 4.838-3.485a25.1 25.1 0 0 0\n    1.349-2.635c.483-1.174.784-2.117 1.123-3.139-.973-2.146-1.282-4.392-.742-5.321a1.207 1.207 0 0 1\n    .986-.663c1.274-.043 1.649 1.562 1.649 2.426a14.064 14.064 0 0 1-.879 4.075 20.321 20.321 0 0 0 1.138 1.9 11.175\n    11.175 0 0 0 1.647 1.775 15.28 15.28 0 0 1 2.578-.245 4.019 4.019 0 0 1 2.908.878 1.1 1.1 0 0 1 .267.72z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilePDF" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilePDF extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4P, create_fragment$4P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileShare.svelte generated by Svelte v3.24.1 */

function create_fragment$4Q(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M16 2v10H6L16 2z");
			attr(path1, "d", "M14 23a3 3 0 0 1 3-3h1.208a3 3 0 0 1 .6-3.008L26 9.016l4 4.427V3a1 1 0 0 0-1-1H18v11a1 1 0 0 1-1 1H6v19a1 1 0 0 0\n    1 1h7z");
			attr(path2, "d", "M31.722 18.331L26 12l-5.708 6.331A1 1 0 0 0 21.035 20H24v7.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V20h2.979a1 1 0 0\n    0 .743-1.669z");
			attr(path3, "d", "M32 22v10H20V22h-3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V23a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4Q, create_fragment$4Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileSingleWebPage.svelte generated by Svelte v3.24.1 */

function create_fragment$4R(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M12 28h12v-6H12zm7-14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7 15a1 1 0 0 1-1\n    1H11a1 1 0 0 1-1-1V19a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileSingleWebPage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileSingleWebPage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4R, create_fragment$4R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileSpace.svelte generated by Svelte v3.24.1 */

function create_fragment$4S(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M23.652 19.889A23.3 23.3 0 0 0 17 19a23.3 23.3 0 0 0-6.652.889.5.5 0 0 0-.348.484v7.947a.514.514 0 0 0\n    .315.469A16.582 16.582 0 0 0 17 29.9a17.163 17.163 0 0 0 6.686-1.111.509.509 0 0 0 .314-.469v-7.947a.5.5 0 0\n    0-.348-.484z");
			attr(path1, "d", "M27.995 7C27.939 3.549 22.272 2.1 17 2.1S6.061 3.549 6.005 7H6v22h.005c.056 3.451 5.723 4.9 10.995\n    4.9s10.939-1.449 10.995-4.9H28V7zM17 4.1c5.384 0 9 1.525 9 2.95S22.384 10 17 10 8 8.475 8 7.05s3.616-2.95 9-2.95zm9\n    24.95c0 1.425-3.616 2.95-9 2.95s-9-1.525-9-2.95c0-.017.007-.033.008-.05H8V10.093C10.128 11.41 13.643 12 17\n    12s6.872-.59 9-1.907V29h-.008c.001.017.008.033.008.05z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileSpace" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileSpace extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4S, create_fragment$4S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileTemplate.svelte generated by Svelte v3.24.1 */

function create_fragment$4T(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-5 15a1 1 0 0 1-1 1H9a1 1 0 0\n    1-1-1v-4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1zm0-8a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1zm0-8a1 1\n    0 0 1-1 1H9a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileTemplate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileTemplate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4T, create_fragment$4T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileTxt.svelte generated by Svelte v3.24.1 */

function create_fragment$4U(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7 15.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0\n    1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5zm0-4a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5\n    0 0 1 .5.5zm0-4a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileTxt" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileTxt extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4U, create_fragment$4U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileUser.svelte generated by Svelte v3.24.1 */

function create_fragment$4V(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M28.677 28.542v-1.4a.966.966 0 0 1 .246-.623 7.366 7.366 0 0 0 1.675-4.6c0-3.479-1.845-5.424-4.633-5.424s-4.686\n    2.021-4.686 5.424a7.447 7.447 0 0 0 1.756 4.6.965.965 0 0 1 .246.623v1.389a.958.958 0 0 1-.836.967c-5.6.487-6.439\n    4.319-6.439 5.83L16 36h20v-.667c0-1.448-.989-5.266-6.49-5.825a.963.963 0 0 1-.833-.966z");
			attr(path1, "d", "M16 2L6 12h10zm13 0H18v11a1 1 0 0 1-1 1H6v19a1 1 0 0 0 1 1h6.139a8.711 8.711 0 0 1 6.551-7.041 10.262 10.262 0 0\n    1-1.41-5.031c0-4.959 3.16-8.424 7.686-8.424A7.55 7.55 0 0 1 30 14.625V3a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileUser" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileUser extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4V, create_fragment$4V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileWord.svelte generated by Svelte v3.24.1 */

function create_fragment$4W(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm4.295 15.992a.56.56 0 0\n    1-.568.408h-1.973a.546.546 0 0 1-.539-.325l-.436-1.83a694.87 694.87 0 0 1-1.355-5.912c-.449 1.891-1.137 4.492-1.639\n    6.391l-.32 1.214a.559.559 0 0 1-.57.463h-1.934a.606.606 0 0 1-.545-.34L10.27\n    18.048l.146-.274.121-.143.279-.031h2.066a.527.527 0 0 1 .578.474c.894 3.754 1.389 5.919 1.676\n    7.29.092-.38.2-.817.322-1.325.334-1.372.8-3.267 1.437-5.983a.55.55 0 0 1 .57-.455h2.117a.535.535 0 0 1\n    .527.425l.232.977a385.655 385.655 0 0 1 1.463 6.351c.309-1.521.8-3.821 1.57-7.292a.56.56 0 0 1\n    .572-.46h2.1l.23.178a.543.543 0 0 1 .109.45z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileWord" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileWord extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4W, create_fragment$4W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileWorkflow.svelte generated by Svelte v3.24.1 */

function create_fragment$4X(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2zM36 27.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5V26h-2v6h2v-1.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1\n    .5.5v5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5V34h-3.5a.5.5 0 0 1-.5-.5V30h-2v3.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0\n    1-.5-.5v-9a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5V28h2v-3.5a.5.5 0 0 1 .5-.5H30v-1.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5z");
			attr(path1, "d", "M15.5 33.5v-9a3 3 0 0 1 3-3h9.172A2.991 2.991 0 0 1 30 19.579V14H19a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0\n    1 1h8.551a2.912 2.912 0 0 1-.051-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileWorkflow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileWorkflow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4X, create_fragment$4X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileXML.svelte generated by Svelte v3.24.1 */

function create_fragment$4Y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7.069 16.752h-1.931a.612.612 0 0\n    1-.59-.344s-1.41-2.4-1.908-3.271c-.6 1.1-1.215 2.213-1.83 3.289a.566.566 0 0 1-.533.325h-1.839a.476.476 0 0\n    1-.406-.725l2.94-4.8-2.872-4.757a.476.476 0 0 1 .407-.723H19.4a.67.67 0 0 1 .584.342l1.8 3.2L23.49 20.1a.67.67 0 0 1\n    .59-.353h1.786a.476.476 0 0 1 .406.724l-2.83 4.63 3.032 4.926a.476.476 0 0 1-.405.725zM14.62 29.028a.257.257 0 0\n    1-.209.408h-2.744a.257.257 0 0 1-.206-.1L8 24.718l3.461-4.618a.256.256 0 0 1 .206-.1h2.744a.257.257 0 0 1\n    .209.407l-3.505 4.31z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileXML" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileXML extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4Y, create_fragment$4Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FileZip.svelte generated by Svelte v3.24.1 */

function create_fragment$4Z(ctx) {
	let svg;
	let path0;
	let path1;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2h-4v15.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h5v-3.5a.5.5\n    0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V34h15a1 1 0 0 0 1-1V14zm-1 13a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V17a1 1 0 0 1\n    1-1h1v4h6v-4h1a1 1 0 0 1 1 1z");
			attr(circle, "cx", circle_cx_value = 13);
			attr(circle, "cy", circle_cy_value = 24);
			attr(circle, "r", circle_r_value = 2.186);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileZip" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileZip extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4Z, create_fragment$4Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilingCabinet.svelte generated by Svelte v3.24.1 */

function create_fragment$4_(ctx) {
	let svg;
	let path;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr(path, "d", "M31 2H5a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h3v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-3h12v3a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1v-3h3a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-1 24H6V16h24zM6 14V4h24v10z");
			attr(circle0, "cx", circle0_cx_value = 18);
			attr(circle0, "cy", circle0_cy_value = 10);
			attr(circle0, "r", circle0_r_value = 2);
			attr(circle1, "cx", circle1_cx_value = 18);
			attr(circle1, "cy", circle1_cy_value = 20);
			attr(circle1, "r", circle1_r_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle0);
			append(svg, circle1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilingCabinet" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilingCabinet extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4_, create_fragment$4_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Filmroll.svelte generated by Svelte v3.24.1 */

function create_fragment$4$(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 22);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 14);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 8);
			attr(path, "d", "M26 24a5.015 5.015 0 0 1 5-5h1a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H20v18h3a3 3 0 0 0 3-3zM14 6V4a1 1 0 0 0-1-1H9a1 1 0\n    0 0-1 1v2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$4$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Filmroll" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Filmroll extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4$, create_fragment$4$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilmrollAutoAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$50(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M32 26v-3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h3v3a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1v-3h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 22);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 14);
			attr(rect, "y", rect_y_value = 8);
			attr(path1, "d", "M20 24a5.015 5.015 0 0 1 5-5h1a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H16v18h2a2 2 0 0 0 2-2zM10 6V4a1 1 0 0 0-1-1H5a1 1 0\n    0 0-1 1v2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$50($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilmrollAutoAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilmrollAutoAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$50, create_fragment$50, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Filter.svelte generated by Svelte v3.24.1 */

function create_fragment$51(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.946 2H3.054a1 1 0 0 0-.787 1.617L14 18.589V33.9a.992.992 0 0 0 1.68.824l3.981-4.153a1.219 1.219 0 0 0\n    .339-.843V18.589L31.733 3.617A1 1 0 0 0 30.946 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$51($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Filter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Filter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$51, create_fragment$51, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$52(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.8 27a13.146 13.146 0 0 1 3.2-8.411C20.083 15.9 29.733 3.617 29.733 3.617A1 1 0 0 0 28.946 2H1.054a1 1 0 0\n    0-.787 1.617L12 18.589V33.9a.992.992 0 0 0 1.68.825l2.338-2.439A12.131 12.131 0 0 1 14.8 27z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$52($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$52, create_fragment$52, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$53(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.8 27a13.146 13.146 0 0 1 3.2-8.411c2.083-2.694 11.733-14.972 11.733-14.972A1 1 0 0 0 28.946 2H1.054a1 1 0 0\n    0-.787 1.617L12 18.589V33.9a.992.992 0 0 0 1.68.825l2.338-2.439A12.131 12.131 0 0 1 14.8 27z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$53($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$53, create_fragment$53, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterDelete.svelte generated by Svelte v3.24.1 */

function create_fragment$54(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5z");
			attr(path1, "d", "M14.8 27a13.146 13.146 0 0 1 3.2-8.411c2.083-2.694 11.733-14.972 11.733-14.972A1 1 0 0 0 28.946 2H1.054a1 1 0 0\n    0-.787 1.617L12 18.589V33.9a.992.992 0 0 0 1.68.825l2.338-2.439A12.131 12.131 0 0 1 14.8 27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$54($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterDelete" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterDelete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$54, create_fragment$54, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$55(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.785 21.721l-3.505-3.506a.739.739 0 0 0-.527-.215h-.023a.833.833 0 0 0-.564.247L20.344 29.069a.608.608 0 0\n    0-.153.256l-2.027 6c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039 5.123-1.764 6-2.028a.6.6 0 0 0\n    .252-.151l10.824-10.829A.835.835 0 0 0 36 22.3a.743.743 0 0 0-.215-.579zm-11.6 10.963c-1.314.395-3.3 1.229-4.43\n    1.568l1.56-4.431zM30.946 2H3.054a1 1 0 0 0-.787 1.617L14 18.589V30a.992.992 0 0 0 1.68.825l3.98-4.153a1.22 1.22 0 0\n    0 .34-.845v-7.238L31.733 3.617A1 1 0 0 0 30.946 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$55($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$55, create_fragment$55, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterHeart.svelte generated by Svelte v3.24.1 */

function create_fragment$56(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.8 27a13.146 13.146 0 0 1 3.2-8.411c2.083-2.694 11.733-14.972 11.733-14.972A1 1 0 0 0 28.946 2H1.054a1 1 0 0\n    0-.787 1.617L12 18.589V33.9a.992.992 0 0 0 1.68.825l2.338-2.439A12.131 12.131 0 0 1 14.8 27z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM27 34s-7-5.4-7-8.273a3.818 3.818 0 0 1 3.818-3.818A4.006\n    4.006 0 0 1 27 23.818a4.006 4.006 0 0 1 3.182-1.909A3.818 3.818 0 0 1 34 25.727C34 28.6 27 34 27 34z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$56($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterHeart" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterHeart extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$56, create_fragment$56, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$57(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826 12.267a.5.5 0 0 1 0 .707l-1.752 1.752a.5.5 0 0 1-.707\n    0L27 29.459l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0 0 1 0-.707L24.541 27l-3.367-3.367a.5.5 0 0 1\n    0-.707l1.752-1.752a.5.5 0 0 1 .707 0L27 24.541l3.367-3.367a.5.5 0 0 1 .707 0l1.752 1.752a.5.5 0 0 1 0 .707L29.459\n    27z");
			attr(path1, "d", "M14.8 27a13.146 13.146 0 0 1 3.2-8.411c2.083-2.694 11.733-14.972 11.733-14.972A1 1 0 0 0 28.946 2H1.054a1 1 0 0\n    0-.787 1.617L12 18.589V33.9a.992.992 0 0 0 1.68.825l2.338-2.439A12.131 12.131 0 0 1 14.8 27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$57($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$57, create_fragment$57, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FilterStar.svelte generated by Svelte v3.24.1 */

function create_fragment$58(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.8 27a13.146 13.146 0 0 1 3.2-8.411c2.083-2.694 11.733-14.972 11.733-14.972A1 1 0 0 0 28.946 2H1.054a1 1 0 0\n    0-.787 1.617L12 18.589V33.9a.992.992 0 0 0 1.68.825l2.338-2.439A12.131 12.131 0 0 1 14.8 27z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm6.874 7.083l-3.789 3.037 1.281 4.68a.2.2 0 0 1-.306.222L27\n    30.461l-4.059 2.665a.2.2 0 0 1-.306-.222l1.281-4.684-3.789-3.037a.2.2 0 0 1 .117-.36l4.85-.23 1.718-4.542a.2.2 0 0 1\n    .378 0l1.718 4.542 4.85.23a.2.2 0 0 1 .116.36z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$58($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FilterStar" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FilterStar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$58, create_fragment$58, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FindAndReplace.svelte generated by Svelte v3.24.1 */

function create_fragment$59(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.63 32.628l-6.275-8.385a12.011 12.011 0 1 0-20.63-6.9A6.561 6.561 0 0 0 11 18.623a10.005 10.005 0 1 1 9.087\n    7.313c-.031.019-.058.046-.089.064a12.327 12.327 0 0 1-3.5 1.265 11.988 11.988 0 0 0 9.393-.478l6.275 8.385a2.155\n    2.155 0 0 0 3.466-2.544z");
			attr(path1, "d", "M23.467 15.737a11.152 11.152 0 0 1-5.213 6.974c-5.068 2.8-11.526.878-14.8-4.259l2.415-1.336A8.337 8.337 0 0 0\n    16.752 20a7.605 7.605 0 0 0 3.92-5.1l-3.763-1.125 6.777-3.748 3.828 6.92zM8.556 5.071a6.5 6.5 0 0 1 4.416-1.151\n    13.873 13.873 0 0 1 3.4-1.435 8.915 8.915 0 0 0-9.309.5A8.746 8.746 0 0 0 3.5 9.164L0 8.575l3.8 5.332\n    5.322-3.795L5.9 9.569a6.213 6.213 0 0 1 2.656-4.498z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$59($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FindAndReplace" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FindAndReplace extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$59, create_fragment$59, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Flag.svelte generated by Svelte v3.24.1 */

function create_fragment$5a(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M28.583 5.854a19.038 19.038 0 0 0-4.113.453 1.093 1.093 0 0 1-1.3-1.084V3.609a1.087 1.087 0 0 0-.815-1.061A19.492\n    19.492 0 0 0 17.75 2 19.154 19.154 0 0 0 8 4.648v15.165a19.1 19.1 0 0 1 9.76-2.646 1.1 1.1 0 0 1 1.073\n    1.1v3.739a.991.991 0 0 0 1.406.908 19.279 19.279 0 0 1 12.515-1.435A1.007 1.007 0 0 0 34 20.511V7.4a1 1 0 0\n    0-.751-.98 19.44 19.44 0 0 0-4.666-.566z");
			attr(rect, "height", rect_height_value = 34);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 4);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Flag" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Flag extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5a, create_fragment$5a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlagExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$5b(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M18.667 17.972A12.259 12.259 0 0 1 34 16.893V7.648a1 1 0 0 0-.751-.98 19.491 19.491 0 0 0-4.666-.568 18.988\n    18.988 0 0 0-4.112.454 1.093 1.093 0 0 1-1.3-1.085v-1.61a1.087 1.087 0 0 0-.814-1.06 19.5 19.5 0 0 0-4.6-.548 19.432\n    19.432 0 0 0-9.75 3v15.161a19.374 19.374 0 0 1 9.759-2.995 1.061 1.061 0 0 1 .901.555z");
			attr(rect, "height", rect_height_value = 32);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 4);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlagExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlagExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5b, create_fragment$5b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlashAuto.svelte generated by Svelte v3.24.1 */

function create_fragment$5c(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.001 2h14l-8 12h10l-19.1 22h-.9l6-16H.251l5.75-18zM28.418 16.417c-.026-.134-.054-.161-.189-.161h-3.754c-.107\n    0-.161.081-.161.189a4.132 4.132 0 0 1-.244 1.455l-5.563 15.83c-.028.189.026.27.189.27h2.7a.267.267 0 0 0\n    .3-.216L22.954 30h6.913l1.333 3.838a.272.272 0 0 0 .271.162H34.5c.161 0 .189-.081.161-.243zm-2.052 2.54h.026c.541\n    1.89 2.1 6.481 2.664 8.264h-5.3c.813-2.457 2.178-6.455 2.61-8.264z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlashAuto" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlashAuto extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5c, create_fragment$5c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlashOff.svelte generated by Svelte v3.24.1 */

function create_fragment$5d(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M13.823 20.473L8 36h.9l9.493-10.935-4.57-4.592zM18.26 13.609L26 2H12l-1.286 4.026 7.546 7.583zM23.643 19.019L28\n    14h-9.351l4.994 5.019zM7.976 14.598L6.25 20h7.102l-5.376-5.402z");
			attr(rect, "height", rect_height_value = 43.854);
			attr(rect, "rx", rect_rx_value = 0.818);
			attr(rect, "ry", rect_ry_value = 0.818);
			attr(rect, "transform", "rotate(-45 18 19)");
			attr(rect, "width", rect_width_value = 2.455);
			attr(rect, "x", rect_x_value = 16.773);
			attr(rect, "y", rect_y_value = -2.926);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlashOff" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlashOff extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5d, create_fragment$5d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlashOn.svelte generated by Svelte v3.24.1 */

function create_fragment$5e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12 2h14l-8 12h10L8.9 36H8l6-16H6.25L12 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlashOn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlashOn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5e, create_fragment$5e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Flashlight.svelte generated by Svelte v3.24.1 */

function create_fragment$5f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.306 18.66l5.973-5.974a1 1 0 0 0 0-1.414l-8.524-8.525a1 1 0 0 0-1.414 0L17.367 8.72a1 1 0 0 0-.286.593l-.468\n    4.078L2.746 27.257a1 1 0 0 0 0 1.414l4.61 4.61a1 1 0 0 0 1.414 0l13.866-13.867 4.077-.468a1 1 0 0 0\n    .593-.286zm-10.352.412a2.75 2.75 0 1 1 3.889 0 2.75 2.75 0 0 1-3.889 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Flashlight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Flashlight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5f, create_fragment$5f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlashlightOff.svelte generated by Svelte v3.24.1 */

function create_fragment$5g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.361 18.209l-.84.841L16.95 7.479l.841-.84a.817.817 0 0 1 1.157 0l10.413 10.413a.817.817 0 0 1 0 1.157zM15.317\n    9.13l-.68.717a1.635 1.635 0 0 0-.4 1.072L12.6 18.49 2.183 28.911a.817.817 0 0 0 0 1.157l3.772 3.771a.817.817 0 0 0\n    1.157 0L17.51 23.4l7.571-1.636a1.635 1.635 0 0 0 1.072-.4l.717-.68zm-1.306 14.594l-2.454 2.455a1.228 1.228 0 0\n    1-1.736-1.736l2.455-2.454a1.227 1.227 0 0 1 1.735 1.735z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlashlightOff" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlashlightOff extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5g, create_fragment$5g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlashlightOn.svelte generated by Svelte v3.24.1 */

function create_fragment$5h(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26.9 10.148a1.044 1.044 0 0 1-.738-1.781l3.473-3.477a1.043 1.043 0 1 1 1.475 1.475l-3.477 3.477a1.038 1.038 0 0\n    1-.733.306zM22.663 6.85a1.04 1.04 0 0 1-1.029-1.216l.7-4.162a1.043 1.043 0 1 1 2.057.345l-.7 4.162a1.043 1.043 0 0\n    1-1.028.871zM30.193 14.384a1.043 1.043 0 0 1-.171-2.072l4.162-.695a1.042 1.042 0 1 1 .345 2.056l-4.162.7a.937.937 0\n    0 1-.174.011zM29.361 18.209l-.84.841L16.95 7.479l.841-.84a.817.817 0 0 1 1.157 0l10.413 10.413a.817.817 0 0 1 0\n    1.157zM15.317 9.13l-.68.717a1.635 1.635 0 0 0-.4 1.072L12.6 18.49 2.183 28.911a.817.817 0 0 0 0 1.157l3.772\n    3.771a.817.817 0 0 0 1.157 0L17.51 23.4l7.571-1.636a1.635 1.635 0 0 0 1.072-.4l.717-.68zm-1.306 14.594l-2.454\n    2.455a1.228 1.228 0 0 1-1.736-1.736l2.455-2.454a1.227 1.227 0 0 1 1.735 1.735z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlashlightOn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlashlightOn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5h, create_fragment$5h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlipHorizontal.svelte generated by Svelte v3.24.1 */

function create_fragment$5i(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 16);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 16);
			attr(rect1, "y", rect1_y_value = 6);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 16);
			attr(rect2, "y", rect2_y_value = 10);
			attr(rect3, "height", rect3_height_value = 2);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 16);
			attr(rect3, "y", rect3_y_value = 14);
			attr(rect4, "height", rect4_height_value = 2);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 16);
			attr(rect4, "y", rect4_y_value = 18);
			attr(rect5, "height", rect5_height_value = 2);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 2);
			attr(rect5, "x", rect5_x_value = 16);
			attr(rect5, "y", rect5_y_value = 22);
			attr(rect6, "height", rect6_height_value = 2);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 16);
			attr(rect6, "y", rect6_y_value = 26);
			attr(rect7, "height", rect7_height_value = 2);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 2);
			attr(rect7, "x", rect7_x_value = 16);
			attr(rect7, "y", rect7_y_value = 30);
			attr(path, "d", "M30.276 28.7L20.2 17.8a1.01 1.01 0 0 1 0-1.428L30.276 5.3A1.01 1.01 0 0 1 32 6.012v21.976a1.01 1.01 0 0\n    1-1.724.712zM3.845 8.079l8.168 8.843L3.845 25.9zM3.044 5a1.009 1.009 0 0 0-1.017 1.012v21.976A1.009 1.009 0 0 0\n    3.045 29a.987.987 0 0 0 .706-.3l10.072-11.067a1.01 1.01 0 0 0 0-1.428L3.751 5.3a.989.989 0 0 0-.707-.3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlipHorizontal" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlipHorizontal extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5i, create_fragment$5i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FlipVertical.svelte generated by Svelte v3.24.1 */

function create_fragment$5j(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 16);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 10);
			attr(rect2, "y", rect2_y_value = 16);
			attr(rect3, "height", rect3_height_value = 2);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 14);
			attr(rect3, "y", rect3_y_value = 16);
			attr(rect4, "height", rect4_height_value = 2);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 18);
			attr(rect4, "y", rect4_y_value = 16);
			attr(rect5, "height", rect5_height_value = 2);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 2);
			attr(rect5, "x", rect5_x_value = 22);
			attr(rect5, "y", rect5_y_value = 16);
			attr(rect6, "height", rect6_height_value = 2);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 26);
			attr(rect6, "y", rect6_y_value = 16);
			attr(rect7, "height", rect7_height_value = 2);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 2);
			attr(rect7, "x", rect7_x_value = 30);
			attr(rect7, "y", rect7_y_value = 16);
			attr(path, "d", "M5.3 30.249l10.9-10.072a1.01 1.01 0 0 1 1.428 0L28.7 30.249a1.01 1.01 0 0 1-.714 1.724H6.012a1.01 1.01 0 0\n    1-.712-1.724zM25.921 3.818l-8.843 8.168L8.1 3.818zM29 3.017A1.009 1.009 0 0 0 27.988 2H6.012A1.009 1.009 0 0 0 5\n    3.018a.987.987 0 0 0 .3.706L16.367 13.8a1.01 1.01 0 0 0 1.428 0L28.7 3.724a.989.989 0 0 0 .3-.707z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FlipVertical" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FlipVertical extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5j, create_fragment$5j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Folder.svelte generated by Svelte v3.24.1 */

function create_fragment$5k(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 8l-14.332.008-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zM4\n    6h9.929l3.887 4H4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Folder" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Folder extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5k, create_fragment$5k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Folder2Color.svelte generated by Svelte v3.24.1 */

function create_fragment$5l(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 8l-14.331.008-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0\n    0-1-1zm-1 20H4V10h28z");
			attr(path1, "d", "M4 10h28v18H4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Folder2Color" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Folder2Color extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5l, create_fragment$5l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$5m(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 16a10.95 10.95 0 0 1 7 2.522V9a1 1 0 0 0-1-1l-14.332.008-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0\n    0 0 1 1h13.427A10.969 10.969 0 0 1 27 16zM4 6h9.929l3.887 4H4z");
			attr(path1, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm5.4 10a.5.5 0 0 1-.5.5h-3.4v3.4a.5.5 0 0 1-.5.5h-2a.5.5 0 0\n    1-.5-.5v-3.4h-3.4a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5h3.4v-3.4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v3.4h3.4a.5.5 0 0\n    1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5m, create_fragment$5m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderAddTo.svelte generated by Svelte v3.24.1 */

function create_fragment$5n(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12.064 27.418l8.356-9.076a3.086 3.086 0 0 1 2.213-.961 3.044 3.044 0 0 1 3.041 3.037v.943A13.842 13.842 0 0 1 34\n    25.605V11a1 1 0 0 0-1-1H2v21a1 1 0 0 0 1 1h13.285z");
			attr(path1, "d", "M23.273 23.6v-3.182a.636.636 0 0 0-1.086-.45l-6.86 7.449 6.86 7.449a.636.636 0 0 0 1.086-.45v-3.229a11.687 11.687\n    0 0 1 11.916 4.632.45.45 0 0 0 .811-.26C36 33.638 33.808 23.6 23.273 23.6zM16 8H2V5.5A1.5 1.5 0 0 1 3.5 4h7.672a2 2\n    0 0 1 1.414.586z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderAddTo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderAddTo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5n, create_fragment$5n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderArchive.svelte generated by Svelte v3.24.1 */

function create_fragment$5o(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14 23.828A3 3 0 0 1 12 21v-2a3 3 0 0 1 3-3h19v-5a1 1 0 0 0-1-1H2v21a1 1 0 0 0 1 1h11z");
			attr(path1, "d", "M35 22H15a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h20a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1zm-1 2v11a1 1 0 0 1-1 1H17a1 1 0 0\n    1-1-1V24zm-6 6v-1a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1zM16 6H2V3.5A1.5 1.5 0 0 1 3.5\n    2h7.672a2 2 0 0 1 1.414.586z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderArchive" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderArchive extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5o, create_fragment$5o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderDelete.svelte generated by Svelte v3.24.1 */

function create_fragment$5p(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27A12.293 12.293 0 0 1 34 16.893V9a1 1 0 0 0-1-1H2v21a1 1 0 0 0 1 1h12.084a12.251 12.251 0 0 1-.384-3z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5zM16 6H2V3.5A1.5 1.5 0 0 1 3.5 2h7.672a2 2 0 0 1 1.414.586z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderDelete" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderDelete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5p, create_fragment$5p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderGear.svelte generated by Svelte v3.24.1 */

function create_fragment$5q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27A12.293 12.293 0 0 1 34 16.893V9a1 1 0 0 0-1-1H2v21a1 1 0 0 0 1 1h12.084a12.251 12.251 0 0 1-.384-3z");
			attr(path1, "d", "M35.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.145 6.145 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.145\n    6.145 0 0 0-2.178.9l-1.513-1.513a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.513a6.142 6.142 0 0\n    0-.9 2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.131a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM27 30.164A3.164 3.164 0 1 1 30.164 27 3.164 3.164 0 0 1 27 30.164zM16\n    6H2V3.5A1.5 1.5 0 0 1 3.5 2h7.672a2 2 0 0 1 1.414.586z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderGear" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderGear extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5q, create_fragment$5q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderLocked.svelte generated by Svelte v3.24.1 */

function create_fragment$5r(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 25.012a3.007 3.007 0 0 1 2.141-2.875A8.954 8.954 0 0 1 27.047 14c.158 0 .318 0 .477.012A8.754 8.754 0 0 1 34\n    17.486V9a1 1 0 0 0-1-1H2v21a1 1 0 0 0 1 1h13zM16 6H2V3.5A1.5 1.5 0 0 1 3.5 2h7.672a2 2 0 0 1 1.414.586z");
			attr(path1, "d", "M35 24h-.955v-1.008a7 7 0 0 0-14 0V24H19a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V25a1 1 0 0 0-1-1zm-6.566\n    7.422v1.928a.694.694 0 0 1-.694.694h-1.388a.694.694 0 0 1-.694-.694v-1.928a2.082 2.082 0 1 1 2.776 0zM31.545\n    24h-9v-1.008a4.5 4.5 0 0 1 9 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderLocked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderLocked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5r, create_fragment$5r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderOpen.svelte generated by Svelte v3.24.1 */

function create_fragment$5s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 14V9a1 1 0 0 0-1-1l-12.332.008-3.3-3.4A2 2 0 0 0 11.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h26.307a1 1 0 0 0\n    .936-.649l5.25-14A1 1 0 0 0 34.557 14zM4 6h7.929l3.305 3.4.59.607h.845L28 10v4H8.693a1 1 0 0 0-.936.649L4 24.667z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderOpen" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderOpen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5s, create_fragment$5s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderOpenOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$5t(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M8.69 14h24.535l-4.666 14H4zm5.239-10H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h26.279a1 1 0 0 0 .949-.684l5.333-16A1 1 0\n    0 0 34.613 12H32V9a1 1 0 0 0-1-1l-12.332.007-3.3-3.4A2 2 0 0 0 13.929 4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderOpenOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderOpenOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5t, create_fragment$5t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$5u(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 8l-14.331.008-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0\n    0-1-1zm-1 20H4V10h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5u, create_fragment$5u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$5v(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 6H2V3.5A1.5 1.5 0 0 1 3.5 2h7.672a2 2 0 0 1 1.414.586zM14.7 27A12.3 12.3 0 0 1 34 16.886V9a1 1 0 0\n    0-1-1H2v21a1 1 0 0 0 1 1h12.069a12.3 12.3 0 0 1-.369-3z");
			attr(path1, "d", "M27.1 18.2a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826 12.267a.5.5 0 0 1 0 .707l-1.752 1.752a.5.5 0 0\n    1-.707 0L27.1 29.559l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0 0 1 0-.707l3.367-3.367-3.367-3.367a.5.5 0 0\n    1 0-.707l1.752-1.752a.5.5 0 0 1 .707 0l3.367 3.367 3.367-3.367a.5.5 0 0 1 .707 0l1.752 1.752a.5.5 0 0 1 0\n    .707L29.559 27.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5v, create_fragment$5v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderSearch.svelte generated by Svelte v3.24.1 */

function create_fragment$5w(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 6H2V3.5A1.5 1.5 0 0 1 3.5 2h7.672a2 2 0 0 1 1.414.586zM11.223 22.734A11.58 11.58 0 0 1 34 19.779V9a1 1 0 0\n    0-1-1H2v21a1 1 0 0 0 1 1h10.793a11.526 11.526 0 0 1-2.57-7.266z");
			attr(path1, "d", "M35.385 32.269l-4.917-4.917a9.065 9.065 0 1 0-3.049 3.048l4.917 4.917a2.044 2.044 0 0 0 3.048 0 2.2 2.2 0 0 0\n    .001-3.048zm-18.15-9.534A5.568 5.568 0 1 1 22.8 28.3a5.568 5.568 0 0 1-5.566-5.565z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderSearch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderSearch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5w, create_fragment$5w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderUser.svelte generated by Svelte v3.24.1 */

function create_fragment$5x(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 6H2V3.5A1.5 1.5 0 0 1 3.5 2h7.672a2 2 0 0 1 1.414.586zM28.677 28.542v-1.4a.966.966 0 0 1 .246-.623 7.366\n    7.366 0 0 0 1.675-4.6c0-3.479-1.845-5.424-4.633-5.424s-4.686 2.021-4.686 5.424a7.447 7.447 0 0 0 1.756 4.6.965.965 0\n    0 1 .246.623v1.389a.958.958 0 0 1-.836.967c-5.6.487-6.439 4.319-6.439 5.83L16\n    36h20v-.667c0-1.448-.989-5.266-6.49-5.825a.963.963 0 0 1-.833-.966z");
			attr(path1, "d", "M19.689 26.959a10.321 10.321 0 0 1-1.41-5.031c0-4.959 3.16-8.424 7.686-8.424 4.564 0 7.633 3.385 7.633\n    8.424a10.492 10.492 0 0 1-1.361 5.059 10.683 10.683 0 0 1 1.763.692V9a1 1 0 0 0-1-1H2v21a1 1 0 0 0 1 1h11.971a9.048\n    9.048 0 0 1 4.718-3.041z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FolderUser" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FolderUser extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5x, create_fragment$5x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Follow.svelte generated by Svelte v3.24.1 */

function create_fragment$5y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14.088 28.9l-.758.1a2.9 2.9 0 0 1-3.252-2.506l-.3-2.725 6.516-.845.3 2.725a2.9 2.9 0 0 1-2.506 3.251zM11.945\n    1.338C10.27-.615 8.4-.8 7.073 3.308c-1.96 8.7-.44 12.21 2.322 17.92l6.516-.845c-.7-5.394.644-7.815.362-9.986a17.567\n    17.567 0 0 0-4.328-9.059zM21.373 35.832l.754.127a2.9 2.9 0 0 0 3.346-2.38l.4-2.659-6.473-1.093-.4 2.659a2.9 2.9 0 0\n    0 2.373 3.346zm3.2-27.462c1.749-1.888 3.628-2 4.794 2.155 1.626 8.767-.027 12.218-3.006\n    17.818l-6.485-1.093c.9-5.363-.344-7.834.02-9.992a17.569 17.569 0 0 1 4.672-8.888z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Follow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Follow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5y, create_fragment$5y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FollowOff.svelte generated by Svelte v3.24.1 */

function create_fragment$5z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M7.9 28.9l-.758.1a2.9 2.9 0 0 1-3.252-2.506l-.3-2.725 6.516-.845.3 2.725A2.9 2.9 0 0 1 7.9 28.9zM5.759\n    1.338C4.083-.615 2.21-.8.886 3.308c-1.96 8.7-.44 12.21 2.323 17.92l6.516-.845c-.7-5.394.643-7.815.362-9.986a17.569\n    17.569 0 0 0-4.328-9.059zM13.689 27.25l1.019.171c0-.14-.008-.28-.008-.421a12.305 12.305 0 0 1 9.067-11.87 37.439\n    37.439 0 0 0-.593-4.6c-1.164-4.16-3.043-4.048-4.792-2.16a17.564 17.564 0 0 0-4.672 8.888c-.364 2.158.885 4.629-.021\n    9.992zM15.107 30.147l-1.9-.32-.4 2.659a2.9 2.9 0 0 0 2.38 3.346l.754.127a2.894 2.894 0 0 0 2.146-.483 12.278 12.278\n    0 0 1-2.98-5.329z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FollowOff" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FollowOff extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5z, create_fragment$5z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ForPlacementOnly.svelte generated by Svelte v3.24.1 */

function create_fragment$5A(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16.484 14.181c-.3 0-.578.006-.793.014v3.311h.6c2.2 0 2.2-1.285\n    2.2-1.707-.001-1.337-1.091-1.618-2.007-1.618zM27.357 14.078c-1.586 0-2.531 1.365-2.531 3.654 0 1.793.687 3.707 2.617\n    3.707 1.562 0 2.5-1.385 2.5-3.707-.019-2.322-.961-3.654-2.586-3.654z");
			attr(path1, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-5.982\n    12.093l-.119.145-.3.033H7.332v2.307h4.2l.123.523v1.979l-.523.123h-3.8v4.547l-.541.141H4.6l-.105-.541v-11.6l.523-.121h6.389a.526.526\n    0 0 1 .555.475l.176 1.756zm4.273 6.023c-.271\n    0-.443-.006-.6-.012v3.662l-.523.123h-2.174l-.121-.524v-11.58l.506-.141c.871-.023 1.961-.053 3.035-.053 3.609 0 4.895\n    2.156 4.895 4.174 0 2.684-1.924 4.352-5.018 4.352zm11.082 3.932c-3.314 0-5.455-2.481-5.455-6.316 0-3.688 2.25-6.264\n    5.473-6.264 3.244 0 5.438 2.5 5.457 6.209 0 3.871-2.148 6.371-5.475 6.371z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ForPlacementOnly" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ForPlacementOnly extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5A, create_fragment$5A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Forecast.svelte generated by Svelte v3.24.1 */

function create_fragment$5B(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M28.971 34H7a1.117 1.117 0 0 1-.953-1.477L7.879 26h20.214l1.831 6.523A1.117 1.117 0 0 1 28.971 34zM32.85\n    2.676l-2.073 2.463a2.623 2.623 0 0 0-.477 2.526l1.027 3.051-2.466-2.073a2.623 2.623 0 0 0-2.525-.479L23.284\n    9.19l2.073-2.463a2.623 2.623 0 0 0 .48-2.527L24.81 1.15l2.463 2.073A2.623 2.623 0 0 0 29.8 3.7z");
			attr(path1, "d", "M29.135 13.316l-2.129-1.791-2.637.887A3.4 3.4 0 0 1 20.684 7l1.791-2.129-.415-1.233A12.352 12.352 0 0 0 9\n    24h17.291A12.316 12.316 0 0 0 30 15.176a12.576 12.576 0 0 0-.075-1.363 3.416 3.416 0 0 1-.79-.497z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Forecast" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Forecast extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5B, create_fragment$5B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Form.svelte generated by Svelte v3.24.1 */

function create_fragment$5C(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.354);
			attr(rect0, "ry", rect0_ry_value = 0.354);
			attr(rect0, "width", rect0_width_value = 32);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 6);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.354);
			attr(rect1, "ry", rect1_ry_value = 0.354);
			attr(rect1, "width", rect1_width_value = 32);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 14);
			attr(path, "d", "M32 24v6H4v-6zm1.5-2h-31a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h31a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Form" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Form extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5C, create_fragment$5C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Forward.svelte generated by Svelte v3.24.1 */

function create_fragment$5D(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26 10V5.207a.5.5 0 0 1 .854-.354L36 14l-9.146 9.146a.5.5 0 0 1-.854-.353V18H10v13a1 1 0 0 1-1 1H3a1 1 0 0\n    1-1-1V16a6 6 0 0 1 6-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Forward" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Forward extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5D, create_fragment$5D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FullScreen.svelte generated by Svelte v3.24.1 */

function create_fragment$5E(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M32 24.5V30h-5.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H34v-7.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5zM4 30v-5.5a.5.5 0\n    0 0-.5-.5h-1a.5.5 0 0 0-.5.5V32h7.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM26 4.5v1a.5.5 0 0 0 .5.5H32v5.5a.5.5 0 0 0\n    .5.5h1a.5.5 0 0 0 .5-.5V4h-7.5a.5.5 0 0 0-.5.5zM4 6h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H2v7.5a.5.5 0 0 0\n    .5.5h1a.5.5 0 0 0 .5-.5z");
			attr(rect, "height", rect_height_value = 16);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 20);
			attr(rect, "x", rect_x_value = 8);
			attr(rect, "y", rect_y_value = 10);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FullScreen" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FullScreen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5E, create_fragment$5E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/FullScreenExit.svelte generated by Svelte v3.24.1 */

function create_fragment$5F(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M6 2.5V8H.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H8V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5zM30 8V2.5a.5.5 0 0\n    0-.5-.5h-1a.5.5 0 0 0-.5.5V10h7.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM0 26.5v1a.5.5 0 0 0 .5.5H6v5.5a.5.5 0 0 0\n    .5.5h1a.5.5 0 0 0 .5-.5V26H.5a.5.5 0 0 0-.5.5zM30 28h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H28v7.5a.5.5 0 0 0\n    .5.5h1a.5.5 0 0 0 .5-.5z");
			attr(rect, "height", rect_height_value = 16);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 20);
			attr(rect, "x", rect_x_value = 8);
			attr(rect, "y", rect_y_value = 10);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FullScreenExit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FullScreenExit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5F, create_fragment$5F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Function.svelte generated by Svelte v3.24.1 */

function create_fragment$5G(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.424 33.412a7.348 7.348 0 0 1-3.283-.712c-.118-.057-.18-.087-.137-.412l.457-3.96a8.417 8.417 0 0 0\n    3.006.628c2.441 0 3.111-1.769 3.689-5.729l.038-.281a14.007 14.007 0 0 0\n    .189-1.662c.02-.383.163-2.374.163-2.374H4.892l.949-2.915a.481.481 0 0 1\n    .459-.334h4.508s.263-2.887.423-3.979l.161-1.138C12.325 3.789 15.126.508 19.955.508A5.609 5.609 0 0 1\n    22.46.95a.294.294 0 0 1 .23.333l-.546 3.723c-.031.192-.1.192-.123.192a6.326 6.326 0 0 0-2.2-.408c-3.058 0-3.768\n    3.149-4.325 6.953l-.129.929c-.1.7-.281 2.987-.281 2.987h5.962l-.948 2.916a.484.484 0 0 1-.459.333h-4.8s-.13\n    2.092-.141 2.426a17.241 17.241 0 0 1-.258 2.231c-.727 5.114-2.201 9.847-8.018 9.847zm23.734.442a318.25 318.25 0 0\n    1-3.751-5.657c.946-1.351 2.644-4.062 3.476-5.388l.046-.075a.374.374 0 0 0 .023-.39.385.385 0 0\n    0-.36-.18h-2.53a.419.419 0 0 0-.431.246l-2.192 3.834-2.071-3.773a.486.486 0 0 0-.511-.307h-2.864a.393.393 0 0\n    0-.372.207.388.388 0 0 0 .046.4l3.488 5.56c-.561.83-1.285 1.953-1.986 3.041-.586.91-1.155 1.795-1.594 2.451a.383.383\n    0 0 0-.035.4.4.4 0 0 0 .356.213h2.557a.475.475 0 0 0 .478-.268l2.253-3.85 2.186 3.8a.592.592 0 0 0\n    .526.313h2.935a.39.39 0 0 0 .394-.223.328.328 0 0 0-.067-.354z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Function" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Function extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5G, create_fragment$5G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Game.svelte generated by Svelte v3.24.1 */

function create_fragment$5H(ctx) {
	let svg;
	let path;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr(path, "d", "M35.091 24.854L32.562 16.4c-1.727-5.765-6.574-10.38-12.033-10.38h-5.821C9.248 6.02 4.4 10.635 2.675 16.4l-2.53\n    8.454c-.727 2.427 1.4 4.708 3.551 3.81l1.61-1.294a19.328 19.328 0 0 1 24.624 0l1.61 1.294c2.152.898 4.278-1.383\n    3.551-3.81zm-23.81-4.085a5 5 0 1 1 5-5 5 5 0 0 1-5 5zM23.114 16.2a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5zM28.5\n    23a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z");
			attr(circle, "cx", circle_cx_value = 11.281);
			attr(circle, "cy", circle_cy_value = 15.769);
			attr(circle, "r", circle_r_value = 2.5);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Game" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Game extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5H, create_fragment$5H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gauge1.svelte generated by Svelte v3.24.1 */

function create_fragment$5I(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33.965 18.754A16 16 0 0 0 2 19.813c0 .072.013.142.014.214l3.02-.327a12.126 12.126 0 0 1 .344-2.892 13.2 13.2 0 0\n    1 13.17-9.984A13.016 13.016 0 0 1 31 19.813a12.878 12.878 0 0 1-.691 4.117.492.492 0 0 0 .116.506L31.987 26a.5.5 0 0\n    0 .818-.154 15.842 15.842 0 0 0 1.16-7.092z");
			attr(path1, "d", "M.846 23.214a.691.691 0 0 0 0 1.368L17.814 27.1a3.219 3.219 0 0 0 3.775-3.166 3.219 3.219 0 0 0-3.766-3.177z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gauge1" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gauge1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5I, create_fragment$5I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gauge2.svelte generated by Svelte v3.24.1 */

function create_fragment$5J(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.7 13.613l-1.535-3.326A15.912 15.912 0 0 0 2 19.813a13.828 13.828 0 0 0 1.394 5.867.5.5 0 0 0\n    .806.133l1.375-1.376a.491.491 0 0 0 .116-.508 12.467 12.467 0 0 1-.313-7.12A13.137 13.137 0 0 1 6.7 13.613zm27.263\n    5.141a16.133 16.133 0 0 0-15.4-14.932 15.939 15.939 0 0 0-7.222 1.459l1.986 2.49a12.562 12.562 0 0 1\n    5.22-.947A13.016 13.016 0 0 1 31 19.813a12.878 12.878 0 0 1-.691 4.117.492.492 0 0 0 .116.506L31.987 26a.5.5 0 0 0\n    .818-.154 15.842 15.842 0 0 0 1.16-7.092zM9.01 7.089a.867.867 0 0 0-1.483.874l7.711 17.643a3.219 3.219 0 0 0 4.646\n    1.639 3.219 3.219 0 0 0 .819-4.858z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gauge2" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gauge2 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5J, create_fragment$5J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gauge3.svelte generated by Svelte v3.24.1 */

function create_fragment$5K(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.861 4.763a.867.867 0 0 0-1.722 0l-2.31 19.116A3.219 3.219 0 0 0 18 27.649a3.219 3.219 0 0 0\n    3.171-3.77zM33.965 18.754A16.163 16.163 0 0 0 21.816 4.292c.006.037.019.071.023.109l.377 3.116A13.022 13.022 0 0 1\n    31 19.813a12.878 12.878 0 0 1-.691 4.117.492.492 0 0 0 .116.506L31.987 26a.5.5 0 0 0 .818-.154 15.842 15.842 0 0 0\n    1.16-7.092zM2 19.813a13.828 13.828 0 0 0 1.394 5.867.5.5 0 0 0 .806.133l1.375-1.376a.491.491 0 0 0 .116-.508 12.465\n    12.465 0 0 1-.313-7.12 13.334 13.334 0 0 1 8.4-9.227L14.16 4.4c0-.039.019-.074.024-.113A15.993 15.993 0 0 0 2\n    19.813z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gauge3" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gauge3 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5K, create_fragment$5K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gauge4.svelte generated by Svelte v3.24.1 */

function create_fragment$5L(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.3 13.613l1.537-3.326A15.912 15.912 0 0 1 34 19.813a13.828 13.828 0 0 1-1.394 5.867.5.5 0 0\n    1-.806.133l-1.375-1.376a.491.491 0 0 1-.116-.508 12.467 12.467 0 0 0 .313-7.12 13.137 13.137 0 0\n    0-1.322-3.196zM2.035 18.754a16.133 16.133 0 0 1 15.4-14.932 15.939 15.939 0 0 1 7.222 1.459l-1.986 2.49a12.562\n    12.562 0 0 0-5.22-.947A13.016 13.016 0 0 0 5 19.813a12.878 12.878 0 0 0 .691 4.117.492.492 0 0 1-.116.506L4.013\n    26a.5.5 0 0 1-.818-.154 15.842 15.842 0 0 1-1.16-7.092zM26.99 7.089a.867.867 0 0 1 1.483.874l-7.71 17.643a3.219\n    3.219 0 0 1-4.646 1.639 3.219 3.219 0 0 1-.819-4.858z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gauge4" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gauge4 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5L, create_fragment$5L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gauge5.svelte generated by Svelte v3.24.1 */

function create_fragment$5M(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M2.035 18.754A16 16 0 0 1 34 19.813c0 .072-.013.142-.014.214l-3.02-.327a12.126 12.126 0 0 0-.344-2.892 13.2 13.2\n    0 0 0-13.17-9.984A13.016 13.016 0 0 0 5 19.813a12.878 12.878 0 0 0 .691 4.117.492.492 0 0 1-.116.506L4.013 26a.5.5 0\n    0 1-.818-.154 15.842 15.842 0 0 1-1.16-7.092z");
			attr(path1, "d", "M35.154 23.214a.691.691 0 0 1 0 1.368L18.186 27.1a3.219 3.219 0 0 1-3.775-3.166 3.219 3.219 0 0 1 3.766-3.177z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gauge5" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gauge5 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5M, create_fragment$5M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gears.svelte generated by Svelte v3.24.1 */

function create_fragment$5N(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M17.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.145 6.145 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607H8.393a.607.607 0 0 0-.607.607v2.125a6.145\n    6.145 0 0 0-2.178.9l-1.513-1.516a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.514a6.142 6.142 0 0\n    0-.9 2.179H.807a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.516\n    1.512a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.514-1.514a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.127a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.513-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM9 30.164A3.164 3.164 0 1 1 12.164 27 3.164 3.164 0 0 1 9 30.164zM35.362\n    14.906l-2.8-1.143a8.757 8.757 0 0 0-.012-3.357l2.81-1.182a.865.865 0 0 0 .462-1.132L35.1 6.383a.864.864 0 0\n    0-1.132-.462L31.157 7.1a8.761 8.761 0 0 0-2.391-2.356l1.143-2.8a.865.865 0 0 0-.474-1.127l-1.6-.653a.865.865 0 0\n    0-1.127.474l-1.143 2.8a8.761 8.761 0 0 0-3.357.012L21.024.644a.864.864 0 0 0-1.132-.462L18.183.9a.865.865 0 0 0-.462\n    1.132L18.9 4.843a8.753 8.753 0 0 0-2.356 2.392l-2.8-1.143a.865.865 0 0 0-1.127.474l-.653 1.6a.865.865 0 0 0 .474\n    1.127l2.8 1.143a8.757 8.757 0 0 0 .012 3.357l-2.81 1.182a.865.865 0 0 0-.462 1.132l.719 1.708a.864.864 0 0 0\n    1.132.462l2.81-1.182a8.761 8.761 0 0 0 2.392 2.356l-1.143 2.8a.865.865 0 0 0 .474 1.127l1.6.653a.865.865 0 0 0\n    1.127-.474l1.143-2.8a8.755 8.755 0 0 0 3.357-.012l1.182 2.81a.864.864 0 0 0 1.132.462l1.709-.719a.865.865 0 0 0\n    .462-1.132L28.9 19.357a8.752 8.752 0 0 0 2.356-2.391l2.8 1.143a.864.864 0 0 0 1.127-.474l.653-1.6a.865.865 0 0\n    0-.474-1.129zM23.9 16.288a4.188 4.188 0 1 1 4.188-4.188 4.188 4.188 0 0 1-4.188 4.188z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gears" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gears extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5N, create_fragment$5N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GearsAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$5O(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.17 30.392a6.142 6.142 0 0 0 .9-2.179h.8a10.742 10.742 0 0 1 0-2.428h-.8a6.141 6.141 0 0\n    0-.9-2.179l1.513-1.513a.606.606 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858 0l-1.513 1.513a6.147 6.147 0 0\n    0-2.178-.9v-2.121a.607.607 0 0 0-.607-.607H8.393a.607.607 0 0 0-.607.607v2.125a6.147 6.147 0 0\n    0-2.178.9l-1.513-1.516a.607.607 0 0 0-.858 0l-.92.92a.606.606 0 0 0 0 .858l1.513 1.514a6.141 6.141 0 0 0-.9\n    2.179H.807a.606.606 0 0 0-.606.607v1.214a.607.607 0 0 0 .606.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.516\n    1.512a.606.606 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.514-1.514a6.146 6.146 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.127a6.146 6.146 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.606.606 0 0 0 0-.858zM9 30.164A3.164 3.164 0 1 1 12.164 27 3.164 3.164 0 0 1 9 30.164zM18.871\n    19.319a11.206 11.206 0 0 1 4.911-3.043 4.192 4.192 0 1 1 1.88-.389 10.976 10.976 0 0 1 7.8 1.978l.6.243a.864.864 0 0\n    0 1.127-.474l.653-1.6a.865.865 0 0 0-.474-1.127l-2.8-1.143a8.749 8.749 0 0 0-.012-3.357l2.811-1.182a.865.865 0 0 0\n    .462-1.132l-.729-1.71a.865.865 0 0 0-1.132-.462L31.157 7.1a8.762 8.762 0 0 0-2.392-2.356l1.143-2.8a.864.864 0 0\n    0-.473-1.127l-1.6-.653a.865.865 0 0 0-1.127.474l-1.143 2.8a8.763 8.763 0 0 0-3.357.012L21.024.644a.865.865 0 0\n    0-1.132-.462L18.183.9a.865.865 0 0 0-.462 1.132L18.9 4.843a8.756 8.756 0 0 0-2.356 2.392l-2.8-1.143a.864.864 0 0\n    0-1.127.474l-.653 1.6a.865.865 0 0 0 .474 1.127l2.8 1.143a8.761 8.761 0 0 0 .012 3.357l-2.811 1.182a.865.865 0 0\n    0-.461 1.132l.719 1.708a.864.864 0 0 0 1.132.462l2.81-1.182a8.783 8.783 0 0 0 2.232 2.224z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GearsAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GearsAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5O, create_fragment$5O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GearsDelete.svelte generated by Svelte v3.24.1 */

function create_fragment$5P(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.17 30.392a6.142 6.142 0 0 0 .9-2.179h.8a10.742 10.742 0 0 1 0-2.428h-.8a6.141 6.141 0 0\n    0-.9-2.179l1.513-1.513a.606.606 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858 0l-1.513 1.513a6.147 6.147 0 0\n    0-2.178-.9v-2.121a.607.607 0 0 0-.607-.607H8.393a.607.607 0 0 0-.607.607v2.125a6.147 6.147 0 0\n    0-2.178.9l-1.513-1.516a.607.607 0 0 0-.858 0l-.92.92a.606.606 0 0 0 0 .858l1.513 1.514a6.141 6.141 0 0 0-.9\n    2.179H.807a.606.606 0 0 0-.606.607v1.214a.607.607 0 0 0 .606.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.516\n    1.512a.606.606 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.514-1.514a6.146 6.146 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.127a6.146 6.146 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.606.606 0 0 0 0-.858zM9 30.164A3.164 3.164 0 1 1 12.164 27 3.164 3.164 0 0 1 9 30.164zM18.871\n    19.319a11.206 11.206 0 0 1 4.911-3.043 4.192 4.192 0 1 1 1.88-.389 10.976 10.976 0 0 1 7.8 1.978l.6.243a.864.864 0 0\n    0 1.127-.474l.653-1.6a.865.865 0 0 0-.474-1.127l-2.8-1.143a8.749 8.749 0 0 0-.012-3.357l2.811-1.182a.865.865 0 0 0\n    .462-1.132l-.729-1.71a.865.865 0 0 0-1.132-.462L31.157 7.1a8.762 8.762 0 0 0-2.392-2.356l1.143-2.8a.864.864 0 0\n    0-.473-1.127l-1.6-.653a.865.865 0 0 0-1.127.474l-1.143 2.8a8.763 8.763 0 0 0-3.357.012L21.024.644a.865.865 0 0\n    0-1.132-.462L18.183.9a.865.865 0 0 0-.462 1.132L18.9 4.843a8.756 8.756 0 0 0-2.356 2.392l-2.8-1.143a.864.864 0 0\n    0-1.127.474l-.653 1.6a.865.865 0 0 0 .474 1.127l2.8 1.143a8.761 8.761 0 0 0 .012 3.357l-2.811 1.182a.865.865 0 0\n    0-.461 1.132l.719 1.708a.864.864 0 0 0 1.132.462l2.81-1.182a8.783 8.783 0 0 0 2.232 2.224z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GearsDelete" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GearsDelete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5P, create_fragment$5P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GearsEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$5Q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.193 25.786h-2.125a6.142 6.142 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.145 6.145 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607H8.393a.607.607 0 0 0-.607.607v2.125a6.145\n    6.145 0 0 0-2.178.9l-1.513-1.516a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.514a6.142 6.142 0 0\n    0-.9 2.179H.807a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.516\n    1.512a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.514-1.514a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.127a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.513-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM9 30.164A3.164 3.164 0 1 1 12.164 27 3.164 3.164 0 0 1 9 30.164zM19.967\n    24.036a.865.865 0 0 0 1.127-.474l1.144-2.8a8.691 8.691 0 0 0 3 .025l4.188-4.188a3.221 3.221 0 0 1\n    2.187-.949h.1a3.119 3.119 0 0 1 2.224.918l1.182 1.181a.806.806 0 0 0 .072-.108l.653-1.6a.865.865 0 0\n    0-.474-1.127l-2.8-1.143a8.749 8.749 0 0 0-.012-3.357l2.811-1.182a.865.865 0 0 0 .462-1.132L35.1 6.383a.865.865 0 0\n    0-1.132-.462L31.157 7.1a8.762 8.762 0 0 0-2.392-2.356l1.143-2.8a.864.864 0 0 0-.473-1.127l-1.6-.653a.865.865 0 0\n    0-1.127.474l-1.143 2.8a8.763 8.763 0 0 0-3.357.012L21.024.644a.865.865 0 0 0-1.132-.462L18.183.9a.865.865 0 0 0-.462\n    1.132L18.9 4.843a8.756 8.756 0 0 0-2.356 2.392l-2.8-1.143a.864.864 0 0 0-1.127.474l-.653 1.6a.865.865 0 0 0 .474\n    1.127l2.8 1.143a8.761 8.761 0 0 0 .012 3.357l-2.811 1.182a.865.865 0 0 0-.461 1.132l.719 1.708a.864.864 0 0 0\n    1.132.462l2.81-1.182a8.758 8.758 0 0 0 2.392 2.356l-1.143 2.8a.865.865 0 0 0 .474 1.127zM23.9 7.912a4.188 4.188 0 1\n    1-4.188 4.188A4.188 4.188 0 0 1 23.9 7.912z");
			attr(path1, "d", "M35.738 21.764l-3.506-3.506a.739.739 0 0 0-.527-.215h-.023a.834.834 0 0 0-.564.247L20.3 29.113a.611.611 0 0\n    0-.153.256l-2.027 6c-.069.229.279.517.477.517a.284.284 0 0 0 .037 0c.168-.039 5.123-1.764 6-2.028a.591.591 0 0 0\n    .252-.152l10.82-10.828a.834.834 0 0 0 .246-.537.742.742 0 0 0-.214-.577zM19.7 34.3l1.56-4.431 2.871\n    2.863c-1.309.391-3.29 1.225-4.431 1.568z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GearsEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GearsEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5Q, create_fragment$5Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GenderFemale.svelte generated by Svelte v3.24.1 */

function create_fragment$5R(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 3.685);
			attr(circle, "r", circle_r_value = 3.685);
			attr(path, "d", "M12.861 13.247l.518 6.039-4.108 7.068a.558.558 0 0 0 .537.712h4.215l1.654 8.485a.555.555 0 0 0\n    .545.449h3.557a.555.555 0 0 0 .545-.449l1.654-8.485h4.215a.558.558 0 0 0 .537-.712l-4.07-7.068.487-6.056a3.873 3.873\n    0 0 0-1.829-3.745A3.933 3.933 0 0 0 19.421 9h-2.842a3.934 3.934 0 0 0-1.89.482 3.87 3.87 0 0 0-1.828 3.765z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GenderFemale" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GenderFemale extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5R, create_fragment$5R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GenderMale.svelte generated by Svelte v3.24.1 */

function create_fragment$5S(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 17.25);
			attr(circle, "cy", circle_cy_value = 3.948);
			attr(circle, "r", circle_r_value = 3.948);
			attr(path, "d", "M17.475 9h-.45c-3.6 0-6.525 1.814-6.525 5.453v9.413a.562.562 0 0 0 .563.563h2.186L14.28 35.51a.563.563 0 0 0\n    .558.49h4.812a.562.562 0 0 0 .558-.489l1.038-11.082h2.192a.562.562 0 0 0 .562-.563v-9.413C24 10.814 21.079 9 17.475\n    9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GenderMale" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GenderMale extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5S, create_fragment$5S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gift.svelte generated by Svelte v3.24.1 */

function create_fragment$5T(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 33a1 1 0 0 0 1 1h13V20H2zM0 13v4a1 1 0 0 0 1 1h15v-6H1a1 1 0 0 0-1 1zm20 21h13a1 1 0 0 0\n    1-1V20H20zm15-22H20v6h15a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1zM26 2c-1.81 0-5.638 1.39-8 5.172C15.638 3.39 11.81 2 10 2a4\n    4 0 0 0 0 8h16a4 4 0 0 0 0-8zM10 8a2 2 0 0 1 0-4 8.734 8.734 0 0 1 6.2 4zm16 0h-6.2A8.734 8.734 0 0 1 26 4a2 2 0 0 1\n    0 4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gift" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gift extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5T, create_fragment$5T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Globe.svelte generated by Svelte v3.24.1 */

function create_fragment$5U(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M7.146 13.769C6.1 9.982 8.8 8.352 8.534 5.116A16.072 16.072 0 0 0 2 18c0 9.112 7.943 14.542 13.554 15.731a6.853\n    6.853 0 0 0 1.046.169c2-5.1-1.773-10.789-4.263-14.494-2.075-3.088-3.959-1.18-5.191-5.637z");
			attr(path1, "d", "M32.781 19.031c-1.611-.613-2.992 1.475-3.114-4.164a5.763 5.763 0 0 1 1.666-4 3.083 3.083 0 0 1\n    .729-.349c-.191-.349-.4-.684-.62-1.018-.037.02-.07.045-.109.062-1.25.584-1.423.756-2 0a1.576 1.576 0 0 1 .346-2.325\n    15.987 15.987 0 0 0-11.653-5.222c2.028.028 4.447 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889\n    1.36-2.639a16.094 16.094 0 0 0-6.615 1.423c1.093.707 2.311.46 3.543.764a3.014 3.014 0 0 1 1.1.452 3.735 3.735 0 0\n    0-1.1-.452c-1.817-.21.88 4.778.778 4.114.5-2.292 3.612-3.176 4.566-.147a3.742 3.742 0 0 1-.838 2.265c-1.41 1.854-1.7\n    5.154-2.4 4.31-6.59-2.7-5.865.871-3.7 3.258 3.464 3.82 1.706.391 6.242 2.392 3.648 1.608 8.039 1.989 6.968 3.2-3.242\n    3.67-2.56 6.1-8.293 10.4.477-.013 2-.165 2.311-.216a16.275 16.275 0 0 0 13.375-14.4 2.4 2.4 0 0 1-1.155-.347z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Globe" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Globe extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5U, create_fragment$5U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$5V(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27a12.316 12.316 0 0 1 .408-3.1 50.148 50.148 0 0 0-2.772-4.5c-2.073-3.086-3.958-1.178-5.19-5.636C6.1 9.982\n    8.8 8.352 8.534 5.116A16.073 16.073 0 0 0 2 18c0 9.112 7.943 14.542 13.554 15.732a6.889 6.889 0 0 0\n    1.046.168c.03-.077.047-.155.075-.232A12.226 12.226 0 0 1 14.7 27z");
			attr(path1, "d", "M16.027 4.654a3.705 3.705 0 0 0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.565-.147a3.742\n    3.742 0 0 1-.837 2.265c-1.411 1.854-1.7 5.154-2.4 4.31-6.591-2.7-5.865.871-3.7 3.258 2.558 2.821 2.273 1.693 3.773\n    1.713A12.232 12.232 0 0 1 29.672 15v-.133a5.766 5.766 0 0 1 1.666-4 3.1 3.1 0 0 1\n    .73-.349c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576 1.576 0 0 1 .347-2.326\n    15.986 15.986 0 0 0-11.66-5.221c2.027.028 4.446 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889\n    1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.459 3.544.764a3.014 3.014 0 0 1 1.099.452zM27 18.1a8.9\n    8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.128a.5.5 0 0 1 0-.707l1.036-1.036a.5.5 0 0 1 .707\n    0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5 7.5a.5.5 0 0 1-.702-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5V, create_fragment$5V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeClock.svelte generated by Svelte v3.24.1 */

function create_fragment$5W(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M32.063 10.518c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576 1.576 0 0 1\n    .347-2.326 15.984 15.984 0 0 0-11.655-5.221c2.027.028 4.446 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0\n    1.575-2.889 1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.46 3.544.764a3.014 3.014 0 0 1 1.1.452 3.711\n    3.711 0 0 0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.565-.147a3.742 3.742 0 0 1-.837\n    2.265c-1.411 1.854-1.7 5.154-2.4 4.31-6.591-2.7-5.865.871-3.7 3.258 2.558 2.821 2.273 1.693 3.773 1.713A12.232\n    12.232 0 0 1 29.672 15v-.133a5.766 5.766 0 0 1 1.666-4 3.1 3.1 0 0 1 .725-.349zM15.108 23.9a50.138 50.138 0 0\n    0-2.772-4.5c-2.073-3.086-3.958-1.178-5.19-5.636C6.1 9.982 8.8 8.352 8.534 5.116A16.073 16.073 0 0 0 2 18c0 9.112\n    7.943 14.542 13.554 15.732a6.889 6.889 0 0 0 1.046.168c.03-.077.047-.155.075-.232a12.158 12.158 0 0\n    1-1.567-9.768zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM27 34a7 7 0 1 1 7-7 7 7 0 0 1-7 7z");
			attr(path1, "d", "M27.905 26.533v-4.128a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v5.229l3.275 2.072a.5.5 0 0 0 .69-.155l.535-.845a.5.5 0\n    0 0-.155-.69z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeClock" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeClock extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5W, create_fragment$5W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeEnter.svelte generated by Svelte v3.24.1 */

function create_fragment$5X(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M7.211 13.769C6.164 9.982 8.866 8.352 8.6 5.116A16.073 16.073 0 0 0 2.065 18c0 9.112 7.943 14.542 13.554\n    15.732a6.893 6.893 0 0 0 1.045.166c2-5.1-1.772-10.789-4.263-14.494-2.073-3.086-3.958-1.177-5.19-5.635z");
			attr(path1, "d", "M23.892 21.841l1.863-1.928a2.443 2.443 0 0 1 1.807-.778 2.505 2.505 0 0 1 2.5 2.5v2.045h2.9A15.594 15.594 0 0 0\n    34 19.383a2.393 2.393 0 0 1-1.153-.352c-1.611-.613-2.992 1.475-3.114-4.164a5.766 5.766 0 0 1 1.666-4 3.1 3.1 0 0 1\n    .73-.349c-.191-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576 1.576 0 0 1 .347-2.326\n    15.985 15.985 0 0 0-11.655-5.221c2.027.028 4.446 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889\n    1.36-2.639a16.086 16.086 0 0 0-6.615 1.423c1.094.706 2.312.46 3.544.764a3.014 3.014 0 0 1 1.1.452 3.711 3.711 0 0\n    0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.566-.147a3.744 3.744 0 0 1-.837 2.265c-1.411\n    1.854-1.7 5.154-2.4 4.31-6.591-2.7-5.865.871-3.7 3.258 3.464 3.82 1.706.392 6.242 2.392a34.948 34.948 0 0 0 4.25\n    1.447zM20.612 32.06a24.582 24.582 0 0 1-2.3 1.94c.478-.013 2-.165 2.311-.216.477-.078.944-.181 1.406-.3z");
			attr(path2, "d", "M27.126 21.3a.5.5 0 0 1 .874.332v4.045h7a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-7V35.5a.5.5 0 0 1-.874.332L20 28.681z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeEnter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeEnter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5X, create_fragment$5X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeExit.svelte generated by Svelte v3.24.1 */

function create_fragment$5Y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M7.146 13.769C6.1 9.982 8.8 8.352 8.534 5.116A16.073 16.073 0 0 0 2 18c0 9.112 7.943 14.542 13.554 15.732a6.9 6.9\n    0 0 0 1.046.168c2-5.1-1.773-10.789-4.263-14.494-2.075-3.088-3.959-1.18-5.191-5.637zM28.874 21.3a.5.5 0 0\n    0-.874.332v4.045h-7a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h7V35.5a.5.5 0 0 0 .874.332L36 28.681z");
			attr(path1, "d", "M32.781 19.031c-1.611-.613-2.992 1.475-3.114-4.164a5.766 5.766 0 0 1 1.666-4 3.1 3.1 0 0 1\n    .73-.349c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576 1.576 0 0 1 .347-2.326\n    15.984 15.984 0 0 0-11.655-5.221c2.027.028 4.446 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889\n    1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.46 3.544.764a3.014 3.014 0 0 1 1.1.452 3.711 3.711 0 0\n    0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.565-.147a3.742 3.742 0 0 1-.837 2.265c-1.411\n    1.854-1.7 5.154-2.4 4.31-6.591-2.7-5.865.871-3.7 3.258 3.464 3.82 1.706.392 6.242 2.392C22 21.462 24.74 21.989 26\n    22.578v-.942a2.5 2.5 0 0 1 4.367-1.662l2.819 2.917a15.528 15.528 0 0 0 .748-3.508 2.393 2.393 0 0 1-1.153-.352z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeExit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeExit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5Y, create_fragment$5Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeGrid.svelte generated by Svelte v3.24.1 */

function create_fragment$5Z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M17 0a17 17 0 1 0 17 17A17 17 0 0 0 17 0zm13.749 16h-5.571a27.12 27.12 0 0 0-.853-6h4.547a13.676 13.676 0 0 1\n    1.877 6zm-3.311-8H23.7a14.681 14.681 0 0 0-2.2-4.04A13.864 13.864 0 0 1 27.438 8zM16 18v6h-4.268a24.81 24.81 0 0\n    1-.911-6zm-5.179-2a24.81 24.81 0 0 1 .911-6H16v6zM18 18h5.179a24.81 24.81 0 0 1-.911 6H18zm0-2v-6h4.268a24.81 24.81\n    0 0 1 .911 6zm3.568-8H18V3.619C19.307 4.158 20.6 5.7 21.568 8zM16 3.619V8h-3.568C13.4 5.7 14.693 4.158 16\n    3.619zm-3.5.341A14.681 14.681 0 0 0 10.305 8H6.562A13.864 13.864 0 0 1 12.5 3.96zM5.128 10h4.547a27.12 27.12 0 0\n    0-.853 6H3.251a13.676 13.676 0 0 1 1.877-6zm-1.877 8h5.571a27.12 27.12 0 0 0 .853 6H5.128a13.676 13.676 0 0\n    1-1.877-6zm3.311 8h3.743a14.681 14.681 0 0 0 2.195 4.04A13.864 13.864 0 0 1 6.562 26zm5.87\n    0H16v4.381c-1.307-.539-2.6-2.081-3.568-4.381zM18 30.381V26h3.568c-.968 2.3-2.261 3.842-3.568 4.381zm3.5-.341A14.681\n    14.681 0 0 0 23.7 26h3.743a13.864 13.864 0 0 1-5.943 4.04zM28.872 24h-4.547a27.12 27.12 0 0 0 .853-6h5.571a13.676\n    13.676 0 0 1-1.877 6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeGrid" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeGrid extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5Z, create_fragment$5Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$5_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 1.85A16.293 16.293 0 0 0 1.85 18 16.293 16.293 0 0 0 18 34.15 16.3 16.3 0 0 0 34.15 18 16.3 16.3 0 0 0 18\n    1.85zm13.721 19.087a13.873 13.873 0 0 1-.666 2.143c-.065.165-.111.339-.182.5a14.082 14.082 0 0 1-1.222\n    2.251c-.034.051-.079.094-.114.145A14.144 14.144 0 0 1 28 27.839c-.092.1-.2.178-.3.272a14.1 14.1 0 0 1-1.845\n    1.522l-.025.017A13.968 13.968 0 0 1 18.355 32c4.938-3.721 4.334-5.9\n    7.132-9.012.936-1.248-2.808-1.56-5.927-2.808-4.056-1.872-2.5 1.248-5.616-2.184-1.872-2.184-2.5-5.3\n    3.12-2.808.624.624.936-2.184 2.184-3.744.623-.623.623-1.247.936-2.183a2.053 2.053 0 0 0-4.056.312c0\n    .624-2.184-3.744-.624-3.744a11.081 11.081 0 0 1-3.12-.624c.293-.15.6-.268.9-.391a13.841 13.841 0 0 1 4.553-.853c.054\n    0 .108-.006.162 0 .312-.312-1.872 2.184-1.248 2.184s4.368.936 4.056 1.248c1.072-1.875-.387-3.053-2.007-3.351a13.891\n    13.891 0 0 1 6.23 1.872c.339.207.7.373 1.021.611.119.084.219.19.336.277A12.843 12.843 0 0 1 28.3\n    8.641c-.624.312-.624 1.247-.312 1.871.621.621.628.622 1.858.007.2.314.359.652.533.982-.187.073-.259.26-.519.26a5.011\n    5.011 0 0 0-1.56 3.431c0 4.992 1.248 3.12 2.808 3.744a1.137 1.137 0 0 0 .812.3 14.281 14.281 0 0 1-.146\n    1.445c-.023.085-.034.172-.053.256zM12.949 31.065A15.108 15.108 0 0 1 3.96 18a13.889 13.889 0 0 1\n    .222-2.294c.049-.293.09-.587.157-.875a13.951 13.951 0 0 1\n    .533-1.743c.149-.395.318-.782.5-1.161.128-.269.275-.525.421-.784a14.03 14.03 0 0 1\n    1.12-1.7c.187-.243.387-.488.587-.72.265-.3.529-.6.82-.882A13.944 13.944 0 0 1 9.576 6.8c.291 2.789-2.181 4.35-1.248\n    7.459 1.248 4.056 2.808 2.184 4.68 4.992 2.164 3.091 5.537 8.325 3.778 12.669a13.906 13.906 0 0 1-3.837-.855z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5_, create_fragment$5_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$5$(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M15.108 23.9a50.138 50.138 0 0 0-2.772-4.5c-2.073-3.086-3.958-1.178-5.19-5.636C6.1 9.982 8.8 8.352 8.534\n    5.116A16.073 16.073 0 0 0 2 18c0 9.112 7.943 14.542 13.554 15.732a6.889 6.889 0 0 0\n    1.046.168c.03-.077.047-.155.075-.232a12.158 12.158 0 0\n    1-1.567-9.768zm16.955-13.382c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576\n    1.576 0 0 1 .347-2.326 15.984 15.984 0 0 0-11.655-5.221c2.027.028 4.446 1.53 3.213\n    3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889 1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.46\n    3.544.764a3.014 3.014 0 0 1 1.1.452 3.711 3.711 0 0 0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176\n    4.565-.147a3.742 3.742 0 0 1-.837 2.265c-1.411 1.854-1.7 5.154-2.4 4.31-6.591-2.7-5.865.871-3.7 3.258 2.558 2.821\n    2.273 1.693 3.773 1.713A12.232 12.232 0 0 1 29.672 15v-.133a5.766 5.766 0 0 1 1.666-4 3.1 3.1 0 0 1 .725-.349zM27\n    18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5$, create_fragment$5$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeSearch.svelte generated by Svelte v3.24.1 */

function create_fragment$60(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M7.146 13.769C6.1 9.982 8.8 8.352 8.534 5.116A16.073 16.073 0 0 0 2 18c0 9.112 7.943 14.542 13.554 15.732a6.9 6.9\n    0 0 0 1.046.168c2-5.1-1.773-10.789-4.263-14.494-2.075-3.088-3.959-1.18-5.191-5.637zM29.188 17.958a6.027 6.027 0 0\n    0-5.1 4.923 5.952 5.952 0 0 0 1.935 5.484L22.27 34.22a.5.5 0 0 0 .151.691l.842.54a.5.5 0 0 0 .691-.151l3.746-5.855a6\n    6 0 1 0 1.483-11.487zM30 27.9a4 4 0 1 1 4-4 4 4 0 0 1-4 4z");
			attr(path1, "d", "M32.063 10.518c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576 1.576 0 0 1\n    .347-2.326 15.984 15.984 0 0 0-11.655-5.221c2.027.028 4.446 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0\n    1.575-2.889 1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.46 3.544.764a3.014 3.014 0 0 1 1.1.452 3.711\n    3.711 0 0 0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.565-.147a3.742 3.742 0 0 1-.837\n    2.265c-1.411 1.854-1.7 5.154-2.4 4.31-6.591-2.7-5.865.871-3.7 3.258 3.464 3.82 1.706.392 6.242 2.392a26.464 26.464 0\n    0 0 2.916 1.05 8.023 8.023 0 0 1 6.533-5.469c.232-.03.46-.034.689-.045a25.037 25.037 0 0 1-.045-1.063 5.766 5.766 0\n    0 1 1.666-4 3.1 3.1 0 0 1 .729-.349z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$60($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeSearch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeSearch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$60, create_fragment$60, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeStrike.svelte generated by Svelte v3.24.1 */

function create_fragment$61(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M7.146 13.769a6.06 6.06 0 0 1-.21-1.883L4.509 9.458A16.017 16.017 0 0 0 2 18c0 9.112 7.943 14.542 13.554\n    15.732a6.889 6.889 0 0 0 1.046.168c2-5.1-1.772-10.789-4.263-14.494-2.074-3.088-3.959-1.179-5.191-5.637zM18.249\n    34c.478-.013 2-.165 2.311-.216a15.607 15.607 0 0 0 5.959-2.316l-3.086-3.086A17.565 17.565 0 0 1 18.249\n    34zm14.532-14.969c-1.611-.613-2.992 1.475-3.114-4.164a5.766 5.766 0 0 1 1.666-4 3.1 3.1 0 0 1\n    .73-.349c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2 0a1.576 1.576 0 0 1 .347-2.326\n    15.984 15.984 0 0 0-11.655-5.221c2.027.028 4.446 1.53 3.213 3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889\n    1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.46 3.544.764a3.014 3.014 0 0 1 1.1.452 3.711 3.711 0 0\n    0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.565-.147a3.742 3.742 0 0 1-.837 2.265 10.193 10.193\n    0 0 0-1.314 2.737l13.336 13.335a15.869 15.869 0 0 0 2.48-7.123 2.393 2.393 0 0 1-1.154-.352z");
			attr(rect, "height", rect_height_value = 42.243);
			attr(rect, "rx", rect_rx_value = 0.509);
			attr(rect, "ry", rect_ry_value = 0.509);
			attr(rect, "transform", "rotate(-45 18.065 18.065)");
			attr(rect, "width", rect_width_value = 3);
			attr(rect, "x", rect_x_value = 16.565);
			attr(rect, "y", rect_y_value = -3.056);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$61($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeStrike" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeStrike extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$61, create_fragment$61, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GlobeStrikeClock.svelte generated by Svelte v3.24.1 */

function create_fragment$62(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.084a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm0 15.9a7 7 0 1 1 7-7 7 7 0 0 1-7 7z");
			attr(path1, "d", "M27.905 26.517v-4.128a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v5.229l3.275 2.072a.5.5 0 0 0 .69-.155l.535-.845a.5.5 0\n    0 0-.155-.69zM14.7 27a12.318 12.318 0 0 1 .408-3.1 50.167 50.167 0 0\n    0-2.772-4.5c-2.073-3.086-3.958-1.178-5.19-5.636a6.06 6.06 0 0 1-.21-1.883L4.509 9.458A16.017 16.017 0 0 0 2 18c0\n    9.112 7.943 14.542 13.554 15.732a6.889 6.889 0 0 0 1.046.168c.03-.077.047-.155.074-.232A12.232 12.232 0 0 1 14.7\n    27zM17.314 19.436a12.371 12.371 0 0 1 2.121-2.121L4.551 2.429a.509.509 0 0 0-.72 0l-1.4 1.4a.509.509 0 0 0 0\n    .719zM16.027 4.654a3.711 3.711 0 0 0-1.1-.452c-1.818-.211.88 4.777.777 4.114.5-2.292 3.612-3.176 4.565-.147a3.742\n    3.742 0 0 1-.837 2.265 10.193 10.193 0 0 0-1.314 2.737l3.014 3.014A12.242 12.242 0 0 1 29.672 15v-.133a5.766 5.766 0\n    0 1 1.666-4 3.1 3.1 0 0 1 .73-.349c-.192-.349-.4-.684-.62-1.018-.037.019-.07.044-.109.062-1.25.583-1.423.755-2\n    0a1.576 1.576 0 0 1 .347-2.326 15.984 15.984 0 0 0-11.66-5.221c2.027.028 4.446 1.53 3.213\n    3.929.186-.381-4.027-1.29-4.6-1.29-.772 0 1.575-2.889 1.36-2.639a16.085 16.085 0 0 0-6.615 1.423c1.094.706 2.311.46\n    3.544.764a3.014 3.014 0 0 1 1.099.452z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$62($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GlobeStrikeClock" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GlobeStrikeClock extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$62, create_fragment$62, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Gradient.svelte generated by Svelte v3.24.1 */

function create_fragment$63(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;
	let path8;
	let path9;
	let path10;
	let path11;
	let path12;
	let path13;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			path9 = svg_element("path");
			path10 = svg_element("path");
			path11 = svg_element("path");
			path12 = svg_element("path");
			path13 = svg_element("path");
			attr(path0, "d", "M4 6h2v24H4z");
			attr(path1, "d", "M6 6h2v24H6z");
			attr(path2, "d", "M8 6h2v24H8z");
			attr(path3, "d", "M10 6h2v24h-2z");
			attr(path4, "d", "M12 6h2v24h-2z");
			attr(path5, "d", "M14 6h2v24h-2z");
			attr(path6, "d", "M20 6h2v24h-2z");
			attr(path7, "d", "M18 6h2v24h-2z");
			attr(path8, "d", "M16 6h2v24h-2z");
			attr(path9, "d", "M22 6h2v24h-2z");
			attr(path10, "d", "M24 6h2v24h-2z");
			attr(path11, "d", "M26 6h2v24h-2z");
			attr(path12, "d", "M28 6h2v24h-2z");
			attr(path13, "d", "M2 5v26a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm30 25H4V6h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
			append(svg, path5);
			append(svg, path6);
			append(svg, path7);
			append(svg, path8);
			append(svg, path9);
			append(svg, path10);
			append(svg, path11);
			append(svg, path12);
			append(svg, path13);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$63($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Gradient" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Gradient extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$63, create_fragment$63, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphArea.svelte generated by Svelte v3.24.1 */

function create_fragment$64(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M30.371 16.743L34 24v9a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V18l10 12 3.584-5.376a.5.5 0 0 1 .832 0L20\n    30l9.517-13.324a.5.5 0 0 1 .854.067z");
			attr(path1, "d", "M11.769 25.66l2.068-3.1.083-.124a2.5 2.5 0 0 1 4.16 0l.083.124 1.911 2.866 7.811-10.935.1-.135a2.5 2.5 0 0 1\n    4.271.335l.074.148L34 18.187V2l-8 10-5.609-5.609a.5.5 0 0 0-.74.037L7.8 20.9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$64($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphArea" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphArea extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$64, create_fragment$64, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphAreaStacked.svelte generated by Svelte v3.24.1 */

function create_fragment$65(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M30.371 16.321L34 23.578v9a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-15l10 12 3.584-5.378a.5.5 0 0 1 .832 0L20\n    29.578l9.517-13.324a.5.5 0 0 1 .854.067z");
			attr(path1, "d", "M11.769 25.239l2.151-3.227a2.5 2.5 0 0 1 4.16 0L20.074 25l7.906-11.067a2.5 2.5 0 0 1 4.271.335L34\n    17.765V7.578l-3.57-5.355a.5.5 0 0 0-.84.012L20 17.578 16.416 12.2a.5.5 0 0 0-.832 0L12 17.578l-10-10v5.938z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$65($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphAreaStacked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphAreaStacked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$65, create_fragment$65, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBarHorizontal.svelte generated by Svelte v3.24.1 */

function create_fragment$66(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M33 10H6V4h27a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1zM23 18H6v-6h17a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1zM15 26H6v-6h9a1 1 0 0 1\n    1 1v4a1 1 0 0 1-1 1zM11 34H6v-6h5a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1z");
			attr(rect, "height", rect_height_value = 34);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 2);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$66($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBarHorizontal" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBarHorizontal extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$66, create_fragment$66, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBarHorizontalAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$67(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 34);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 2);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			attr(path, "d", "M22.939 12H6v6h12.636A12.25 12.25 0 0 1 24 15.084v-2.023A1.06 1.06 0 0 0 22.939 12zM33 4H6v6h27a1 1 0 0 0 1-1V5a1\n    1 0 0 0-1-1zM10.775 28H6v6h4.775A1.225 1.225 0 0 0 12 32.775v-3.55A1.225 1.225 0 0 0 10.775\n    28zm4.106-8H6v6h8.75A12.215 12.215 0 0 1 16 21.52v-.4A1.118 1.118 0 0 0 14.882 20zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9\n    8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5\n    0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$67($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBarHorizontalAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBarHorizontalAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$67, create_fragment$67, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBarHorizontalStacked.svelte generated by Svelte v3.24.1 */

function create_fragment$68(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 34);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 2);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			attr(path, "d", "M6 20h6v6H6zM6 4h14v6H6zM6 28h4v6H6zM6 12h10v6H6zM25 12h-7v6h7a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1zM33 4H22v6h11a1 1 0\n    0 0 1-1V5a1 1 0 0 0-1-1zM17 20h-3v6h3a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1zM15 28h-3v6h3a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$68($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBarHorizontalStacked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBarHorizontalStacked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$68, create_fragment$68, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBarVertical.svelte generated by Svelte v3.24.1 */

function create_fragment$69(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M26 3v27h6V3a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1zM18 13v17h6V13a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1zM10 21v9h6v-9a1 1 0 0\n    0-1-1h-4a1 1 0 0 0-1 1zM2 25v5h6v-5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1z");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 34);
			attr(rect, "y", rect_y_value = 32);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$69($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBarVertical" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBarVertical extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$69, create_fragment$69, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBarVerticalAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$6a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M23 12h-4a1 1 0 0 0-1 1v5.635a12.269 12.269 0 0 1 6-3.551V13a1 1 0 0 0-1-1zM18.1 27a8.9 8.9 0 1 0 8.9-8.9 8.9 8.9\n    0 0 0-8.9 8.9zm3.9-.5a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1 .5.5v1a.5.5 0 0\n    1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5zM32 15.769V3a1 1 0 0 0-1-1h-4a1 1 0 0 0-1\n    1v11.75c.331-.027.662-.05 1-.05a12.241 12.241 0 0 1 5 1.069zM.5 34h16.393a12.321 12.321 0 0 1-1.124-2H.5a.5.5 0 0\n    0-.5.5v1a.5.5 0 0 0 .5.5zM16 21a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v9h5.084A12.1 12.1 0 0 1 16 21.52zM3 24a1 1 0 0 0-1\n    1v5h6v-5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBarVerticalAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBarVerticalAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6a, create_fragment$6a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBarVerticalStacked.svelte generated by Svelte v3.24.1 */

function create_fragment$6b(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 34);
			attr(rect, "y", rect_y_value = 32);
			attr(path, "d", "M10 24h6v6h-6zM26 16h6v14h-6zM2 26h6v4H2zM18 20h6v10h-6zM24 11v7h-6v-7a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1zM32\n    3v11h-6V3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1zM16 19v3h-6v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1zM8 21v3H2v-3a1 1 0 0 1 1-1h4a1\n    1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBarVerticalStacked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBarVerticalStacked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6b, create_fragment$6b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBubble.svelte generated by Svelte v3.24.1 */

function create_fragment$6c(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			attr(circle0, "cx", circle0_cx_value = 8);
			attr(circle0, "cy", circle0_cy_value = 8);
			attr(circle0, "r", circle0_r_value = 6);
			attr(circle1, "cx", circle1_cx_value = 6);
			attr(circle1, "cy", circle1_cy_value = 24);
			attr(circle1, "r", circle1_r_value = 4);
			attr(path, "d", "M26.5 14.338a4.941 4.941 0 1 0-6.547.507 10.04 10.04 0 1 0 6.547-.507z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBubble" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBubble extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6c, create_fragment$6c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphBullet.svelte generated by Svelte v3.24.1 */

function create_fragment$6d(ctx) {
	let svg;
	let path;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(path, "d", "M2 8.5v3a.5.5 0 0 0 .5.5H8V8H2.5a.5.5 0 0 0-.5.5zM29.5 8H16v4h13.5a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5zM14\n    16H2.378a.378.378 0 0 0-.378.378v3.244a.378.378 0 0 0 .378.378H14zM2 24.5v3a.5.5 0 0 0 .5.5H20v-4H2.5a.5.5 0 0\n    0-.5.5zM33.5 24H28v4h5.5a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5z");
			attr(rect0, "height", rect0_height_value = 8);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 4);
			attr(rect0, "x", rect0_x_value = 10);
			attr(rect0, "y", rect0_y_value = 6);
			attr(rect1, "height", rect1_height_value = 8);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 4);
			attr(rect1, "x", rect1_x_value = 16);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 8);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 4);
			attr(rect2, "x", rect2_x_value = 22);
			attr(rect2, "y", rect2_y_value = 22);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphBullet" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphBullet extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6d, create_fragment$6d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphConfidenceBands.svelte generated by Svelte v3.24.1 */

function create_fragment$6e(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.9 20.984a1 1 0 0 0 .582-1.814l-1.627-1.162a1 1 0 1 0-1.155 1.629l1.622 1.163a1.009 1.009 0 0 0\n    .578.184zM10.277 19.668l1.48-1.346a1 1 0 1 0-1.344-1.48l-1.48 1.346a1 1 0 1 0 1.344 1.48zM5.838 23.705l1.481-1.346a1\n    1 0 1 0-1.344-1.48l-1.48 1.346a1 1 0 1 0 1.344 1.48zM25.836 22a1.012 1.012 0 0 0-.543.279l-9.186\n    9.186-5.307-7.078a1.013 1.013 0 0 0-.686-.395 1.048 1.048 0 0 0-.756.227L0 32.018v2.6l9.832-8.193 5.368 7.161a1.006\n    1.006 0 0 0 .73.4.958.958 0 0 0 .777-.291l9.773-9.775L36 22.333v-2.027zM2.879 26.395a1 1 0 0 0-1.344-1.481L.055\n    26.26a1.426 1.426 0 0 0-.055.055v1.371a1 1 0 0 0 1.4.055zM28.105 13.932l1.631-.467a1 1 0 0\n    0-.551-1.922l-1.734.5a.99.99 0 0 0-.432.254l-.139.139a.923.923 0 0 0 .068 1.346.94.94 0 0 0 .67.26 1.2 1.2 0 0 0\n    .487-.11z");
			attr(path1, "d", "M35.976 0L24.355 4.357a.983.983 0 0 0-.355.229l-7.6 7.6-7.451-1.864a1.007 1.007 0 0 0-.949.264l-8 8v2.828L9.014\n    12.4l7.451 1.863a1.008 1.008 0 0 0 .949-.263l7.848-7.848L36 2.125V0zM34.955 9.895l-1.924.551a1 1 0 0 0 .275\n    1.961.965.965 0 0 0 .275-.039l1.924-.551a.993.993 0 0 0 .495-.323v-1.279a.984.984 0 0 0-1.045-.32zM19.809\n    22.332l1.416-1.416a1 1 0 1 0-1.414-1.416l-1.416 1.416a1 1 0 1 0 1.414 1.414zM24.053 18.088l1.414-1.414a1 1 0 0\n    0-1.414-1.414l-1.414 1.414a1 1 0 1 0 1.414 1.414z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphConfidenceBands" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphConfidenceBands extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6e, create_fragment$6e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphDonut.svelte generated by Svelte v3.24.1 */

function create_fragment$6f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20 2.728v7.19a.489.489 0 0 0 .353.466 7.96 7.96 0 0 1 0 15.234.489.489 0 0 0-.353.466v7.189a.513.513 0 0 0\n    .587.506 15.986 15.986 0 0 0 0-31.555.513.513 0 0 0-.587.504zM12.959 11.827a8.036 8.036 0 0 1 2.69-1.444A.486.486 0\n    0 0 16 9.92V2.729a.514.514 0 0 0-.587-.506A15.977 15.977 0 0 0 6.3 7.111a.511.511 0 0 0 .1.767l5.98 3.982a.485.485 0\n    0 0 .579-.033zM10 18a7.914 7.914 0 0 1 .333-2.275.486.486 0 0 0-.193-.551L4.168 11.2a.513.513 0 0 0-.748.206 15.989\n    15.989 0 0 0 11.993 22.371.513.513 0 0 0 .587-.506v-7.188a.489.489 0 0 0-.353-.466A7.977 7.977 0 0 1 10 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphDonut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphDonut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6f, create_fragment$6f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphDonutAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$6g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M3.42 11.408a15.991 15.991 0 0 0 11.993 22.369.513.513 0 0 0 .587-.506v-.791a11.936 11.936 0 0 1-1.168-7.187\n    7.922 7.922 0 0 1-4.5-9.567.485.485 0 0 0-.192-.551L4.168 11.2a.514.514 0 0 0-.748.208zM12.959 11.826a8.044 8.044 0\n    0 1 2.689-1.443A.486.486 0 0 0 16 9.92V2.729a.514.514 0 0 0-.588-.506A15.977 15.977 0 0 0 6.3 7.111a.511.511 0 0 0\n    .1.767l5.987 3.982a.484.484 0 0 0 .572-.034zM25.314 14.829a12.044 12.044 0 0 1 8.633 2.024 15.988 15.988 0 0\n    0-13.36-14.631.513.513 0 0 0-.587.507v7.188a.488.488 0 0 0 .354.465 8.013 8.013 0 0 1 4.96 4.447zM27 35.9a8.9 8.9 0\n    1 0-8.9-8.9 8.9 8.9 0 0 0 8.9 8.9zm-5-9.4a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0\n    0 1 .5.5v1a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphDonutAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphDonutAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6g, create_fragment$6g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphGantt.svelte generated by Svelte v3.24.1 */

function create_fragment$6h(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 8);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 18);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 6);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 8);
			attr(rect2, "x", rect2_x_value = 10);
			attr(rect2, "y", rect2_y_value = 12);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 6);
			attr(rect3, "x", rect3_x_value = 14);
			attr(rect3, "y", rect3_y_value = 18);
			attr(rect4, "height", rect4_height_value = 4);
			attr(rect4, "rx", rect4_rx_value = 1);
			attr(rect4, "ry", rect4_ry_value = 1);
			attr(rect4, "width", rect4_width_value = 16);
			attr(rect4, "x", rect4_x_value = 14);
			attr(rect4, "y", rect4_y_value = 24);
			attr(rect5, "height", rect5_height_value = 4);
			attr(rect5, "rx", rect5_rx_value = 1);
			attr(rect5, "ry", rect5_ry_value = 1);
			attr(rect5, "width", rect5_width_value = 18);
			attr(rect5, "x", rect5_x_value = 18);
			attr(rect5, "y", rect5_y_value = 30);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphGantt" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphGantt extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6h, create_fragment$6h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphHistogram.svelte generated by Svelte v3.24.1 */

function create_fragment$6i(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.5 30h-3a.5.5 0 0 0-.5.5v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v-6a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v-8a.5.5\n    0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V6.519A.519.519 0 0 0 17.481 6h-2.962a.519.519 0 0 0-.519.519V10.5a.5.5 0 0\n    0-.5-.5h-3a.5.5 0 0 0-.5.5v10a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v8a.5.5 0 0 0-.5-.5h-3a.5.5 0 0\n    0-.5.5V34h32v-3.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphHistogram" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphHistogram extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6i, create_fragment$6i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphPathing.svelte generated by Svelte v3.24.1 */

function create_fragment$6j(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(rect0, "height", rect0_height_value = 12);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 8);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 8);
			attr(rect1, "x", rect1_x_value = 26);
			attr(rect1, "y", rect1_y_value = 2);
			attr(rect2, "height", rect2_height_value = 8);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 8);
			attr(rect2, "x", rect2_x_value = 26);
			attr(rect2, "y", rect2_y_value = 14);
			attr(rect3, "height", rect3_height_value = 8);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 8);
			attr(rect3, "x", rect3_x_value = 26);
			attr(rect3, "y", rect3_y_value = 26);
			attr(path0, "d", "M24 6.479a.508.508 0 0 1-.513.5 28.045 28.045 0 0 1-7.35-1.088 22.668 22.668 0 0 0-5.639-.9.5.5 0 0\n    1-.5-.5v-1a.51.51 0 0 1 .518-.5 24.63 24.63 0 0 1 6.115.965A26.4 26.4 0 0 0 23.5 4.982a.5.5 0 0 1 .5.5zM24\n    18.058a.5.5 0 0 1-.525.5c-2.937-.236-4.214-2.459-5.452-4.612-1.532-2.666-2.982-5.189-7.531-5.358A.5.5 0 0 1 10\n    8.1v-1a.505.505 0 0 1 .517-.5c5.7.194 7.657 3.606 9.241 6.362 1.225 2.132 2.045 3.412 3.769 3.6a.511.511 0 0 1\n    .473.5z");
			attr(path1, "d", "M24 30.452a.51.51 0 0 1-.591.5c-3.2-.431-4.6-4.385-6.079-8.557-1.573-4.437-3.2-9.019-6.858-9.381a.505.505 0 0\n    1-.472-.499v-1.007a.5.5 0 0 1 .525-.5c5.02.357 6.966 5.851 8.69 10.718 1.249 3.522 2.432 6.862 4.417 7.23a.479.479 0\n    0 1 .368.481z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphPathing" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphPathing extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6j, create_fragment$6j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphPie.svelte generated by Svelte v3.24.1 */

function create_fragment$6k(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 12.661V2.73a.515.515 0 0 0-.588-.507 15.952 15.952 0 0 0-8.384 4.163.511.511 0 0 0 .057.779l8.121 5.9a.5.5 0\n    0 0 .794-.404zm4-9.932v30.542a.513.513 0 0 0 .587.506 15.986 15.986 0 0 0 0-31.555.513.513 0 0 0-.587.507zM2\n    18a15.993 15.993 0 0 0 13.413 15.777.513.513 0 0 0 .587-.506V19.707a.5.5 0 0 0-.206-.4L4.31 10.959a.51.51 0 0\n    0-.756.184A15.872 15.872 0 0 0 2 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphPie" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphPie extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6k, create_fragment$6k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphProfitCurve.svelte generated by Svelte v3.24.1 */

function create_fragment$6l(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M2.513 2.006A.51.51 0 0 0 2 2.514v1a.5.5 0 0 0 .492.493A28.07 28.07 0 0 1 22.036 12H20v2h3.89a30.937 30.937 0 0 1\n    7.1 19.512.494.494 0 0 0 .493.49h1a.508.508 0 0 0 .507-.512C32.745 16.791 20.308 2.28 2.513 2.006zM22 28h2v4h-2z");
			attr(path1, "d", "M22 22h2v4h-2zM22 16h2v4h-2zM14 12h4v2h-4zM8 12h4v2H8zM2 12h4v2H2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphProfitCurve" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphProfitCurve extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6l, create_fragment$6l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphScatter.svelte generated by Svelte v3.24.1 */

function create_fragment$6m(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let circle5;
	let circle5_cx_value;
	let circle5_cy_value;
	let circle5_r_value;
	let circle6;
	let circle6_cx_value;
	let circle6_cy_value;
	let circle6_r_value;
	let circle7;
	let circle7_cx_value;
	let circle7_cy_value;
	let circle7_r_value;
	let circle8;
	let circle8_cx_value;
	let circle8_cy_value;
	let circle8_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			circle5 = svg_element("circle");
			circle6 = svg_element("circle");
			circle7 = svg_element("circle");
			circle8 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = 18);
			attr(circle0, "cy", circle0_cy_value = 16);
			attr(circle0, "r", circle0_r_value = 2.2);
			attr(circle1, "cx", circle1_cx_value = 16);
			attr(circle1, "cy", circle1_cy_value = 8);
			attr(circle1, "r", circle1_r_value = 2.2);
			attr(circle2, "cx", circle2_cx_value = 30);
			attr(circle2, "cy", circle2_cy_value = 6);
			attr(circle2, "r", circle2_r_value = 2.2);
			attr(circle3, "cx", circle3_cx_value = 20);
			attr(circle3, "cy", circle3_cy_value = 20);
			attr(circle3, "r", circle3_r_value = 2.2);
			attr(circle4, "cx", circle4_cx_value = 26);
			attr(circle4, "cy", circle4_cy_value = 16);
			attr(circle4, "r", circle4_r_value = 2.2);
			attr(circle5, "cx", circle5_cx_value = 12);
			attr(circle5, "cy", circle5_cy_value = 20);
			attr(circle5, "r", circle5_r_value = 2.2);
			attr(circle6, "cx", circle6_cx_value = 12);
			attr(circle6, "cy", circle6_cy_value = 10);
			attr(circle6, "r", circle6_r_value = 2.2);
			attr(circle7, "cx", circle7_cx_value = 16);
			attr(circle7, "cy", circle7_cy_value = 28);
			attr(circle7, "r", circle7_r_value = 2.2);
			attr(circle8, "cx", circle8_cx_value = 6);
			attr(circle8, "cy", circle8_cy_value = 30);
			attr(circle8, "r", circle8_r_value = 2.2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
			append(svg, circle5);
			append(svg, circle6);
			append(svg, circle7);
			append(svg, circle8);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphScatter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphScatter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6m, create_fragment$6m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphStream.svelte generated by Svelte v3.24.1 */

function create_fragment$6n(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 10c-4.947 0-5.356-6-10-6-4.213 0-5.9 6.567-12 7.788v2.85a16.034 16.034 0 0 0 6.336-2.128A11.374 11.374 0 0 1\n    14 10.75a10.6 10.6 0 0 1 6.354 2.4A6.635 6.635 0 0 0 24 14.75a14.535 14.535 0 0 0 4.082-.762A28.181 28.181 0 0 1 34\n    12.843V6.165C29.646 6.916 28.346 10 24 10zm0 13.25a16.5 16.5 0 0 0-4.242.887A20.569 20.569 0 0 1 14 25.25a29.526\n    29.526 0 0 1-7.283-1.033A33.457 33.457 0 0 0 2 23.349v2.832C6.329 26.956 9.168 30 14 30c3.46 0 7.064-2 10-2 2.637 0\n    4.518 3.217 10 3.875v-6.73a39.216 39.216 0 0 1-5.76-1.117A19.554 19.554 0 0 0 24 23.25zm0-6c-2.094\n    0-3.6-1.035-5.061-2.035S16.076 13.25 14 13.25a9.131 9.131 0 0 0-4.5 1.471A18.469 18.469 0 0 1 2 17.149v3.688a34.9\n    34.9 0 0 1 5.293.946A27.036 27.036 0 0 0 14 22.75a18.768 18.768 0 0 0 5.053-1.01A18.018 18.018 0 0 1 24 20.75a21.058\n    21.058 0 0 1 4.848.852A38.535 38.535 0 0 0 34 22.631v-7.289a25.875 25.875 0 0 0-5.232 1.048 16.625 16.625 0 0\n    1-4.768.86z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphStream" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphStream extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6n, create_fragment$6n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphStreamRanked.svelte generated by Svelte v3.24.1 */

function create_fragment$6o(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M22.42 27.532C16.185 27.783 14.172 29.5 10 29.5c-3.929 0-6.961-2-8-2V34h32v-4.5c-7.555 0-9.58-1.7-11.58-1.968zM10\n    14.5a10.219 10.219 0 0 1 5.967 2.3c1.352.914 2.518 1.7 4.033 1.7.779 0 1.139-4.258\n    1.291-6.076.039-.457.08-.933.125-1.414A1.84 1.84 0 0 1 20 12c-3.271 0-5.615-4-10-4-5.98 0-5.328 4-8 4v6.5c.768 0\n    1.338-.492 2.281-1.359A7.984 7.984 0 0 1 10 14.5z");
			attr(path1, "d", "M24.281 12.676C23.916 17.014 23.537 21.5 20 21.5a9.885 9.885 0 0 1-5.715-2.223C12.877 18.324 11.662 17.5 10\n    17.5c-1.682 0-2.611.855-3.686 1.846C5.219 20.355 3.977 21.5 2 21.5v3a8.7 8.7 0 0 1 3.926 1.016A8.5 8.5 0 0 0 10\n    26.5a16.8 16.8 0 0 0 4.432-.729A34.514 34.514 0 0 1 22 24.552a3.375 3.375 0 0 1 .447-.022c.494-.018 1.008-.03\n    1.553-.03.656 0 .936-.785 1.3-3.654.42-3.324 1.055-8.346 6.7-8.346h2v-9h-6c-2.736 0-3.268 3.8-3.719 9.176z");
			attr(path2, "d", "M28.273 21.221a12.082 12.082 0 0 1-1.2 4.535A27.212 27.212 0 0 0 34 26.5v-11h-2c-2.719 0-3.225 1.744-3.727 5.721z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphStreamRanked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphStreamRanked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6o, create_fragment$6o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphStreamRankedAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$6p(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28 3.5c-2.736 0-3.268 3.8-3.719 9.176a90.77 90.77 0 0 1-.232 2.4A12.3 12.3 0 0 1 27 14.7c.052 0\n    .1.007.153.008A5.6 5.6 0 0 1 32 12.5h2v-9zm-18 23a16.8 16.8 0 0 0 4.432-.729l.34-.084a12.2 12.2 0 0 1 1.728-5.072\n    19.525 19.525 0 0 1-2.217-1.337C12.877 18.324 11.662 17.5 10 17.5c-1.682 0-2.611.855-3.686 1.846C5.219 20.355 3.977\n    21.5 2 21.5v3a8.7 8.7 0 0 1 3.926 1.016A8.5 8.5 0 0 0 10 26.5zm0 3c-3.93 0-6.961-2-8-2V34h14.893a12.225 12.225 0 0\n    1-2.053-5.239A18.34 18.34 0 0 1 10 29.5zM20 12c-3.271 0-5.615-4-10-4-5.98 0-5.328 4-8 4v6.5c.768 0 1.338-.492\n    2.281-1.359A7.984 7.984 0 0 1 10 14.5a10.219 10.219 0 0 1 5.967 2.3 12.019 12.019 0 0 0 2.469 1.387 12.32 12.32 0 0\n    1 2.4-1.816c.229-1.337.37-2.977.451-3.941.039-.457.08-.933.125-1.414A1.84 1.84 0 0 1 20 12zM27 18.1a8.9 8.9 0 1 0\n    8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0\n    1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphStreamRankedAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphStreamRankedAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6p, create_fragment$6p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphSunburst.svelte generated by Svelte v3.24.1 */

function create_fragment$6q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M11.006 15.84h3.329a.494.494 0 0 0 .408-.226 4 4 0 0 1 1.075-1.076.494.494 0 0 0 .226-.408V10.8a.5.5 0 0\n    0-.648-.479 7.988 7.988 0 0 0-4.87 4.87.5.5 0 0 0 .48.649zM18.761 25.809a8.073 8.073 0 0 0 7.252-7.25 7.976 7.976 0\n    0 0-5.283-8.223.505.505 0 0 0-.685.467v3.327a.5.5 0 0 0 .227.411 3.986 3.986 0 1 1-5.528 5.528.5.5 0 0\n    0-.411-.227h-3.326a.5.5 0 0 0-.467.685 7.976 7.976 0 0 0 8.221 5.282z");
			attr(path1, "d", "M20.392 4.248V7.3a.494.494 0 0 0 .384.479 10.017 10.017 0 0 1 7.616 9.712 8.916 8.916 0 0 1-.11 1.323.5.5 0 0 0\n    .309.542l2.863 1.127a.5.5 0 0 0 .677-.362 13.709 13.709 0 0 0 .261-2.631A14.011 14.011 0 0 0 20.98 3.75a.5.5 0 0\n    0-.588.498zM10.018 7.144l.794.794a.492.492 0 0 0 .623.062 11.917 11.917 0 0 1 4.208-1.742.493.493 0 0 0\n    .4-.481V4.6a.5.5 0 0 0-.59-.5 13.89 13.89 0 0 0-5.376 2.28.5.5 0 0 0-.059.764zM4.8 15.84h1.047a.493.493 0 0 0 .48-.4\n    11.9 11.9 0 0 1 1.713-4.049.493.493 0 0 0-.058-.625l-.774-.774a.5.5 0 0 0-.769.066A13.909 13.909 0 0 0 4.3\n    15.251a.5.5 0 0 0 .5.589zM7.123 19.84H4.8a.5.5 0 0 0-.5.59 14.02 14.02 0 0 0 11.155 11.154.505.505 0 0 0\n    .59-.5V28.9a.494.494 0 0 0-.391-.48A10.685 10.685 0 0 1 7.6 20.238a.494.494 0 0 0-.477-.398zm19.8 4.072a10.667\n    10.667 0 0 1-6.488 4.506.5.5 0 0 0-.392.481v2.183a.505.505 0 0 0 .59.5 14.018 14.018 0 0 0 9.249-6.3.5.5 0 0\n    0-.248-.731l-2.116-.833a.5.5 0 0 0-.593.195z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphSunburst" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphSunburst extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6q, create_fragment$6q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphTree.svelte generated by Svelte v3.24.1 */

function create_fragment$6r(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 18);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 18);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 8);
			attr(rect1, "height", rect1_height_value = 10);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 12);
			attr(rect1, "x", rect1_x_value = 22);
			attr(rect1, "y", rect1_y_value = 8);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 8);
			attr(rect2, "x", rect2_x_value = 22);
			attr(rect2, "y", rect2_y_value = 20);
			attr(rect3, "height", rect3_height_value = 6);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 32);
			attr(rect3, "y", rect3_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphTree" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphTree extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6r, create_fragment$6r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphTrend.svelte generated by Svelte v3.24.1 */

function create_fragment$6s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.093 6.061l-8.14 11.374L20.9 9.321a.5.5 0 0 0-.917.053l-5.45 14.992-4.081-4.081a.5.5 0 0 0-.674-.031L2.18\n    26.579a.5.5 0 0 0-.18.384v4.188a.5.5 0 0 0 .829.376l7.048-6.157 5.708 5.708a.5.5 0 0 0 .823-.183l4.548-12.51L24\n    24.481a.5.5 0 0 0 .857.063l9.053-12.928a.5.5 0 0 0 .09-.286V6.352a.5.5 0 0 0-.907-.291z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphTrend" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphTrend extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6s, create_fragment$6s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphTrendAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$6t(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20.063 16.846l.894-2.459.76 1.518a11.922 11.922 0 0 1 7.127-1.052l5.066-7.237A.5.5 0 0 0 34 7.33V2.352a.5.5 0 0\n    0-.906-.291l-8.141 11.375-4.058-8.115a.5.5 0 0 0-.917.053l-5.45 14.992-4.081-4.082a.5.5 0 0 0-.674-.031L2.18\n    22.579a.5.5 0 0 0-.18.384v4.188a.5.5 0 0 0 .829.377l7.048-6.157 4.861 4.861a12.281 12.281 0 0 1 5.325-9.386z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphTrendAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphTrendAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6t, create_fragment$6t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/GraphTrendAlert.svelte generated by Svelte v3.24.1 */

function create_fragment$6u(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 33.809l-8.659-17.158a1.5 1.5 0 0 0-2.678 0L15 33.809A1.55 1.55 0 0 0 16.407 36h17.186A1.55 1.55 0 0 0 35\n    33.809zM24.5 20h1a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-7a.5.5 0 0 1 .5-.5zm1.491\n    12.4h-1.982a.409.409 0 0 1-.409-.409v-1.982a.409.409 0 0 1 .409-.409h1.982a.409.409 0 0 1 .409.409v1.983a.409.409 0\n    0 1-.409.408zM33.094 2.061l-7.74 10.815a4.423 4.423 0 0 1 3.423 2.074l5.133-7.334A.5.5 0 0 0 34 7.33V2.352a.5.5 0 0\n    0-.906-.291zM19.978 5.374l-5.45 14.992-4.081-4.082a.5.5 0 0 0-.674-.031L2.18 22.579a.5.5 0 0 0-.18.384v4.188a.5.5 0\n    0 0 .829.377l7.048-6.157 5.343 5.342 4.48-8.871 1.532-2.9a4.425 4.425 0 0 1 3.438-2.067l-3.775-7.554a.5.5 0 0\n    0-.917.053z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "GraphTrendAlert" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class GraphTrendAlert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6u, create_fragment$6u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Graphic.svelte generated by Svelte v3.24.1 */

function create_fragment$6v(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 14h-9V1.385a.482.482 0 0 0-.481-.5H23.5a.494.494 0 0 0-.35.147L1.091 23.146a.5.5 0 0 0 .354.854h8.838A7.909\n    7.909 0 0 0 10 26a7.976 7.976 0 0 0 14.89 4H33a1 1 0 0 0 1-1V15a1 1 0 0 0-1-1zM4.828 22L22 4.828V14h-3a1 1 0 0 0-1\n    1v3a7.967 7.967 0 0 0-6.891 4zM18 32a6 6 0 1 1 6-6 6.007 6.007 0 0 1-6 6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Graphic" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Graphic extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6v, create_fragment$6v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Group.svelte generated by Svelte v3.24.1 */

function create_fragment$6w(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M22 14v-3a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h3v-8z");
			attr(path1, "d", "M25 16h-9v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-8a1 1 0 0 0-1-1z");
			attr(path2, "d", "M33 8a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v1H8V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h1v20H3a1\n    1 0 0 0-1 1v4a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1h20v1a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-1V8zm-3 20h-1a1\n    1 0 0 0-1 1v1H8v-1a1 1 0 0 0-1-1H6V8h1a1 1 0 0 0 1-1V6h20v1a1 1 0 0 0 1 1h1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Group" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Group extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6w, create_fragment$6w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hammer.svelte generated by Svelte v3.24.1 */

function create_fragment$6x(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.591 4.066l-5.08 5.08a1.455 1.455 0 0 0 0 2.063l.344.33-1.51 1.573a.968.968 0 0 0-1.392-.041l-1.55\n    1.55a.727.727 0 0 0 0 1.03l4.109 4.108a.726.726 0 0 0 1.029\n    0l1.55-1.55c.569-.568-.023-1.374-.023-1.374l1.594-1.535a1.457 1.457 0 0 0 2.046-.013l.866-.867 16.869 16.869a1.455\n    1.455 0 0 0 2.059 0l1.366-1.366a1.455 1.455 0 0 0 0-2.059L17 11l.565-.565a1.456 1.456 0 0 0\n    0-2.058l-.684-.684s2.012-2.257 2.434-2.68c1.777-1.777 5.711-.631 5.893-1.541s-8.736-4.287-13.617.594z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hammer" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hammer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6x, create_fragment$6x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hand.svelte generated by Svelte v3.24.1 */

function create_fragment$6y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.11 9.757a2.678 2.678 0 0 0-2.91 1.587l-3.267\n    5.048c-.238.48-.85.927-1.285.738s-.555-.7-.335-1.511l1.571-9.226A2.382 2.382 0 0 0 25.809 3.4a2.469 2.469 0 0\n    0-2.558 1.875l-1.5 8.6s-.109 1.117-1 1.079-.794-1.181-.794-1.181V3.714a2.381 2.381 0 1 0-4.761 0v10.021c0\n    .629-.957.613-1.135.1-.819-2.389-2.62-7.794-2.62-7.794a2.47 2.47 0 0 0-2.668-1.71A2.383 2.383 0 0 0 6.9 7.45l3.244\n    9.434a8.039 8.039 0 0 1 .3 1.281 1.984 1.984 0 0 1-.893\n    2.183c-.463.265-4.884-3.119-5.239-3.278-2.07-1.2-3.375-.692-3.943-.018-.655.776-.2 2.05.747 3.032l6.967 7.909A10.646\n    10.646 0 0 1 9.2 29.52a17.341 17.341 0 0 0 1.64 2.369c1.667 1.825 4.028 2.778 7.539 2.778 4.432 0 7.72-1.694\n    8.889-4.444.793-2.3 1.545-5.408 1.905-6.489.235-.706 6-10.826 6-10.826.642-1.295.381-2.708-1.063-3.151z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hand" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hand extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6y, create_fragment$6y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hand0.svelte generated by Svelte v3.24.1 */

function create_fragment$6z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.239 19.456c-.552-.312-1.139-2.848-3.378-2.848a1.307 1.307 0 0 1-.6-.072c-.139-.089-.5-2.593-2.949-2.593a7.55\n    7.55 0 0 1-1.664-.12 3.3 3.3 0 0 0-2.816-1.859c-.232 0-1.388.261-1.423.261-1.26\n    0-1.664-1.25-3.627-.788-2.222.523-2.307 3.2-2.307 4.622 0 .671-2.114 2.966-2.114 2.966a5.613 5.613 0 0 0-.553\n    5.18c1.042 2.639 3.466 10.462 11.68 10.462 4.733 0 8.245-1.81 9.494-4.747.848-2.458 1.557-5.152 1.821-6.34a3.712\n    3.712 0 0 0-1.564-4.124z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hand0" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hand0 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6z, create_fragment$6z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hand1.svelte generated by Svelte v3.24.1 */

function create_fragment$6A(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.241 19.577c-.532-.3-1.1-2.747-3.258-2.747a1.262 1.262 0 0 1-.582-.07c-.134-.086-.482-2.5-2.843-2.5a7.284\n    7.284 0 0 1-1.6-.116 3.18 3.18 0 0 0-2.716-1.793c-.224 0-1.338.251-1.372.251-1.215 0-1.6-1.206-3.5-.76-2.143.5-2.224\n    3.088-2.224 4.457a12.594 12.594 0 0 1-.223 2.458 1.779 1.779 0 0 1-.9\n    1.27c-.463.264-4.1-2.645-4.1-2.645-2.381-1.621-3.849-1.06-4.464-.331-.655.776-.2 2.05.747 3.032L7.3 27.01c1.582\n    1.909 6.521 7.656 11.174 7.656 4.565 0 8.312-2.167 9.517-5 .818-2.371 1.5-4.968 1.756-6.113a3.58 3.58 0 0\n    0-1.506-3.976z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hand1" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hand1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6A, create_fragment$6A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hand2.svelte generated by Svelte v3.24.1 */

function create_fragment$6B(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.241 19.577c-.532-.3-1.1-2.747-3.258-2.747a1.262 1.262 0 0 1-.582-.07c-.134-.086-.482-2.5-2.843-2.5a7.284\n    7.284 0 0 1-1.6-.116A3.021 3.021 0 0 0 17.645 13a4.618 4.618 0 0 0-2.684 1.151.628.628 0 0\n    1-.806-.319c-.82-2.389-2.62-7.794-2.62-7.794a2.471 2.471 0 0 0-2.673-1.707A2.383 2.383 0 0 0 6.986 7.45l3.244\n    9.434a8.021 8.021 0 0 1 .3 1.281 1.983 1.983 0 0 1-.893\n    2.183c-.18.1-.9-.231-1.712-.675-1.484-1.083-3.005-2.291-3.005-2.291-2.381-1.621-3.849-1.06-4.464-.331-.655.776-.2\n    2.05.747 3.032L7.3 27.01c.357.431.893 1.063 1.551 1.776a21.816 21.816 0 0 0 2.074 3.1c1.667 1.825 4.028 2.778 7.539\n    2.778h.054a11.225 11.225 0 0 0 6.928-2.039 7.122 7.122 0 0 0 2.545-2.959c.818-2.371 1.5-4.968 1.756-6.113a3.58 3.58\n    0 0 0-1.506-3.976z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hand2" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hand2 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6B, create_fragment$6B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hand3.svelte generated by Svelte v3.24.1 */

function create_fragment$6C(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.241 19.577c-.532-.3-1.1-2.747-3.258-2.747a1.262 1.262 0 0 1-.582-.07c-.134-.086-.482-2.5-2.843-2.5-.326\n    0-1.506.256-1.506-1.261V3.714a2.381 2.381 0 1 0-4.762 0V13s.056 1.005-.329 1.151a.628.628 0 0\n    1-.806-.319c-.82-2.389-2.62-7.794-2.62-7.794a2.471 2.471 0 0 0-2.673-1.707A2.383 2.383 0 0 0 6.986 7.45l3.244\n    9.434a8.021 8.021 0 0 1 .3 1.281 1.983 1.983 0 0 1-.893\n    2.183c-.18.1-.9-.231-1.712-.675-1.484-1.083-3.005-2.291-3.005-2.291-2.381-1.621-3.849-1.06-4.464-.331-.655.776-.2\n    2.05.747 3.032L7.3 27.01c.357.431.893 1.063 1.551 1.776a21.816 21.816 0 0 0 2.074 3.1c1.667 1.825 4.028 2.778 7.539\n    2.778h.054a11.225 11.225 0 0 0 6.928-2.039 7.122 7.122 0 0 0 2.545-2.959c.818-2.371 1.5-4.968 1.756-6.113a3.58 3.58\n    0 0 0-1.506-3.976z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hand3" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hand3 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6C, create_fragment$6C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Hand4.svelte generated by Svelte v3.24.1 */

function create_fragment$6D(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26.118 17.121l1.853-10.728A2.382 2.382 0 0 0 25.9 3.4a2.469 2.469 0 0 0-2.56 1.877L22 13.136s-.159 1.135-.963\n    1.135c-.5 0-.982-.252-.982-1.272V3.714a2.381 2.381 0 1 0-4.762 0V13s.056 1.005-.329 1.151a.628.628 0 0\n    1-.806-.319c-.82-2.389-2.62-7.794-2.62-7.794a2.471 2.471 0 0 0-2.676-1.707A2.383 2.383 0 0 0 6.986 7.45l3.244\n    9.434a8.021 8.021 0 0 1 .3 1.281 1.983 1.983 0 0 1-.893\n    2.183c-.18.1-.9-.231-1.712-.675-1.484-1.083-3.005-2.291-3.005-2.291-2.381-1.621-3.849-1.06-4.464-.331-.655.776-.2\n    2.05.747 3.032L7.3 27.01c.357.431.893 1.063 1.551 1.776a21.816 21.816 0 0 0 2.074 3.1c1.667 1.825 4.028 2.778 7.539\n    2.778h.054a11.225 11.225 0 0 0 6.928-2.039 7.122 7.122 0 0 0 2.545-2.959c.818-2.371 1.5-4.968\n    1.756-6.113.489-2.206.268-4.147-3.629-6.432z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Hand4" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Hand4 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6D, create_fragment$6D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Heal.svelte generated by Svelte v3.24.1 */

function create_fragment$6E(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.728 3.272a6 6 0 0 0-8.485 0l-6.456 6.456L3.272 24.243a6 6 0 0 0 8.485 8.485l5.943-5.947 15.028-15.024a6 6 0 0\n    0 0-8.485zM19 11a2 2 0 1 1-2 2 2 2 0 0 1 2-2zm-6 10a2 2 0 1 1 2-2 2 2 0 0 1-2 2zm4 4a2 2 0 1 1 2-2 2 2 0 0 1-2\n    2zm6-6a2 2 0 1 1 2-2 2 2 0 0 1-2 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Heal" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Heal extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6E, create_fragment$6E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Heart.svelte generated by Svelte v3.24.1 */

function create_fragment$6F(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24.364 6.509A8.013 8.013 0 0 0 18 10.327a8.013 8.013 0 0 0-6.364-3.818A7.636 7.636 0 0 0 4 14.145c0 7.292 14\n    16.546 14 16.546s14-9.156 14-16.546a7.636 7.636 0 0 0-7.636-7.636z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Heart" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Heart extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6F, create_fragment$6F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Help.svelte generated by Svelte v3.24.1 */

function create_fragment$6G(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm.047 26.876a2.69 2.69 0 1 1 0-5.375 2.62 2.62 0 0 1 2.8 2.67 2.581\n    2.581 0 0 1-2.8 2.705zm3.566-12.818l-.2.21c-.789.829-1.684 1.768-1.684 2.351a2.771 2.771 0 0 0 .359\n    1.348l.145.277-.113.429a.617.617 0 0 1-.567.378h-2.682a.867.867 0 0 1-.65-.235 4.111 4.111 0 0\n    1-.845-2.525c0-1.677.934-2.714 2.225-4.15.2-.219.39-.42.575-.609.629-.651 1.013-1.071 1.013-1.515 0-.308\n    0-1.245-1.786-1.245a5.918 5.918 0 0 0-3.159.919.592.592 0 0 1-.653-.02l-.237-.169-.055-.443v-2.9a.879.879 0 0 1\n    .393-.819 8.275 8.275 0 0 1 4.3-1.1c3.291 0 5.5 2.117 5.5 5.272a6.131 6.131 0 0 1-1.879 4.546z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Help" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Help extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6G, create_fragment$6G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/HelpOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$6H(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20.181 25.932a1.833 1.833 0 0 1-1.954 2.015 1.862 1.862 0 0 1-1.956-2.015 1.955 1.955 0 1 1 3.91 0zM17.953\n    8a9.232 9.232 0 0 0-4.518 1.072c-.119.063-.119.185-.119.307v2.971a.15.15 0 0 0 .238.122 7.385 7.385 0 0 1\n    3.744-1.01c1.813 0 2.527.766 2.527 1.869 0 .95-.565 1.593-1.545 2.603-1.427 1.472-2.29 2.389-2.29 3.829a3.417 3.417\n    0 0 0 .714 2.114.488.488 0 0 0 .386.123h2.586a.13.13 0 0 0 .119-.215 3.302 3.302 0 0 1-.476-1.686c0-.917 1.1-1.928\n    2.26-3.062a5.474 5.474 0 0 0 1.901-4.226c0-2.696-1.96-4.81-5.527-4.81zM35 18A17 17 0 1 1 18 1a17 17 0 0 1 17\n    17zm-3.65 0A13.35 13.35 0 1 0 18 31.35 13.35 13.35 0 0 0 31.35 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "HelpOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class HelpOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6H, create_fragment$6H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Histogram.svelte generated by Svelte v3.24.1 */

function create_fragment$6I(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 10);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 24);
			attr(rect1, "height", rect1_height_value = 18);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 18);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 18);
			attr(rect2, "y", rect2_y_value = 16);
			attr(rect3, "height", rect3_height_value = 14);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 26);
			attr(rect3, "y", rect3_y_value = 20);
			attr(rect4, "height", rect4_height_value = 6);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 30);
			attr(rect4, "y", rect4_y_value = 28);
			attr(rect5, "height", rect5_height_value = 28);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 2);
			attr(rect5, "x", rect5_x_value = 10);
			attr(rect5, "y", rect5_y_value = 6);
			attr(rect6, "height", rect6_height_value = 22);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 14);
			attr(rect6, "y", rect6_y_value = 12);
			attr(rect7, "height", rect7_height_value = 24);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 2);
			attr(rect7, "x", rect7_x_value = 22);
			attr(rect7, "y", rect7_y_value = 10);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Histogram" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Histogram extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6I, create_fragment$6I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/History.svelte generated by Svelte v3.24.1 */

function create_fragment$6J(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M19 6h-2a1 1 0 0 0-1 1v10.586a1 1 0 0 0 .293.707L21.9 23.9a1 1 0 0 0 1.414 0l1.336-1.336a1 1 0 0 0 0-1.414L20\n    16.5V7a1 1 0 0 0-1-1z");
			attr(path1, "d", "M18 2A15.946 15.946 0 0 0 6.856 6.519 13.124 13.124 0 0 0 2.847 14H.5a.5.5 0 0 0-.5.5.49.49 0 0 0 .147.35l3.537\n    4.033a.5.5 0 0 0 .632 0l3.537-4.033A.49.49 0 0 0 8 14.5a.5.5 0 0 0-.5-.5H4.969a11.708 11.708 0 0 1 3.489-6.245 14 14\n    0 1 1-.009 20.481.5.5 0 0 0-.691.006l-.707.707a.506.506 0 0 0 0 .723A16 16 0 1 0 18 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "History" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class History extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6J, create_fragment$6J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Home.svelte generated by Svelte v3.24.1 */

function create_fragment$6K(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.332 20.25L18.75 3.668a1.063 1.063 0 0 0-1.5 0L.668 20.25a1.061 1.061 0 0 0 0 1.5l1.958 1.957a1 1 0 0 0\n    .707.293H4v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V23a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v10a1 1 0 0 0 1 1h8a1 1 0 0 0\n    1-1v-9h.667a1 1 0 0 0 .707-.293l1.958-1.957a1.061 1.061 0 0 0 0-1.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Home" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Home extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6K, create_fragment$6K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Homepage.svelte generated by Svelte v3.24.1 */

function create_fragment$6L(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M6 22h12v4H6zM20 22h4v4h-4zM26 22h4v4h-4zM6 14h24v6H6z");
			attr(path1, "d", "M33 4H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM4 28V10h28v18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Homepage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Homepage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6L, create_fragment$6L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/HotFixes.svelte generated by Svelte v3.24.1 */

function create_fragment$6M(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14.14 1.787a.5.5 0 0 0-.852.471 15.054 15.054 0 0 1 .653 6.566 16.977 16.977 0 0 1-2.91 6.165 26.831 26.831 0 0\n    0-2.849 5.5 10.411 10.411 0 1 0 20.223 3.5v-.037c-.076-4.845-3.036-11.542-6.022-16a.5.5 0 0 0-.907.327c.521 8.357-4\n    11.315-4 11.315S21.124 9.256 14.14 1.787z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "HotFixes" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class HotFixes extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6M, create_fragment$6M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/HotelBed.svelte generated by Svelte v3.24.1 */

function create_fragment$6N(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.2 22H.8L6 14h24zM0 24v5a1 1 0 0 0 1 1h3v1.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V30h24v1.5a.5.5 0 0 0\n    .5.5h1a.5.5 0 0 0 .5-.5V30h3a1 1 0 0 0 1-1v-5zm8-13a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v1h4v-1a1 1 0 0 1 1-1h6a1 1 0 0 1 1\n    1v1h2V7a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v5h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "HotelBed" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class HotelBed extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6N, create_fragment$6N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/IdentityService.svelte generated by Svelte v3.24.1 */

function create_fragment$6O(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M8.607 31.849a1 1 0 0 1-.546-1.838c7.322-4.776 9.058-13.395 9.076-13.482a1 1 0 0 1 1.963.379c-.075.387-1.921\n    9.544-9.948 14.779a1 1 0 0 1-.545.162z");
			attr(path1, "d", "M12.638 34.637a1 1 0 0 1-.628-1.779A27.887 27.887 0 0 0 21.5 17.5a4.008 4.008 0 0 0-.51-2.876 3.386 3.386 0 0\n    0-2.147-1.583 3.445 3.445 0 0 0-4.1 2.87c-.019.093-1.8 7.962-7.982 11.74a1 1 0 1 1-1.043-1.707c5.41-3.3 7.049-10.355\n    7.064-10.425a5.532 5.532 0 0 1 6.5-4.429 5.356 5.356 0 0 1 3.409 2.484 6 6 0 0 1 .772 4.3 30.019 30.019 0 0 1-10.2\n    16.539 1 1 0 0 1-.625.224zM18.987 34.793a1 1 0 0 1-.752-1.659c6.16-7.035 7.176-12.329 7.559-14.323l.069-.356a1 1 0 1\n    1 1.961.4l-.066.336c-.41 2.139-1.5 7.821-8.019 15.264a.994.994 0 0 1-.752.338zm-13.9-12.332a1 1 0 0 1-.536-1.845\n    7.813 7.813 0 0 0 2.681-3.279A1 1 0 0 1 9 18.274a9.635 9.635 0 0 1-3.379 4.032 1 1 0 0 1-.534.155zm4.323-6.768a1.014\n    1.014 0 0 1-.189-.017 1 1 0 0 1-.794-1.171 10.286 10.286 0 0 1 7.046-7.936 1 1 0 1 1 .564 1.92 8.265 8.265 0 0\n    0-5.645 6.393 1 1 0 0 1-.982.811zm17.264-.655a1 1 0 0 1-.964-.735 8.809 8.809 0 0 0-1-2.3 7.728 7.728 0 0\n    0-4.91-3.616 1 1 0 1 1 .426-1.955 9.714 9.714 0 0 1 6.19 4.521 10.893 10.893 0 0 1 1.228 2.82 1 1 0 0 1-.7 1.23\n    1.049 1.049 0 0 1-.27.035z");
			attr(path2, "d", "M25.937 32.588a1 1 0 0 1-.835-1.549c4.357-6.632 4.862-11.355 4.881-11.554a17.247 17.247 0 0 0-.385-6.169 1 1 0 0\n    1 1.907-.6 18.831 18.831 0 0 1 .469 6.965c-.054.546-.655 5.536-5.2 12.456a1 1 0 0 1-.837.451zM4.776 16.812h-.078a1 1\n    0 0 1-.92-1.075c.656-8.514 6.516-12.674 11.336-13.65C24.079.274 28.6 5.851 30.132 8.333a1 1 0 1 1-1.7\n    1.049c-1.309-2.125-5.179-6.9-12.918-5.334-4.137.837-9.169 4.44-9.739 11.841a1 1 0 0 1-.999.923z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "IdentityService" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class IdentityService extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6O, create_fragment$6O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Image.svelte generated by Svelte v3.24.1 */

function create_fragment$6P(ctx) {
	let svg;
	let path;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": ariaLabel },
		/*$$restProps*/ ctx[5],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[4]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[4]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr(path, "d", "M33 6H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 19.373L26.728 20.1a2 2 0 0 0-2.828 0l-3.072 3.072-7.556-7.557a2 2 0 0 0-2.828 0L4 22.059V8h28z");
			attr(circle, "cx", circle_cx_value = 26.7);
			attr(circle, "cy", circle_cy_value = 13.3);
			attr(circle, "r", circle_r_value = 2.7);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				{ "aria-label": ariaLabel },
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				dirty & /*width, autoScale*/ 18 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[4]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 20 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[4]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

let ariaLabel = "Image";

function instance$6P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(4, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
	};

	return [scale, width, height, className, autoScale, $$restProps];
}

class Image extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6P, create_fragment$6P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3
		});
	}
}

/* src/ImageAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$6Q(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 23.8);
			attr(circle, "cy", circle_cy_value = 12.6);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path0, "d", "M14.7 27a12.227 12.227 0 0 1 1.262-5.4c-2.108-2.358-4.305-5.6-6.177-5.6C7.113 16 2 24 2 24V6h32v10.893a12.366\n    12.366 0 0 1 2 1.743V5a1.068 1.068 0 0 0-1.125-1H1.125A1.068 1.068 0 0 0 0 5v26a1.068 1.068 0 0 0 1.125\n    1h14.644a12.24 12.24 0 0 1-1.069-5z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6Q, create_fragment$6Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageAlbum.svelte generated by Svelte v3.24.1 */

function create_fragment$6R(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 26.5);
			attr(circle, "cy", circle_cy_value = 13.5);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path, "d", "M33 6H3a1 1 0 0 0-1 1v3H1a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h1v8H1a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h1v3a1 1 0 0 0 1\n    1h30a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM6 25a1 1 0 0 1-1 1H4v-4h1a1 1 0 0 1 1 1zm0-12a1 1 0 0 1-1 1H4v-4h1a1 1 0 0 1 1\n    1zm26 12.748l-4.519-4.519a1.713 1.713 0 0 0-2.424 0l-2.633 2.632-6.476-6.477a1.716 1.716 0 0 0-2.425 0L8\n    22.908V8h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageAlbum" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageAlbum extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6R, create_fragment$6R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageAutoMode.svelte generated by Svelte v3.24.1 */

function create_fragment$6S(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 20.757);
			attr(circle, "cy", circle_cy_value = 19.283);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path0, "d", "M20.865.409l.1 2.842a2.318 2.318 0 0 0 1.186 1.939l2.482 1.39-2.843.1a2.317 2.317 0 0 0-1.938 1.184l-1.39\n    2.482-.1-2.843a2.317 2.317 0 0 0-1.184-1.939l-2.482-1.39 2.843-.1a2.318 2.318 0 0 0 1.936-1.184zM29.686 5.541l.133\n    3.659a2.984 2.984 0 0 0 1.524 2.5l3.2 1.79-3.661.133a2.982 2.982 0 0 0-2.5 1.524l-1.791 3.2-.132-3.661a2.986 2.986 0\n    0 0-1.525-2.5l-3.2-1.791 3.661-.132a2.987 2.987 0 0 0 2.5-1.525z");
			attr(path1, "d", "M26 22v6.463l-3.687-3.686a2 2 0 0 0-2.828 0l-3.071 3.071-7.556-7.556a2 2 0 0 0-2.829 0L2 24.321V14h21l-3-2H1a1 1\n    0 0 0-1 1v18a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V19z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageAutoMode" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageAutoMode extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6S, create_fragment$6S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageCarousel.svelte generated by Svelte v3.24.1 */

function create_fragment$6T(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			attr(rect, "height", rect_height_value = 22);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 6);
			attr(rect, "y", rect_y_value = 2);
			attr(path, "d", "M4 22H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h3zM35 22h-3V6h3a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1z");
			attr(circle0, "cx", circle0_cx_value = 8);
			attr(circle0, "cy", circle0_cy_value = 30);
			attr(circle0, "r", circle0_r_value = 1.4);
			attr(circle1, "cx", circle1_cx_value = 14);
			attr(circle1, "cy", circle1_cy_value = 30);
			attr(circle1, "r", circle1_r_value = 2.1);
			attr(circle2, "cx", circle2_cx_value = 20);
			attr(circle2, "cy", circle2_cy_value = 30);
			attr(circle2, "r", circle2_r_value = 1.4);
			attr(circle3, "cx", circle3_cx_value = 26);
			attr(circle3, "cy", circle3_cy_value = 30);
			attr(circle3, "r", circle3_r_value = 1.4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageCarousel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageCarousel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6T, create_fragment$6T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$6U(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 23.8);
			attr(circle, "cy", circle_cy_value = 12.6);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path0, "d", "M14.7 27a12.238 12.238 0 0 1 1.262-5.4c-2.108-2.358-4.306-5.6-6.178-5.6C7.113 16 2 24 2 24V6h32v10.893a12.279\n    12.279 0 0 1 2 1.743V5a1.068 1.068 0 0 0-1.125-1H1.125A1.068 1.068 0 0 0 0 5v26a1.069 1.069 0 0 0 1.125\n    1h14.644a12.244 12.244 0 0 1-1.069-5z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.128a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6U, create_fragment$6U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageCheckedOut.svelte generated by Svelte v3.24.1 */

function create_fragment$6V(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 4H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h12.55c-.028-.33-.05-.662-.05-1a11.452 11.452 0 0 1\n    3.205-7.952l-5.433-5.433a2 2 0 0 0-2.828 0L4 20.06V6h28v10.298a10.452 10.452 0 0 1 2 1.102V5a1 1 0 0 0-1-1zm-6.3\n    4.6a2.7 2.7 0 1 0 2.7 2.7 2.7 2.7 0 0 0-2.7-2.7z");
			attr(path1, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm5 10.814a.5.5 0 0 1-.854.354L29.05 27.07l-4.636 4.636a.5.5 0 0 1-.707\n    0l-1.414-1.414a.5.5 0 0 1 0-.707l4.636-4.636-2.097-2.096a.5.5 0 0 1 .354-.854h6.527a.287.287 0 0 1 .287.287z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageCheckedOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageCheckedOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6V, create_fragment$6V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageMapCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$6W(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 10.461V4.5a.5.5 0 0 0-.5-.5h-5.961a15.907 15.907 0 0 0-15.078 0H4.5a.5.5 0 0 0-.5.5v5.961a15.906 15.906 0 0 0\n    0 15.078V31.5a.5.5 0 0 0 .5.5h5.961a15.907 15.907 0 0 0 15.078 0H31.5a.5.5 0 0 0 .5-.5v-5.961a15.906 15.906 0 0 0\n    0-15.079zM26 6h4v4h-4zM6 6h4v4H6zm4 24H6v-4h4zm20 0h-4v-4h4zm.537-6H24.5a.5.5 0 0 0-.5.5v6.038a13.778 13.778 0 0\n    1-12 0V24.5a.5.5 0 0 0-.5-.5H5.463a13.778 13.778 0 0 1 0-12H11.5a.5.5 0 0 0 .5-.5V5.462a13.778 13.778 0 0 1 12\n    0V11.5a.5.5 0 0 0 .5.5h6.037a13.778 13.778 0 0 1 0 12z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageMapCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageMapCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6W, create_fragment$6W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageMapPolygon.svelte generated by Svelte v3.24.1 */

function create_fragment$6X(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.5 2h-7a.5.5 0 0 0-.5.5v4.412l-6.011 3.561A.5.5 0 0 0 21.5 10h-7a.5.5 0 0 0-.5.5v.952L8 9.23V4.5a.5.5 0 0\n    0-.5-.5h-7a.5.5 0 0 0-.5.5v7a.5.5 0 0 0 .5.5h3.877l3.691 12H6.5a.5.5 0 0 0-.5.5v7a.5.5 0 0 0 .5.5h7a.5.5 0 0 0\n    .5-.5v-2.57l10-1.667V29.5a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.5-.5h-1.449L31.9 10h3.6a.5.5 0 0 0\n    .5-.5v-7a.5.5 0 0 0-.5-.5zM16 12h4v4h-4zM6 10H2V6h4zm6 20H8v-4h4zm12-7.5v2.736L14 26.9v-2.4a.5.5 0 0\n    0-.5-.5h-3.338L6.469 12H7.5a.5.5 0 0 0 .5-.5v-.137l6 2.222V17.5a.5.5 0 0 0 .5.5h7a.5.5 0 0 0\n    .5-.5v-4.708l6-3.556V9.5a.5.5 0 0 0 .5.5h1.372l-1.846 12H24.5a.5.5 0 0 0-.5.5zm6 5.5h-4v-4h4zm4-20h-4V4h4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageMapPolygon" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageMapPolygon extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6X, create_fragment$6X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageMapRectangle.svelte generated by Svelte v3.24.1 */

function create_fragment$6Y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.5 10a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.5-.5h-7a.5.5 0 0 0-.5.5V4H10V2.5a.5.5 0 0 0-.5-.5h-7a.5.5 0 0\n    0-.5.5v7a.5.5 0 0 0 .5.5H4v16H2.5a.5.5 0 0 0-.5.5v7a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5V32h16v1.5a.5.5 0 0 0\n    .5.5h7a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.5-.5H32V10zM4 4h4v4H4zm4 28H4v-4h4zm18-5.5V30H10v-3.5a.5.5 0 0\n    0-.5-.5H6V10h3.5a.5.5 0 0 0 .5-.5V6h16v3.5a.5.5 0 0 0 .5.5H30v16h-3.5a.5.5 0 0 0-.5.5zm6 5.5h-4v-4h4zM28 8V4h4v4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageMapRectangle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageMapRectangle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6Y, create_fragment$6Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageNext.svelte generated by Svelte v3.24.1 */

function create_fragment$6Z(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 15.8);
			attr(circle, "cy", circle_cy_value = 13.393);
			attr(circle, "r", circle_r_value = 2.5);
			attr(path0, "d", "M29.668 23.722L35.8 18l-6.132-5.708a1 1 0 0 0-1.668.743V16h-7.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5H28v2.978a1 1 0\n    0 0 1.668.744z");
			attr(path1, "d", "M24.875 6H1.125A1.068 1.068 0 0 0 0 7v22a1.068 1.068 0 0 0 1.125 1h23.75A1.068 1.068 0 0 0 26\n    29v-7h-2v2c-1.791-1.058-3.067-1.84-4.628-1.84-2.938 0-2.893 2.029-5.833 2.029s-3.274-4.438-6.213-4.438C4.654 19.751\n    2 24 2 24V8h22v6h2V7a1.068 1.068 0 0 0-1.125-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageNext" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageNext extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6Z, create_fragment$6Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageProfile.svelte generated by Svelte v3.24.1 */

function create_fragment$6_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 4H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-1\n    26h-3.456c-1.238-1.822-3.516-3.556-7.63-3.974a1.335 1.335 0 0 1-1.155-1.34v-1.933a1.341 1.341 0 0 1 .34-.863 10.209\n    10.209 0 0 0 2.323-6.372C24.422 10.695 21.865 8 18 8s-6.5 2.8-6.5 7.517a10.324 10.324 0 0 0 2.434 6.372 1.336 1.336\n    0 0 1 .341.863v1.925a1.328 1.328 0 0 1-1.159 1.34C8.876 26.388 6.6 28.143 5.4 30H2V6h32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageProfile" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageProfile extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6_, create_fragment$6_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageSearch.svelte generated by Svelte v3.24.1 */

function create_fragment$6$(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.634 33.866l-5.168-5.168a8.02 8.02 0 1 0-1.768 1.768l5.168 5.168a1.25 1.25 0 0 0 1.768-1.768zM18 24a6 6 0 1 1\n    6 6 6 6 0 0 1-6-6zm-1.227-6.883l-5.5-5.5a2 2 0 0 0-2.829-.001L2 18.058V4h28v12.045a10.01 10.01 0 0 1 2 2.01V3a1 1 0\n    0 0-1-1H1a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h13.202a9.946 9.946 0 0 1 2.571-8.883zM22 10.051a2.7 2.7 0 1 0 2.7-2.7 2.7\n    2.7 0 0 0-2.7 2.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageSearch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageSearch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6$, create_fragment$6$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ImageText.svelte generated by Svelte v3.24.1 */

function create_fragment$70(ctx) {
	let svg;
	let path0;
	let path1;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			attr(path0, "d", "M35 18H17a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-1h4v10h-1a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0\n    1-1v-2a1 1 0 0 0-1-1h-1V22h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1z");
			attr(path1, "d", "M31 2H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11v-8a2 2 0 0 1 2-2h2.687l-5.415-5.414a2 2 0 0 0-2.828 0L4\n    17.029V4h26v12h2V3a1 1 0 0 0-1-1z");
			attr(circle, "cx", circle_cx_value = 24.7);
			attr(circle, "cy", circle_cy_value = 9.3);
			attr(circle, "r", circle_r_value = 2.7);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$70($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ImageText" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ImageText extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$70, create_fragment$70, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Images.svelte generated by Svelte v3.24.1 */

function create_fragment$71(ctx) {
	let svg;
	let path0;
	let path1;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			attr(path0, "d", "M32 5a1.068 1.068 0 0 0-1.125-1H1.125A1.068 1.068 0 0 0 0 5v22a1.068 1.068 0 0 0 1.125 1H2V6h30z");
			attr(path1, "d", "M35 8H5a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zm-1 19.373L28.728 22.1a2 2 0 0 0-2.828\n    0l-3.072 3.072-7.556-7.557a2 2 0 0 0-2.828 0L6 24.059V10h28z");
			attr(circle, "cx", circle_cx_value = 29);
			attr(circle, "cy", circle_cy_value = 15);
			attr(circle, "r", circle_r_value = 2.5);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$71($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Images" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Images extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$71, create_fragment$71, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Import.svelte generated by Svelte v3.24.1 */

function create_fragment$72(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 2H11a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h16v24H14v-3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v6a1 1 0 0 0 1\n    1h22a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z");
			attr(path1, "d", "M16 25.2a.8.8 0 0 0 .8.8.787.787 0 0 0 .527-.2l7.524-7.445a.5.5 0 0 0 0-.7L17.332 10.2a.787.787 0 0 0-.527-.2.8.8\n    0 0 0-.8.8V16H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h13z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$72($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Import" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Import extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$72, create_fragment$72, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Inbox.svelte generated by Svelte v3.24.1 */

function create_fragment$73(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 6);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 24);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 8);
			attr(rect2, "height", rect2_height_value = 2);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 24);
			attr(rect2, "x", rect2_x_value = 6);
			attr(rect2, "y", rect2_y_value = 12);
			attr(rect3, "height", rect3_height_value = 2);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 24);
			attr(rect3, "x", rect3_x_value = 6);
			attr(rect3, "y", rect3_y_value = 16);
			attr(path, "d", "M32 10v10h-5a1 1 0 0 0-1 1v2a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1v-2a1 1 0 0 0-1-1H4V10H1a1 1 0 0 0-1 1v20a1 1 0 0 0 1\n    1h34a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$73($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Inbox" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Inbox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$73, create_fragment$73, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Individual.svelte generated by Svelte v3.24.1 */

function create_fragment$74(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 7);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 7);
			attr(rect, "x", rect_x_value = 14.5);
			attr(rect, "y", rect_y_value = 14.5);
			attr(path, "d", "M29.5 12a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0-.5.5V8H12V6.5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0\n    0-.5.5v5a.5.5 0 0 0 .5.5H8v12H6.5a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 .5-.5V28h12v1.5a.5.5 0 0 0\n    .5.5h5a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5H28V12zM26 24h-1.5a.5.5 0 0 0-.5.5V26H12v-1.5a.5.5 0 0\n    0-.5-.5H10V12h1.5a.5.5 0 0 0 .5-.5V10h12v1.5a.5.5 0 0 0 .5.5H26z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$74($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Individual" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Individual extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$74, create_fragment$74, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Info.svelte generated by Svelte v3.24.1 */

function create_fragment$75(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-.3 4.3a2.718 2.718 0 0 1 2.864 2.824 2.664 2.664 0 0 1-2.864 2.863\n    2.705 2.705 0 0 1-2.864-2.864A2.717 2.717 0 0 1 17.7 6.3zM22 27a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1\n    1-1h1v-6h-1a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v9h1a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$75($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Info" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Info extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$75, create_fragment$75, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/InfoOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$76(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20.15 12A2.15 2.15 0 1 1 18 9.85 2.15 2.15 0 0 1 20.15 12zm.183 12H20v-7.6a.4.4 0 0\n    0-.4-.4h-3.934s-1.166.032-1.166 1c0 .967 1.167 1 1.167 1H16v6h-.333s-1.167.032-1.167 1c0 .967 1.167 1 1.167\n    1h4.667s1.166-.033 1.166-1c0-.968-1.167-1-1.167-1zM18 1a17 17 0 1 0 17 17A17 17 0 0 0 18 1zm0 30.35A13.35 13.35 0 1\n    1 31.35 18 13.35 13.35 0 0 1 18 31.35z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$76($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "InfoOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class InfoOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$76, create_fragment$76, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/IntersectOverlap.svelte generated by Svelte v3.24.1 */

function create_fragment$77(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 12h-7V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h7v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V13a1 1 0 0\n    0-1-1zm-19 1v9H6V6h16v6h-9a1 1 0 0 0-1 1zm18 17H14v-6h10V14h6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$77($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "IntersectOverlap" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class IntersectOverlap extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$77, create_fragment$77, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/InvertAdj.svelte generated by Svelte v3.24.1 */

function create_fragment$78(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M8 18.5a10.4 10.4 0 0 0 2.182 6.341L25.919 11.07A10.5 10.5 0 0 0 8 18.5z");
			attr(path1, "d", "M35 2H1a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h34a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-6 16.5a10.466 10.466 0 0 1-18.818\n    6.341L2 32V4h32l-8.081 7.07A10.472 10.472 0 0 1 29 18.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$78($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "InvertAdj" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class InvertAdj extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$78, create_fragment$78, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Journey.svelte generated by Svelte v3.24.1 */

function create_fragment$79(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M29 22.2a2.8 2.8 0 1 1-2.8 2.8 2.8 2.8 0 0 1 2.8-2.8zm0-4.2a7 7 0 0 0-7 7c0 3.866 7 11 7 11s7-7.134 7-11a7 7 0 0\n    0-7-7z");
			attr(path1, "d", "M20.775 28H20a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4 4v6h-4.1a5 5 0 1 0 0 2H16v8a4 4 0 0\n    0 4 4h1.825a19.039 19.039 0 0 1-1.05-2zM29 4a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$79($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Journey" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Journey extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$79, create_fragment$79, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JourneyAction.svelte generated by Svelte v3.24.1 */

function create_fragment$7a(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.193 25.786h-2.125a6.125 6.125 0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858\n    0l-1.511 1.514a6.147 6.147 0 0 0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.147\n    6.147 0 0 0-2.178.9L22.1 20.319a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.508 1.513a6.125 6.125 0 0 0-.9\n    2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.125 6.125 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.147 6.147 0 0 0 2.178.9V35.2a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.132a6.147 6.147 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.125 6.125 0 0 0 .9-2.179h2.13a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.607-.607zM27 30.164A3.164 3.164 0 1 1 30.164 27 3.165 3.165 0 0 1 27 30.164z");
			attr(path1, "d", "M16 26c0 .114.024.222.034.334A10.924 10.924 0 0 1 18 20.687V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4\n    4v6h-4.1a5 5 0 1 0 0 2H16zM29 4a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JourneyAction" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JourneyAction extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7a, create_fragment$7a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JourneyData.svelte generated by Svelte v3.24.1 */

function create_fragment$7b(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M29 28c-3.866 0-7-1.253-7-2.8v-4c0 1.546 3.134 3.066 7 3.066s7-1.52 7-3.066v4c0 1.547-3.134 2.8-7 2.8zm7\n    5.179v-5.158c0 1.546-3.134 2.8-7 2.8s-7-1.253-7-2.8v5.159c0 1.546 3.134 2.8 7 2.8s7-1.254\n    7-2.801zm0-15.068c0-1.546-3.195-2.626-7.061-2.626S22 16.565 22 18.111s3.134 2.8 7 2.8 7-1.253 7-2.8z");
			attr(path1, "d", "M20 28a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4 4v6h-4.1a5 5 0 1 0 0 2H16v8a4 4 0 0 0 4\n    4zm9-24a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JourneyData" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JourneyData extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7b, create_fragment$7b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JourneyEvent.svelte generated by Svelte v3.24.1 */

function create_fragment$7c(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm4.081 9.748l-5.927 6.778a.613.613 0 0 1-1.027-.642l2-4.749-2.827-1.214a1.059\n    1.059 0 0 1-.379-1.67l5.928-6.777a.613.613 0 0 1 1.026.642l-2 4.749 2.825 1.214a1.058 1.058 0 0 1 .381 1.669z");
			attr(path1, "d", "M16 26c0 .114.024.222.034.334A10.924 10.924 0 0 1 18 20.687V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4\n    4v6h-4.1a5 5 0 1 0 0 2H16zM29 4a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JourneyEvent" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JourneyEvent extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7c, create_fragment$7c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JourneyEvent2.svelte generated by Svelte v3.24.1 */

function create_fragment$7d(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.1 18.1A8.9 8.9 0 1 0 36 27a8.9 8.9 0 0 0-8.9-8.9zm0 16a7.1 7.1 0 0 1-1-14.121V27a1 1 0 0 0 .293.707l3.022\n    3.023a.5.5 0 0 0 .708 0l.707-.708a.5.5 0 0 0 0-.707l-2.73-2.729v-6.608a7.1 7.1 0 0 1-1 14.122z");
			attr(path1, "d", "M16 26c0 .114.024.222.034.334A10.924 10.924 0 0 1 18 20.687V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4\n    4v6h-4.1a5 5 0 1 0 0 2H16zM29 4a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JourneyEvent2" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JourneyEvent2 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7d, create_fragment$7d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JourneyReports.svelte generated by Svelte v3.24.1 */

function create_fragment$7e(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 18);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "width", rect0_width_value = 2);
			attr(rect0, "x", rect0_x_value = 34);
			attr(rect0, "y", rect0_y_value = 18);
			attr(rect1, "height", rect1_height_value = 12);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 30);
			attr(rect1, "y", rect1_y_value = 24);
			attr(rect2, "height", rect2_height_value = 8);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "width", rect2_width_value = 2);
			attr(rect2, "x", rect2_x_value = 26);
			attr(rect2, "y", rect2_y_value = 28);
			attr(rect3, "height", rect3_height_value = 6);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 22);
			attr(rect3, "y", rect3_y_value = 30);
			attr(path, "d", "M20 28a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4 4v6h-4.1a5 5 0 1 0 0 2H16v8a4 4 0 0 0 4\n    4zm9-24a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JourneyReports" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JourneyReports extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7e, create_fragment$7e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JourneyVoyager.svelte generated by Svelte v3.24.1 */

function create_fragment$7f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29 24a5 5 0 0 0-4.9 4H20a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h4.1a5 5 0 1 0 0-2H20a4 4 0 0 0-4 4v6h-4.1a5 5 0 1 0 0\n    2H16v8a4 4 0 0 0 4 4h4.1a5 5 0 1 0 4.9-6zm0-20a3 3 0 1 1-3 3 3 3 0 0 1 3-3zM7 20a3 3 0 1 1 3-3 3 3 0 0 1-3 3zm22\n    12a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JourneyVoyager" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JourneyVoyager extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7f, create_fragment$7f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/JumpToTop.svelte generated by Svelte v3.24.1 */

function create_fragment$7g(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M22 22v11a1 1 0 0 1-1 1h-8a1 1 0 0 1-1-1V22H5.007a.5.5 0 0 1-.354-.854L17 9l12.346 12.146a.5.5 0 0 1-.354.854z");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 34);
			attr(rect, "y", rect_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "JumpToTop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class JumpToTop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7g, create_fragment$7g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Key.svelte generated by Svelte v3.24.1 */

function create_fragment$7h(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.522 8.775L29.06 2.312a1.5 1.5 0 0 0-2.122 0L13.177 16.073A8.9 8.9 0 0 0 9 15a9 9 0 1 0 9 9 8.9 8.9 0 0\n    0-1.049-4.133l6.726-6.726 3.74 3.74a.75.75 0 0 0 1.061 0l3.344-3.344-4.27-4.271 1.231-1.231 4.27 4.271\n    2.469-2.47a.75.75 0 0 0 0-1.061zM7.5 28.5a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Key" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Key extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7h, create_fragment$7h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/KeyClock.svelte generated by Svelte v3.24.1 */

function create_fragment$7i(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.084a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm0 15.9a7 7 0 1 1 7-7 7 7 0 0 1-7 7z");
			attr(path1, "d", "M27.905 26.517v-4.128a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v5.229l3.275 2.072a.5.5 0 0 0 .69-.155l.535-.845a.5.5 0\n    0 0-.155-.69zM16.967 19.9c.52-.52 6.71-6.761 6.71-6.761l1.681 1.682a11.712 11.712 0 0 1\n    4.861.317l1.6-1.6-4.267-4.272 1.231-1.23 4.27 4.271 2.47-2.47a.75.75 0 0 0 0-1.061L29.06 2.313a1.5 1.5 0 0 0-2.122\n    0l-13.761 13.76A8.888 8.888 0 0 0 9 15a9 9 0 1 0 6.21 15.491c-1.241-4.201-.022-8.81 1.757-10.591zM7.5 28.5a3 3 0 1 1\n    3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "KeyClock" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class KeyClock extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7i, create_fragment$7i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/KeyExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$7j(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			attr(path1, "d", "M16.967 19.9c.52-.52 6.71-6.761 6.71-6.761l1.681 1.682a11.712 11.712 0 0 1 4.861.317l1.6-1.6-4.267-4.272\n    1.231-1.23 4.27 4.271 2.47-2.47a.75.75 0 0 0 0-1.061L29.06 2.313a1.5 1.5 0 0 0-2.122 0l-13.761 13.76A8.888 8.888 0 0\n    0 9 15a9 9 0 1 0 6.21 15.491c-1.241-4.201-.022-8.81 1.757-10.591zM7.5 28.5a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "KeyExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class KeyExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7j, create_fragment$7j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Keyboard.svelte generated by Svelte v3.24.1 */

function create_fragment$7k(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let rect8;
	let rect8_height_value;
	let rect8_rx_value;
	let rect8_ry_value;
	let rect8_width_value;
	let rect8_x_value;
	let rect8_y_value;
	let rect9;
	let rect9_height_value;
	let rect9_rx_value;
	let rect9_ry_value;
	let rect9_width_value;
	let rect9_x_value;
	let rect9_y_value;
	let rect10;
	let rect10_height_value;
	let rect10_rx_value;
	let rect10_ry_value;
	let rect10_width_value;
	let rect10_x_value;
	let rect10_y_value;
	let rect11;
	let rect11_height_value;
	let rect11_rx_value;
	let rect11_ry_value;
	let rect11_width_value;
	let rect11_x_value;
	let rect11_y_value;
	let rect12;
	let rect12_height_value;
	let rect12_rx_value;
	let rect12_ry_value;
	let rect12_width_value;
	let rect12_x_value;
	let rect12_y_value;
	let rect13;
	let rect13_height_value;
	let rect13_rx_value;
	let rect13_ry_value;
	let rect13_width_value;
	let rect13_x_value;
	let rect13_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			rect8 = svg_element("rect");
			rect9 = svg_element("rect");
			rect10 = svg_element("rect");
			rect11 = svg_element("rect");
			rect12 = svg_element("rect");
			rect13 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 4);
			attr(rect0, "y", rect0_y_value = 8);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 8);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 28);
			attr(rect2, "y", rect2_y_value = 14);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 8);
			attr(rect3, "x", rect3_x_value = 26);
			attr(rect3, "y", rect3_y_value = 20);
			attr(rect4, "height", rect4_height_value = 4);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 6);
			attr(rect4, "y", rect4_y_value = 20);
			attr(rect5, "height", rect5_height_value = 4);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 16);
			attr(rect5, "x", rect5_x_value = 8);
			attr(rect5, "y", rect5_y_value = 20);
			attr(rect6, "height", rect6_height_value = 4);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 4);
			attr(rect6, "x", rect6_x_value = 6);
			attr(rect6, "y", rect6_y_value = 8);
			attr(rect7, "height", rect7_height_value = 4);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 4);
			attr(rect7, "x", rect7_x_value = 12);
			attr(rect7, "y", rect7_y_value = 8);
			attr(rect8, "height", rect8_height_value = 4);
			attr(rect8, "rx", rect8_rx_value = 0.5);
			attr(rect8, "ry", rect8_ry_value = 0.5);
			attr(rect8, "width", rect8_width_value = 4);
			attr(rect8, "x", rect8_x_value = 18);
			attr(rect8, "y", rect8_y_value = 8);
			attr(rect9, "height", rect9_height_value = 4);
			attr(rect9, "rx", rect9_rx_value = 0.5);
			attr(rect9, "ry", rect9_ry_value = 0.5);
			attr(rect9, "width", rect9_width_value = 4);
			attr(rect9, "x", rect9_x_value = 10);
			attr(rect9, "y", rect9_y_value = 14);
			attr(rect10, "height", rect10_height_value = 4);
			attr(rect10, "rx", rect10_rx_value = 0.5);
			attr(rect10, "ry", rect10_ry_value = 0.5);
			attr(rect10, "width", rect10_width_value = 4);
			attr(rect10, "x", rect10_x_value = 16);
			attr(rect10, "y", rect10_y_value = 14);
			attr(rect11, "height", rect11_height_value = 4);
			attr(rect11, "rx", rect11_rx_value = 0.5);
			attr(rect11, "ry", rect11_ry_value = 0.5);
			attr(rect11, "width", rect11_width_value = 4);
			attr(rect11, "x", rect11_x_value = 22);
			attr(rect11, "y", rect11_y_value = 14);
			attr(rect12, "height", rect12_height_value = 4);
			attr(rect12, "rx", rect12_rx_value = 0.5);
			attr(rect12, "ry", rect12_ry_value = 0.5);
			attr(rect12, "width", rect12_width_value = 4);
			attr(rect12, "x", rect12_x_value = 24);
			attr(rect12, "y", rect12_y_value = 8);
			attr(rect13, "height", rect13_height_value = 4);
			attr(rect13, "rx", rect13_rx_value = 0.5);
			attr(rect13, "ry", rect13_ry_value = 0.5);
			attr(rect13, "width", rect13_width_value = 4);
			attr(rect13, "x", rect13_x_value = 30);
			attr(rect13, "y", rect13_y_value = 8);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, rect8);
			append(svg, rect9);
			append(svg, rect10);
			append(svg, rect11);
			append(svg, rect12);
			append(svg, rect13);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Keyboard" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Keyboard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7k, create_fragment$7k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Label.svelte generated by Svelte v3.24.1 */

function create_fragment$7l(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.293 19.292l-17-17A1 1 0 0 0 17.586 2H3a1 1 0 0 0-1 1v14.585a1 1 0 0 0 .293.708l17 17a1 1 0 0 0 1.414\n    0l14.586-14.586a1 1 0 0 0 0-1.415zM8 10.6A2.6 2.6 0 1 1 10.6 8 2.6 2.6 0 0 1 8 10.6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Label" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Label extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7l, create_fragment$7l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LabelExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$7m(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27.1a12.3 12.3 0 0 1 17.054-11.345L18.293 2.293A1 1 0 0 0 17.586 2H3a1 1 0 0 0-1 1v14.586a1 1 0 0 0\n    .293.707l13.246 13.246A12.25 12.25 0 0 1 14.7 27.1zM8 10.6A2.6 2.6 0 1 1 10.6 8 2.6 2.6 0 0 1 8 10.6z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LabelExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LabelExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7m, create_fragment$7m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Labels.svelte generated by Svelte v3.24.1 */

function create_fragment$7n(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33.293 15.293l-15-15A1 1 0 0 0 17.586 0H5a1 1 0 0 0-1 1v12.586a1 1 0 0 0 .293.707l15 15a1 1 0 0 0 1.414\n    0l12.586-12.586a1 1 0 0 0 0-1.414zM10 8.6A2.6 2.6 0 1 1 12.6 6 2.6 2.6 0 0 1 10 8.6z");
			attr(path1, "d", "M33.293 21.507l-.793-.793-11.793 11.793a1 1 0 0 1-1.414 0l-15-15A1 1 0 0 1 4 16.8v3a1 1 0 0 0 .293.708l15 15a1 1\n    0 0 0 1.414 0l12.586-12.587a1 1 0 0 0 0-1.414z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Labels" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Labels extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7n, create_fragment$7n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Landscape.svelte generated by Svelte v3.24.1 */

function create_fragment$7o(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 14);
			attr(circle, "r", circle_r_value = 4);
			attr(path, "d", "M33 6H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 22h-6v-4a4 4 0 0 0-4-4h-8a4 4 0 0 0-4\n    4v4H4V8h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Landscape" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Landscape extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7o, create_fragment$7o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Launch.svelte generated by Svelte v3.24.1 */

function create_fragment$7p(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.978.377A34.727 34.727 0 0 0 9.586 21.99a.522.522 0 0 0 .125.545l3.752 3.751a.522.522 0 0 0 .541.127A34.428\n    34.428 0 0 0 35.619 1.018a.544.544 0 0 0-.641-.641zM7.8 19.148H.9a.524.524 0 0 1-.46-.783C2.021 15.609 7.92 6.52\n    16.848 6.52 14.776 8.591 7.962 17.569 7.8 19.148zM16.848 28.2v6.908a.524.524 0 0 0 .779.461c2.752-1.554 11.849-7.376\n    11.849-16.419-2.076 2.07-11.05 8.884-12.628 9.05z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Launch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Launch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7p, create_fragment$7p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Layers.svelte generated by Svelte v3.24.1 */

function create_fragment$7q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M28.288 19.938l-9.839 6.827a.789.789 0 0 1-.9 0l-9.837-6.827L1.858 24a.251.251 0 0 0 0 .411l15.85 11a.515.515 0 0\n    0 .584 0l15.85-11a.251.251 0 0 0 0-.411z");
			attr(path1, "d", "M17.7 22.988L1.858 12a.249.249 0 0 1 0-.41L17.7.594a.53.53 0 0 1 .6 0l15.842 10.992a.249.249 0 0 1 0 .41L18.3\n    22.988a.53.53 0 0 1-.6 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Layers" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Layers extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7q, create_fragment$7q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LayersBackward.svelte generated by Svelte v3.24.1 */

function create_fragment$7r(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M9 14H6.993V3a.988.988 0 0 0-.987-1h-.992a1 1 0 0 0-1 1l-.007 11H2a.5.5 0 0 0-.5.5.49.49 0 0 0 .147.35l3.537\n    4.033a.5.5 0 0 0 .632 0l3.537-4.033a.49.49 0 0 0 .147-.35.5.5 0 0 0-.5-.5zM23 3.829L31.682 9 23 14.17 14.318 9zM23\n    1a1.2 1.2 0 0 0-.629.178l-11.99 7.141a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0\n    .007-1.366L23.629 1.178A1.194 1.194 0 0 0 23 1z");
			attr(path1, "d", "M35.62 17.319L31.726 15 23 20l-8.726-5-3.893 2.319a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0\n    1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			attr(path2, "d", "M31.726 24l-2.54 1.513L31.682 27 23 32.17 14.318 27l2.5-1.487L14.274 24l-3.893 2.319a.8.8 0 0 0 0 1.362l11.99\n    7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LayersBackward" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LayersBackward extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7r, create_fragment$7r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LayersBringToFront.svelte generated by Svelte v3.24.1 */

function create_fragment$7s(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M2 8h2.007v25a.988.988 0 0 0 .987 1h.992a1 1 0 0 0 1-1l.007-25H9a.5.5 0 0 0 .5-.5.49.49 0 0 0-.147-.35L5.816\n    3.113a.5.5 0 0 0-.632 0L1.647 7.146A.49.49 0 0 0 1.5 7.5.5.5 0 0 0 2 8zM23 1a1.2 1.2 0 0 0-.629.178l-11.99\n    7.141a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366L23.629 1.178A1.194\n    1.194 0 0 0 23 1zM31.726 24l-2.54 1.513L31.682 27 23 32.17 14.318 27l2.5-1.487L14.274 24l-3.893 2.319a.8.8 0 0 0 0\n    1.362l11.99 7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			attr(path1, "d", "M31.726 15l-2.54 1.513L31.682 18 23 23.17 14.318 18l2.5-1.487L14.274 15l-3.893 2.319a.8.8 0 0 0 0 1.362l11.99\n    7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LayersBringToFront" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LayersBringToFront extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7s, create_fragment$7s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LayersForward.svelte generated by Svelte v3.24.1 */

function create_fragment$7t(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M1.994 22H4v11a.988.988 0 0 0 .986 1h.993a1 1 0 0 0 1-1l.006-11h2.007a.5.5 0 0 0 .5-.5.491.491 0 0\n    0-.148-.35l-3.535-4.037a.5.5 0 0 0-.633 0L1.64 21.146a.49.49 0 0 0-.147.35.5.5 0 0 0 .501.504zM23 3.829L31.682 9 23\n    14.17 14.318 9zM23 1a1.2 1.2 0 0 0-.629.178l-11.99 7.141a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0\n    1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366L23.629 1.178A1.194 1.194 0 0 0 23 1z");
			attr(path1, "d", "M35.62 17.319L31.726 15 23 20l-8.726-5-3.893 2.319a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0\n    1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			attr(path2, "d", "M31.726 24l-2.54 1.513L31.682 27 23 32.17 14.318 27l2.5-1.487L14.274 24l-3.893 2.319a.8.8 0 0 0 0 1.362l11.99\n    7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LayersForward" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LayersForward extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7t, create_fragment$7t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LayersSendToBack.svelte generated by Svelte v3.24.1 */

function create_fragment$7u(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9.106 28.069H7.1v-25a.989.989 0 0 0-.986-1h-.993a1 1 0 0 0-1 1l-.006 25H2.108a.5.5 0 0 0-.5.5.49.49 0 0 0\n    .148.35l3.536 4.034a.5.5 0 0 0 .633 0l3.535-4.03a.489.489 0 0 0 .147-.35.5.5 0 0 0-.501-.504zM23 3.829L31.682 9 23\n    14.17 14.318 9zM23 1a1.2 1.2 0 0 0-.629.178l-11.99 7.141a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0\n    1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366L23.629 1.178A1.194 1.194 0 0 0 23 1zM35.62 26.319L31.726 24 23\n    29l-8.726-5-3.893 2.319a.8.8 0 0 0 0 1.362l11.99 7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			attr(path1, "d", "M31.726 15l-2.54 1.513L31.682 18 23 23.17 14.318 18l2.5-1.487L14.274 15l-3.893 2.319a.8.8 0 0 0 0 1.362l11.99\n    7.141a1.2 1.2 0 0 0 1.249.006l11.993-7.143a.8.8 0 0 0 .007-1.366z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LayersSendToBack" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LayersSendToBack extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7u, create_fragment$7u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Light.svelte generated by Svelte v3.24.1 */

function create_fragment$7v(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 7.9);
			attr(rect0, "height", rect0_height_value = 6);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 3.6);
			attr(rect0, "x", rect0_x_value = 16.2);
			attr(rect1, "height", rect1_height_value = 6);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 3.6);
			attr(rect1, "x", rect1_x_value = 16.2);
			attr(rect1, "y", rect1_y_value = 30);
			attr(rect2, "height", rect2_height_value = 3.6);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "y", rect2_y_value = 16.2);
			attr(rect3, "height", rect3_height_value = 3.6);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 6);
			attr(rect3, "x", rect3_x_value = 30);
			attr(rect3, "y", rect3_y_value = 16.2);
			attr(rect4, "height", rect4_height_value = 3.6);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "transform", "rotate(-45 29.02 7.02)");
			attr(rect4, "width", rect4_width_value = 6);
			attr(rect4, "x", rect4_x_value = 26.02);
			attr(rect4, "y", rect4_y_value = 5.22);
			attr(rect5, "height", rect5_height_value = 3.6);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "transform", "rotate(-45 7.02 29.02)");
			attr(rect5, "width", rect5_width_value = 6);
			attr(rect5, "x", rect5_x_value = 4.02);
			attr(rect5, "y", rect5_y_value = 27.22);
			attr(rect6, "height", rect6_height_value = 6);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "transform", "rotate(-45 7 7)");
			attr(rect6, "width", rect6_width_value = 3.6);
			attr(rect6, "x", rect6_x_value = 5.2);
			attr(rect6, "y", rect6_y_value = 4);
			attr(rect7, "height", rect7_height_value = 6);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "transform", "rotate(-45 28.98 28.98)");
			attr(rect7, "width", rect7_width_value = 3.6);
			attr(rect7, "x", rect7_x_value = 27.18);
			attr(rect7, "y", rect7_y_value = 25.98);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Light" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Light extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7v, create_fragment$7v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Line.svelte generated by Svelte v3.24.1 */

function create_fragment$7w(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "transform", "rotate(-45 18 18)");
			attr(rect, "width", rect_width_value = 39.598);
			attr(rect, "x", rect_x_value = -1.799);
			attr(rect, "y", rect_y_value = 17);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Line" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Line extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7w, create_fragment$7w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LineHeight.svelte generated by Svelte v3.24.1 */

function create_fragment$7x(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 12);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 12);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 12);
			attr(rect2, "y", rect2_y_value = 28);
			attr(path, "d", "M9 30H6.994L7 8h2.006a.5.5 0 0 0 .5-.5.49.49 0 0 0-.147-.35L5.824 3.113a.5.5 0 0 0-.633 0L1.655 7.146a.491.491 0\n    0 0-.148.35.5.5 0 0 0 .5.5h2.008L4.009 30H2a.5.5 0 0 0-.5.5.49.49 0 0 0 .147.35l3.537 4.033a.5.5 0 0 0 .632\n    0l3.536-4.033a.491.491 0 0 0 .148-.35.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LineHeight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LineHeight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7x, create_fragment$7x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinearGradient.svelte generated by Svelte v3.24.1 */

function create_fragment$7y(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;
	let path8;
	let path9;
	let path10;
	let path11;
	let path12;
	let path13;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			path9 = svg_element("path");
			path10 = svg_element("path");
			path11 = svg_element("path");
			path12 = svg_element("path");
			path13 = svg_element("path");
			attr(path0, "d", "M4 32v-2h28v2z");
			attr(path1, "d", "M4 30v-2h28v2z");
			attr(path2, "d", "M4 28v-2h28v2z");
			attr(path3, "d", "M4 26v-2h28v2z");
			attr(path4, "d", "M4 24v-2h28v2z");
			attr(path5, "d", "M4 22v-2h28v2z");
			attr(path6, "d", "M4 16v-2h28v2z");
			attr(path7, "d", "M4 18v-2h28v2z");
			attr(path8, "d", "M4 20v-2h28v2z");
			attr(path9, "d", "M4 14v-2h28v2z");
			attr(path10, "d", "M4 12v-2h28v2z");
			attr(path11, "d", "M4 10V8h28v2z");
			attr(path12, "d", "M4 8V6h28v2z");
			attr(path13, "d", "M3 34h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1zM32 4v28H4V4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
			append(svg, path5);
			append(svg, path6);
			append(svg, path7);
			append(svg, path8);
			append(svg, path9);
			append(svg, path10);
			append(svg, path11);
			append(svg, path12);
			append(svg, path13);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinearGradient" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinearGradient extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7y, create_fragment$7y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Link.svelte generated by Svelte v3.24.1 */

function create_fragment$7z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M31.7 4.3a7.176 7.176 0 0 0-10.148 0c-.385.386-4.264 4.222-5.351 5.309a8.307 8.307 0 0 1 3.743.607c.519-.52\n    3.568-3.526 3.783-3.741a4.1 4.1 0 0 1 5.8 5.8l-7.119 7.115a4.617 4.617 0 0 1-3.372 1.3 3.953 3.953 0 0 1-2.7-1.109\n    4.154 4.154 0 0 1-1.241-1.626 2.067 2.067 0 0 0-.428.318l-1.635 1.712a7.144 7.144 0 0 0 1.226 1.673c2.8 2.8 7.875\n    2.364 10.677-.438l6.765-6.768a7.174 7.174 0 0 0 0-10.152z");
			attr(path1, "d", "M15.926 25.824c-.52.52-3.5 3.547-3.713 3.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.58 4.58 0 0 1 3.366-1.292 4.2 4.2\n    0 0 1 3.784 2.782 2.067 2.067 0 0 0 .428-.318l1.734-1.721a7.165 7.165 0 0 0-1.226-1.673 7.311 7.311 0 0\n    0-10.26.048l-7.187 7.186a7.176 7.176 0 0 0 10.148 10.149c.386-.386 4.194-4.243 5.281-5.33a8.3 8.3 0 0 1-3.742-.607z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Link" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Link extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7z, create_fragment$7z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$7A(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.748 28.057a7.957 7.957 0 0 1-.822-.232c-.52.52-1.5 1.547-1.713 1.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.585\n    4.585 0 0 1 3.366-1.292 3.94 3.94 0 0 1 2.678 1.112 6.533 6.533 0 0 1 .439.511 12.246 12.246 0 0 1 2.553-1.319 6.845\n    6.845 0 0 0-.951-1.233 7.311 7.311 0 0 0-10.26.047l-7.186 7.186A7.176 7.176 0 0 0 14.388\n    31.76c.142-.142.478-.485.9-.913a12.248 12.248 0 0 1-.54-2.79zM23.722 6.479a4.1 4.1 0 1 1 5.8 5.8L27 14.8a12.291\n    12.291 0 0 1 3.759.59l.938-.937A7.176 7.176 0 0 0 21.547 4.3c-.385.385-4.264 4.222-5.351 5.309a8.3 8.3 0 0 1\n    3.742.607c.521-.516 3.569-3.522 3.784-3.737z");
			attr(path1, "d", "M16.926 20.056a3.579 3.579 0 0 1-.594-.478 4.159 4.159 0 0 1-1.241-1.625 2.053 2.053 0 0 0-.428.318l-1.636\n    1.712a7.155 7.155 0 0 0 1.227 1.673 6.109 6.109 0 0 0 1.3.97 12.276 12.276 0 0 1 1.372-2.57zM27 18.1a8.9 8.9 0 1 0\n    8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.128a.5.5 0 0 1 0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731\n    2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5 7.5a.5.5 0 0 1-.702-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7A, create_fragment$7A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkGlobe.svelte generated by Svelte v3.24.1 */

function create_fragment$7B(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M14.748 28.057a8.007 8.007 0 0 1-.822-.232c-.52.52-1.5 1.547-1.713 1.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.585\n    4.585 0 0 1 3.366-1.292 3.939 3.939 0 0 1 2.678 1.112 6.6 6.6 0 0 1 .439.51 12.264 12.264 0 0 1 2.553-1.319 6.847\n    6.847 0 0 0-.951-1.233 7.311 7.311 0 0 0-10.26.048l-7.186 7.186a7.176 7.176 0 0 0 10.149\n    10.149c.142-.142.478-.485.9-.914a12.248 12.248 0 0 1-.54-2.79z");
			attr(path1, "d", "M16.926 20.056a3.579 3.579 0 0 1-.594-.478 4.159 4.159 0 0 1-1.241-1.625 2.041 2.041 0 0 0-.428.318l-1.636\n    1.712a7.164 7.164 0 0 0 1.227 1.673 6.115 6.115 0 0 0 1.3.97 12.271 12.271 0 0 1 1.372-2.57zM23.722 6.479a4.1 4.1 0\n    1 1 5.8 5.8L27 14.8a12.292 12.292 0 0 1 3.759.59l.938-.937A7.176 7.176 0 0 0 21.547 4.3c-.385.385-4.264 4.222-5.351\n    5.309a8.3 8.3 0 0 1 3.742.607c.521-.516 3.569-3.522 3.784-3.737zM20.98 24.646c-.582-2.107.921-3.013.772-4.813A8.941\n    8.941 0 0 0 18.118 27c0 5.069 4.418 8.089 7.539 8.751a3.836 3.836 0 0 0\n    .581.092c1.113-2.837-.986-6-2.371-8.062-1.153-1.716-2.201-.655-2.887-3.135z");
			attr(path2, "d", "M35.24 27.573c-.9-.341-1.664.821-1.732-2.316a3.206 3.206 0 0 1 .927-2.225 1.718 1.718 0 0 1 .405-.194 9.09 9.09 0\n    0 0-.345-.566c-.021.011-.039.025-.061.035-.7.324-.792.42-1.112 0a.877.877 0 0 1 .192-1.294 8.892 8.892 0 0\n    0-6.482-2.9c1.128.015 2.473.851 1.787 2.185.1-.212-2.24-.718-2.559-.718-.429 0 .877-1.607.757-1.468a8.946 8.946 0 0\n    0-3.68.791c.608.393 1.286.256 1.971.425.147.017.2.05 0 0-1.011-.117.489 2.657.433 2.288a1.281 1.281 0 0 1 2.54-.082\n    2.082 2.082 0 0 1-.466 1.26c-.785 1.031-.944 2.867-1.335 2.4-3.666-1.5-3.262.484-2.059 1.812 1.926 2.125.949.218\n    3.472 1.33 2.029.895 4.471 1.106 3.875 1.781-1.8 2.042-1.424 3.395-4.613 5.787a18.738 18.738 0 0 0 1.285-.12 9.052\n    9.052 0 0 0 7.44-8.011 1.336 1.336 0 0 1-.64-.2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkGlobe" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkGlobe extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7B, create_fragment$7B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkNav.svelte generated by Svelte v3.24.1 */

function create_fragment$7C(ctx) {
	let svg;
	let path0;
	let path1;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(path0, "d", "M16 28.355a8.153 8.153 0 0 1-2.074-.531c-.52.52-1.5 1.547-1.713 1.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.585 4.585\n    0 0 1 3.366-1.292 4.061 4.061 0 0 1 2.162.692h3.753a7.1 7.1 0 0 0-1.2-1.622 7.311 7.311 0 0 0-10.26.048l-7.182\n    7.186a7.176 7.176 0 0 0 10.149 10.149c.216-.216.88-.9 1.612-1.641zM23.722 6.479a4.1 4.1 0 1 1 5.8 5.8L25.8\n    16h4.349l1.551-1.547A7.176 7.176 0 0 0 21.547 4.3c-.385.385-4.264 4.222-5.351 5.309a8.3 8.3 0 0 1\n    3.742.607c.521-.516 3.569-3.522 3.784-3.737z");
			attr(path1, "d", "M16 19.25a3.151 3.151 0 0 1-.909-1.3 2.041 2.041 0 0 0-.428.318l-1.636 1.712a7.164 7.164 0 0 0 1.227 1.673A6.165\n    6.165 0 0 0 16 22.833z");
			attr(rect0, "height", rect0_height_value = 3);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 18);
			attr(rect0, "x", rect0_x_value = 18);
			attr(rect0, "y", rect0_y_value = 18);
			attr(rect1, "height", rect1_height_value = 3);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 18);
			attr(rect1, "x", rect1_x_value = 18);
			attr(rect1, "y", rect1_y_value = 30);
			attr(rect2, "height", rect2_height_value = 3);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 18);
			attr(rect2, "x", rect2_x_value = 18);
			attr(rect2, "y", rect2_y_value = 24);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkNav" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkNav extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7C, create_fragment$7C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkOff.svelte generated by Svelte v3.24.1 */

function create_fragment$7D(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.136 9.523l-1.496 1.44-5.328-5.24 1.496-1.439 5.328 5.239zM31.801 30.277l-1.496 1.439-5.299-5.334 1.495-1.439\n    5.3 5.334zM11.057 1.8h2.314v4.629h-2.314zM1.8 11.057h4.629v2.314H1.8zM29.571 22.629H34.2v2.314h-4.629zM22.629\n    29.571h2.314V34.2h-2.314zM18.053 23.708l-5.84 5.878a4.101 4.101 0 0 1-5.8-5.8l5.858-5.858-2.171-2.174-5.861\n    5.858A7.176 7.176 0 0 0 14.388 31.76l5.842-5.874zM17.917 12.258l5.84-5.878a4.101 4.101 0 1 1 5.8 5.8l-5.858 5.858\n    2.171 2.174 5.861-5.858A7.176 7.176 0 1 0 21.582 4.206L15.74 10.08z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkOff" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkOff extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7D, create_fragment$7D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkOut.svelte generated by Svelte v3.24.1 */

function create_fragment$7E(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 18h-2a1 1 0 0 0-1 1v11H6V6h11a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0\n    1-1V19a1 1 0 0 0-1-1z");
			attr(path1, "d", "M33.5 2H22.754a.8.8 0 0 0-.754.8.784.784 0 0 0 .235.56l3.786 3.79-7.042 7.042a1 1 0 0 0 0 1.415l1.414 1.414a1 1 0\n    0 0 1.414 0l7.043-7.042 3.786 3.785A.781.781 0 0 0 33.2 14a.8.8 0 0 0 .8-.754V2.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7E, create_fragment$7E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkOutLight.svelte generated by Svelte v3.24.1 */

function create_fragment$7F(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M32 17.5V30H4V4h14.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H3a1 1 0 0 0-1 1v28a1 1 0 0 0 1 1h30a1 1 0 0 0\n    1-1V17.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5z");
			attr(path1, "d", "M23.54 2.853l3.389 3.39-9.546 9.546a.5.5 0 0 0 0 .707l2.117 2.121a.5.5 0 0 0 .707 0l9.546-9.546 3.389 3.389a.5.5\n    0 0 0 .858-.353V2H23.893a.5.5 0 0 0-.353.853z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkOutLight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkOutLight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7F, create_fragment$7F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkPage.svelte generated by Svelte v3.24.1 */

function create_fragment$7G(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 28.355a8.153 8.153 0 0 1-2.074-.531c-.52.52-1.5 1.547-1.713 1.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.585 4.585\n    0 0 1 3.366-1.292 4.061 4.061 0 0 1 2.162.692h3.753a7.1 7.1 0 0 0-1.2-1.622 7.311 7.311 0 0 0-10.26.048l-7.182\n    7.186a7.176 7.176 0 0 0 10.149 10.149c.216-.216.88-.9 1.612-1.641zM23.722 6.479a4.1 4.1 0 1 1 5.8 5.8L25.8\n    16h4.349l1.551-1.547A7.176 7.176 0 0 0 21.547 4.3c-.385.385-4.264 4.222-5.351 5.309a8.3 8.3 0 0 1\n    3.742.607c.521-.516 3.569-3.522 3.784-3.737z");
			attr(path1, "d", "M16 19.25a3.151 3.151 0 0 1-.909-1.3 2.041 2.041 0 0 0-.428.318l-1.636 1.712a7.164 7.164 0 0 0 1.227 1.673A6.165\n    6.165 0 0 0 16 22.833zM18 19v16a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1H19a1 1 0 0 0-1 1zm16 15H20V22h14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkPage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkPage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7G, create_fragment$7G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LinkUser.svelte generated by Svelte v3.24.1 */

function create_fragment$7H(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.231 28.412a8.242 8.242 0 0 1-3.306-.587c-.52.52-1.5 1.547-1.713 1.762a4.1 4.1 0 1 1-5.8-5.8L13.6 16.6a4.585\n    4.585 0 0 1 3.366-1.292 3.939 3.939 0 0 1 2.678 1.112 6.292 6.292 0 0 1 .523.609 6.64 6.64 0 0 1 2.022-2.057 6.413\n    6.413 0 0 0-.5-.594 7.311 7.311 0 0 0-10.26.048l-7.19 7.186A7.175 7.175 0 0 0 14.37 31.774a7.869 7.869 0 0 1\n    2.861-3.362zM23.722 6.479a4.1 4.1 0 1 1 5.8 5.8l-1.81 1.809a6.371 6.371 0 0 1 2.852 1.5l1.136-1.135A7.176 7.176 0 0\n    0 21.547 4.3c-.385.385-4.264 4.222-5.351 5.309a8.3 8.3 0 0 1 3.742.607c.521-.516 3.569-3.522 3.784-3.737z");
			attr(path1, "d", "M19.157 23.522a8.674 8.674 0 0 1-.236-1.865c0-.338.048-.652.078-.975a3.941 3.941 0 0 1-2.667-1.105 4.159 4.159 0\n    0 1-1.241-1.625 2.041 2.041 0 0 0-.428.318l-1.636 1.712a7.164 7.164 0 0 0 1.227 1.673 6.806 6.806 0 0 0 4.903\n    1.867zM28.668 28.227v-1.385a.958.958 0 0 1 .244-.618 7.317 7.317 0 0 0\n    1.664-4.566c0-3.455-1.833-5.386-4.6-5.386s-4.653 2.007-4.653 5.386a7.4 7.4 0 0 0 1.743 4.566.958.958 0 0 1\n    .244.619v1.379a.952.952 0 0 1-.83.96c-5.563.484-6.432 4.289-6.432 5.79 0\n    .167.02.823.032.987h19.843s.017-.82.017-.987c0-1.438-.983-5.23-6.445-5.785a.956.956 0 0 1-.827-.96z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LinkUser" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LinkUser extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7H, create_fragment$7H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Location.svelte generated by Svelte v3.24.1 */

function create_fragment$7I(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 1.925a12 12 0 0 0-12 12c0 6.627 12 21.75 12 21.75s12-15.123 12-21.75a12 12 0 0 0-12-12zm0 16.725A4.65 4.65 0\n    1 1 22.65 14 4.65 4.65 0 0 1 18 18.65z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Location" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Location extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7I, create_fragment$7I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LocationBasedDate.svelte generated by Svelte v3.24.1 */

function create_fragment$7J(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 8);
			attr(rect, "x", rect_x_value = 22);
			attr(rect, "y", rect_y_value = 16);
			attr(path0, "d", "M35 4h-5V1a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H14V1a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H5a1 1 0 0 0-1 1v6.109a10.633\n    10.633 0 0 1 2-.809V6h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h12v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h4v22H17.143a49.728\n    49.728 0 0 1-1.17 2H35a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			attr(path1, "d", "M9 12.367a8.25 8.25 0 0 0-8.25 8.25C.75 25.173 9 35.57 9 35.57s8.25-10.4 8.25-14.953A8.25 8.25 0 0 0 9 12.367zm0\n    11.75a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LocationBasedDate" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LocationBasedDate extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7J, create_fragment$7J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LocationBasedEvent.svelte generated by Svelte v3.24.1 */

function create_fragment$7K(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20.5 14.054a.494.494 0 0 0-.5.5v19.782a.494.494 0 0 0 .846.353L26.51 29h8c.446 0 .479-.726.225-.98L20.846\n    14.2a.489.489 0 0 0-.346-.146z");
			attr(path1, "d", "M2 2v10.476A10.735 10.735 0 0 1 6 10.3V6h22v11.158l4 4V2z");
			attr(path2, "d", "M9 12.367a8.25 8.25 0 0 0-8.25 8.25C.75 25.173 9 35.57 9 35.57s8.25-10.4 8.25-14.953A8.25 8.25 0 0 0 9 12.367zm0\n    11.75a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LocationBasedEvent" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LocationBasedEvent extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7K, create_fragment$7K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LocationContribution.svelte generated by Svelte v3.24.1 */

function create_fragment$7L(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M2 5v26a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm4 3h18v14H6zm0 20v-4h18v4zm24 0h-4V8h4z");
			attr(path1, "d", "M18.838 10.346l-4.988 7.127-2.84-2.573a.5.5 0 0 0-.706.035l-.939 1.038a.5.5 0 0 0 .035.706l3.84 3.476a1.21 1.21 0\n    0 0 1.8-.2l5.76-8.233a.5.5 0 0 0-.123-.7l-1.147-.8a.5.5 0 0 0-.692.124z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LocationContribution" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LocationContribution extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7L, create_fragment$7L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LockClosed.svelte generated by Svelte v3.24.1 */

function create_fragment$7M(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29 16h-1v-2a10 10 0 0 0-20 0v2H7a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V17a1 1 0 0 0-1-1zm-17-2a6 6 0 0\n    1 12 0v2H12zm8 12.222V29a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2.778a3 3 0 1 1 4 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LockClosed" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LockClosed extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7M, create_fragment$7M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LockOpen.svelte generated by Svelte v3.24.1 */

function create_fragment$7N(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29 16H11.9v-5.647A6.213 6.213 0 0 1 18 4a6.143 6.143 0 0 1 5.508 3.419c.31.639.266 1.146.777 1.146a.508.508 0 0\n    0 .186-.036l2.681-1.069a.513.513 0 0 0 .322-.471A9.92 9.92 0 0 0 18 .1C11.5.1 8 6.067 8 10.292V16H7a1 1 0 0 0-1\n    1v16a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V17a1 1 0 0 0-1-1zm-9 10.222V29a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2.778a3 3 0 1 1 4\n    0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LockOpen" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LockOpen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7N, create_fragment$7N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LogOut.svelte generated by Svelte v3.24.1 */

function create_fragment$7O(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 18);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 4);
			attr(rect, "x", rect_x_value = 16);
			attr(path, "d", "M25.215 5.063l-1.14 1.823a1.01 1.01 0 0 0 .337 1.384 11.738 11.738 0 1 1-12.82 0 1 1 0 0 0\n    .336-1.377l-1.144-1.831A1 1 0 0 0 9.4 4.731a15.9 15.9 0 1 0 17.191 0 1 1 0 0 0-1.376.332z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LogOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LogOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7O, create_fragment$7O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Login.svelte generated by Svelte v3.24.1 */

function create_fragment$7P(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M11.6 30.177a7.9 7.9 0 0 1 7.891-7.889 7.573 7.573 0 0 1 1.951.255l.9-.9c0-.032-.017-.062-.017-.1v-2.221a1.54\n    1.54 0 0 1 .392-.993A11.746 11.746 0 0 0 25.388 11c0-5.547-2.941-8.646-7.387-8.646s-7.47 3.221-7.47 8.646a11.873\n    11.873 0 0 0 2.8 7.33 1.54 1.54 0 0 1 .392.993v2.214a1.528 1.528 0 0 1-1.333 1.542c-8.931.777-10.326 6.886-10.326\n    9.3 0 .268.031 1.321.051 1.584h10.492a7.785 7.785 0 0 1-1.007-3.786z");
			attr(path1, "d", "M35.665 20.892l-3.942-3.942a.915.915 0 0 0-1.294 0l-8.393 8.393a5.428 5.428 0 0 0-2.547-.654 5.489 5.489 0 1 0\n    5.489 5.489 5.432 5.432 0 0 0-.64-2.521l4.1-4.1 2.281 2.281a.457.457 0 0 0 .647 0l2.04-2.04-2.6-2.6.751-.751 2.6 2.6\n    1.506-1.506a.457.457 0 0 0 .002-.649zM18.9 32.6a1.83 1.83 0 1 1 1.83-1.83 1.83 1.83 0 0 1-1.83 1.83z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Login" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Login extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7P, create_fragment$7P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Looks.svelte generated by Svelte v3.24.1 */

function create_fragment$7Q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.99 13.206c0-.07.01-.137.01-.206a11 11 0 0 0-22 0c0 .069.009.136.01.206A10.994 10.994 0 1 0 17 32.213a10.994\n    10.994 0 1 0 10.99-19.007zM17 29.664a8.925 8.925 0 0 1-2.94-6.073 10.771 10.771 0 0 0 5.88 0A8.925 8.925 0 0 1 17\n    29.664zM17 22a8.9 8.9 0 0 1-2.848-.5A8.929 8.929 0 0 1 17 16.336a8.929 8.929 0 0 1 2.848 5.16A8.9 8.9 0 0 1 17\n    22zm-4.736-1.376A8.961 8.961 0 0 1 8.152 14.5 8.9 8.9 0 0 1 11 14a8.9 8.9 0 0 1 4.308 1.144 10.978 10.978 0 0\n    0-3.044 5.48zm6.428-5.48a8.53 8.53 0 0 1 7.156-.64 8.961 8.961 0 0 1-4.112 6.12 10.978 10.978 0 0 0-3.044-5.48zM17\n    4a8.973 8.973 0 0 1 8.94 8.41A10.9 10.9 0 0 0 17 13.787a10.9 10.9 0 0 0-8.94-1.377A8.973 8.973 0 0 1 17 4zm-6\n    28a8.981 8.981 0 0 1-4.736-16.624A11.011 11.011 0 0 0 12.01 22.8c0 .069-.01.136-.01.2a10.961 10.961 0 0 0 3.308\n    7.856A8.894 8.894 0 0 1 11 32zm12 0a8.894 8.894 0 0 1-4.308-1.144A10.961 10.961 0 0 0 22\n    23c0-.069-.009-.136-.01-.2a11.011 11.011 0 0 0 5.746-7.419A8.981 8.981 0 0 1 23 32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Looks" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Looks extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7Q, create_fragment$7Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/LoupeView.svelte generated by Svelte v3.24.1 */

function create_fragment$7R(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr(rect, "height", rect_height_value = 32);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "LoupeView" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class LoupeView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7R, create_fragment$7R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MBox.svelte generated by Svelte v3.24.1 */

function create_fragment$7S(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 4H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-1 26H4V10h28z");
			attr(path1, "d", "M6 12h2v2H6zM6 22h2v2H6zM10 12h4v2h-4zM16 12h4v2h-4zM22 12h4v2h-4zM10 26h4v2h-4zM16 26h4v2h-4zM22 26h4v2h-4zM28\n    12h2v2h-2zM28 16h2v2h-2zM6 16h2v4H6zM28 20h2v4h-2zM6 26h2v2H6zM28 26h2v2h-2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MBox" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MBox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7S, create_fragment$7S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MagicWand.svelte generated by Svelte v3.24.1 */

function create_fragment$7T(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "transform", "rotate(-45 12.249 21.751)");
			attr(rect, "width", rect_width_value = 30.118);
			attr(rect, "x", rect_x_value = -2.811);
			attr(rect, "y", rect_y_value = 19.752);
			attr(path, "d", "M31.506 13.559l.078 2.156a1.756 1.756 0 0 0 .9 1.47l1.882 1.054-2.156.078a1.756 1.756 0 0 0-1.47.9L29.684\n    21.1l-.078-2.156a1.756 1.756 0 0 0-.9-1.47l-1.882-1.054 2.156-.078a1.759 1.759 0 0 0 1.47-.9zM29.732.1l.108\n    2.99a2.437 2.437 0 0 0 1.245 2.038L33.7 6.589l-2.99.108a2.434 2.434 0 0 0-2.039 1.245l-1.462 2.61-.109-2.99a2.44\n    2.44 0 0 0-1.245-2.039l-2.614-1.462 2.99-.108a2.439 2.439 0 0 0 2.039-1.245zM12.7 1.68l.139 3.851a3.138 3.138 0 0 0\n    1.6 2.625L17.8 10.04l-3.851.139a3.139 3.139 0 0 0-2.626 1.6l-1.88 3.365-.143-3.851a3.139 3.139 0 0 0-1.6-2.626L4.339\n    6.784l3.851-.139a3.141 3.141 0 0 0 2.626-1.6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MagicWand" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MagicWand extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7T, create_fragment$7T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Magnify.svelte generated by Svelte v3.24.1 */

function create_fragment$7U(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.173 30.215L25.4 22.443a12.826 12.826 0 1 0-2.957 2.957l7.772 7.772a2.1 2.1 0 0 0 2.958-2.958zM6 15a9 9 0 1 1\n    9 9 9 9 0 0 1-9-9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Magnify" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Magnify extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7U, create_fragment$7U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Mailbox.svelte generated by Svelte v3.24.1 */

function create_fragment$7V(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M5 8a5 5 0 0 0-5 5v16a1 1 0 0 0 1 1h11V13a5 5 0 0 0-5-5zM31 8H18v7a1 1 0 0 1-1 1h-3v14h21a1 1 0 0 0 1-1V13a5 5 0\n    0 0-5-5z");
			attr(path1, "d", "M21 0h-6a1 1 0 0 0-1 1v13h2V6h5a1 1 0 0 0 1-1V1a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Mailbox" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Mailbox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7V, create_fragment$7V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MapView.svelte generated by Svelte v3.24.1 */

function create_fragment$7W(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M25.6 2.106L18 5.905l-7.553-3.777a1 1 0 0 0-.894 0l-7 3.5A1 1 0 0 0 2 6.523v25.764a1 1 0 0 0 1.447.894L10\n    29.905l7.553 3.776a1 1 0 0 0 .894 0L26 29.905l8.629 3.451A1 1 0 0 0 36 32.428V6.582a1 1 0 0\n    0-.629-.929l-8.954-3.581a1 1 0 0 0-.817.034zM18 31.741l-8-4V4l8 4zm16-.711l-8-3.125v-24l8 3.125z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MapView" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MapView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7W, create_fragment$7W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MarginBottom.svelte generated by Svelte v3.24.1 */

function create_fragment$7X(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M32 3v14H4V3zm1-2H3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 10);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 23);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MarginBottom" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MarginBottom extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7X, create_fragment$7X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MarginLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$7Y(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M32 32H18V4h14zm2 1V3a1 1 0 0 0-1-1H17a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1z");
			attr(rect, "height", rect_height_value = 10);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "transform", "rotate(90 7 18)");
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = -9);
			attr(rect, "y", rect_y_value = 13);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MarginLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MarginLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7Y, create_fragment$7Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MarginRight.svelte generated by Svelte v3.24.1 */

function create_fragment$7Z(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M4 4h14v28H4zM2 3v30a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1z");
			attr(rect, "height", rect_height_value = 10);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "transform", "rotate(-90 29 18)");
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 13);
			attr(rect, "y", rect_y_value = 13);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MarginRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MarginRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7Z, create_fragment$7Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MarginTop.svelte generated by Svelte v3.24.1 */

function create_fragment$7_(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M4 32V18h28v14zm30 1V17a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1z");
			attr(rect, "height", rect_height_value = 10);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MarginTop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MarginTop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7_, create_fragment$7_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MarketingActivities.svelte generated by Svelte v3.24.1 */

function create_fragment$7$(ctx) {
	let svg;
	let path;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			attr(path, "d", "M25.865 6.9a4.853 4.853 0 0 1-1.508 1.315l3.91 4.729a4.859 4.859 0 0 1 1.559-1.253zm-16.85 8.869l4.268\n    3.386a4.843 4.843 0 0 1 1.312-1.512l-4.31-3.419a4.852 4.852 0 0 1-1.27 1.545zm12.71 3.4a4.79 4.79 0 0 1 .584\n    1.928l5.623-2.473a4.809 4.809 0 0 1-.706-1.875zM7.042 28.255A4.851 4.851 0 0 1 8.3 29.809l5.88-4.791a4.864 4.864 0 0\n    1-1.152-1.641zM10.136 9.5a4.8 4.8 0 0 1 .657 1.938L18.2 6.98a4.8 4.8 0 0 1-.89-1.8z");
			attr(circle0, "cx", circle0_cx_value = 4);
			attr(circle0, "cy", circle0_cy_value = 32);
			attr(circle0, "r", circle0_r_value = 3.85);
			attr(circle1, "cx", circle1_cx_value = 17.5);
			attr(circle1, "cy", circle1_cy_value = 21.5);
			attr(circle1, "r", circle1_r_value = 3.85);
			attr(circle2, "cx", circle2_cx_value = 22);
			attr(circle2, "cy", circle2_cy_value = 4);
			attr(circle2, "r", circle2_r_value = 3.85);
			attr(circle3, "cx", circle3_cx_value = 6);
			attr(circle3, "cy", circle3_cy_value = 12);
			attr(circle3, "r", circle3_r_value = 3.85);
			attr(circle4, "cx", circle4_cx_value = 32);
			attr(circle4, "cy", circle4_cy_value = 16);
			attr(circle4, "r", circle4_r_value = 3.85);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MarketingActivities" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MarketingActivities extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7$, create_fragment$7$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Maximize.svelte generated by Svelte v3.24.1 */

function create_fragment$80(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14.077 20.707a1 1 0 0 0-1.414 0l-6.484 6.484L3.2 24.206A.688.688 0 0 0 2.705 24a.7.7 0 0 0-.7.7v8.84a.5.5 0 0 0\n    .454.46H11.3a.7.7 0 0 0 .7-.7.685.685 0 0 0-.207-.49l-2.984-2.989 6.484-6.484a1 1 0 0 0 0-1.414zM33.541 2H24.7a.7.7\n    0 0 0-.7.705.685.685 0 0 0 .207.49l2.984 2.984-6.484 6.484a1 1 0 0 0 0 1.414l1.216 1.216a1 1 0 0 0 1.414\n    0l6.484-6.484 2.984 2.985A.688.688 0 0 0 33.3 12a.7.7 0 0 0 .7-.7V2.459A.5.5 0 0 0 33.541 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$80($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Maximize" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Maximize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$80, create_fragment$80, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Measure.svelte generated by Svelte v3.24.1 */

function create_fragment$81(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M25.071 2.444L2.444 25.071a1 1 0 0 0 0 1.414l7.071 7.071a1 1 0 0 0 1.414 0l3.535-3.535-5.3-5.3a.5.5 0 0 1\n    0-.707l.707-.707a.5.5 0 0 1 .707 0l5.3 5.3 5.657-5.657-3.89-3.889a.5.5 0 0 1 0-.707l.708-.708a.5.5 0 0 1 .707\n    0l3.889 3.89 5.657-5.657-5.3-5.3a.5.5 0 0 1 0-.707l.707-.707a.5.5 0 0 1 .708 0l5.3 5.3 3.535-3.535a1 1 0 0 0\n    0-1.414l-7.071-7.072a1 1 0 0 0-1.414 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$81($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Measure" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Measure extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$81, create_fragment$81, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Menu.svelte generated by Svelte v3.24.1 */

function create_fragment$82(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-5.394 13.707L18 25.314l-9.606-9.607A1 1\n    0 0 1 9.1 14h17.8a1 1 0 0 1 .706 1.707z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$82($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Menu" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Menu extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$82, create_fragment$82, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Merge.svelte generated by Svelte v3.24.1 */

function create_fragment$83(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.2 10.206a.688.688 0 0 0-.49-.206.7.7 0 0 0-.7.7V14H18V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1\n    1h9v14H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-9h8v3.3a.7.7 0 0 0 .7.7.688.688 0 0 0\n    .49-.206l5.685-6.469a.5.5 0 0 0 0-.65z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$83($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Merge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Merge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$83, create_fragment$83, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MergeLayers.svelte generated by Svelte v3.24.1 */

function create_fragment$84(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.62 23.319L24.479 18l8.134-5.315a.8.8 0 0 0 .007-1.366L18.629 2.178a1.2 1.2 0 0 0-1.258 0l-13.99 9.141a.8.8 0\n    0 0 0 1.362L11.521 18l-8.14 5.319a.8.8 0 0 0 0 1.362l13.99 9.141a1.2 1.2 0 0 0 1.249.006l13.993-9.143a.8.8 0 0 0\n    .007-1.366zm-8.856 2.047l-5.451 5.524a.5.5 0 0 1-.626 0l-5.451-5.524a.785.785 0 0 1-.236-.56.8.8 0 0 1\n    .8-.806h3.7v-5.836L7.318 12 18 4.829 28.682 12 19.5 18.164V24h3.7a.8.8 0 0 1 .8.806.785.785 0 0 1-.236.56z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$84($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MergeLayers" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MergeLayers extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$84, create_fragment$84, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Messenger.svelte generated by Svelte v3.24.1 */

function create_fragment$85(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2.323c-8.6 0-15.578 6.609-15.578 14.761A14.336 14.336 0 0 0 7.091 27.6v7.562l6.675-3.872a16.414 16.414 0 0 0\n    4.234.555c8.6 0 15.578-6.609 15.578-14.761S26.6 2.323 18 2.323zm1.639 19.713l-4.049-4.154L8.2 22l8.167-8.942 4.083\n    3.978 7.463-4.048z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$85($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Messenger" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Messenger extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$85, create_fragment$85, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Minimize.svelte generated by Svelte v3.24.1 */

function create_fragment$86(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.077 2.707a1 1 0 0 0-1.414 0l-6.484 6.484L21.2 6.206A.688.688 0 0 0 20.705 6a.7.7 0 0 0-.7.7v8.84a.5.5 0 0 0\n    .459.459H29.3a.7.7 0 0 0 .7-.7.685.685 0 0 0-.207-.49l-2.984-2.984 6.484-6.484a1 1 0 0 0 0-1.414zM15.541 20H6.7a.7.7\n    0 0 0-.7.7.685.685 0 0 0 .207.49l2.984 2.984-6.484 6.489a1 1 0 0 0 0 1.414l1.216 1.216a1 1 0 0 0 1.414 0l6.484-6.484\n    2.984 2.985A.688.688 0 0 0 15.3 30a.7.7 0 0 0 .7-.7v-8.84a.5.5 0 0 0-.459-.46z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$86($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Minimize" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Minimize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$86, create_fragment$86, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MobileServices.svelte generated by Svelte v3.24.1 */

function create_fragment$87(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M34 4H2a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h32a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm-4 24H4V8h26zm3-7.5a2.5 2.5 0 1 1\n    2.5-2.5 2.5 2.5 0 0 1-2.5 2.5z");
			attr(path1, "d", "M7.019 25.686a1.249 1.249 0 0 1-.707-.383 1.13 1.13 0 0 1 .094-1.647l4.252-3.668a.631.631 0 0 1 .854.041l2.357\n    2.4 4.667-7.27a.625.625 0 0 1 1.055.035l2.147 3.712 3.95-8.015a1.233 1.233 0 0 1 1.638-.5 1.159 1.159 0 0 1 .545\n    1.575l-5.507 10.923a.623.623 0 0 1-1.083.016l-2.291-3.959-4.276 6.661a.625.625 0 0 1-.963.085l-2.786-2.837-2.93\n    2.565a1.246 1.246 0 0 1-1.016.266z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$87($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MobileServices" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MobileServices extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$87, create_fragment$87, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ModernGridView.svelte generated by Svelte v3.24.1 */

function create_fragment$88(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 14);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 20);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 14);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 8);
			attr(rect1, "x", rect1_x_value = 26);
			attr(rect1, "y", rect1_y_value = 2);
			attr(rect2, "height", rect2_height_value = 14);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 8);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 20);
			attr(rect3, "height", rect3_height_value = 14);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 20);
			attr(rect3, "x", rect3_x_value = 14);
			attr(rect3, "y", rect3_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$88($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ModernGridView" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ModernGridView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$88, create_fragment$88, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Money.svelte generated by Svelte v3.24.1 */

function create_fragment$89(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 22);
			attr(circle, "cy", circle_cy_value = 14);
			attr(circle, "r", circle_r_value = 4);
			attr(path0, "d", "M8 21V7a1 1 0 0 1 1-1h26a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1zm26-9.343A6.016 6.016 0 0 1 30.343\n    8H13.657A6.015 6.015 0 0 1 10 11.657v4.686A6.016 6.016 0 0 1 13.657 20h16.686A6.015 6.015 0 0 1 34 16.343z");
			attr(path1, "d", "M33 26H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h1v16h28v1a1 1 0 0 1-1 1z");
			attr(path2, "d", "M29 30H1a1 1 0 0 1-1-1V13a1 1 0 0 1 1-1h1v16h28v1a1 1 0 0 1-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$89($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Money" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Money extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$89, create_fragment$89, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Monitoring.svelte generated by Svelte v3.24.1 */

function create_fragment$8a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35 2H1a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h13v3a1 1 0 0 1-1 1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-2a1\n    1 0 0 0-1-1h-2a1 1 0 0 1-1-1v-3h13a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-3 15.883h-7.778a1.378 1.378 0 0\n    1-1.237-.83l-2.3-5-4.249 8.072a1.368 1.368 0 0 1-1.2.757H15.2a1.383 1.383 0 0 1-1.2-.83l-1.845-4-1.065 1.317a1.337\n    1.337 0 0 1-1.041.514H4V14h5l2.428-3.609a1.346 1.346 0 0 1 1.217-.5 1.4 1.4 0 0 1 1.061.818l1.61 3.5\n    4.249-8.072a1.405 1.405 0 0 1 1.235-.761 1.378 1.378 0 0 1 1.2.829L25.5 14H32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Monitoring" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Monitoring extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8a, create_fragment$8a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Moon.svelte generated by Svelte v3.24.1 */

function create_fragment$8b(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm1 29.964c-.33.023-.664.036-1 .036a14 14 0 0 1 0-28c.336 0 .67.013 1\n    .036a22 22 0 0 0 0 27.928z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Moon" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Moon extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8b, create_fragment$8b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/More.svelte generated by Svelte v3.24.1 */

function create_fragment$8c(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = 17.8);
			attr(circle0, "cy", circle0_cy_value = 18.2);
			attr(circle0, "r", circle0_r_value = 3.4);
			attr(circle1, "cx", circle1_cx_value = 29.5);
			attr(circle1, "cy", circle1_cy_value = 18.2);
			attr(circle1, "r", circle1_r_value = 3.4);
			attr(circle2, "cx", circle2_cx_value = 6.1);
			attr(circle2, "cy", circle2_cy_value = 18.2);
			attr(circle2, "r", circle2_r_value = 3.4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "More" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class More extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8c, create_fragment$8c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoreCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$8d(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zM9.02 21.391A3.391 3.391 0 1 1 12.411 18a3.391 3.391 0 0 1-3.391\n    3.391zm8.981 0A3.391 3.391 0 1 1 21.391 18 3.392 3.392 0 0 1 18 21.391zm8.822 0A3.391 3.391 0 1 1 30.214 18a3.391\n    3.391 0 0 1-3.391 3.391z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoreCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoreCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8d, create_fragment$8d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoreSmall.svelte generated by Svelte v3.24.1 */

function create_fragment$8e(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = 17.8);
			attr(circle0, "cy", circle0_cy_value = 18.2);
			attr(circle0, "r", circle0_r_value = 3.4);
			attr(circle1, "cx", circle1_cx_value = 29.5);
			attr(circle1, "cy", circle1_cy_value = 18.2);
			attr(circle1, "r", circle1_r_value = 3.4);
			attr(circle2, "cx", circle2_cx_value = 6.1);
			attr(circle2, "cy", circle2_cy_value = 18.2);
			attr(circle2, "r", circle2_r_value = 3.4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoreSmall" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoreSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8e, create_fragment$8e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoreSmallList.svelte generated by Svelte v3.24.1 */

function create_fragment$8f(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = 9);
			attr(circle0, "cy", circle0_cy_value = 18);
			attr(circle0, "r", circle0_r_value = 2.85);
			attr(circle1, "cx", circle1_cx_value = 18);
			attr(circle1, "cy", circle1_cy_value = 18);
			attr(circle1, "r", circle1_r_value = 2.85);
			attr(circle2, "cx", circle2_cx_value = 27);
			attr(circle2, "cy", circle2_cy_value = 18);
			attr(circle2, "r", circle2_r_value = 2.85);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoreSmallList" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoreSmallList extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8f, create_fragment$8f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoreSmallListVert.svelte generated by Svelte v3.24.1 */

function create_fragment$8g(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = 18);
			attr(circle0, "cy", circle0_cy_value = 27);
			attr(circle0, "r", circle0_r_value = 2.85);
			attr(circle1, "cx", circle1_cx_value = 18);
			attr(circle1, "cy", circle1_cy_value = 18);
			attr(circle1, "r", circle1_r_value = 2.85);
			attr(circle2, "cx", circle2_cx_value = 18);
			attr(circle2, "cy", circle2_cy_value = 9);
			attr(circle2, "r", circle2_r_value = 2.85);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoreSmallListVert" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoreSmallListVert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8g, create_fragment$8g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoreVertical.svelte generated by Svelte v3.24.1 */

function create_fragment$8h(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = 18);
			attr(circle0, "cy", circle0_cy_value = 18);
			attr(circle0, "r", circle0_r_value = 4.1);
			attr(circle1, "cx", circle1_cx_value = 18);
			attr(circle1, "cy", circle1_cy_value = 6);
			attr(circle1, "r", circle1_r_value = 4.1);
			attr(circle2, "cx", circle2_cx_value = 18);
			attr(circle2, "cy", circle2_cy_value = 30);
			attr(circle2, "r", circle2_r_value = 4.1);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoreVertical" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoreVertical extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8h, create_fragment$8h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Move.svelte generated by Svelte v3.24.1 */

function create_fragment$8i(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34 18a.5.5 0 0 0-.113-.316L32 16.029V16h-.033l-2.113-1.853A.49.49 0 0 0 29.5 14a.5.5 0 0 0-.5.5V16h-9V7h1.5a.5.5\n    0 0 0 .5-.5.489.489 0 0 0-.147-.35L20 4.033V4h-.029l-1.655-1.887a.5.5 0 0 0-.632 0L16.029 4H16v.033l-1.853\n    2.113A.489.489 0 0 0 14 6.5a.5.5 0 0 0 .5.5H16v9H7v-1.5a.5.5 0 0 0-.5-.5.49.49 0 0 0-.35.147L4.033 16H4v.029l-1.887\n    1.655a.5.5 0 0 0 0 .632L4 19.971V20h.033l2.113 1.852A.491.491 0 0 0 6.5 22a.5.5 0 0 0 .5-.5V20h9v9h-1.5a.5.5 0 0\n    0-.5.5.487.487 0 0 0 .147.35L16 31.967V32h.029l1.655 1.887a.5.5 0 0 0 .632 0L19.971 32H20v-.033l1.853-2.114A.487.487\n    0 0 0 22 29.5a.5.5 0 0 0-.5-.5H20v-9h9v1.5a.5.5 0 0 0 .5.5.491.491 0 0 0 .35-.148L31.967\n    20H32v-.029l1.887-1.655A.5.5 0 0 0 34 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Move" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Move extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8i, create_fragment$8i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoveLeftRight.svelte generated by Svelte v3.24.1 */

function create_fragment$8j(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M6.311 10.483A1 1 0 0 1 8 11.2V14h6v6H8v2.778a1.006 1.006 0 0 1-1.707.722L0 17zM29.707 10.5a1.006 1.006 0 0\n    0-1.707.722V14h-6v6h6v2.8a1 1 0 0 0 1.689.715L36 17z");
			attr(rect, "height", rect_height_value = 30);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 4);
			attr(rect, "x", rect_x_value = 16);
			attr(rect, "y", rect_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoveLeftRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoveLeftRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8j, create_fragment$8j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoveTo.svelte generated by Svelte v3.24.1 */

function create_fragment$8k(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M21.879 20.344a1 1 0 0 1-1.414 0l-4.809-4.809a1 1 0 0 1 0-1.414L23.777 6H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1\n    0 0 0 1-1V12.223z");
			attr(path1, "d", "M23.707 2a.5.5 0 0 0-.353.854l3.482 3.482-8.136 8.139a.5.5 0 0 0 0 .707l2.118 2.118a.5.5 0 0 0 .707 0l8.139-8.139\n    3.482 3.483a.5.5 0 0 0 .854-.351V2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoveTo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoveTo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8k, create_fragment$8k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MoveUpDown.svelte generated by Svelte v3.24.1 */

function create_fragment$8l(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M23.517 6.311A1 1 0 0 1 22.8 8H20v6h-6V8h-2.778a1.006 1.006 0 0 1-.722-1.707L17 0zM23.5 29.707A1.006 1.006 0 0 0\n    22.778 28H20v-6h-6v6h-2.8a1 1 0 0 0-.715 1.689L17 36z");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 30);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 16);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MoveUpDown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MoveUpDown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8l, create_fragment$8l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MovieCamera.svelte generated by Svelte v3.24.1 */

function create_fragment$8m(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.4 10.2L24 16.5V9.818A1.818 1.818 0 0 0 22.182 8H5.818A1.818 1.818 0 0 0 4 9.818v16.364A1.818 1.818 0 0 0\n    5.818 28h16.364A1.818 1.818 0 0 0 24 26.182V19.5l8.4 6.3A1 1 0 0 0 34 25V11a1 1 0 0 0-1.6-.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MovieCamera" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MovieCamera extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8m, create_fragment$8m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Multiple.svelte generated by Svelte v3.24.1 */

function create_fragment$8n(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M31 4H21a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2v4h5a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 12);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 12);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 20);
			attr(path1, "d", "M23 12H13a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2v4h5a1 1 0 0 0 1-1V13a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Multiple" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Multiple extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8n, create_fragment$8n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MultipleAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$8o(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M29 2H19a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2v4h5a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 12);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 12);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 18);
			attr(path1, "d", "M16 18v3.492a12.351 12.351 0 0 1 6-5.733V11a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2zM27.1 18.2a8.9 8.9 0\n    1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-3.5v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3.5h-3.5a.5.5\n    0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3.5v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v3.5h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MultipleAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MultipleAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8o, create_fragment$8o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MultipleCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$8p(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M29 2H19a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2v4h5a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 12);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 12);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 18);
			attr(path1, "d", "M16 18v3.492a12.351 12.351 0 0 1 6-5.733V11a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2zM27.1 18.2a8.9 8.9 0\n    1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.128a.5.5 0 0 1 0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731\n    2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5 7.5a.5.5 0 0 1-.702-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MultipleCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MultipleCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8p, create_fragment$8p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/MultipleExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$8q(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M29 2H19a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2v4h5a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 12);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 12);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 18);
			attr(path1, "d", "M16 18v3.492a12.351 12.351 0 0 1 6-5.733V11a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v5h4a2 2 0 0 1 2 2zM27.1 18.2a8.9 8.9 0\n    1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-7 8.9a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966 0 0 1 20.1\n    27.1zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "MultipleExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class MultipleExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8q, create_fragment$8q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/NamingOrder.svelte generated by Svelte v3.24.1 */

function create_fragment$8r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.161 16.735L4.62 21.756c-.056.182-.141.244-.308.244h-2.8c-.169 0-.225-.091-.2-.3L7.085 3.857a5.029 5.029 0 0 0\n    .253-1.643c0-.123.056-.214.168-.214H11.4c.141 0 .168.03.2.183l6.471 19.543c.029.183 0 .274-.168.274h-3.141a.281.281\n    0 0 1-.281-.183l-1.625-5.082zm5.8-3.319c-.588-2.01-1.905-6.24-2.466-8.371h-.028c-.448 2.04-1.57 5.6-2.409\n    8.371zM19.226 34c-.113 0-.225-.03-.225-.244v-2.04a.692.692 0 0 1 .084-.365l9.722-14.064h-9.385c-.141\n    0-.225-.029-.2-.212l.42-2.831c.028-.182.112-.244.251-.244h13.033c.138 0 .168.062.168.183v2.192a.653.653 0 0\n    1-.141.426L23.4 30.683h10.03c.138 0 .2.091.138.274l-.447 2.8c-.027.182-.084.244-.252.244z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "NamingOrder" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class NamingOrder extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8r, create_fragment$8r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/NewItem.svelte generated by Svelte v3.24.1 */

function create_fragment$8s(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M31 4H5a1 1 0 0 0-1 1v13h13a1 1 0 0 1 1 1v13h13a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			attr(path1, "d", "M16 32h-.086a1 1 0 0 1-.707-.293L4.293 20.793A1 1 0 0 1 4 20.086V20h12z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "NewItem" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class NewItem extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8s, create_fragment$8s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/News.svelte generated by Svelte v3.24.1 */

function create_fragment$8t(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 6H5a1 1 0 0 0-1 1v20a1 1 0 0 1-2 0V10.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V27a3 3 0 0 0 3 3h28a3 3 0 0 0\n    3-3V7a1 1 0 0 0-1-1zm-2 22H6V8h26v19a1 1 0 0 1-1 1z");
			attr(path1, "d", "M20 12h10v2H20zM20 20h10v2H20zM8 24h10v2H8zM20 16h10v2H20zM20 24h10v2H20zM8 12h10v10H8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "News" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class News extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8t, create_fragment$8t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/NewsAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$8u(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 12h10v2H20z");
			attr(path1, "d", "M14.75 28H6V8h26v7.769a12.265 12.265 0 0 1 2 1.124V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v20a1 1 0 0 1-2 0V10.5a.5.5 0 0\n    0-.5-.5h-1a.5.5 0 0 0-.5.5V27a3 3 0 0 0 3 3h12.084a12.259 12.259 0 0 1-.334-2z");
			attr(path2, "d", "M21.52 16H20v.893A12.225 12.225 0 0 1 21.52 16zM18 18.635V12H8v10h7.769A12.3 12.3 0 0 1 18 18.635zM15.084\n    24H8v2h6.75a12.259 12.259 0 0 1 .334-2zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0\n    1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1\n    .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "NewsAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class NewsAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8u, create_fragment$8u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/NoEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$8v(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 43.854);
			attr(rect, "rx", rect_rx_value = 0.818);
			attr(rect, "ry", rect_ry_value = 0.818);
			attr(rect, "transform", "rotate(-45 18 18)");
			attr(rect, "width", rect_width_value = 2.455);
			attr(rect, "x", rect_x_value = 16.773);
			attr(rect, "y", rect_y_value = -3.927);
			attr(path, "d", "M11.181 17.275l-6.1 6.1a1 1 0 0 0-.251.421L2.056 33.1c-.114.376.459.85.783.85a.3.3 0 0 0 .061-.006c.276-.064\n    7.867-2.344 9.312-2.779a.974.974 0 0 0 .414-.249l6.1-6.1zM4.668 31.338l2.009-6.731 4.72 4.708c-2.161.65-4.862\n    1.466-6.729 2.023zM33.567 8.2L27.8 2.432a1.215 1.215 0 0 0-.867-.353H26.9a1.371 1.371 0 0 0-.927.406l-8.8 8.624\n    7.543 7.542 8.8-8.623a1.375 1.375 0 0 0 .4-.883 1.223 1.223 0 0 0-.349-.945z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "NoEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class NoEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8v, create_fragment$8v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Note.svelte generated by Svelte v3.24.1 */

function create_fragment$8w(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h11l3.536 6.839a.5.5 0 0 0 .928 0L22 28h11a1 1 0 0 0 1-1V3a1 1 0 0\n    0-1-1zM8.5 8h17a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-17a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm17 14h-17a.5.5 0 0\n    1-.5-.5v-1a.5.5 0 0 1 .5-.5h17a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5zm4-6h-21a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h21a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Note" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Note extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8w, create_fragment$8w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/NoteAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$8x(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			attr(path1, "d", "M14.8 27a12.13 12.13 0 0 1 1.08-5H8.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h8.519a12.233 12.233 0 0 1\n    4.732-4H8.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h21a.5.5 0 0 1 .5.5v.687a12.142 12.142 0 0 1 4 1.83V3a1 1 0 0\n    0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h9l3.536 6.839a.5.5 0 0 0 .928 0l.483-.934A12.139 12.139 0 0 1 14.8 27zM8\n    8.5a.5.5 0 0 1 .5-.5h17a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-17a.5.5 0 0 1-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "NoteAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class NoteAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8x, create_fragment$8x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OS.svelte generated by Svelte v3.24.1 */

function create_fragment$8y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M19.417 17.9c.029 6.035-3.7 9.97-9.008 9.97-5.656 0-9.037-4.2-9.037-9.883 0-5.6 3.673-9.854 9.037-9.854\n    5.713-.001 8.979 4.367 9.008 9.767zm-8.891 6.851c3.294 0 5.277-2.711 5.247-6.763\n    0-4.081-2.011-6.734-5.422-6.734-3.09 0-5.335 2.42-5.335 6.734-.001 3.758 1.923 6.761 5.509 6.761zM22.185\n    26.819a.433.433 0 0 1-.2-.437V23.35c0-.117.117-.175.233-.117a9.81 9.81 0 0 0 5.182 1.516c2.39 0 3.411-.933\n    3.411-2.187 0-1.079-.7-1.895-2.915-2.828l-1.4-.583c-3.586-1.516-4.519-3.323-4.519-5.51 0-3.119 2.361-5.51\n    6.763-5.51a10.69 10.69 0 0 1 4.46.758c.146.087.175.175.175.379V12.1c0 .117-.088.233-.263.117a9.107 9.107 0 0\n    0-4.4-.962c-2.507 0-3.294 1.05-3.294 2.07 0 1.05.671 1.778 2.974 2.74l1.108.466c3.79 1.574 4.868 3.411 4.868 5.714 0\n    3.411-2.682 5.626-7.084 5.626a11.094 11.094 0 0 1-5.099-1.052z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OS" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OS extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8y, create_fragment$8y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Offer.svelte generated by Svelte v3.24.1 */

function create_fragment$8z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.26 10.911l1.993 5.228 5.629.264a.233.233 0 0 1 .136.415l-4.4 3.5 1.489 5.382a.235.235 0 0\n    1-.356.256l-4.711-3.063-4.711 3.068a.235.235 0 0 1-.356-.256l1.486-5.391-4.4-3.5a.233.233 0 0 1 .141-.414l5.629-.264\n    1.993-5.228a.236.236 0 0 1 .438.003zM2 28H0v2a2 2 0 0 0 2 2h4v-2H2zM6 4h4v2H6zM8 30h4v2H8zM0 10h2v4H0zM2 6h2V4H2a2 2\n    0 0 0-2 2v2h2zM0 16h2v4H0zM0 22h2v4H0zM34 10h2v4h-2zM34 16h2v4h-2zM34 22h2v4h-2zM14 30h4v2h-4zM12 4h4v2h-4zM34\n    4h-4v2h4v2h2V6a2 2 0 0 0-2-2zM18 4h4v2h-4zM34 30h-2v2h2a2 2 0 0 0 2-2v-2h-2zM26 30h4v2h-4zM20 30h4v2h-4zM24\n    4h4v2h-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Offer" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Offer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8z, create_fragment$8z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OfferDelete.svelte generated by Svelte v3.24.1 */

function create_fragment$8A(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 4h-4v2h4zm6 0h-4v2h4zM2 6h2V4H2a2 2 0 0 0-2 2v2h2zm32 8h2v-4h-2zm0 2.893a12.279 12.279 0 0 1 2\n    1.743V16h-2zM24 6h4V4h-4zm10-2h-4v2h4v2h2V6a2 2 0 0 0-2-2zM2 10H0v4h2zm0 6H0v4h2zm16.213-1.861L16.22 8.911a.235.235\n    0 0 0-.439 0l-1.993 5.228-5.63.261a.233.233 0 0 0-.137.415l4.4 3.5-1.487 5.385a.234.234 0 0 0 .355.257L16\n    20.894l.238.155a12.322 12.322 0 0 1 7.235-5.83l.5-.4a.233.233 0 0 0-.137-.415zM14 30v2h1.769a12.223 12.223 0 0\n    1-.685-2zm-6 2h4v-2H8zm2-28H6v2h4zM2 22H0v4h2zm0 6H0v2a2 2 0 0 0 2 2h4v-2H2zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0\n    0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OfferDelete" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OfferDelete extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8A, create_fragment$8A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OnAir.svelte generated by Svelte v3.24.1 */

function create_fragment$8B(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M21.812 18.678a.5.5 0 0 0-.107.678l.574.823a.5.5 0 0 0 .716.115 8 8 0 1 0-9.971.015.5.5 0 0 0\n    .718-.117l.571-.824a.5.5 0 0 0-.109-.679 6 6 0 0 1 5.26-10.471 5.913 5.913 0 0 1 3.991 3.3 6.02 6.02 0 0 1-1.643\n    7.16z");
			attr(path1, "d", "M16.419 1.094a13 13 0 0 0-6.244 23.288.508.508 0 0 0 .717-.122l.569-.821a.5.5 0 0 0-.116-.681 11 11 0 1 1\n    13.337-.019.5.5 0 0 0-.115.68l.573.821a.506.506 0 0 0 .715.119 13 13 0 0 0-9.436-23.265z");
			attr(path2, "d", "M19.4 17.2a3.5 3.5 0 1 0-2.809 0L11.75 33.356a.5.5 0 0 0 .479.644h1.043a.5.5 0 0 0 .479-.356L15.443\n    28h5.113l1.693 5.644a.5.5 0 0 0 .479.356h1.043a.5.5 0 0 0 .479-.644zM16 14a2 2 0 1 1 2 2 2 2 0 0 1-2-2zm.043 12L18\n    19.477 19.957 26z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OnAir" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OnAir extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8B, create_fragment$8B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OpenIn.svelte generated by Svelte v3.24.1 */

function create_fragment$8C(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 2H3a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V6h24v24H19a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h14a1 1 0 0 0\n    1-1V3a1 1 0 0 0-1-1z");
			attr(path1, "d", "M18.636 27.764A.781.781 0 0 0 19.2 28a.8.8 0 0 0 .8-.754V16.5a.5.5 0 0 0-.5-.5H8.754a.8.8 0 0 0-.754.8.784.784 0\n    0 0 .235.56l3.786 3.786-9.042 9.046a1 1 0 0 0 0 1.415l1.414 1.414a1 1 0 0 0 1.414 0l9.043-9.042z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OpenIn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OpenIn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8C, create_fragment$8C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OpenInLight.svelte generated by Svelte v3.24.1 */

function create_fragment$8D(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M4 15.5V4h28v26H18.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H33a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v12.5a.5.5\n    0 0 0 .5.5h1a.5.5 0 0 0 .5-.5z");
			attr(path1, "d", "M5.54 18.853l3.389 3.39-7.546 7.546a.5.5 0 0 0 0 .707L3.5 32.617a.5.5 0 0 0 .707 0l7.546-7.546 3.389 3.389a.5.5 0\n    0 0 .858-.353V18H5.893a.5.5 0 0 0-.353.853z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OpenInLight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OpenInLight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8D, create_fragment$8D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OpenRecent.svelte generated by Svelte v3.24.1 */

function create_fragment$8E(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27.1 18.1A8.9 8.9 0 1 0 36 27a8.9 8.9 0 0 0-8.9-8.9zm0 16a7.1 7.1 0 0 1-1-14.121V27a1 1 0 0 0 .293.707l3.022\n    3.023a.5.5 0 0 0 .708 0l.707-.708a.5.5 0 0 0 0-.707l-2.73-2.729v-6.608a7.1 7.1 0 0 1-1 14.122z");
			attr(path1, "d", "M15.8 27a11.289 11.289 0 0 1 18.565-8.642l1.128-3.007A1 1 0 0 0 34.557 14H30V9a1 1 0 0\n    0-1-1l-12.332.008-3.3-3.4A2 2 0 0 0 11.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h13.216a11.254 11.254 0 0\n    1-.416-3zM7.757 14.649L4 24.667V6h7.929l3.305 3.4.59.607h.845L28 10v4H8.693a1 1 0 0 0-.936.649z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OpenRecent" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OpenRecent extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8E, create_fragment$8E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OpenRecentOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$8F(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16.051 28H4l4.689-14h24.536l-1.093 3.279a10.983 10.983 0 0 1 1.729 1.138l1.7-5.1A1 1 0 0 0 34.613 12H32V9a1 1 0\n    0 0-1-1l-12.332.007-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h13.427a10.837 10.837 0 0 1-.376-2z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm0 16a7.1 7.1 0 0 1-1-14.121V27a1 1 0 0 0 .293.707l3.023\n    3.023a.5.5 0 0 0 .707 0l.707-.708a.5.5 0 0 0 0-.707L28 26.586v-6.608A7.1 7.1 0 0 1 27 34.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OpenRecentOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OpenRecentOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8F, create_fragment$8F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Orbit.svelte generated by Svelte v3.24.1 */

function create_fragment$8G(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.757 13.871A7.983 7.983 0 0 0 12.7 8.748a25.63 25.63 0 0 0-1.948-.09C5.305 8.658 1.157 10.549.2 14c-1.04 3.769\n    2.038 8.372 7.356 11.946l-2.847 3.415a.381.381 0 0 0 .291.625h12.9l-5.81-8.716a.382.382 0 0 0-.61-.033L9.511\n    23.6c-4.5-2.942-7-6.5-6.371-8.787.522-1.888 3.512-3.108 7.617-3.108.411 0 .842.036 1.266.061 0\n    .08-.023.154-.023.234a7.985 7.985 0 0 0 14.477 4.664c4.4 2.921 6.809 6.428 6.182 8.69-.521 1.888-3.511 3.108-7.614\n    3.108a20.33 20.33 0 0 1-1.74-.082.761.761 0 0 0-.835.751v1.532a.772.772 0 0 0 .706.767c.637.05 1.262.079 1.869.079\n    5.45 0 9.6-1.891 10.552-5.342 1.076-3.888-2.209-8.678-7.84-12.296z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Orbit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Orbit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8G, create_fragment$8G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Organisations.svelte generated by Svelte v3.24.1 */

function create_fragment$8H(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 2H15a1 1 0 0 0-1 1v11h10v20h9a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-11 8h-6V6h6zm10\n    16h-6v-4h6zm0-8h-6v-4h6zm0-8h-6V6h6z");
			attr(path1, "d", "M2 17v16a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V17a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm12 1h6v4h-6zM4 18h6v4H4zm0 8h6v4H4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Organisations" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Organisations extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8H, create_fragment$8H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Organize.svelte generated by Svelte v3.24.1 */

function create_fragment$8I(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14 8H2V5a1 1 0 0 1 1-1h6.586a1 1 0 0 1 .707.293zM33 10H2v21a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1zm-21\n    4.5a.5.5 0 0 1 .5-.5h14a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-14a.5.5 0 0 1-.5-.5zM8.5 27.75a.75.75 0 0\n    1-.75.75h-1.5a.75.75 0 0 1-.75-.75v-1.5a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75zm0-6a.75.75 0 0\n    1-.75.75h-1.5a.75.75 0 0 1-.75-.75v-1.5a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75zm0-6a.75.75 0 0\n    1-.75.75h-1.5a.75.75 0 0 1-.75-.75v-1.5a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75zM25 27.5a.5.5 0 0\n    1-.5.5h-12a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h12a.5.5 0 0 1 .5.5zm6-6a.5.5 0 0 1-.5.5h-18a.5.5 0 0 1-.5-.5v-1a.5.5\n    0 0 1 .5-.5h18a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Organize" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Organize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8I, create_fragment$8I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/OutlinePath.svelte generated by Svelte v3.24.1 */

function create_fragment$8J(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10.5 22H6V6h16v4.5h2V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h5.5zM31 12h-5.5v2H30v16H14v-4.5h-2V31a1 1\n    0 0 0 1 1h18a1 1 0 0 0 1-1V13a1 1 0 0 0-1-1z");
			attr(path1, "d", "M22 15.5V22h-6.5v2H23a1 1 0 0 0 1-1v-7.5zM20.5 12H13a1 1 0 0 0-1 1v7.5h2V14h6.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "OutlinePath" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class OutlinePath extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8J, create_fragment$8J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PaddingBottom.svelte generated by Svelte v3.24.1 */

function create_fragment$8K(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M32 4v28H4V4zm1-2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 6);
			attr(rect, "y", rect_y_value = 22);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PaddingBottom" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PaddingBottom extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8K, create_fragment$8K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PaddingLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$8L(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M32 32H4V4h28zm2 1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1z");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "transform", "rotate(90 10 18)");
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = -2);
			attr(rect, "y", rect_y_value = 14);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PaddingLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PaddingLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8L, create_fragment$8L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PaddingRight.svelte generated by Svelte v3.24.1 */

function create_fragment$8M(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M4 3h28v28H4zM3 33h30a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1z");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "transform", "rotate(90 26 17)");
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 14);
			attr(rect, "y", rect_y_value = 13);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PaddingRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PaddingRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8M, create_fragment$8M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PaddingTop.svelte generated by Svelte v3.24.1 */

function create_fragment$8N(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M4 31V3h28v28zm30 1V2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1z");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 6);
			attr(rect, "y", rect_y_value = 5);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PaddingTop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PaddingTop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8N, create_fragment$8N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PageBreak.svelte generated by Svelte v3.24.1 */

function create_fragment$8O(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 14v10h10L20 14zM6 11a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V2H6z");
			attr(path1, "d", "M19 26a1 1 0 0 1-1-1V14H7a1 1 0 0 0-1 1v19h24v-8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PageBreak" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PageBreak extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8O, create_fragment$8O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PageExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$8P(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.059 30H2V10h28v5.184a12.273 12.273 0 0 1 2 .685V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h14.721a12.177 12.177 0 0 1-.662-2z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PageExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PageExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8P, create_fragment$8P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PageGear.svelte generated by Svelte v3.24.1 */

function create_fragment$8Q(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M34.925 24.678H32.61a6.69 6.69 0 0 0-.977-2.373l1.648-1.648a.661.661 0 0 0 0-.935l-1-1a.661.661 0 0 0-.935 0L29.7\n    20.368a6.693 6.693 0 0 0-2.373-.978v-2.314a.661.661 0 0 0-.661-.661h-1.327a.661.661 0 0 0-.661.661v2.315a6.692 6.692\n    0 0 0-2.373.978l-1.648-1.649a.661.661 0 0 0-.935 0l-1 1a.661.661 0 0 0 0 .935l1.648 1.648a6.69 6.69 0 0 0-.977\n    2.373h-2.317a.661.661 0 0 0-.661.661v1.322a.661.661 0 0 0 .661.661h2.315a6.69 6.69 0 0 0 .977 2.373l-1.648\n    1.651a.661.661 0 0 0 0 .935l1 1a.661.661 0 0 0 .935 0l1.648-1.648a6.692 6.692 0 0 0 2.373.977v2.315a.661.661 0 0 0\n    .661.661h1.322a.661.661 0 0 0 .661-.661V32.61a6.693 6.693 0 0 0 2.373-.977l1.648 1.648a.661.661 0 0 0 .935\n    0l1-1a.661.661 0 0 0 0-.935L31.632 29.7a6.69 6.69 0 0 0 .977-2.373h2.315a.661.661 0 0 0 .661-.661v-1.327a.661.661 0\n    0 0-.66-.661zM26 29.6a3.6 3.6 0 1 1 3.6-3.6 3.6 3.6 0 0 1-3.6 3.6z");
			attr(path1, "d", "M14.684 30H4V10h28v5.605a12.069 12.069 0 0 1 2 1.451V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h12.605a12.027 12.027 0 0 1-.921-2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PageGear" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PageGear extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8Q, create_fragment$8Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PageRule.svelte generated by Svelte v3.24.1 */

function create_fragment$8R(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M34.875 4H1.125A1.147 1.147 0 0 0 0 5.167v25.666A1.147 1.147 0 0 0 1.125 32h33.75A1.147 1.147 0 0 0 36\n    30.833V5.167A1.147 1.147 0 0 0 34.875 4zM34 30H2V8h32z");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 28);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 12);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PageRule" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PageRule extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8R, create_fragment$8R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PageShare.svelte generated by Svelte v3.24.1 */

function create_fragment$8S(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M29.722 18.331L24 12l-5.708 6.331A1 1 0 0 0 19.035 20H22v7.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V20h2.979a1 1 0 0\n    0 .743-1.669z");
			attr(path1, "d", "M30 22v10H18V22h-3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V23a1 1 0 0 0-1-1z");
			attr(path2, "d", "M12 30H4V10h28v10h2V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PageShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PageShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8S, create_fragment$8S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PageTag.svelte generated by Svelte v3.24.1 */

function create_fragment$8T(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16.2 30H2V10h28v6.2l2 2V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h17.2z");
			attr(path1, "d", "M35.668 26.106l-9.88-9.879a.772.772 0 0 0-.546-.227h-8.47a.772.772 0 0 0-.772.772v8.471a.772.772 0 0 0\n    .226.546l9.879 9.88a.772.772 0 0 0 1.092 0l8.471-8.469a.772.772 0 0 0 0-1.094zM20.4 22.948a2.548 2.548 0 1 1\n    2.548-2.548 2.548 2.548 0 0 1-2.548 2.548z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PageTag" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PageTag extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8T, create_fragment$8T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PagesExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$8U(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M2 6h26V3a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h1z");
			attr(path1, "d", "M15.721 32H6V14h24v1.184a12.273 12.273 0 0 1 2 .685V9a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v24a1 1 0 0 0 1\n    1h11.818a12.266 12.266 0 0 1-1.097-2z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PagesExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PagesExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8U, create_fragment$8U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Pan.svelte generated by Svelte v3.24.1 */

function create_fragment$8V(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31.647 9.806c-.938-.335-1.971.5-2.406 1.524l-2.7\n    4.846c-.2.461-.7.889-1.062.708s-.46-.668-.278-1.45l1.3-8.858a2.278 2.278 0 0 0-1.714-2.871 2.1 2.1 0 0 0-2.116\n    1.8l-1.236 8.258s-.09 1.073-.826 1.036-.657-1.134-.657-1.134v-9.66a2.145 2.145 0 0 0-1.968-2.286 2.145 2.145 0 0\n    0-1.969 2.286v9.62c0 .6-.791.589-.938.093-.677-2.294-2.166-7.483-2.166-7.483A2.053 2.053 0 0 0 10.7 4.6a2.324 2.324\n    0 0 0-1.554 2.991l2.682 9.057a8.658 8.658 0 0 1 .247 1.229 2.08 2.08 0 0 1-.739\n    2.1c-.383.254-5.315-2.882-5.315-2.882-1.968-1.555-3.182-1.017-3.691-.317-.542.745-.164 1.968.617 2.91l6.969\n    6.993a4.155 4.155 0 0 1 .43.7 26.63 26.63 0 0 0 2.054 3.672c1.378 1.752 3.331 2.666 6.234 2.666 3.664 0 6.382-1.626\n    7.35-4.266.656-2.21 1.277-5.192 1.575-6.23.194-.678 4.965-10.393 4.965-10.393.533-1.242.317-2.597-.877-3.024z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Pan" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Pan extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8V, create_fragment$8V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Panel.svelte generated by Svelte v3.24.1 */

function create_fragment$8W(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 3);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 16);
			attr(rect0, "x", rect0_x_value = 10);
			attr(rect0, "y", rect0_y_value = 30);
			attr(rect1, "height", rect1_height_value = 3);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 16);
			attr(rect1, "x", rect1_x_value = 10);
			attr(rect1, "y", rect1_y_value = 8);
			attr(rect2, "height", rect2_height_value = 3);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 16);
			attr(rect2, "x", rect2_x_value = 10);
			attr(rect2, "y", rect2_y_value = 14);
			attr(path, "d", "M30.5 2h-25A1.5 1.5 0 0 0 4 3.5V34h2v-8h24v8h2V3.5A1.5 1.5 0 0 0 30.5 2zM30 22H6V4h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Panel" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Panel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8W, create_fragment$8W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Paste.svelte generated by Svelte v3.24.1 */

function create_fragment$8X(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M28 6v5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V6H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1z");
			attr(path1, "d", "M22 6V4a4 4 0 0 0-8 0v2h-4v4h16V6zm-2 0h-4V4a2 2 0 0 1 4 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Paste" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Paste extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8X, create_fragment$8X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PasteHTML.svelte generated by Svelte v3.24.1 */

function create_fragment$8Y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M22 6V4a4 4 0 0 0-8 0v2h-4v4h16V6zm-2 0h-4V4a2 2 0 0 1 4 0z");
			attr(path1, "d", "M31 6h-3v5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V6H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0\n    0-1-1zM14.049 25.183a.4.4 0 0 1 0 .563l-1.688 1.688a.4.4 0 0 1-.563 0l-4.871-4.871a.8.8 0 0 1\n    0-1.125l4.873-4.872a.4.4 0 0 1 .563 0l1.688 1.688a.4.4 0 0 1 0 .563L10.866 22zm3.833 4.7a.4.4 0 0\n    1-.468.312l-2.34-.468a.4.4 0 0 1-.313-.468l3.027-15.139a.4.4 0 0 1 .468-.312l2.341.468a.4.4 0 0 1\n    .312.468zm11.191-7.318L24.2 27.434a.4.4 0 0 1-.563 0l-1.688-1.688a.4.4 0 0 1 0-.563L25.134 22l-3.183-3.183a.4.4 0 0\n    1 0-.563l1.688-1.688a.4.4 0 0 1 .563 0l4.871 4.871a.8.8 0 0 1 0 1.126z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PasteHTML" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PasteHTML extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8Y, create_fragment$8Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PasteList.svelte generated by Svelte v3.24.1 */

function create_fragment$8Z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M22 6V4a4 4 0 0 0-8 0v2h-4v4h16V6zm-2 0h-4V4a2 2 0 0 1 4 0z");
			attr(path1, "d", "M31 6h-3v5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V6H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM12\n    27a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1zm0-8a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1\n    1-1h2a1 1 0 0 1 1 1zm14 6.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5zm0-8a.5.5 0 0\n    1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PasteList" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PasteList extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8Z, create_fragment$8Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PasteText.svelte generated by Svelte v3.24.1 */

function create_fragment$8_(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M22 6V4a4 4 0 0 0-8 0v2h-4v4h16V6zm-2 0h-4V4a2 2 0 0 1 4 0z");
			attr(path1, "d", "M31 6h-3v5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V6H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-5\n    13.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V18h-4v10h1.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-1a.5.5\n    0 0 1 .5-.5H16V18h-4v1.473a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V16.5a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PasteText" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PasteText extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8_, create_fragment$8_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Pattern.svelte generated by Svelte v3.24.1 */

function create_fragment$8$(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let rect8;
	let rect8_height_value;
	let rect8_rx_value;
	let rect8_ry_value;
	let rect8_width_value;
	let rect8_x_value;
	let rect8_y_value;
	let rect9;
	let rect9_height_value;
	let rect9_rx_value;
	let rect9_ry_value;
	let rect9_width_value;
	let rect9_x_value;
	let rect9_y_value;
	let rect10;
	let rect10_height_value;
	let rect10_rx_value;
	let rect10_ry_value;
	let rect10_width_value;
	let rect10_x_value;
	let rect10_y_value;
	let rect11;
	let rect11_height_value;
	let rect11_rx_value;
	let rect11_ry_value;
	let rect11_width_value;
	let rect11_x_value;
	let rect11_y_value;
	let rect12;
	let rect12_height_value;
	let rect12_rx_value;
	let rect12_ry_value;
	let rect12_width_value;
	let rect12_x_value;
	let rect12_y_value;
	let rect13;
	let rect13_height_value;
	let rect13_rx_value;
	let rect13_ry_value;
	let rect13_width_value;
	let rect13_x_value;
	let rect13_y_value;
	let rect14;
	let rect14_height_value;
	let rect14_rx_value;
	let rect14_ry_value;
	let rect14_width_value;
	let rect14_x_value;
	let rect14_y_value;
	let rect15;
	let rect15_height_value;
	let rect15_rx_value;
	let rect15_ry_value;
	let rect15_width_value;
	let rect15_x_value;
	let rect15_y_value;
	let rect16;
	let rect16_height_value;
	let rect16_rx_value;
	let rect16_ry_value;
	let rect16_width_value;
	let rect16_x_value;
	let rect16_y_value;
	let rect17;
	let rect17_height_value;
	let rect17_rx_value;
	let rect17_ry_value;
	let rect17_width_value;
	let rect17_x_value;
	let rect17_y_value;
	let rect18;
	let rect18_height_value;
	let rect18_rx_value;
	let rect18_ry_value;
	let rect18_width_value;
	let rect18_x_value;
	let rect18_y_value;
	let rect19;
	let rect19_height_value;
	let rect19_rx_value;
	let rect19_ry_value;
	let rect19_width_value;
	let rect19_x_value;
	let rect19_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			rect8 = svg_element("rect");
			rect9 = svg_element("rect");
			rect10 = svg_element("rect");
			rect11 = svg_element("rect");
			rect12 = svg_element("rect");
			rect13 = svg_element("rect");
			rect14 = svg_element("rect");
			rect15 = svg_element("rect");
			rect16 = svg_element("rect");
			rect17 = svg_element("rect");
			rect18 = svg_element("rect");
			rect19 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 8);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 2);
			attr(rect1, "x", rect1_x_value = 10);
			attr(rect1, "y", rect1_y_value = 2);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 4);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 6);
			attr(rect3, "x", rect3_x_value = 26);
			attr(rect3, "y", rect3_y_value = 4);
			attr(rect4, "height", rect4_height_value = 8);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 22);
			attr(rect4, "y", rect4_y_value = 2);
			attr(rect5, "height", rect5_height_value = 4);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 6);
			attr(rect5, "x", rect5_x_value = 2);
			attr(rect5, "y", rect5_y_value = 20);
			attr(rect6, "height", rect6_height_value = 8);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 10);
			attr(rect6, "y", rect6_y_value = 18);
			attr(rect7, "height", rect7_height_value = 4);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 6);
			attr(rect7, "x", rect7_x_value = 14);
			attr(rect7, "y", rect7_y_value = 20);
			attr(rect8, "height", rect8_height_value = 4);
			attr(rect8, "rx", rect8_rx_value = 0.5);
			attr(rect8, "ry", rect8_ry_value = 0.5);
			attr(rect8, "width", rect8_width_value = 6);
			attr(rect8, "x", rect8_x_value = 26);
			attr(rect8, "y", rect8_y_value = 20);
			attr(rect9, "height", rect9_height_value = 8);
			attr(rect9, "rx", rect9_rx_value = 0.5);
			attr(rect9, "ry", rect9_ry_value = 0.5);
			attr(rect9, "width", rect9_width_value = 2);
			attr(rect9, "x", rect9_x_value = 22);
			attr(rect9, "y", rect9_y_value = 18);
			attr(rect10, "height", rect10_height_value = 8);
			attr(rect10, "rx", rect10_rx_value = 0.5);
			attr(rect10, "ry", rect10_ry_value = 0.5);
			attr(rect10, "width", rect10_width_value = 2);
			attr(rect10, "x", rect10_x_value = 4);
			attr(rect10, "y", rect10_y_value = 10);
			attr(rect11, "height", rect11_height_value = 4);
			attr(rect11, "rx", rect11_rx_value = 0.5);
			attr(rect11, "ry", rect11_ry_value = 0.5);
			attr(rect11, "width", rect11_width_value = 6);
			attr(rect11, "x", rect11_x_value = 8);
			attr(rect11, "y", rect11_y_value = 12);
			attr(rect12, "height", rect12_height_value = 4);
			attr(rect12, "rx", rect12_rx_value = 0.5);
			attr(rect12, "ry", rect12_ry_value = 0.5);
			attr(rect12, "width", rect12_width_value = 6);
			attr(rect12, "x", rect12_x_value = 20);
			attr(rect12, "y", rect12_y_value = 12);
			attr(rect13, "height", rect13_height_value = 8);
			attr(rect13, "rx", rect13_rx_value = 0.5);
			attr(rect13, "ry", rect13_ry_value = 0.5);
			attr(rect13, "width", rect13_width_value = 2);
			attr(rect13, "x", rect13_x_value = 16);
			attr(rect13, "y", rect13_y_value = 10);
			attr(rect14, "height", rect14_height_value = 8);
			attr(rect14, "rx", rect14_rx_value = 0.5);
			attr(rect14, "ry", rect14_ry_value = 0.5);
			attr(rect14, "width", rect14_width_value = 2);
			attr(rect14, "x", rect14_x_value = 28);
			attr(rect14, "y", rect14_y_value = 10);
			attr(rect15, "height", rect15_height_value = 8);
			attr(rect15, "rx", rect15_rx_value = 0.5);
			attr(rect15, "ry", rect15_ry_value = 0.5);
			attr(rect15, "width", rect15_width_value = 2);
			attr(rect15, "x", rect15_x_value = 4);
			attr(rect15, "y", rect15_y_value = 26);
			attr(rect16, "height", rect16_height_value = 4);
			attr(rect16, "rx", rect16_rx_value = 0.5);
			attr(rect16, "ry", rect16_ry_value = 0.5);
			attr(rect16, "width", rect16_width_value = 6);
			attr(rect16, "x", rect16_x_value = 8);
			attr(rect16, "y", rect16_y_value = 28);
			attr(rect17, "height", rect17_height_value = 4);
			attr(rect17, "rx", rect17_rx_value = 0.5);
			attr(rect17, "ry", rect17_ry_value = 0.5);
			attr(rect17, "width", rect17_width_value = 6);
			attr(rect17, "x", rect17_x_value = 20);
			attr(rect17, "y", rect17_y_value = 28);
			attr(rect18, "height", rect18_height_value = 8);
			attr(rect18, "rx", rect18_rx_value = 0.5);
			attr(rect18, "ry", rect18_ry_value = 0.5);
			attr(rect18, "width", rect18_width_value = 2);
			attr(rect18, "x", rect18_x_value = 16);
			attr(rect18, "y", rect18_y_value = 26);
			attr(rect19, "height", rect19_height_value = 8);
			attr(rect19, "rx", rect19_rx_value = 0.5);
			attr(rect19, "ry", rect19_ry_value = 0.5);
			attr(rect19, "width", rect19_width_value = 2);
			attr(rect19, "x", rect19_x_value = 28);
			attr(rect19, "y", rect19_y_value = 26);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, rect8);
			append(svg, rect9);
			append(svg, rect10);
			append(svg, rect11);
			append(svg, rect12);
			append(svg, rect13);
			append(svg, rect14);
			append(svg, rect15);
			append(svg, rect16);
			append(svg, rect17);
			append(svg, rect18);
			append(svg, rect19);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Pattern" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Pattern extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8$, create_fragment$8$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Pause.svelte generated by Svelte v3.24.1 */

function create_fragment$90(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 28);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 8);
			attr(rect0, "x", rect0_x_value = 6);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 28);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 8);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$90($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Pause" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Pause extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$90, create_fragment$90, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PauseCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$91(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-2 23a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V11a1 1 0 0 1 1-1h2a1 1 0 0 1 1\n    1zm8 0a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V11a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$91($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PauseCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PauseCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$91, create_fragment$91, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Pawn.svelte generated by Svelte v3.24.1 */

function create_fragment$92(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 0.894);
			attr(rect, "ry", rect_ry_value = 0.894);
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 6);
			attr(rect, "y", rect_y_value = 32);
			attr(path, "d", "M25.184 12H21.31a6 6 0 1 0-6.619 0h-3.875a.816.816 0 0 0-.816.816v2.367a.816.816 0 0 0 .816.816H15L12\n    30h12l-3-14h4.184a.816.816 0 0 0 .816-.816v-2.368a.816.816 0 0 0-.816-.816z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$92($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Pawn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Pawn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$92, create_fragment$92, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Pending.svelte generated by Svelte v3.24.1 */

function create_fragment$93(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 16.086V7a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v10.586a1 1 0 0 0 .293.707L21.9 23.9a1 1 0 0 0 1.415 0l1.335-1.335a1 1\n    0 0 0 0-1.415l-4.357-4.357a1 1 0 0 1-.293-.707zM26.485 6.9a14.163 14.163 0 0 1 2.626 2.6l1.743-1a16.173 16.173 0 0\n    0-3.365-3.336zM33.893 16.2a15.964 15.964 0 0 0-1.227-4.589l-1.742 1.006a13.976 13.976 0 0 1 .947 3.583zM24.376\n    3.357A15.986 15.986 0 0 0 19.8 2.111v2.023a14.114 14.114 0 0 1 3.572.962z");
			attr(path1, "d", "M31.872 19.8A13.994 13.994 0 1 1 16.2 4.128V2.107A16 16 0 1 0 33.892 19.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$93($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Pending" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Pending extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$93, create_fragment$93, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PeopleGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$94(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M13.974 6.752a3.947 3.947 0 1 0-.008-5.6 5.872 5.872 0 0 1 .731 2.8 5.886 5.886 0 0 1-.723 2.8zm3\n    2.248h-.449a9.833 9.833 0 0 0-1.352.093 6.961 6.961 0 0 1 2.326 5.36v9.412a2.567 2.567 0 0 1-2.562 2.563h-.371l-.818\n    8.743.032.34a.562.562 0 0 0 .558.489h4.812a.562.562 0 0 0 .558-.489l1.038-11.082h2.192a.563.563 0 0 0\n    .563-.562v-9.415C23.5 10.813 20.579 9 16.975 9z");
			attr(path1, "d", "M22.474 6.752a3.947 3.947 0 1 0-.008-5.6 5.872 5.872 0 0 1 .731 2.8 5.886 5.886 0 0 1-.723 2.8zm3\n    2.248h-.449a9.833 9.833 0 0 0-1.352.093A6.961 6.961 0 0 1 26 14.453v9.412a2.567 2.567 0 0 1-2.562 2.563h-.371l-.818\n    8.743.032.34a.562.562 0 0 0 .558.489h4.812a.562.562 0 0 0 .558-.489l1.038-11.082h2.192a.563.563 0 0 0\n    .561-.563v-9.414C32 10.813 29.079 9 25.475 9zM12.7 3.948A3.948 3.948 0 1 1 8.75 0a3.948 3.948 0 0 1 3.95\n    3.948zM8.975 9h-.45C4.921 9 2 10.814 2 14.453v9.413a.562.562 0 0 0 .563.563h2.185L5.78 35.51a.563.563 0 0 0\n    .558.49h4.812a.562.562 0 0 0 .558-.489l1.038-11.082h2.192a.562.562 0 0 0 .562-.563v-9.413C15.5 10.814 12.579 9 8.975\n    9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$94($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PeopleGroup" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PeopleGroup extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$94, create_fragment$94, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PersonalizationField.svelte generated by Svelte v3.24.1 */

function create_fragment$95(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 2H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM12 29.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0\n    1-.5-.5v-1a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5zm18 0a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h13a.5.5\n    0 0 1 .5.5zm0-7.5h-2.47c-.946-1.392-2.686-2.161-5.829-2.48a1.018 1.018 0 0 1-.882-1.023V17.02a1.023 1.023 0 0 1\n    .26-.659 7.8 7.8 0 0 0 1.773-4.868c0-3.684-1.953-5.742-4.905-5.742s-4.962 2.139-4.962 5.742a7.885 7.885 0 0 0 1.859\n    4.868 1.019 1.019 0 0 1 .26.659v1.47a1.015 1.015 0 0 1-.885 1.024c-3.242.282-4.98 1.067-5.9 2.486H6V4h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$95($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PersonalizationField" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PersonalizationField extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$95, create_fragment$95, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Perspective.svelte generated by Svelte v3.24.1 */

function create_fragment$96(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 3.281v31.276a1 1 0 0 0 1.351.936l30-11.25a1 1 0 0 0 .649-.936V10.781a1 1 0 0 0-.757-.97l-30-7.5A1 1 0 0 0 2\n    3.281zm30 12.836l-6 .4v-6.5l6 1.446zM16 17.19V7.613l8 1.929v7.112zm8 1.356v7.126l-8 2.938v-9.419zM14 7.131v10.193L4\n    18V4.72zM4 20.16l10-.807v9.992L4 33.017zm22 4.778v-6.554l6-.484v4.834z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$96($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Perspective" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Perspective extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$96, create_fragment$96, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PinOff.svelte generated by Svelte v3.24.1 */

function create_fragment$97(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.646 21.998l2.379 2.381L3.924 34.406 0 36l1.645-3.975 10.001-10.027zM23.951 26.32h.008L24 20.289 32.293\n    12l2.27-.023v-.009a1.446 1.446 0 0 0 1.01-2.47L31.041 4.96 26.5.483a1.446 1.446 0 0 0-2.469 1.011h-.008L24 3.708\n    15.707 12l-6.025.044v.007a1.429 1.429 0 0 0-1.106.414 1.446 1.446 0 0 0 0 2.047l6.459 6.458 6.457 6.459a1.442 1.442\n    0 0 0 2.463-1.108z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$97($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PinOff" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PinOff extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$97, create_fragment$97, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PinOn.svelte generated by Svelte v3.24.1 */

function create_fragment$98(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M5.646 28l2.379 2.381-3.74 3.669a.5.5 0 0 1-.713-.01l-1.59-1.66a.5.5 0 0 1 .008-.7zM17.951 32.32h.008L18 26.289\n    26.293 18l2.27-.023.005-.009a1.446 1.446 0 0 0 1.01-2.47l-4.537-4.538L20.5 6.424a1.446 1.446 0 0 0-2.469\n    1.011h-.008L18 9.708 9.707 18l-6.025.044v.007a1.429 1.429 0 0 0-1.106.414 1.446 1.446 0 0 0 0 2.047l6.459 6.458\n    6.457 6.459a1.442 1.442 0 0 0 2.463-1.108z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$98($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PinOn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PinOn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$98, create_fragment$98, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Pivot.svelte generated by Svelte v3.24.1 */

function create_fragment$99(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 26V12a6 6 0 0 0-6-6H10V1.207a.5.5 0 0 0-.854-.353L0 10l9.146 9.146a.5.5 0 0 0 .854-.353V14h12v12h-4.793a.5.5\n    0 0 0-.354.854L26 36l9.146-9.146a.5.5 0 0 0-.353-.854z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$99($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Pivot" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Pivot extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$99, create_fragment$99, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PlatformDataMapping.svelte generated by Svelte v3.24.1 */

function create_fragment$9a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.328 20.005a4.988 4.988 0 0 0-6.074 3.328H10v-4.398a.5.5 0 0 0-.83-.376l-6.74 5.898a.5.5 0 0 0 0 .753l6.74\n    5.898a.5.5 0 0 0 .83-.377v-4.398h14.254a4.993 4.993 0 1 0 6.074-6.328zM5.672 13.662a4.988 4.988 0 0 0\n    6.074-3.329H26v4.398a.5.5 0 0 0 .83.377l6.74-5.898a.5.5 0 0 0 0-.753l-6.74-5.898a.5.5 0 0\n    0-.83.376v4.398H11.746a4.993 4.993 0 1 0-6.074 6.329z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PlatformDataMapping" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PlatformDataMapping extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9a, create_fragment$9a, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Play.svelte generated by Svelte v3.24.1 */

function create_fragment$9b(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M9.46 4H7a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h2.46a2 2 0 0 0 1.007-.272l22.064-12.866a1 1 0 0 0 0-1.724L10.467 4.272A2\n    2 0 0 0 9.46 4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Play" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Play extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9b, create_fragment$9b, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PlayCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$9c(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm8.537 16.86l-12.027 7A1 1 0 0 1 14 26h-1a1 1 0 0 1-1-1V11a1 1 0 0 1\n    1-1h1a1 1 0 0 1 .51.14l12.027 7a1 1 0 0 1 0 1.72z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PlayCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PlayCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9c, create_fragment$9c, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Plug.svelte generated by Svelte v3.24.1 */

function create_fragment$9d(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M3.355 25.983a6.119 6.119 0 0 1 0-8.653l5.288-5.288-.034-.034a2.719 2.719 0 0 1 0-3.846l1.923-1.923a2.719 2.719 0\n    0 1 3.846 0L16.3 8.162l6.523-6.523a1.02 1.02 0 0 1 1.442 0l1.442 1.442a1.02 1.02 0 0 1 0 1.442l-6.524 6.524 5.769\n    5.769 6.524-6.524a1.02 1.02 0 0 1 1.442 0l1.442 1.442a1.02 1.02 0 0 1 0 1.442L27.838 19.7l1.923 1.923a2.719 2.719 0\n    0 1 0 3.846l-1.923 1.923a2.719 2.719 0 0 1-3.846 0l-.059-.059-5.288 5.287a6.118 6.118 0 0 1-8.653 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Plug" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Plug extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9d, create_fragment$9d, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Polygon.svelte generated by Svelte v3.24.1 */

function create_fragment$9e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.61 17.53L26.942 4.565A1.077 1.077 0 0 0 26 4H10.046a1.077 1.077 0 0 0-.946.561l-7.708 12.9a1.079 1.079 0 0 0\n    0 1.03L9.1 31.438a1.079 1.079 0 0 0 .946.562H26a1.078 1.078 0 0 0 .947-.563l7.666-12.881a1.079 1.079 0 0\n    0-.003-1.026zM25.447 30H10.6L3.388 17.98 10.593 6h14.851l7.169 12.04z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Polygon" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Polygon extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9e, create_fragment$9e, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PolygonSelect.svelte generated by Svelte v3.24.1 */

function create_fragment$9f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.455 1.829l-10.174 6.62L2.665 5.513a1 1 0 0 0-1.073 1.405l6.683 14.507a5.406 5.406 0 0 0-.475 1.944c0 2.737\n    2.731 4.956 6.1 4.956a7.238 7.238 0 0 0 .915-.075A6.578 6.578 0 0 1 16.1 30.1a2.427 2.427 0 0 1-.237 2.115 5.312\n    5.312 0 0 1-3.224 1.666.5.5 0 0 0-.413.541l.1 1a.5.5 0 0 0 .579.445c1.055-.186 3.409-.782 4.6-2.505a4.367 4.367 0 0\n    0 .527-3.779 5.812 5.812 0 0 0-1.117-1.928c.85-.372 3.021-2.093 3.021-3.7l11.319-2.987A1 1 0 0 0 32 20V2.667a1 1 0 0\n    0-1.545-.838zM9.8 23.369a2.953 2.953 0 0 1 1.972-2.5 6.41 6.41 0 0 0-.142 3.063 6.544 6.544 0 0 0 1.444\n    2.331c-1.842-.286-3.274-1.495-3.274-2.894zm5.751 2.691l-.007-.008a10.672 10.672 0 0 1-1.975-2.608 5.8 5.8 0 0 1\n    .449-3.024c2.17.048 3.984 1.374 3.984 2.949a3.146 3.146 0 0 1-2.451 2.691zM30 19.229l-10.259 2.708a6.079 6.079 0 0\n    0-5.84-3.525 6.8 6.8 0 0 0-4.178 1.377L4.2 7.8l16.137 2.69a1 1 0 0 0 .71-.149L30 4.511z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PolygonSelect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PolygonSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9f, create_fragment$9f, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PopIn.svelte generated by Svelte v3.24.1 */

function create_fragment$9g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M9.8 17.716L23.819 3.7a1 1 0 0 1 1.414 0l7.067 7.067a1 1 0 0 1 0 1.414L18.284 26.2l4.945 4.945a.5.5 0 0\n    1-.353.854H4V13.125a.5.5 0 0 1 .854-.353z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PopIn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PopIn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9g, create_fragment$9g, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Portrait.svelte generated by Svelte v3.24.1 */

function create_fragment$9h(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 11);
			attr(circle, "r", circle_r_value = 3.5);
			attr(path, "d", "M31 2H5a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-1 30h-6v-4a2 2 0 0 0 2-2v-6a4 4 0 0\n    0-4-4h-8a4 4 0 0 0-4 4v6a2 2 0 0 0 2 2v4H6V4h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Portrait" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Portrait extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9h, create_fragment$9h, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Preset.svelte generated by Svelte v3.24.1 */

function create_fragment$9i(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M34 14a12 12 0 0 0-23.483-3.483 12.038 12.038 0 0 1 2.3-.457A10 10 0 1 1 25.94 23.185a12.038 12.038 0 0 1-.457\n    2.3A12 12 0 0 0 34 14z");
			attr(path1, "d", "M14 12h2v2h-2zM12 14h2v2h-2zM14 16h2v2h-2zM12 18h2v2h-2zM14 20h2v2h-2zM16 22h2v2h-2zM16 18h2v2h-2zM16\n    14h2v2h-2zM18 16h2v2h-2zM18 20h2v2h-2z");
			attr(path2, "d", "M24 25.817V24h-2v2a11.986 11.986 0 0 1-2-.18V24h-2v1.3a11.939 11.939 0 0 1-2-.922V24h-.628A11.886 11.886 0 0 1 14\n    22.926V22h-.926A12.173 12.173 0 0 1 12 20.628V20h-.381a11.856 11.856 0 0 1-.921-2H12v-2h-1.82a11.986 11.986 0 0\n    1-.18-2h2v-2h-1.817a12.068 12.068 0 0 1 .334-1.482 12 12 0 1 0 14.966 14.964 12.128 12.128 0 0 1-1.483.335z");
			attr(path3, "d", "M20 22h2v2h-2zM22 20h2v2h-2zM20 18h2v2h-2zM22 16h2v2h-2zM20 14h2v2h-2zM18 12h2v2h-2zM26 22h-2v2h1.817A11.881\n    11.881 0 0 0 26 22zM25.3 18H24v2h1.82a11.908 11.908 0 0 0-.52-2zM24 15.372V16h.381a11.785 11.785 0 0 0-.381-.628zM12\n    12h2v-2a11.881 11.881 0 0 0-2 .183zM16 10.18V12h2v-1.3a11.908 11.908 0 0 0-2-.52zM20 11.619V12h.628a11.785 11.785 0\n    0 0-.628-.381zM22 13.074V14h.926a11.9 11.9 0 0 0-.926-.926z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Preset" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Preset extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9i, create_fragment$9i, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Preview.svelte generated by Svelte v3.24.1 */

function create_fragment$9j(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33.191 32.143L28.646 27.6a9.065 9.065 0 1 0-3.046 3.046l4.546 4.545a2.044 2.044 0 0 0 3.048 0A2.133 2.133 0 0 0\n    33.781 34a2.163 2.163 0 0 0-.59-1.857zM15.412 22.98a5.568 5.568 0 1 1 5.568 5.568 5.568 5.568 0 0 1-5.568-5.568z");
			attr(path1, "d", "M33 4H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h11.232a11.322 11.322 0 0 1-2.068-2H4V10h28v17.777l2 1.99V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Preview" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Preview extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9j, create_fragment$9j, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Print.svelte generated by Svelte v3.24.1 */

function create_fragment$9k(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35 10h-5V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v7H1a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h3v7a1 1 0 0 0 1 1h26a1 1 0 0 0\n    1-1v-7h3a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1zM8 4h20v6H8zm22 28H6V20h24z");
			attr(path1, "d", "M10 26h16v2H10zM10 22h16v2H10z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Print" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Print extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9k, create_fragment$9k, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PrintPreview.svelte generated by Svelte v3.24.1 */

function create_fragment$9l(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M10 2v8H2l8-8z");
			attr(path1, "d", "M11.7 23A11.3 11.3 0 0 1 23 11.7c.338 0 .67.021 1 .05V3a1 1 0 0 0-1-1H12v9a1 1 0 0 1-1 1H2v15a1 1 0 0 0 1\n    1h9.878a11.229 11.229 0 0 1-1.178-5z");
			attr(path2, "d", "M35.191 32.143L30.646 27.6a9.066 9.066 0 1 0-3.046 3.046l4.545 4.545a2.044 2.044 0 0 0 3.048 0 2.195 2.195 0 0\n    0-.002-3.048zM17.412 22.98a5.568 5.568 0 1 1 5.568 5.567 5.568 5.568 0 0 1-5.568-5.567z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PrintPreview" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PrintPreview extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9l, create_fragment$9l, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Project.svelte generated by Svelte v3.24.1 */

function create_fragment$9m(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14 8H2V5a1 1 0 0 1 1-1h6.586a1 1 0 0 1 .707.293zM33 10H2v21a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1zM10\n    27.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-13a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm6 0a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-9a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm6 0a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-5a.5.5 0 0 1 .5-.5h3a.5.5 0\n    0 1 .5.5zm6 0a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Project" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Project extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9m, create_fragment$9m, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ProjectAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$9n(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 8H0V5a1 1 0 0 1 1-1h6.586a1 1 0 0 1 .707.293zM14.7 27.1A12.287 12.287 0 0 1 32 15.869V11a1 1 0 0 0-1-1H0v21a1\n    1 0 0 0 1 1h14.721a12.251 12.251 0 0 1-1.021-4.9zm-6.7.4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-13a.5.5 0 0 1\n    .5-.5h3a.5.5 0 0 1 .5.5zm6 0a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ProjectAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ProjectAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9n, create_fragment$9n, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ProjectEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$9o(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M19.521 24H4V4h28v10.441a2.722 2.722 0 0 1 .739.511L34 16.213V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1\n    1h14.521z");
			attr(path1, "d", "M35.645 20.685l-4.324-4.323a1.083 1.083 0 0 0-.678-.265 1.13 1.13 0 0 0-.7.3L18.711 27.639a.736.736 0 0\n    0-.188.315l-2.444 7.34c-.085.282.345.638.588.638a.231.231 0 0 0 .046-.005c.207-.048 6.26-2.118 7.344-2.444a.733.733\n    0 0 0 .31-.187L35.6 22.059a1.03 1.03 0 0 0 .3-.662.916.916 0 0 0-.255-.712zM18.039 33.973l1.978-5.519 3.54\n    3.531c-1.621.487-4.118 1.57-5.518 1.988z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ProjectEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ProjectEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9o, create_fragment$9o, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ProjectNameEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$9p(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14 24H4V4h28v12h2V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11z");
			attr(path1, "d", "M35 18H17a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-1h4v10h-1a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0\n    1-1v-2a1 1 0 0 0-1-1h-1V22h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ProjectNameEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ProjectNameEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9p, create_fragment$9p, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Promote.svelte generated by Svelte v3.24.1 */

function create_fragment$9q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6 6a6 6 0 0 0 0 12h6V6zM13.079 34h-2.908a1.5 1.5 0 0 1-1.455-1.136L6 20h6l2.534 12.136A1.5 1.5 0 0 1 13.079\n    34zM32.5 23.957S25.974 18 17.425 18H14V6h3.425C25.845 6 32.5.043 32.5.043A1.268 1.268 0 0 1 34 1.426v21.148a1.268\n    1.268 0 0 1-1.5 1.383z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Promote" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Promote extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9q, create_fragment$9q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Properties.svelte generated by Svelte v3.24.1 */

function create_fragment$9r(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.5 6H15.9a5 5 0 0 0-9.8 0H2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h3.6a5 5 0 0 0 9.8 0h17.6a.5.5 0 0 0\n    .5-.5v-1a.5.5 0 0 0-.5-.5zM11 10a3 3 0 1 1 3-3 3 3 0 0 1-3 3zM33.5 26H19.9a5 5 0 0 0-9.8 0H2.5a.5.5 0 0\n    0-.5.5v1a.5.5 0 0 0 .5.5h7.6a5 5 0 0 0 9.8 0h13.6a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM15 30a3 3 0 1 1 3-3 3 3 0 0\n    1-3 3zM2 16.5v1a.5.5 0 0 0 .5.5h17.6a5 5 0 0 0 9.8 0h3.6a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-3.6a5 5 0 0 0-9.8\n    0H2.5a.5.5 0 0 0-.5.5zm20 .5a3 3 0 1 1 3 3 3 3 0 0 1-3-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Properties" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Properties extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9r, create_fragment$9r, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PropertiesCopy.svelte generated by Svelte v3.24.1 */

function create_fragment$9s(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm4.9 10.5h-3.4v3.4a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-3.4h-3.4a.5.5 0 0\n    1-.5-.5v-2a.5.5 0 0 1 .5-.5h3.4v-3.4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v3.4h3.4a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5zM2\n    17.5v-1a.5.5 0 0 1 .5-.5h15.6a5 5 0 0 1 9.8 0s-.559-.007-.9 0a11.217 11.217 0 0 0-1.165.061 2.99 2.99 0 1 0-5.535\n    2.222 11.105 11.105 0 0 0-1.506 1.4A4.965 4.965 0 0 1 18.1 18H2.5a.5.5 0 0 1-.5-.5zm0-10v-1a.5.5 0 0 1 .5-.5h3.6a5 5\n    0 0 1 9.8 0h17.6a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H15.9a5 5 0 0 1-9.8 0H2.5a.5.5 0 0 1-.5-.5zM8 7a3 3 0 1 0 3-3 3 3\n    0 0 0-3 3zm7.842 20.961a3 3 0 1 1 0-1.922 11.1 11.1 0 0 1 .565-2.676A4.98 4.98 0 0 0 8.1 26H2.5a.5.5 0 0\n    0-.5.5v1a.5.5 0 0 0 .5.5h5.6a4.98 4.98 0 0 0 8.306 2.637 11.109 11.109 0 0 1-.564-2.676z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PropertiesCopy" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PropertiesCopy extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9s, create_fragment$9s, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PublishCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$9t(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.191 1.113L1.8 10.478a.5.5 0 0 0-.08.926l7.92 3.954zM15.614 22.355L10.08 19.25v7.639a.713.713 0 0 0\n    1.174.544l3.763-3.169a12.206 12.206 0 0 1 .597-1.909zM27 14.7a12.3 12.3 0 0 1 2.827.339l5.81-12.676-22.548 14.668\n    4.378 2.2A12.273 12.273 0 0 1 27 14.7zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338\n    14.312l-4.128-4.127a.5.5 0 0 1 0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043\n    1.043a.5.5 0 0 1 0 .707l-7.5 7.5a.5.5 0 0 1-.702-.005z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PublishCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PublishCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9t, create_fragment$9t, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PublishPending.svelte generated by Svelte v3.24.1 */

function create_fragment$9u(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33.191 1.113L1.8 10.478a.5.5 0 0 0-.08.926l7.92 3.954zM15.645 22.372L10.08 19.25v7.639a.713.713 0 0 0\n    1.174.544l3.795-3.2a12.239 12.239 0 0 1 .596-1.861zM27 14.8a12.288 12.288 0 0 1 2.786.329l5.851-12.765-22.548 14.667\n    4.435 2.229A12.273 12.273 0 0 1 27 14.8zM26 26.617l-3.132 3.132 1.415 1.414L28 27.446v-7.123h-2v6.294zM33.717\n    28.3a6.96 6.96 0 0 1-1.041 2.536l1.437 1.437a8.929 8.929 0 0 0 1.632-3.973zM35.752 25.7a8.835 8.835 0 0\n    0-1.6-3.916L32.713 23.2a6.863 6.863 0 0 1 1.014 2.5z");
			attr(path1, "d", "M30.849 32.687A6.772 6.772 0 0 1 27 33.9a6.876 6.876 0 0 1-1.2-13.651v-2.007A8.867 8.867 0 0 0 27 35.9a8.733\n    8.733 0 0 0 5.271-1.791zM28.2 18.238v2.018a6.887 6.887 0 0 1 2.69 1.093l1.434-1.411a8.834 8.834 0 0 0-4.124-1.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PublishPending" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PublishPending extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9u, create_fragment$9u, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PublishReject.svelte generated by Svelte v3.24.1 */

function create_fragment$9v(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.191 1.113L1.8 10.478a.5.5 0 0 0-.08.926l7.92 3.954zM15.645 22.372L10.08 19.25v7.639a.713.713 0 0 0\n    1.174.544l3.795-3.2a12.239 12.239 0 0 1 .596-1.861zM27 14.8a12.288 12.288 0 0 1 2.786.329l5.851-12.765-22.548 14.667\n    4.435 2.229A12.273 12.273 0 0 1 27 14.8zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0\n    1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PublishReject" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PublishReject extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9v, create_fragment$9v, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PublishRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$9w(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.191 1.113L1.8 10.478a.5.5 0 0 0-.08.926l7.92 3.954zM15.645 22.372L10.08 19.25v7.639a.713.713 0 0 0\n    1.174.544l3.795-3.2a12.242 12.242 0 0 1 .596-1.861zM27 14.8a12.288 12.288 0 0 1 2.786.329l5.851-12.765-22.548 14.667\n    4.435 2.229A12.273 12.273 0 0 1 27 14.8zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826 12.267a.5.5 0 0\n    1 0 .707l-1.752 1.752a.5.5 0 0 1-.707 0L27 29.459l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0 0 1\n    0-.707L24.541 27l-3.367-3.367a.5.5 0 0 1 0-.707l1.752-1.752a.5.5 0 0 1 .707 0L27 24.541l3.367-3.367a.5.5 0 0 1 .707\n    0l1.752 1.752a.5.5 0 0 1 0 .707L29.459 27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PublishRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PublishRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9w, create_fragment$9w, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PublishSchedule.svelte generated by Svelte v3.24.1 */

function create_fragment$9x(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.191 1.113L1.8 10.478a.5.5 0 0 0-.08.926l7.92 3.954zM15.645 22.372L10.08 19.25v7.639a.713.713 0 0 0\n    1.174.544l3.795-3.2a12.242 12.242 0 0 1 .596-1.861zM27 14.8a12.288 12.288 0 0 1 2.786.329l5.851-12.765-22.548 14.667\n    4.435 2.229A12.273 12.273 0 0 1 27 14.8zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm0 15.8a6.885 6.885 0 0\n    1-1-13.7v7.245l3.717 3.717 1.415-1.414L28 26.617V20.2a6.885 6.885 0 0 1-1 13.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PublishSchedule" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PublishSchedule extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9x, create_fragment$9x, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/PushNotification.svelte generated by Svelte v3.24.1 */

function create_fragment$9y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 .1A8.9 8.9 0 1 0 35.9 9 8.9 8.9 0 0 0 27 .1zM29.684 14h-5.631c-.127\n    0-.163-.054-.145-.163l-.008-1.856a.174.174 0 0 1 .2-.163h1.68V6.371a15.522 15.522 0 0\n    1-1.953.507c-.126.018-.163-.018-.163-.127V5.177c0-.091.019-.145.127-.163a11.585 11.585 0 0 0 2.339-.924.667.667 0 0\n    1 .311-.09h1.479c.091 0 .109.054.109.127v7.691h1.619c.127 0 .163.055.181.163v1.82c.017.145-.037.199-.145.199z");
			attr(path1, "d", "M27 21.3A12.3 12.3 0 0 1 14.7 9c0-.338.024-.669.05-1H4a2 2 0 0 0-2 2v22a2 2 0 0 0 2 2h22a2 2 0 0 0\n    2-2V21.25c-.331.026-.662.05-1 .05z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "PushNotification" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class PushNotification extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9y, create_fragment$9y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Question.svelte generated by Svelte v3.24.1 */

function create_fragment$9z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 4H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11l3.536 6.839a.5.5 0 0 0 .928 0L22 28h11a1 1 0 0 0 1-1V5a1 1 0 0\n    0-1-1zM17.754 25.444a2.557 2.557 0 0 1-2.7-2.7 2.6 2.6 0 0 1 2.7-2.671 2.6 2.6 0 0 1 2.7 2.671 2.531 2.531 0 0 1-2.7\n    2.7zM20.809 14.2l-.173.164c-.7.662-1.493 1.412-1.493 1.872a2 2 0 0 0 .3 1.04.6.6 0 0 1-.51.948h-2.089a.941.941 0 0\n    1-.692-.271 3.169 3.169 0 0 1-.7-1.98c0-1.358.837-2.2 1.994-3.353.765-.765 1.1-1.155 1.1-1.684 0-.264\n    0-.964-1.537-.964a5.651 5.651 0 0 0-2.8.739l-.181.072h-.118a.609.609 0 0 1-.616-.614V7.837a.709.709 0 0 1 .357-.68\n    8.11 8.11 0 0 1 3.885-.9c2.968 0 4.961 1.714 4.961 4.266a4.747 4.747 0 0 1-1.688 3.677z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Question" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Question extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9z, create_fragment$9z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/QuickSelect.svelte generated by Svelte v3.24.1 */

function create_fragment$9A(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16.333 17.814a4.468 4.468 0 0 0-3.14.838 6.435 6.435 0 0 0-1.968 3.436c-.433 1.378-.948 2.877-2.182 3.627a2.28\n    2.28 0 0 0-.588.41.524.524 0 0 0-.062.657.729.729 0 0 0 .4.189c3.317.764 7.549 1.018 10.278-1.434a4.4 4.4 0 0\n    0-1.281-7.327 4.714 4.714 0 0 0-1.457-.396zM22.937 19.527c5.707-6.49 12.954-15.41 11.056-17.308S24.235 9.174 18.582\n    15.37a7.93 7.93 0 0 1 4.355 4.157zM7.469 5.954l-.6-2.037A11.153 11.153 0 0 0 3.064 8.39l1.985.483a9.007 9.007 0 0 1\n    2.42-2.919zM4 13c0-.242.052-.469.071-.706l-1.988-.484A11.163 11.163 0 0 0 2 13.111v3.111h2zM4\n    23v-3.222H2v3.111a11.167 11.167 0 0 0 .11 1.483l1.98-.483A8.717 8.717 0 0 1 4 23zM5.14 27.293l-1.994.486a11.151\n    11.151 0 0 0 3.726 4.3l.6-2.038a8.979 8.979 0 0 1-2.332-2.748zM13 32a8.87 8.87 0 0 1-2.3-.336l-.563 1.921a10.864\n    10.864 0 0 0 5.948 0L15.5 31.6a8.868 8.868 0 0 1-2.5.4zM20.886 27.245A8.991 8.991 0 0 1 18.71 29.9l.64 2.185a11.154\n    11.154 0 0 0 3.727-4.3zM20.942 8.856q.805-.869 1.554-1.66a11.1 11.1 0 0 0-3.146-3.279L18.71 6.1a8.98 8.98 0 0 1\n    2.232 2.756zM13 4a8.867 8.867 0 0 1 2.5.4l.581-1.983a10.864 10.864 0 0 0-5.948 0l.562 1.92A8.884 8.884 0 0 1 13 4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "QuickSelect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class QuickSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9A, create_fragment$9A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RSS.svelte generated by Svelte v3.24.1 */

function create_fragment$9B(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle, "cx", circle_cx_value = 7.993);
			attr(circle, "cy", circle_cy_value = 28.007);
			attr(circle, "r", circle_r_value = 4);
			attr(path0, "d", "M21.983 32.007h-4a.5.5 0 0 1-.5-.489 13.519 13.519 0 0 0-13-13 .5.5 0 0 1-.488-.5v-4a.5.5 0 0 1 .511-.5A18.525\n    18.525 0 0 1 22.486 31.5a.5.5 0 0 1-.503.507z");
			attr(path1, "d", "M31.985 32.007h-4a.5.5 0 0 1-.5-.493 23.7 23.7 0 0 0-23-23.19.5.5 0 0 1-.493-.5V4.015a.5.5 0 0 1 .51-.5A28.535\n    28.535 0 0 1 32.489 31.5a.5.5 0 0 1-.504.507z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RSS" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RSS extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9B, create_fragment$9B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RadialGradient.svelte generated by Svelte v3.24.1 */

function create_fragment$9C(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;
	let path8;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			attr(path0, "d", "M18 12.356A5.644 5.644 0 1 0 23.644 18 5.644 5.644 0 0 0 18 12.356z");
			attr(path1, "d", "M18 10.669A7.331 7.331 0 1 0 25.331 18 7.331 7.331 0 0 0 18 10.669zm0 12.975A5.644 5.644 0 1 1 23.644 18 5.644\n    5.644 0 0 1 18 23.644z");
			attr(path2, "d", "M18 8.909A9.091 9.091 0 1 0 27.091 18 9.091 9.091 0 0 0 18 8.909zm0 16.422A7.331 7.331 0 1 1 25.331 18 7.331\n    7.331 0 0 1 18 25.331z");
			attr(path3, "d", "M18 7.091A10.909 10.909 0 1 0 28.909 18 10.909 10.909 0 0 0 18 7.091zm0 20A9.091 9.091 0 1 1 27.091 18 9.091\n    9.091 0 0 1 18 27.091z");
			attr(path4, "d", "M18 5.273A12.727 12.727 0 1 0 30.727 18 12.727 12.727 0 0 0 18 5.273zm0 23.636A10.909 10.909 0 1 1 28.909 18\n    10.909 10.909 0 0 1 18 28.909z");
			attr(path5, "d", "M14.1 32h7.8A14.551 14.551 0 0 0 32 21.9v-7.8A14.551 14.551 0 0 0 21.9 4h-7.8A14.551 14.551 0 0 0 4\n    14.1v7.8A14.551 14.551 0 0 0 14.1 32zM18 5.273A12.727 12.727 0 1 1 5.273 18 12.727 12.727 0 0 1 18 5.273z");
			attr(path6, "d", "M14.1 4H9.56A16.413 16.413 0 0 0 4 9.56v4.54A14.551 14.551 0 0 1 14.1 4zM21.9 32h4.536A16.4 16.4 0 0 0 32\n    26.439V21.9A14.551 14.551 0 0 1 21.9 32zM4 21.9v4.535A16.4 16.4 0 0 0 9.561 32H14.1A14.551 14.551 0 0 1 4 21.9zM32\n    14.1V9.56A16.413 16.413 0 0 0 26.44 4H21.9A14.551 14.551 0 0 1 32 14.1z");
			attr(path7, "d", "M26.439 32H29.6a18.172 18.172 0 0 0 2.4-2.4v-3.161A16.4 16.4 0 0 1 26.439 32zM9.56 4H6.4A18.172 18.172 0 0 0 4\n    6.4v3.16A16.413 16.413 0 0 1 9.56 4zM4 26.439V29.6A18.172 18.172 0 0 0 6.4 32h3.161A16.4 16.4 0 0 1 4 26.439zM32\n    9.56V6.4A18.172 18.172 0 0 0 29.6 4h-3.16A16.413 16.413 0 0 1 32 9.56z");
			attr(path8, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-1 27.6a18.172 18.172 0 0 1-2.4\n    2.4H6.4A18.172 18.172 0 0 1 4 29.6V6.4A18.172 18.172 0 0 1 6.4 4h23.2A18.172 18.172 0 0 1 32 6.4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
			append(svg, path5);
			append(svg, path6);
			append(svg, path7);
			append(svg, path8);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RadialGradient" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RadialGradient extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9C, create_fragment$9C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Rail.svelte generated by Svelte v3.24.1 */

function create_fragment$9D(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 6);
			attr(rect0, "y", rect0_y_value = 8);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 24);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 24);
			attr(rect2, "x", rect2_x_value = 6);
			attr(rect2, "y", rect2_y_value = 24);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Rail" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Rail extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9D, create_fragment$9D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RailBottom.svelte generated by Svelte v3.24.1 */

function create_fragment$9E(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.875 4H1.125A1.147 1.147 0 0 0 0 5.167v25.666A1.147 1.147 0 0 0 1.125 32h33.75A1.147 1.147 0 0 0 36\n    30.833V5.167A1.147 1.147 0 0 0 34.875 4zM20.6 27.5a.5.5 0 0 1-.5.5H2.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h17.6a.5.5 0 0 1 .5.5zM34 24H2V8h32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RailBottom" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RailBottom extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9E, create_fragment$9E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RailLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$9F(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.875 4H1.125A1.146 1.146 0 0 0 0 5.167v25.666A1.146 1.146 0 0 0 1.125 32h33.75A1.146 1.146 0 0 0 36\n    30.833V5.167A1.146 1.146 0 0 0 34.875 4zM9.3 24H2.7v-2h6.6zm0-6H2.7v-2h6.6zm0-6H2.7v-2h6.6zM34 30H12V10h22z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RailLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RailLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9F, create_fragment$9F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RailRight.svelte generated by Svelte v3.24.1 */

function create_fragment$9G(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M0 5.167v25.666A1.146 1.146 0 0 0 1.125 32h33.75A1.146 1.146 0 0 0 36 30.833V5.167A1.146 1.146 0 0 0 34.875\n    4H1.125A1.146 1.146 0 0 0 0 5.167zM33.3 11.5a.5.5 0 0 1-.5.5h-5.6a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h5.6a.5.5 0 0\n    1 .5.5zm0 6a.5.5 0 0 1-.5.5h-5.6a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h5.6a.5.5 0 0 1 .5.5zm-6.6 5a.5.5 0 0 1\n    .5-.5h5.6a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-5.6a.5.5 0 0 1-.5-.5zM2 10h22v20H2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RailRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RailRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9G, create_fragment$9G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RailRightClose.svelte generated by Svelte v3.24.1 */

function create_fragment$9H(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M22 14h-9.006a.994.994 0 0 0-.994.994v6.012a.994.994 0 0 0 .994.994H22v8.912a.5.5 0 0 0 .848.351L36 18 22.848\n    4.736a.5.5 0 0 0-.848.352z");
			attr(rect, "height", rect_height_value = 28);
			attr(rect, "rx", rect_rx_value = 0.707);
			attr(rect, "ry", rect_ry_value = 0.707);
			attr(rect, "width", rect_width_value = 4);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RailRightClose" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RailRightClose extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9H, create_fragment$9H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RailRightOpen.svelte generated by Svelte v3.24.1 */

function create_fragment$9I(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M14 14h9.006a.994.994 0 0 1 .994.994v6.012a.994.994 0 0 1-.994.994H14v8.912a.5.5 0 0 1-.848.351L0 18 13.152\n    4.736a.5.5 0 0 1 .848.352z");
			attr(rect, "height", rect_height_value = 28);
			attr(rect, "rx", rect_rx_value = 0.707);
			attr(rect, "ry", rect_ry_value = 0.707);
			attr(rect, "width", rect_width_value = 4);
			attr(rect, "x", rect_x_value = 28);
			attr(rect, "y", rect_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RailRightOpen" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RailRightOpen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9I, create_fragment$9I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RailTop.svelte generated by Svelte v3.24.1 */

function create_fragment$9J(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M1.125 32h33.75A1.147 1.147 0 0 0 36 30.833V5.167A1.147 1.147 0 0 0 34.875 4H1.125A1.147 1.147 0 0 0 0\n    5.167v25.666A1.147 1.147 0 0 0 1.125 32zM15.4 8.5a.5.5 0 0 1 .5-.5h17.6a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H15.9a.5.5\n    0 0 1-.5-.5zM2 12h32v16H2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9J($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RailTop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RailTop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9J, create_fragment$9J, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RangeMask.svelte generated by Svelte v3.24.1 */

function create_fragment$9K(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M25.949 22.088a10.9 10.9 0 0 1-.846 3.279l1.776 1.026A12.944 12.944 0 0 0 28 22.088zM21.669 29.747l1.031\n    1.781a13.088 13.088 0 0 0 3.126-3.228l-1.782-1.028a11.062 11.062 0 0 1-2.375 2.475zM16.451 31.9v2.07a12.928 12.928 0\n    0 0 4.389-1.307l-1.024-1.773a10.907 10.907 0 0 1-3.365 1.01zM10.754 31.157l-1.027 1.78a12.981 12.981 0 0 0 4.548\n    1.081v-2.045a10.927 10.927 0 0 1-3.521-.816zM6.18 27.558L4.392 28.59a13.111 13.111 0 0 0 3.424\n    3.31l1.024-1.778a11.076 11.076 0 0 1-2.66-2.564zM4.058 22.088H2a12.947 12.947 0 0 0 1.279 4.632l1.782-1.028a10.908\n    10.908 0 0 1-1.003-3.604zM5.068 16.313L3.279 15.28A12.947 12.947 0 0 0 2 19.912h2.059a10.928 10.928 0 0 1\n    1.009-3.599zM8.848 11.893l-1.032-1.788a13.111 13.111 0 0 0-3.424 3.305l1.8 1.038a11.085 11.085 0 0 1\n    2.656-2.555zM14.275 10.047V7.982a12.959 12.959 0 0 0-4.548 1.081l1.037 1.8a10.943 10.943 0 0 1 3.511-.816zM35.823\n    4.258a3.238 3.238 0 0 0-.913-2.618l-.525-.525A3.206 3.206 0 0 0 32.1.187h-.121a3.734 3.734 0 0 0-2.5 1.108L25.95\n    4.822l-1.313-1.313A.89.89 0 0 0 24 3.251a1.037 1.037 0 0 0-.728.308l-2.36 2.362a.966.966 0 0 0-.051\n    1.363l.766.766-11.3 11.3a4.471 4.471 0 0 0 6.323 6.323l11.3-11.3.79.791a.894.894 0 0 0 .636.257 1.033 1.033 0 0 0\n    .728-.308l2.362-2.361a.967.967 0 0 0 .05-1.364L31.2 10.075l3.525-3.526a3.749 3.749 0 0 0 1.098-2.291zm-20.591\n    20a2.471 2.471 0 1 1-3.494-3.494l11.3-11.3 3.5 3.495z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9K($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RangeMask" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RangeMask extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9K, create_fragment$9K, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RealTimeCustomerProfile.svelte generated by Svelte v3.24.1 */

function create_fragment$9L(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 1a17 17 0 1 0 17 17A17 17 0 0 0 18 1zm10.982 27.183a10.826 10.826 0 0 0-6.224-3.128 1.307 1.307 0 0\n    1-1.131-1.311V21.85a1.313 1.313 0 0 1 .333-.844 9.99 9.99 0 0 0 2.28-6.236c0-4.72-2.508-7.36-6.287-7.36s-6.358\n    2.737-6.358 7.36a10.103 10.103 0 0 0 2.383 6.238 1.31 1.31 0 0 1 .334.845v1.883a1.3 1.3 0 0 1-1.14 1.31 10.863\n    10.863 0 0 0-6.24 3.042 15 15 0 1 1 22.05.094z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9L($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RealTimeCustomerProfile" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RealTimeCustomerProfile extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9L, create_fragment$9L, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RectSelect.svelte generated by Svelte v3.24.1 */

function create_fragment$9M(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 4h6v2h-6zM20 4h6v2h-6zM3 4a1 1 0 0 0-1 1v3h2V6h2V4zM2 12h2v4H2zM2 20h2v4H2zM4 30v-2H2v3a1 1 0 0 0 1\n    1h3v-2zM10 30h6v2h-6zM20 30h6v2h-6zM30 4v2h2v2h2V5a1 1 0 0 0-1-1zM32 12h2v4h-2zM32 20h2v4h-2zM32 28v2h-2v2h3a1 1 0 0\n    0 1-1v-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9M($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RectSelect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RectSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9M, create_fragment$9M, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Rectangle.svelte generated by Svelte v3.24.1 */

function create_fragment$9N(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 5v26a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm30 25H4V6h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9N($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Rectangle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Rectangle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9N, create_fragment$9N, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Redo.svelte generated by Svelte v3.24.1 */

function create_fragment$9O(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M5.337 12.542A10.391 10.391 0 0 1 12.329 10H25V4.8a.8.8 0 0 1 .8-.8.787.787 0 0 1 .527.2l7.524 7.445a.5.5 0 0 1 0\n    .7L26.332 19.8a.787.787 0 0 1-.527.2.8.8 0 0 1-.8-.8V14H12.123A6.139 6.139 0 0 0 5.9 19.8 5.889 5.889 0 0 0 12\n    26h7a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6.526a10.335 10.335 0 0 1-10.426-9.013 9.947 9.947 0 0 1 3.289-8.445z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9O($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Redo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Redo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9O, create_fragment$9O, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Refresh.svelte generated by Svelte v3.24.1 */

function create_fragment$9P(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.674 20H30.78a1.215 1.215 0 0 0-1.162.938A11.447 11.447 0 0 1 10.5 26.012l-.692-.693 3.955-3.955A.784.784 0 0\n    0 14 20.8a.8.8 0 0 0-.754-.8H2.5a.5.5 0 0 0-.5.5v10.75a.8.8 0 0 0 .8.75.781.781 0 0 0\n    .56-.236l3.617-3.617.356.357a16.181 16.181 0 0 0 7.284 4.331A15.43 15.43 0 0 0 33.665 21.17a1 1 0 0\n    0-.991-1.17zM33.2 4a.781.781 0 0 0-.56.236l-3.621 3.617-.356-.353a16.181 16.181 0 0 0-7.284-4.331A15.43 15.43 0 0 0\n    2.335 14.83 1 1 0 0 0 3.326 16H5.22a1.215 1.215 0 0 0 1.162-.938A11.447 11.447 0 0 1 25.5 9.988l.692.693-3.955\n    3.955A.784.784 0 0 0 22 15.2a.8.8 0 0 0 .754.8H33.5a.5.5 0 0 0 .5-.5V4.754A.8.8 0 0 0 33.2 4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9P($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Refresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Refresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9P, create_fragment$9P, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RegionSelect.svelte generated by Svelte v3.24.1 */

function create_fragment$9Q(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.092 12.044C33.276 6.93 27.3 3.488 20.008 3.488a24.207 24.207 0 0 0-3.8.305C7.281 5.217.82 11.219 1.774\n    17.2a7.861 7.861 0 0 0 1.737 3.752 8.67 8.67 0 0 0-.015.417c0 2.737 2.732 4.956 6.1 4.956a7.239 7.239 0 0 0\n    .916-.075A6.6 6.6 0 0 1 11.8 28.1a2.434 2.434 0 0 1-.237 2.115 5.314 5.314 0 0 1-3.224 1.666.5.5 0 0 0-.414.541l.1\n    1a.5.5 0 0 0 .579.446c1.055-.187 3.409-.783 4.6-2.506a4.37 4.37 0 0 0 .528-3.779 5.847 5.847 0 0\n    0-1.117-1.928c.068-.032.118-.083.185-.116a22.05 22.05 0 0 0 3.06.218 24.22 24.22 0 0 0 3.8-.3c8.925-1.43\n    15.386-7.433 14.432-13.413zM5.5 21.369a2.953 2.953 0 0 1 1.972-2.5 6.41 6.41 0 0 0-.142 3.063 6.544 6.544 0 0 0 1.44\n    2.329c-1.842-.284-3.27-1.493-3.27-2.892zm5.752 2.691l-.008-.008a10.663 10.663 0 0 1-1.974-2.608 5.815 5.815 0 0 1\n    .448-3.024c2.17.048 3.984 1.374 3.984 2.949a3.146 3.146 0 0 1-2.454 2.691zm8.1-.584a22.2 22.2 0 0 1-3.488.28c-.369\n    0-.717-.042-1.077-.061l.619-.87a4.066 4.066 0 0 0 .3-1.456c0-2.738-2.731-4.957-6.1-4.957a6.615 6.615 0 0 0-4.87\n    1.988l-.249.4a5.594 5.594 0 0 1-.738-1.913C2.983 12.085 8.832 7 16.521 5.768a22.191 22.191 0 0 1 3.488-.28c6.381 0\n    11.473 2.89 12.108 6.871.766 4.799-5.083 9.89-12.772 11.117z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RegionSelect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RegionSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9Q, create_fragment$9Q, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Relevance.svelte generated by Svelte v3.24.1 */

function create_fragment$9R(ctx) {
	let svg;
	let path;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr(path, "d", "M4.225 15.585a13.987 13.987 0 0 1 11.36-11.36A.494.494 0 0 0 16 3.74V2.721a.5.5 0 0 0-.578-.5 15.992 15.992 0 0\n    0-13.2 13.2.5.5 0 0 0 .5.578H3.74a.494.494 0 0 0 .485-.414zM20.415 4.225a13.987 13.987 0 0 1 11.36 11.36.494.494 0 0\n    0 .485.415h1.019a.5.5 0 0 0 .5-.578 15.992 15.992 0 0 0-13.2-13.2.5.5 0 0 0-.578.5V3.74a.494.494 0 0 0\n    .414.485zM15.585 31.775a13.987 13.987 0 0 1-11.36-11.36A.494.494 0 0 0 3.74 20H2.721a.5.5 0 0 0-.5.578 15.992 15.992\n    0 0 0 13.2 13.2.5.5 0 0 0 .578-.5V32.26a.494.494 0 0 0-.414-.485zM31.775 20.415a13.987 13.987 0 0 1-11.36\n    11.36.494.494 0 0 0-.415.485v1.019a.5.5 0 0 0 .578.5 15.992 15.992 0 0 0 13.2-13.2.5.5 0 0 0-.5-.578H32.26a.494.494\n    0 0 0-.485.414z");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 6);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9R($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Relevance" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Relevance extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9R, create_fragment$9R, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Remove.svelte generated by Svelte v3.24.1 */

function create_fragment$9S(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 6);
			attr(rect, "y", rect_y_value = 16);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9S($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Remove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Remove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9S, create_fragment$9S, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RemoveCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$9T(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm10 17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9T($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RemoveCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RemoveCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9T, create_fragment$9T, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Rename.svelte generated by Svelte v3.24.1 */

function create_fragment$9U(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 0h2v36h-2zM25.588 31.7L15.633 4.21c-.041-.169-.082-.21-.251-.21h-4.153a.2.2 0 0 0-.21.21 4.564 4.564 0 0 1-.3\n    1.739L1.485 31.662c-.041.21.045.338.255.338h2.88a.3.3 0 0 0 .338-.255L8.09 23H18.7l3.161 8.79a.376.376 0 0 0\n    .339.21h3.218c.214 0 .256-.128.17-.3zM13.347 6.88h.041c.759 2.707 3.355 9.972 4.44 13.12h-8.87c1.59-4.584\n    3.704-10.546 4.389-13.12z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9U($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Rename" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Rename extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9U, create_fragment$9U, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Reorder.svelte generated by Svelte v3.24.1 */

function create_fragment$9V(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 4a.994.994 0 0 0-.747.336l-11 10a.979.979 0 0 0-.253.658A1 1 0 0 0 7 16h22a1 1 0 0 0 1-1.006.979.979 0 0\n    0-.255-.658l-11-10A1 1 0 0 0 18 4zM18 32a1 1 0 0 0 .747-.336l11-10a.979.979 0 0 0 .253-.658A1 1 0 0 0 29 20H7a1 1 0\n    0 0-1 1.006.979.979 0 0 0 .255.658l11 10A.994.994 0 0 0 18 32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9V($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Reorder" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Reorder extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9V, create_fragment$9V, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Replay.svelte generated by Svelte v3.24.1 */

function create_fragment$9W(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.338 10.14a.878.878 0 0 0-.475-.14h-.931A.968.968 0 0 0 12 11v14a.968.968 0 0 0 .932 1h.931a.878.878 0 0 0\n    .475-.14l11.205-7a1.038 1.038 0 0 0 0-1.72z");
			attr(path1, "d", "M33.263 20.625l-.986-.169a.494.494 0 0 0-.568.394A14 14 0 1 1 19.883 4.127a12.5 12.5 0 0 1 8.249 5.035l-1.985\n    1.984A.49.49 0 0 0 26 11.5a.5.5 0 0 0 .5.5h5.052a.5.5 0 0 0 .448-.447V6.5a.5.5 0 0 0-.5-.5.494.494 0 0\n    0-.35.147l-1.71 1.711a12.44 12.44 0 0 0-8.957-5.664A16 16 0 0 0 5.4 27.861a16 16 0 0 0 28.274-6.642.507.507 0 0\n    0-.411-.594z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9W($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Replay" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Replay extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9W, create_fragment$9W, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Replies.svelte generated by Svelte v3.24.1 */

function create_fragment$9X(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M21.947 6.059V2.878a.636.636 0 0 0-1.086-.45l-7.187 7.449 7.186 7.449a.636.636 0 0 0 1.086-.45v-3.229a11.687\n    11.687 0 0 1 11.916 4.632.45.45 0 0 0 .811-.26c.001-1.919-2.191-11.96-12.726-11.96zM11.975 18v-3.749a.75.75 0 0\n    0-1.28-.53L2.225 22.5l8.47 8.779a.75.75 0 0 0 1.28-.53v-3.8A13.773 13.773 0 0 1 26.019 32.4a.531.531 0 0 0\n    .956-.307c0-2.261-2.584-14.093-15-14.093z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9X($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Replies" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Replies extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9X, create_fragment$9X, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Reply.svelte generated by Svelte v3.24.1 */

function create_fragment$9Y(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M15.029 10H14V4.8a.8.8 0 0 0-.806-.8.785.785 0 0 0-.56.236L2.207 15.464a.8.8 0 0 0 0 1.072l10.427 11.228a.785.785\n    0 0 0 .56.236.8.8 0 0 0 .806-.8V22a19.71 19.71 0 0 1 18.791 6.81.67.67 0 0 0 1.209-.4C34 25.453 30.732 10 15.029 10z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Reply" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Reply extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9Y, create_fragment$9Y, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ReplyAll.svelte generated by Svelte v3.24.1 */

function create_fragment$9Z(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M22.105 6H22V3a.733.733 0 0 0-.739-.735.718.718 0 0 0-.513.216l-6.843 6.885a.735.735 0 0 0 0 .984l6.843\n    7.434a.718.718 0 0 0 .513.216.733.733 0 0 0 .739-.735V14a12.429 12.429 0 0 1 12.179 4.785.455.455 0 0 0 .821-.272C35\n    16.5 32.779 6 22.105 6zM12.27 18.5H12v-3.765a.733.733 0 0 0-.739-.735.718.718 0 0 0-.513.216l-8.559 8.292a.735.735 0\n    0 0 0 .984l8.559 8.292a.718.718 0 0 0 .513.216.733.733 0 0 0 .739-.735v-3.548c6.4-1.033 12.118 2.748 15\n    6.379a.555.555 0 0 0 1-.332C28 31.313 25.29 18.5 12.27 18.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ReplyAll" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ReplyAll extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9Z, create_fragment$9Z, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Report.svelte generated by Svelte v3.24.1 */

function create_fragment$9_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27 4H9a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-11 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1\n    .5.5v7a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm-6 4a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5zm12 15a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 .5.5zm4-6a.5.5 0 0\n    1-.5.5h-15a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-11a.5.5\n    0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Report" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Report extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9_, create_fragment$9_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ReportAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$9$(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.084 30H10.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h4.25a12.252 12.252 0 0 1 .334-2H10.5a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h6.393a12.349 12.349 0 0 1 1.743-2H16.5a.5.5 0 0 1-.5-.5v-7a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1\n    .5.5v6.393a12.269 12.269 0 0 1 2-1.124V6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v8.25c.331-.027.662-.05 1-.05s.669.024\n    1 .05V5a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h6.769a12.2 12.2 0 0 1-.685-2zM10 14.5a.5.5 0 0 1 .5-.5h3a.5.5\n    0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z");
			attr(path1, "d", "M27.1 18.2a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5h-3.5v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0\n    0 1-.5-.5v-3.5h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3.5v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v3.5h3.5a.5.5 0\n    0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ReportAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ReportAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9$, create_fragment$9$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Resize.svelte generated by Svelte v3.24.1 */

function create_fragment$a0(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 4H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM18 20.828l4.414-4.414 2.732 2.732a.5.5 0\n    0 0 .854-.353V10h-8.793a.5.5 0 0 0-.354.854l2.732 2.732L15.172 18H8V8h20v20H18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a0($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Resize" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Resize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a0, create_fragment$a0, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Retweet.svelte generated by Svelte v3.24.1 */

function create_fragment$a1(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12 24V14h2a.5.5 0 0 0 .4-.8L9 6l-5.4 7.2a.5.5 0 0 0 .4.8h2v10a6 6 0 0 0 6 6h12l-4.759-6zM32 22h-2V12a6 6 0 0\n    0-6-6H12l4.735 6H24v10h-2a.5.5 0 0 0-.4.8L27 30l5.4-7.2a.5.5 0 0 0-.4-.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Retweet" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Retweet extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a1, create_fragment$a1, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Reuse.svelte generated by Svelte v3.24.1 */

function create_fragment$a2(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16.74 4.308a13.767 13.767 0 0 0-10.561 6.3l-3.13-1.634a.692.692 0 0 0-.937.3.673.673 0 0 0-.043.523L4.4\n    17.333a.431.431 0 0 0 .541.283l7.483-2.41a.679.679 0 0 0 .4-.335.69.69 0 0 0-.29-.937l-3.29-1.721A10.316 10.316 0 0\n    1 19.4 7.857a.863.863 0 0 0 .994-.625l.432-1.683a.859.859 0 0 0-.661-1.065 13.722 13.722 0 0 0-3.425-.176zM32.912\n    8.255a.678.678 0 0 0-.449-.273l-7.783-1.3a.436.436 0 0 0-.322.076.43.43 0 0 0-.173.281l-1.2 7.77a.678.678 0 0 0\n    .117.512.691.691 0 0 0 .968.16l2.892-2.081a10.188 10.188 0 0 1 1.138 3.919 10.317 10.317 0 0 1-2.459 7.481.869.869 0\n    0 0 .023 1.187l1.222 1.227a.865.865 0 0 0 1.254-.014 13.732 13.732 0 0 0 1.668-15.851l2.948-2.124a.691.691 0 0 0\n    .156-.97zM23.765 29.066l-6.028-5.048a.675.675 0 0 0-.5-.164.691.691 0 0 0-.638.746l.3 3.68a10.382 10.382 0 0\n    1-8.871-6.78.866.866 0 0 0-1.047-.564l-1.665.473a.869.869 0 0 0-.6 1.1 13.821 13.821 0 0 0 12.457 9.255l.283\n    3.508a.691.691 0 0 0 .749.634.678.678 0 0 0 .465-.242l5.141-5.989a.432.432 0 0 0-.05-.609z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Reuse" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Reuse extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a2, create_fragment$a2, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Revenue.svelte generated by Svelte v3.24.1 */

function create_fragment$a3(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18 23.658V33a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V21.9l-4.27 3.493zM2 33a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V20.7l-6\n    5.139zM10 18.981V33a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V21.658l-4.211-4.211zM26 20.259V33a1 1 0 0 0 1 1h4a1 1 0 0 0\n    1-1V20.769l-2.8-3.13z");
			attr(path1, "d", "M24.6 8.833l2.169 2.427-6.631 5.4-7.7-7.7a.5.5 0 0 0-.679-.026L2 17.289v5.267l9.895-8.481 7.651 7.651a.5.5 0 0 0\n    .67.034l9.056-7.814 1.856 2.195a.5.5 0 0 0 .872-.333V8h-7.03a.5.5 0 0 0-.37.833z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Revenue" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Revenue extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a3, create_fragment$a3, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Revert.svelte generated by Svelte v3.24.1 */

function create_fragment$a4(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 26);
			attr(path, "d", "M2.5 20h10.75a.8.8 0 0 0 .75-.8.784.784 0 0 0-.235-.56L9.81 14.681l.692-.693a11.447 11.447 0 0 1 19.116\n    5.074A1.215 1.215 0 0 0 30.78 20h1.894a1 1 0 0 0 .991-1.17A15.43 15.43 0 0 0 14.621 7.165 16.181 16.181 0 0 0 7.337\n    11.5l-.356.357-3.617-3.621A.781.781 0 0 0 2.8 8a.8.8 0 0 0-.8.754V19.5a.5.5 0 0 0 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Revert" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Revert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a4, create_fragment$a4, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Rewind.svelte generated by Svelte v3.24.1 */

function create_fragment$a5(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4 18L18.341 5.452A1 1 0 0 1 20 6.2v23.6a1 1 0 0 1-1.659.753zM22 11l6.342-5.549A1 1 0 0 1 30 6.2v23.6a1 1 0 0\n    1-1.658.753L22 25z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Rewind" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Rewind extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a5, create_fragment$a5, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RewindCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$a6(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2A16 16 0 1 1 2 18 16 16 0 0 1 18 2zm2 19.91l2.861 2.5a1 1 0 0 0 1.659-.753V12.249a1 1 0 0 0-1.659-.753L20\n    14zm-3.658 2.5A1 1 0 0 0 18 23.662V12.248a1 1 0 0 0-1.658-.752l-7.383 6.459z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RewindCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RewindCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a6, create_fragment$a6, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Ribbon.svelte generated by Svelte v3.24.1 */

function create_fragment$a7(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.776 22.661L7.564 30.24a.5.5 0 0 0 .617.693L12.2 29.5a.5.5 0 0 1 .639.3l1.432 4.016a.5.5 0 0 0\n    .926.038l1.681-3.708-3.042-6.441a11.429 11.429 0 0 1-2.06-1.044zm16.66 7.579l-3.869-7.807a11.248 11.248 0 0 1-8.218\n    1.935l4.459 9.49a.5.5 0 0 0 .925-.038l1.432-4.02a.5.5 0 0 1 .64-.3l4.014 1.432a.5.5 0 0 0 .617-.692zM18 4a9 9 0 1 0\n    9 9 9 9 0 0 0-9-9zm0 14.5a5.5 5.5 0 1 1 5.5-5.5 5.5 5.5 0 0 1-5.5 5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Ribbon" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Ribbon extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a7, create_fragment$a7, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateCCW.svelte generated by Svelte v3.24.1 */

function create_fragment$a8(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let circle5;
	let circle5_cx_value;
	let circle5_cy_value;
	let circle5_r_value;
	let circle6;
	let circle6_cx_value;
	let circle6_cy_value;
	let circle6_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			circle5 = svg_element("circle");
			circle6 = svg_element("circle");
			path = svg_element("path");
			attr(circle0, "cx", circle0_cx_value = 26.747);
			attr(circle0, "cy", circle0_cy_value = 29.988);
			attr(circle0, "r", circle0_r_value = 1.1);
			attr(circle1, "cx", circle1_cx_value = 30.347);
			attr(circle1, "cy", circle1_cy_value = 26.121);
			attr(circle1, "r", circle1_r_value = 1.1);
			attr(circle2, "cx", circle2_cx_value = 21.992);
			attr(circle2, "cy", circle2_cy_value = 32.269);
			attr(circle2, "r", circle2_r_value = 1.1);
			attr(circle3, "cx", circle3_cx_value = 16.796);
			attr(circle3, "cy", circle3_cy_value = 32.756);
			attr(circle3, "r", circle3_r_value = 1.1);
			attr(circle4, "cx", circle4_cx_value = 11.712);
			attr(circle4, "cy", circle4_cy_value = 31.419);
			attr(circle4, "r", circle4_r_value = 1.1);
			attr(circle5, "cx", circle5_cx_value = 7.367);
			attr(circle5, "cy", circle5_cy_value = 28.392);
			attr(circle5, "r", circle5_r_value = 1.1);
			attr(circle6, "cx", circle6_cx_value = 4.454);
			attr(circle6, "cy", circle6_cy_value = 24.202);
			attr(circle6, "r", circle6_r_value = 1.1);
			attr(path, "d", "M18 1.8A15.948 15.948 0 0 0 6.727 6.461L3.3 4.1a.5.5 0 0 0-.781.463l1.048 10.221 9.9-2.679a.5.5 0 0 0\n    .153-.894l-3.346-2.3a13.533 13.533 0 0 1 8.7-3.1c7.18 0 13.019 5.457 13.019 12.084v.028a14.832 14.832 0 0 1-.344\n    3.006 1.005 1.005 0 1 0 1.963.4A16 16 0 0 0 18 1.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
			append(svg, circle5);
			append(svg, circle6);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateCCW" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateCCW extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a8, create_fragment$a8, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateCCWBold.svelte generated by Svelte v3.24.1 */

function create_fragment$a9(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2A16.03 16.03 0 0 0 4.644 9.228L1 7.521a.69.69 0 0 0-.531-.027.7.7 0 0 0-.424.9L3.053 16.7a.5.5 0 0 0\n    .589.276l8.311-3.008a.7.7 0 0 0 .42-.9.686.686 0 0 0-.361-.39l-3.677-1.72a11.971 11.971 0 1 1-.161 13.917 2 2 0 0\n    0-3.274 2.3A16 16 0 1 0 18 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateCCWBold" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateCCWBold extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a9, create_fragment$a9, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateCW.svelte generated by Svelte v3.24.1 */

function create_fragment$aa(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let circle5;
	let circle5_cx_value;
	let circle5_cy_value;
	let circle5_r_value;
	let circle6;
	let circle6_cx_value;
	let circle6_cy_value;
	let circle6_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			circle5 = svg_element("circle");
			circle6 = svg_element("circle");
			path = svg_element("path");
			attr(circle0, "cx", circle0_cx_value = 9.253);
			attr(circle0, "cy", circle0_cy_value = 29.988);
			attr(circle0, "r", circle0_r_value = 1.1);
			attr(circle1, "cx", circle1_cx_value = 5.653);
			attr(circle1, "cy", circle1_cy_value = 26.121);
			attr(circle1, "r", circle1_r_value = 1.1);
			attr(circle2, "cx", circle2_cx_value = 14.008);
			attr(circle2, "cy", circle2_cy_value = 32.269);
			attr(circle2, "r", circle2_r_value = 1.1);
			attr(circle3, "cx", circle3_cx_value = 19.204);
			attr(circle3, "cy", circle3_cy_value = 32.756);
			attr(circle3, "r", circle3_r_value = 1.1);
			attr(circle4, "cx", circle4_cx_value = 24.288);
			attr(circle4, "cy", circle4_cy_value = 31.419);
			attr(circle4, "r", circle4_r_value = 1.1);
			attr(circle5, "cx", circle5_cx_value = 28.633);
			attr(circle5, "cy", circle5_cy_value = 28.392);
			attr(circle5, "r", circle5_r_value = 1.1);
			attr(circle6, "cx", circle6_cx_value = 31.546);
			attr(circle6, "cy", circle6_cy_value = 24.202);
			attr(circle6, "r", circle6_r_value = 1.1);
			attr(path, "d", "M18 1.8a15.948 15.948 0 0 1 11.273 4.66L32.7 4.1a.5.5 0 0 1 .781.463l-1.048 10.221-9.9-2.679a.5.5 0 0\n    1-.153-.894l3.346-2.3a13.533 13.533 0 0 0-8.7-3.1c-7.18 0-13.019 5.457-13.019 12.084v.028a14.832 14.832 0 0 0 .344\n    3.006 1.072 1.072 0 0 1-.7 1.254 1.08 1.08 0 0 1-1.262-.856A16 16 0 0 1 18 1.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
			append(svg, circle5);
			append(svg, circle6);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aa($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateCW" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateCW extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aa, create_fragment$aa, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateCWBold.svelte generated by Svelte v3.24.1 */

function create_fragment$ab(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16.03 16.03 0 0 1 13.356 7.228L35 7.521a.69.69 0 0 1 .531-.027.7.7 0 0 1 .424.9L32.947 16.7a.5.5 0 0\n    1-.589.276l-8.311-3.008a.7.7 0 0 1-.42-.9.686.686 0 0 1 .361-.39l3.677-1.723a11.971 11.971 0 1 0 .161 13.917 2 2 0 0\n    1 3.274 2.3A16 16 0 1 1 18 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ab($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateCWBold" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateCWBold extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ab, create_fragment$ab, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$ac(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 10H11a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			attr(path1, "d", "M7.5 15h-2v-3a6 6 0 0 1 6-6h2a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-2a9 9 0 0 0-9 9v3h-2a.5.5 0 0 0-.5.5.49.49 0 0 0\n    .147.35l3.537 4.033a.5.5 0 0 0 .632 0l3.537-4.033A.49.49 0 0 0 8 15.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ac($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ac, create_fragment$ac, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateLeftOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$ad(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 10H11a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1zm-1 22H12V12h20z");
			attr(path1, "d", "M7.5 15h-2v-3a6 6 0 0 1 6-6h2a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-2a9 9 0 0 0-9 9v3h-2a.5.5 0 0 0-.5.5.49.49 0 0 0\n    .147.35l3.537 4.033a.5.5 0 0 0 .632 0l3.537-4.033A.49.49 0 0 0 8 15.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ad($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateLeftOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateLeftOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ad, create_fragment$ad, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateRight.svelte generated by Svelte v3.24.1 */

function create_fragment$ae(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M25 10H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			attr(path1, "d", "M35.5 15h-2v-3a9 9 0 0 0-9-9h-2a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h2a6 6 0 0 1 6 6v3h-2a.5.5 0 0 0-.5.5.49.49 0 0 0\n    .147.35l3.537 4.033a.5.5 0 0 0 .632 0l3.537-4.033A.49.49 0 0 0 36 15.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ae($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ae, create_fragment$ae, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/RotateRightOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$af(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M25 10H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1zm-1 22H4V12h20z");
			attr(path1, "d", "M35.5 15h-2v-3a9 9 0 0 0-9-9h-2a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h2a6 6 0 0 1 6 6v3h-2a.5.5 0 0 0-.5.5.49.49 0 0 0\n    .147.35l3.537 4.033a.5.5 0 0 0 .632 0l3.537-4.033A.49.49 0 0 0 36 15.5a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$af($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "RotateRightOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class RotateRightOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$af, create_fragment$af, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SMS.svelte generated by Svelte v3.24.1 */

function create_fragment$ag(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 4H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5l3.536 6.839a.5.5 0 0 0 .928 0L16 28h17a1 1 0 0 0 1-1V5a1 1 0 0\n    0-1-1zM6.66 21.145a6.547 6.547 0 0 1-3.006-.613.658.658 0 0 1-.314-.611v-2.066l.406-.129a6.437 6.437 0 0 0\n    2.967.848c.688 0 1.51-.158 1.51-.908 0-.336-.109-.717-1.41-1.359l-.725-.318C4.16 15.084 3.34 14 3.34 12.369c0-2.174\n    1.647-3.578 4.2-3.578a5.9 5.9 0 0 1 2.631.477.539.539 0 0 1 .314.559v1.955l-.4.145-.242-.016a4.541 4.541 0 0\n    0-2.3-.535c-.443 0-1.475.082-1.475.842 0 .334.109.684 1.42 1.287l.613.271c2.072.951 2.953 2.062 2.953 3.719-.005\n    2.218-1.728 3.65-4.394 3.65zm17.3-.383l-.049.057-.162.135-.228.035h-2.14l-.189-.439a439.332 439.332 0 0\n    1-.1-6.67c-.377 1.342-.826 2.9-1.227 4.277l-.738 2.568-.422.25-1.705.013a.531.531 0 0 1-.553-.394 431.388 431.388 0\n    0 1-1.74-6.75 628.034 628.034 0 0 1-.248 6.643l-.006.133-.131.238-.314.119-2.035.012-.189-.461.639-11.41.457-.146\n    2.676-.008a.547.547 0 0 1 .543.367c.272.945 1.275 4.518 1.856 6.859.353-1.24.848-2.871\n    1.273-4.277.316-1.043.6-1.973.762-2.539l.027-.06.121-.176.275-.15 2.941-.024.207.369.48 11.225zm4.314.383a6.546\n    6.546 0 0 1-3.006-.613.648.648 0 0 1-.314-.611v-2.066l.406-.129a6.437 6.437 0 0 0 2.967.848c.688 0 1.51-.158\n    1.51-.908 0-.336-.109-.717-1.412-1.359l-.723-.318c-1.928-.9-2.748-1.986-2.748-3.619 0-2.174 1.646-3.578\n    4.2-3.578a5.914 5.914 0 0 1 2.631.477.539.539 0 0 1 .315.559v1.955l-.4.145-.242-.016a4.581 4.581 0 0\n    0-2.3-.535c-.443 0-1.475.082-1.475.842 0 .334.109.684 1.42 1.287l.613.271c2.07.951 2.953 2.062 2.953 3.719-.009\n    2.217-1.731 3.649-4.398 3.649z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ag($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SMS" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SMS extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ag, create_fragment$ag, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SMSKey.svelte generated by Svelte v3.24.1 */

function create_fragment$ah(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M21.179 28.77a1.856 1.856 0 1 1-1.857 1.856 1.856 1.856 0 0 1 1.857-1.856zm1.667 5.182a4.395 4.395 0 0 0\n    3.683-3.686 4.489 4.489 0 0 0-.048-1.569l2.12-2.188v-1.957h2.361a.339.339 0 0 0 .338-.337v-2.362h2.361a.338.338 0 0\n    0 .339-.337v-3.374a.338.338 0 0 0-.338-.337h-1.546a.349.349 0 0 0-.239.1l-7.766 7.766a4.342 4.342 0 0 0-2-.442 4.451\n    4.451 0 0 0-4.3 4.682 4.387 4.387 0 0 0 5.035 4.041z");
			attr(path1, "d", "M33 4H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5l3.536 6.839a.5.5 0 0 0 .928 0L16 28h.056a6.47 6.47 0 0 1 1.454-2.691 6.4\n    6.4 0 0 1 4.561-2.082h.01a7.018 7.018 0 0 1 1.49.154l2.529-2.527a4.44 4.44 0 0 1-.832-.322.648.648 0 0\n    1-.314-.611v-2.066l.406-.129a6.437 6.437 0 0 0 2.967.848h.057l1.316-1.327a2.914 2.914 0 0\n    0-1.282-.941l-.723-.318c-1.928-.9-2.748-1.986-2.748-3.619 0-2.174 1.646-3.578 4.2-3.578a5.914 5.914 0 0 1\n    2.631.477.539.539 0 0 1 .315.559v1.955l-.4.145-.242-.016a4.581 4.581 0 0 0-2.3-.535c-.443 0-1.475.082-1.475.842 0\n    .334.109.684 1.42 1.287l.613.271A5.14 5.14 0 0 1 32.2 15.8h1.467a2.179 2.179 0 0 1 .338.068V5A1 1 0 0 0 33 4zM6.66\n    21.145a6.547 6.547 0 0 1-3.006-.613.658.658 0 0 1-.314-.611v-2.066l.406-.129a6.437 6.437 0 0 0 2.967.848c.688 0\n    1.51-.158 1.51-.908 0-.336-.109-.717-1.41-1.359l-.725-.318C4.16 15.084 3.34 14 3.34 12.369c0-2.174 1.647-3.578\n    4.2-3.578a5.9 5.9 0 0 1 2.631.477.539.539 0 0 1 .314.559v1.955l-.4.145-.242-.016a4.541 4.541 0 0 0-2.3-.535c-.443\n    0-1.475.082-1.475.842 0 .334.109.684 1.42 1.287l.613.271c2.072.951 2.953 2.062 2.953 3.719-.005 2.218-1.728\n    3.65-4.394 3.65zm17.3-.383l-.049.057-.162.135-.228.035h-2.14l-.189-.439a439.332 439.332 0 0 1-.1-6.67c-.377\n    1.342-.826 2.9-1.227 4.277l-.738 2.568-.422.25-1.705.013a.531.531 0 0 1-.553-.394 431.388 431.388 0 0 1-1.74-6.75\n    628.034 628.034 0 0 1-.248 6.643l-.006.133-.131.238-.314.119-2.035.012-.189-.461.639-11.41.457-.146\n    2.676-.008a.547.547 0 0 1 .543.367c.272.945 1.275 4.518 1.856 6.859.353-1.24.848-2.871\n    1.273-4.277.316-1.043.6-1.973.762-2.539l.027-.06.121-.176.275-.15 2.941-.024.207.369.48 11.225z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ah($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SMSKey" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SMSKey extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ah, create_fragment$ah, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SMSLightning.svelte generated by Svelte v3.24.1 */

function create_fragment$ai(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 4H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5l3.536 6.839a.5.5 0 0 0 .928 0l2.581-4.992a12.131 12.131 0 0 1\n    1.437-9.2c-.009-.021-.027-.029-.035-.052a431.388 431.388 0 0 1-1.74-6.75 628.034 628.034 0 0 1-.248\n    6.643l-.006.133-.131.238-.314.119-2.035.012-.189-.461.639-11.41.457-.146 2.676-.008a.547.547 0 0 1 .543.367c.272.945\n    1.275 4.518 1.856 6.859.353-1.24.848-2.871 1.273-4.277.316-1.043.6-1.973.762-2.539l.027-.06.121-.176.275-.15\n    2.941-.024.207.369.248 5.8a12.255 12.255 0 0 1 2.109-.378 3.262 3.262 0 0 1-.967-2.385c0-2.174 1.646-3.578\n    4.2-3.578a5.914 5.914 0 0 1 2.631.477.539.539 0 0 1 .315.559v1.955l-.4.145-.242-.016a4.581 4.581 0 0\n    0-2.3-.535c-.443 0-1.475.082-1.475.842 0 .334.109.684 1.42 1.287l.613.271a5.033 5.033 0 0 1 2.531 2.108A12.27 12.27\n    0 0 1 34 16.893V5a1 1 0 0 0-1-1zM6.66 21.145a6.547 6.547 0 0 1-3.006-.613.658.658 0 0\n    1-.314-.611v-2.066l.406-.129a6.437 6.437 0 0 0 2.967.848c.688 0 1.51-.158 1.51-.908\n    0-.336-.109-.717-1.41-1.359l-.725-.318C4.16 15.084 3.34 14 3.34 12.369c0-2.174 1.647-3.578 4.2-3.578a5.9 5.9 0 0 1\n    2.631.477.539.539 0 0 1 .314.559v1.955l-.4.145-.242-.016a4.541 4.541 0 0 0-2.3-.535c-.443 0-1.475.082-1.475.842 0\n    .334.109.684 1.42 1.287l.613.271c2.072.951 2.953 2.062 2.953 3.719-.005 2.218-1.728 3.65-4.394 3.65zM20.288\n    16.7c.271-.177.544-.349.828-.5-.01-.815-.018-1.61-.022-2.318-.25.885-.529 1.856-.806 2.818z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm4.081 9.648l-5.928 6.777a.613.613 0 0\n    1-1.026-.642l2-4.748-2.827-1.214a1.059 1.059 0 0 1-.379-1.67l5.928-6.777a.613.613 0 0 1 1.026.642l-2 4.748 2.825\n    1.215a1.059 1.059 0 0 1 .381 1.669z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ai($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SMSLightning" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SMSLightning extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ai, create_fragment$ai, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SMSRefresh.svelte generated by Svelte v3.24.1 */

function create_fragment$aj(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 4.1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5l3.536 6.839a.5.5 0 0 0 .928 0l2.581-4.992a12.131 12.131 0 0 1\n    1.437-9.2c-.009-.021-.027-.029-.035-.052a431.388 431.388 0 0 1-1.74-6.75 628.034 628.034 0 0 1-.248\n    6.643l-.006.133-.131.238-.314.119-2.035.012-.189-.461.639-11.41.457-.146 2.676-.008a.547.547 0 0 1 .543.367c.272.945\n    1.275 4.518 1.856 6.859.353-1.24.848-2.871 1.273-4.277.316-1.043.6-1.973.762-2.539l.027-.061.121-.176.275-.15\n    2.941-.024.207.369.248 5.8a12.255 12.255 0 0 1 2.109-.378 3.262 3.262 0 0 1-.967-2.385c0-2.174 1.646-3.578\n    4.2-3.578a5.914 5.914 0 0 1 2.631.477.539.539 0 0 1 .315.559v1.955l-.4.145-.242-.016a4.581 4.581 0 0\n    0-2.3-.535c-.443 0-1.475.082-1.475.842 0 .334.109.684 1.42 1.287l.613.271a5.033 5.033 0 0 1 2.531 2.108A12.27 12.27\n    0 0 1 34 16.993V5.1a1 1 0 0 0-1-1zM6.66 21.245a6.547 6.547 0 0 1-3.006-.613.658.658 0 0\n    1-.314-.611v-2.066l.406-.129a6.437 6.437 0 0 0 2.967.848c.688 0 1.51-.158 1.51-.908\n    0-.336-.109-.717-1.41-1.359l-.725-.318C4.16 15.184 3.34 14.1 3.34 12.469c0-2.174 1.647-3.578 4.2-3.578a5.9 5.9 0 0 1\n    2.631.477.539.539 0 0 1 .314.559v1.955l-.4.145-.242-.016a4.541 4.541 0 0 0-2.3-.535c-.443 0-1.475.082-1.475.842 0\n    .334.109.684 1.42 1.287l.613.271c2.072.951 2.953 2.062 2.953 3.719-.005 2.218-1.728 3.65-4.394 3.65zM20.288\n    16.8c.271-.177.544-.349.828-.5-.01-.815-.018-1.61-.022-2.318-.25.885-.529 1.856-.806 2.818z");
			attr(path1, "d", "M27.1 33.463a6.143 6.143 0 0 1-4.718-2.1l2.282-2.287H18.2v6.477l2.476-2.481A8.648 8.648 0 0 0 27.1 36a9.2 9.2 0 0\n    0 8.9-8.9h-2.255a6.812 6.812 0 0 1-6.645 6.363zM33.585 21.126A9.112 9.112 0 0 0 27.1 18.2a9.2 9.2 0 0 0-8.9\n    8.9h2.255a6.812 6.812 0 0 1 6.645-6.364 6.214 6.214 0 0 1 4.817 2.093l-2.245 2.293H36V18.66z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aj($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SMSRefresh" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SMSRefresh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aj, create_fragment$aj, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SQLQuery.svelte generated by Svelte v3.24.1 */

function create_fragment$ak(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.41 32.478l-5.03-5.031a8.534 8.534 0 1 0-2.87 2.87l5.031 5.03a1.924 1.924 0 0 0 2.87 0 2.006 2.006 0 0 0\n    .555-1.12 2.036 2.036 0 0 0-.555-1.75zM17.923 23.1a5.241 5.241 0 1 1 5.242 5.241 5.241 5.241 0 0 1-5.242-5.24zM18\n    12c8.837 0 16-2.239 16-5s-7.163-5-16-5S2 4.239 2 7s7.163 5 16 5zm10.297 1.125a11.289 11.289 0 0 1 5.058 5.271A2.078\n    2.078 0 0 0 34 17v-6.73c-1.039 1.314-3.194 2.23-5.703 2.855zm-16.246 8.514a11.218 11.218 0 0 1 4.265-7.406C11.199\n    14.009 3.601 12.81 2 10.27V17c0 2.103 4.163 3.9 10.05 4.639zm-.07 2.215c-4.32-.56-8.796-1.702-9.981-3.579V29c0 2.761\n    7.163 5 16 5 .774 0 1.53-.023 2.275-.056a11.237 11.237 0 0 1-8.294-10.09z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ak($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SQLQuery" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SQLQuery extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ak, create_fragment$ak, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Sampler.svelte generated by Svelte v3.24.1 */

function create_fragment$al(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M22.457 17.037L8.232 31.262a2.471 2.471 0 1 1-3.494-3.494l14.225-14.225zm7.271-14.931a3.591 3.591 0 0 0-2.546\n    1.055l-4.525 4.525-1.414-1.414a1 1 0 0 0-1.414 0l-3.362 3.361a1 1 0 0 0 0 1.414l1.081 1.082L3.324 26.354a4.47 4.47 0\n    1 0 6.322 6.322l14.225-14.224 1.082 1.081a1 1 0 0 0 1.414 0l3.361-3.361a1 1 0 0 0 0-1.415l-1.414-1.414\n    4.525-4.525a3.6 3.6 0 0 0 0-5.092l-.565-.565a3.592 3.592 0 0 0-2.546-1.055z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$al($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Sampler" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Sampler extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$al, create_fragment$al, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Sandbox.svelte generated by Svelte v3.24.1 */

function create_fragment$am(ctx) {
	let svg;
	let rect;
	let rect_x_value;
	let rect_y_value;
	let rect_width_value;
	let rect_height_value;
	let rect_rx_value;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;
	let path8;
	let path9;
	let path10;
	let g0;
	let path11;
	let path12;
	let g1;
	let path13;
	let path14;
	let g2;
	let path15;
	let path16;
	let g3;
	let path17;
	let path18;
	let g4;
	let path19;
	let path20;
	let g5;
	let path21;
	let path22;
	let g6;
	let path23;
	let path24;
	let g7;
	let path25;
	let path26;
	let g8;
	let path27;
	let path28;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			path9 = svg_element("path");
			path10 = svg_element("path");
			g0 = svg_element("g");
			path11 = svg_element("path");
			path12 = svg_element("path");
			g1 = svg_element("g");
			path13 = svg_element("path");
			path14 = svg_element("path");
			g2 = svg_element("g");
			path15 = svg_element("path");
			path16 = svg_element("path");
			g3 = svg_element("g");
			path17 = svg_element("path");
			path18 = svg_element("path");
			g4 = svg_element("g");
			path19 = svg_element("path");
			path20 = svg_element("path");
			g5 = svg_element("g");
			path21 = svg_element("path");
			path22 = svg_element("path");
			g6 = svg_element("g");
			path23 = svg_element("path");
			path24 = svg_element("path");
			g7 = svg_element("g");
			path25 = svg_element("path");
			path26 = svg_element("path");
			g8 = svg_element("g");
			path27 = svg_element("path");
			path28 = svg_element("path");
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 2);
			attr(rect, "width", rect_width_value = 14);
			attr(rect, "height", rect_height_value = 30);
			attr(rect, "rx", rect_rx_value = 1);
			attr(path0, "d", "M24 2h2v2h-2z");
			attr(path1, "d", "M24 2h2v2h-2zM28 2h2v2h-2z");
			attr(path2, "d", "M28 2h2v2h-2zM34 4V3a1 1 0 0 0-1-1h-1v2z");
			attr(path3, "d", "M34 4V3a1 1 0 0 0-1-1h-1v2zM22 4V2h-1a1 1 0 0 0-1 1v1zM20 6h2v2h-2z");
			attr(path4, "d", "M20 6h2v2h-2zM20 10h2v2h-2z");
			attr(path5, "d", "M20 10h2v2h-2zM20 14h2v2h-2z");
			attr(path6, "d", "M20 14h2v2h-2zM20 18h2v2h-2z");
			attr(path7, "d", "M20 18h2v2h-2zM20 22h2v2h-2z");
			attr(path8, "d", "M20 22h2v2h-2zM20 26h2v2h-2z");
			attr(path9, "d", "M20 26h2v2h-2zM22 32v-2h-2v1a1 1 0 0 0 1 1z");
			attr(path10, "d", "M22 32v-2h-2v1a1 1 0 0 0 1 1z");
			attr(path11, "d", "M24 30h2v2h-2z");
			attr(path12, "d", "M24 30h2v2h-2z");
			attr(path13, "d", "M28 30h2v2h-2z");
			attr(path14, "d", "M28 30h2v2h-2z");
			attr(path15, "d", "M32 6h2v2h-2z");
			attr(path16, "d", "M32 6h2v2h-2z");
			attr(path17, "d", "M32 10h2v2h-2z");
			attr(path18, "d", "M32 10h2v2h-2z");
			attr(path19, "d", "M32 14h2v2h-2z");
			attr(path20, "d", "M32 14h2v2h-2z");
			attr(path21, "d", "M32 18h2v2h-2z");
			attr(path22, "d", "M32 18h2v2h-2z");
			attr(path23, "d", "M32 22h2v2h-2z");
			attr(path24, "d", "M32 22h2v2h-2z");
			attr(path25, "d", "M32 26h2v2h-2z");
			attr(path26, "d", "M32 26h2v2h-2z");
			attr(path27, "d", "M34 31v-1h-2v2h1a1 1 0 0 0 1-1z");
			attr(path28, "d", "M34 31v-1h-2v2h1a1 1 0 0 0 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
			append(svg, path5);
			append(svg, path6);
			append(svg, path7);
			append(svg, path8);
			append(svg, path9);
			append(svg, path10);
			append(svg, g0);
			append(g0, path11);
			append(g0, path12);
			append(svg, g1);
			append(g1, path13);
			append(g1, path14);
			append(svg, g2);
			append(g2, path15);
			append(g2, path16);
			append(svg, g3);
			append(g3, path17);
			append(g3, path18);
			append(svg, g4);
			append(g4, path19);
			append(g4, path20);
			append(svg, g5);
			append(g5, path21);
			append(g5, path22);
			append(svg, g6);
			append(g6, path23);
			append(g6, path24);
			append(svg, g7);
			append(g7, path25);
			append(g7, path26);
			append(svg, g8);
			append(g8, path27);
			append(g8, path28);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$am($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Sandbox" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Sandbox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$am, create_fragment$am, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SaveAsFloppy.svelte generated by Svelte v3.24.1 */

function create_fragment$an(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 2h4v6h-4z");
			attr(path1, "d", "M15.769 32H8V16h13.52a12.24 12.24 0 0 1 12.48.893V8.42a1 1 0 0 0-.292-.707s-5.425-5.422-5.557-5.535A.967.967 0 0\n    0 27.589 2H26v8H12V2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h13.892a12.255 12.255 0 0 1-1.123-2z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$an($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SaveAsFloppy" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SaveAsFloppy extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$an, create_fragment$an, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SaveFloppy.svelte generated by Svelte v3.24.1 */

function create_fragment$ao(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 4h4v6h-4z");
			attr(path1, "d", "M31.708 8.293s-4.015-4-4.146-4.114A.969.969 0 0 0 27 4h-1v8H14V4H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0\n    1-1V9a1 1 0 0 0-.292-.707zM26 30H10V16h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ao($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SaveFloppy" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SaveFloppy extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ao, create_fragment$ao, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SaveTo.svelte generated by Svelte v3.24.1 */

function create_fragment$ap(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 10h-6a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h3v16H6V14h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1\n    1h30a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			attr(path1, "d", "M10.2 17.331l7.445 7.525a.5.5 0 0 0 .7 0l7.455-7.525a.782.782 0 0 0 .2-.526.8.8 0 0 0-.8-.8H20V3a1 1 0 0\n    0-1-1h-2a1 1 0 0 0-1 1v13h-5.2a.8.8 0 0 0-.8.8.782.782 0 0 0 .2.531z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ap($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SaveTo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SaveTo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ap, create_fragment$ap, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SaveToLight.svelte generated by Svelte v3.24.1 */

function create_fragment$aq(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 8h-7v2h6v20H4V10h6V8H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1z");
			attr(path1, "d", "M24.793 14H20V.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V14h-4.793a.5.5 0 0 0-.353.854L18 22l7.146-7.146a.5.5 0 0\n    0-.353-.854z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aq($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SaveToLight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SaveToLight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aq, create_fragment$aq, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Scribble.svelte generated by Svelte v3.24.1 */

function create_fragment$ar(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.965 4.572a.965.965 0 0 0-.043-1.362.963.963 0 0 0-1.362-.044 1.329 1.329 0 0 0-.117.145l-.011-.011-8.739\n    8.736.012.016a.685.685 0 0 0-.145.119.995.995 0 0 0 1.4 1.4.909.909 0 0 0 .119-.145l.013.013L27.835\n    4.7l-.015-.013a.855.855 0 0 0 .145-.115zM29.742 6.1c-.721.721-9.538 9.645-9.589 9.7a2.213 2.213 0 0\n    1-2.361.029l-.768-.725L6.229 25.686a1.5 1.5 0 0 0-.327.48l-1.871 6.406a.375.375 0 0 0 .495.491l6.433-1.956a1.5 1.5 0\n    0 0 .46-.313L33 9.291zM30.757 4.384l3.105 2.956a2.779 2.779 0 0 0-.807-3.233 3.3 3.3 0 0\n    0-3.22-1.061c-.179.065.064.3.138.375s.736.867.784.963zM34.074 28.947a10.743 10.743 0 0 0-7.834-.927 19.245 19.245 0\n    0 0-6.881 3.4c-.8.577-1.684 1.182-2.277.919a2.586 2.586 0 0 1-.877-1.013 8.469 8.469 0 0 0-.6-.857 4.528 4.528 0 0\n    0-.388-.386L13.78 31.52a2.517 2.517 0 0 1 .279.22 6.748 6.748 0 0 1 .457.662 4.107 4.107 0 0 0 1.766 1.771 2.721\n    2.721 0 0 0 1.1.228 5.741 5.741 0 0 0 3.156-1.364 17.327 17.327 0 0 1 6.16-3.066 8.879 8.879 0 0 1 6.381.714 1 1 0 0\n    0 1-1.734z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ar($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Scribble" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Scribble extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ar, create_fragment$ar, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Search.svelte generated by Svelte v3.24.1 */

function create_fragment$as(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.173 30.215L25.4 22.443a12.826 12.826 0 1 0-2.957 2.957l7.772 7.772a2.1 2.1 0 0 0 2.958-2.958zM6 15a9 9 0 1 1\n    9 9 9 9 0 0 1-9-9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$as($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Search" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Search extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$as, create_fragment$as, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Seat.svelte generated by Svelte v3.24.1 */

function create_fragment$at(ctx) {
	let svg;
	let path0;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M5 18H4a2 2 0 0 0-2 2v13a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1zM32 18h-1a1 1 0 0 0-1 1v14a1 1 0 0 0 1\n    1h2a1 1 0 0 0 1-1V20a2 2 0 0 0-2-2z");
			attr(rect, "height", rect_height_value = 8);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 20);
			attr(rect, "x", rect_x_value = 8);
			attr(rect, "y", rect_y_value = 22);
			attr(path1, "d", "M22 4h-8a6 6 0 0 0-6 6v9a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-9a6 6 0 0 0-6-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$at($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Seat" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Seat extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$at, create_fragment$at, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SeatAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$au(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M5 18H4a2 2 0 0 0-2 2v13a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1zM9 20h7.886A12.285 12.285 0 0 1 27\n    14.7c.337 0 .67.014 1 .041V10a6 6 0 0 0-6-6h-8a6 6 0 0 0-6 6v9a1 1 0 0 0 1 1zM14.7 27a12.256 12.256 0 0 1 1.06-5H9a1\n    1 0 0 0-1 1v6a1 1 0 0 0 1 1h6.069a12.3 12.3 0 0 1-.369-3zM27.1 18.2a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5\n    9.4a.5.5 0 0 1-.5.5h-3.5v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3.5h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h3.5v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v3.5h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$au($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SeatAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SeatAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$au, create_fragment$au, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Segmentation.svelte generated by Svelte v3.24.1 */

function create_fragment$av(ctx) {
	let svg;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 4.201);
			attr(path, "d", "M26.149 19.5a8.247 8.247 0 0 1-11.195 6.2l-4.117 6.587A15.969 15.969 0 0 0 33.924 19.5zM19.5 9.851a8.267 8.267 0\n    0 1 4.26 2.19l6.319-4.513A15.951 15.951 0 0 0 19.5 2.076zM31.823 9.97L25.5 14.489a8.222 8.222 0 0 1 .653\n    2.011h7.775a15.869 15.869 0 0 0-2.105-6.53zM12.416 24.1A8.26 8.26 0 0 1 16.5 9.851V2.076A15.981 15.981 0 0 0 8.294\n    30.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$av($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Segmentation" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Segmentation extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$av, create_fragment$av, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Segments.svelte generated by Svelte v3.24.1 */

function create_fragment$aw(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.118 14h23.764A1.119 1.119 0 0 0 36 12.882V5.118A1.118 1.118 0 0 0 34.882 4H11.118A1.118 1.118 0 0 0 10\n    5.118V8H6a2 2 0 0 0-2 2v3.1a5 5 0 0 0 0 9.8V26a2 2 0 0 0 2 2h4v2.882A1.119 1.119 0 0 0 11.118 32h23.764A1.119 1.119\n    0 0 0 36 30.882v-7.764A1.118 1.118 0 0 0 34.882 22H11.118A1.118 1.118 0 0 0 10 23.118V26H6v-3.1a5 5 0 0 0\n    0-9.8V10h4v2.882A1.119 1.119 0 0 0 11.118 14zM8 18a3 3 0 1 1-3-3 3 3 0 0 1 3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aw($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Segments" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Segments extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aw, create_fragment$aw, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Select.svelte generated by Svelte v3.24.1 */

function create_fragment$ax(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M8.5 2.054a.5.5 0 0 0-.5.5v32.78a.5.5 0 0 0 .5.5.49.49 0 0 0 .35-.147L18.524 26h13a.5.5 0 0 0 .354-.854L8.854\n    2.2a.49.49 0 0 0-.354-.146z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ax($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Select" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ax, create_fragment$ax, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$ay(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 10h2v6H2zM4 22v-2H2v3.111a.889.889 0 0 0 .889.889H6v-2zM24 12v-2h-2v3.111a.889.889 0 0 0 .889.889H26v-2zM14\n    32v-2h-2v3.111a.889.889 0 0 0 .889.889H16v-2zM20 32h6v2h-6zM32 20h2v6h-2zM32 30v2h-2v2h3a1 1 0 0 0 1-1v-3zM23.111\n    2H20v2h2v2h2V2.889A.889.889 0 0 0 23.111 2zM33.111 12H30v2h2v2h2v-3.111a.889.889 0 0 0-.889-.889zM13.111\n    22H10v2h2v2h2v-3.111a.889.889 0 0 0-.889-.889zM10 2h6v2h-6zM6 2H3a1 1 0 0 0-1 1v3h2V4h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ay($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ay, create_fragment$ay, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectBox.svelte generated by Svelte v3.24.1 */

function create_fragment$az(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.2 2H6.8A4.8 4.8 0 0 0 2 6.8v22.4A4.8 4.8 0 0 0 6.8 34h22.4a4.8 4.8 0 0 0 4.8-4.8V6.8A4.8 4.8 0 0 0 29.2\n    2zm-.355 10.377L14.566 26.655a.8.8 0 0 1-1.131 0l-6.28-6.278a.8.8 0 0 1 0-1.131l2.491-2.491a.8.8 0 0 1 1.131 0L14\n    19.98 25.223 8.755a.8.8 0 0 1 1.131 0l2.491 2.491a.8.8 0 0 1 0 1.131z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$az($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectBox" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectBox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$az, create_fragment$az, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectBoxAll.svelte generated by Svelte v3.24.1 */

function create_fragment$aA(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M29.2 8H12.8A4.8 4.8 0 0 0 8 12.8v16.4a4.8 4.8 0 0 0 4.8 4.8h16.4a4.8 4.8 0 0 0 4.8-4.8V12.8A4.8 4.8 0 0 0 29.2\n    8zm1.223 9.049L18.988 28.573a.8.8 0 0 1-1.131 0l-6.28-6.278a.8.8 0 0 1 0-1.131l2.491-2.491a.8.8 0 0 1 1.131 0l3.224\n    3.227 8.378-8.47a.8.8 0 0 1 1.131 0l2.491 2.491a.8.8 0 0 1 0 1.128z");
			attr(path1, "d", "M26 2H6.8A4.8 4.8 0 0 0 2 6.8V26a4 4 0 0 0 4 4V6h24a4 4 0 0 0-4-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aA($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectBoxAll" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectBoxAll extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aA, create_fragment$aA, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectCircular.svelte generated by Svelte v3.24.1 */

function create_fragment$aB(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.8 5.46l-.654-1.9A16.023 16.023 0 0 0 6 7.428l1.657 1.159A14.014 14.014 0 0 1 11.8 5.46zM5.608\n    11.493l-1.657-1.16a15.839 15.839 0 0 0-1.844 5.888h2.017a13.919 13.919 0 0 1 1.484-4.728zM4.124 19.777H2.1a16.021\n    16.021 0 0 0 2.145 6.36l1.6-1.206a13.892 13.892 0 0 1-1.721-5.154zM7.984 27.772l-1.606 1.21a15.869 15.869 0 0 0\n    5.273 3.7l.59-1.929a14.026 14.026 0 0 1-4.257-2.981zM18 32a13.978 13.978 0 0 1-2.357-.214l-.59 1.933a15.862 15.862 0\n    0 0 6.44-.116l-.653-1.893A14 14 0 0 1 18 32zM24.2 30.539l.653 1.9A16 16 0 0 0 30 28.569l-1.653-1.158a14.038 14.038 0\n    0 1-4.147 3.128zM31.874 19.777a13.9 13.9 0 0 1-1.484 4.728l1.656 1.159a15.842 15.842 0 0 0 1.844-5.887zM31.874\n    16.221H33.9a16.02 16.02 0 0 0-2.147-6.361l-1.6 1.207a13.887 13.887 0 0 1 1.721 5.154zM28.013\n    8.226l1.607-1.211a15.885 15.885 0 0 0-5.274-3.7l-.59 1.93a14.023 14.023 0 0 1 4.257 2.981zM18 4a14.07 14.07 0 0 1\n    2.356.213l.591-1.935a15.88 15.88 0 0 0-6.44.117l.653 1.894A14.059 14.059 0 0 1 18 4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aB($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectCircular" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectCircular extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aB, create_fragment$aB, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectContainer.svelte generated by Svelte v3.24.1 */

function create_fragment$aC(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 6H7a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM14 32H8v-4h6zm0-6H8v-4h6zm0-6H8v-4h6zm18\n    12H16v-4h16zm0-6H16v-4h16zm0-6H16v-4h16zm0-6H8V8h24z");
			attr(path1, "d", "M4 4h26V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aC($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectContainer" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectContainer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aC, create_fragment$aC, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectGear.svelte generated by Svelte v3.24.1 */

function create_fragment$aD(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M6 8.731V6h10v6.107l4 3.982V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h2zM35.193 25.786h-2.125a6.142 6.142\n    0 0 0-.9-2.179l1.513-1.513a.607.607 0 0 0 0-.858l-.92-.92a.607.607 0 0 0-.858 0l-1.511 1.514a6.145 6.145 0 0\n    0-2.178-.9v-2.123a.607.607 0 0 0-.607-.607h-1.214a.607.607 0 0 0-.607.607v2.125a6.145 6.145 0 0\n    0-2.178.9l-1.513-1.513a.607.607 0 0 0-.858 0l-.92.92a.607.607 0 0 0 0 .858l1.513 1.513a6.142 6.142 0 0 0-.9\n    2.179h-2.123a.607.607 0 0 0-.607.607v1.214a.607.607 0 0 0 .607.607h2.125a6.142 6.142 0 0 0 .9 2.179l-1.513\n    1.513a.607.607 0 0 0 0 .858l.92.92a.607.607 0 0 0 .858 0l1.513-1.513a6.145 6.145 0 0 0 2.178.9v2.125a.607.607 0 0 0\n    .607.607h1.214a.607.607 0 0 0 .607-.607v-2.131a6.145 6.145 0 0 0 2.178-.9l1.513 1.513a.607.607 0 0 0 .858\n    0l.92-.92a.607.607 0 0 0 0-.858l-1.515-1.511a6.142 6.142 0 0 0 .9-2.179h2.125a.607.607 0 0 0\n    .607-.607v-1.213a.607.607 0 0 0-.609-.607zM27 30.164A3.164 3.164 0 1 1 30.164 27 3.164 3.164 0 0 1 27 30.164z");
			attr(path1, "d", "M18.55 18.1L8.5 8.086A.285.285 0 0 0 8.294 8 .292.292 0 0 0 8 8.292v19.139a.292.292 0 0 0 .294.293.285.285 0 0 0\n    .2-.086l4.37-5.657h2.939A12.318 12.318 0 0 1 18.55 18.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aD($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectGear" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectGear extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aD, create_fragment$aD, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectIntersect.svelte generated by Svelte v3.24.1 */

function create_fragment$aE(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 10h2v6H2zM4 22v-2H2v3.111a.889.889 0 0 0 .889.889H8v-2zM14 32v-4h-2v5.111a.889.889 0 0 0 .889.889H16v-2zM20\n    32h6v2h-6zM32 20h2v6h-2zM32 30v2h-2v2h3a1 1 0 0 0 1-1v-3zM23.111 2H20v2h2v4h2V2.889A.889.889 0 0 0 23.111 2zM33.111\n    12H28v2h4v2h2v-3.111a.889.889 0 0 0-.889-.889zM10 2h6v2h-6zM6 2H3a1 1 0 0 0-1 1v3h2V4h2zM12 12h2.25v2.263H12zM16.84\n    12h2.25v2.263h-2.25zM21.739 12.01h2.25v2.263h-2.25zM12 16.824h2.25v2.263H12zM16.84 16.824h2.25v2.263h-2.25zM16.84\n    21.507h2.25v2.263h-2.25zM21.739 16.834h2.25v2.263h-2.25zM12.01 21.737h2.25V24h-2.25zM21.749 21.507h2.25v2.263h-2.25z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aE($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectIntersect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectIntersect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aE, create_fragment$aE, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectSubstract.svelte generated by Svelte v3.24.1 */

function create_fragment$aF(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 14v-2h2v3.111a.889.889 0 0 1-.889.889H28v-2zM14 30v-2h2v3.111a.889.889 0 0 1-.889.889H12v-2zM4 20h2v5H4zM4\n    12h2v5H4zM6 30v-2H4v3.111a.889.889 0 0 0 .889.889H9v-2zM31.111 4H27v2h3v3h2V4.888A.888.888 0 0 0 31.111 4zM19\n    4h5.001v2H19zM11 4h5.001v2H11zM8 4H5a1 1 0 0 0-1 1v4h2V6h2zM14 21h2v4h-2zM21 14h4.001v2H21zM18 14h-3a1 1 0 0 0-1\n    1v3h2v-2h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aF($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectSubstract" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectSubstract extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aF, create_fragment$aF, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Selection.svelte generated by Svelte v3.24.1 */

function create_fragment$aG(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4 20h2v5H4zM4 12h2v5H4zM6 30v-2H4v3.111a.889.889 0 0 0 .89.889H9v-2zM12 30h5v2h-5zM20 30h5v2h-5zM30\n    11h2v5h-2zM30 19h2v5h-2zM30 27v3h-2v2h3a1 1 0 0 0 1-1v-4zM31.112 4H27v2h3v2h2V4.889A.889.889 0 0 0 31.112 4zM19\n    4h5.001v2H19zM11 4h5.001v2H11zM8 4H5a1 1 0 0 0-1 1v4h2V6h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aG($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Selection" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Selection extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aG, create_fragment$aG, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectionChecked.svelte generated by Svelte v3.24.1 */

function create_fragment$aH(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 20h2v6H2zM2 10h2v6H2zM32 10h2v6h-2zM4 32v-2H2v3.111a.889.889 0 0 0 .889.889H6v-2zM33.111\n    2H30v2h2v2h2V2.888A.888.888 0 0 0 33.111 2zM20 2h6v2h-6zM10 2h6v2h-6zM10 32h6v2h-6zM6 2H3a1 1 0 0 0-1 1v3h2V4h2zM27\n    18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm5.957 6.26l-6.476 7.929a.5.5 0 0 1-.738.041l-4.759-4.667a.5.5 0 0\n    1-.008-.708l1.61-1.641a.5.5 0 0 1 .706-.007l2.573 2.519 4.535-5.553a.5.5 0 0 1 .7-.07l1.78 1.453a.5.5 0 0 1\n    .077.704z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aH($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectionChecked" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectionChecked extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aH, create_fragment$aH, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SelectionMove.svelte generated by Svelte v3.24.1 */

function create_fragment$aI(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 20h2v6H2zM2 10h2v6H2zM4 32v-2H2v3.111a.889.889 0 0 0 .889.889H6v-2zM10 32h6v2h-6zM32 10h2v6h-2zM33.111\n    2H30v2h2v2h2V2.889A.889.889 0 0 0 33.111 2zM20 2h6v2h-6zM10 2h6v2h-6zM6 2H3a1 1 0 0 0-1 1v3h2V4h2zM34.887\n    24.684l-4.034-3.537A.489.489 0 0 0 30.5 21a.5.5 0 0 0-.5.5V24h-4v-4h2.5a.5.5 0 0 0 .5-.5.49.49 0 0\n    0-.148-.35l-3.536-4.033a.5.5 0 0 0-.633 0l-3.536 4.033a.489.489 0 0 0-.147.35.5.5 0 0 0 .5.5H24v4h-4v-2.5a.5.5 0 0\n    0-.5-.5.489.489 0 0 0-.35.147l-4.034 3.537a.5.5 0 0 0 0 .632l4.034 3.536a.49.49 0 0 0 .35.148.5.5 0 0 0\n    .5-.5V26h4v4h-2.5a.5.5 0 0 0-.5.5.487.487 0 0 0 .147.35l3.536 4.034a.5.5 0 0 0 .633 0l3.536-4.034A.488.488 0 0 0 29\n    30.5a.5.5 0 0 0-.5-.5H26v-4h4v2.5a.5.5 0 0 0 .5.5.49.49 0 0 0 .35-.148l4.034-3.536a.5.5 0 0 0 0-.632z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aI($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SelectionMove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SelectionMove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aI, create_fragment$aI, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Send.svelte generated by Svelte v3.24.1 */

function create_fragment$aJ(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.191 5.113L1.8 14.478a.5.5 0 0 0-.081.927l7.921 3.953zM13.089 21.032l11.937 6a1 1 0 0 0\n    1.343-.446l9.267-20.222zM10.08 23.25v7.639a.713.713 0 0 0 1.174.544l5.36-4.516z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aJ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Send" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Send extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aJ, create_fragment$aJ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SentimentNegative.svelte generated by Svelte v3.24.1 */

function create_fragment$aK(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm5.473 6.432c1.657 0 3 1.679 3 3.75s-1.343 3.75-3 3.75-3-1.679-3-3.75\n    1.343-3.75 3-3.75zm-11.108.1c1.656 0 3 1.679 3 3.75s-1.344 3.75-3 3.75-3-1.679-3-3.75 1.343-3.748 3-3.748zm14.512\n    16.11l-.942.476a1 1 0 0 1-1.124-.152c-.333-.3-.727-.659-.829-.73a10.487 10.487 0 0 0-5.941-1.736 10.474 10.474 0 0\n    0-6 1.771c-.124.088-.489.424-.8.717a1 1 0 0 1-1.134.161l-.928-.47a1 1 0 0\n    1-.29-1.564c.232-.257.442-.483.526-.558a13.008 13.008 0 0 1 8.626-3.057 12.969 12.969 0 0 1 8.729\n    3.15c.047.043.208.219.4.432a1 1 0 0 1-.293 1.56z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aK($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SentimentNegative" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SentimentNegative extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aK, create_fragment$aK, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SentimentNeutral.svelte generated by Svelte v3.24.1 */

function create_fragment$aL(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-5.635 8.534c1.656 0 3 1.679 3 3.75s-1.344 3.75-3 3.75-3-1.679-3-3.75\n    1.343-3.75 3-3.75zM23.2 26H12.8a.8.8 0 0 1-.8-.8v-.4a.8.8 0 0 1 .8-.8h10.4a.8.8 0 0 1 .8.8v.4a.8.8 0 0\n    1-.8.8zm.273-8.068c-1.657 0-3-1.679-3-3.75s1.343-3.75 3-3.75 3 1.679 3 3.75-1.343 3.75-3 3.75z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aL($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SentimentNeutral" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SentimentNeutral extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aL, create_fragment$aL, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SentimentPositive.svelte generated by Svelte v3.24.1 */

function create_fragment$aM(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-5.635 6.534c1.656 0 3 1.679 3 3.75s-1.344 3.75-3 3.75-3-1.679-3-3.75\n    1.343-3.75 3-3.75zm11.108-.1c1.657 0 3 1.679 3 3.75s-1.343 3.75-3 3.75-3-1.679-3-3.75 1.343-3.752 3-3.752zM18\n    28.04c-5.033 0-9.556-3.633-10-8.14h20c-.444 4.507-4.967 8.14-10 8.14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aM($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SentimentPositive" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SentimentPositive extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aM, create_fragment$aM, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Separator.svelte generated by Svelte v3.24.1 */

function create_fragment$aN(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M29 4H7a1 1 0 0 0-1 1v9h24V5a1 1 0 0 0-1-1zM6 31a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-9H6z");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 32);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 16);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aN($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Separator" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Separator extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aN, create_fragment$aN, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Servers.svelte generated by Svelte v3.24.1 */

function create_fragment$aO(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11 10h22a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v3H4V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v31a.5.5 0 0\n    0 .5.5h1a.5.5 0 0 0 .5-.5V30h6v3a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1H4v-8h6v1a1 1 0 0\n    0 1 1h22a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v3H4V8h6v1a1 1 0 0 0 1 1zm1\n    18h4v2h-4zm0-12h4v2h-4zm0-12h4v2h-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aO($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Servers" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Servers extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aO, create_fragment$aO, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Settings.svelte generated by Svelte v3.24.1 */

function create_fragment$aP(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.9 15.793h-3.111a11.953 11.953 0 0 0-1.842-4.507l2.205-2.206a1.1 1.1 0 0 0 0-1.56l-1.673-1.672a1.1 1.1 0 0\n    0-1.56 0l-2.205 2.205a11.925 11.925 0 0 0-4.507-1.841V3.1A1.1 1.1 0 0 0 19.1 2h-2.2a1.1 1.1 0 0 0-1.1\n    1.1v3.112a11.925 11.925 0 0 0-4.507 1.841l-2.2-2.205a1.1 1.1 0 0 0-1.56 0L5.848 7.52a1.1 1.1 0 0 0 0 1.56l2.205\n    2.206a11.953 11.953 0 0 0-1.842 4.507H3.1A1.1 1.1 0 0 0 2 16.9v2.2a1.1 1.1 0 0 0 1.1 1.1h3.111a11.934 11.934 0 0 0\n    1.842 4.507l-2.205 2.212a1.1 1.1 0 0 0 0 1.56l1.673 1.673a1.1 1.1 0 0 0 1.56 0l2.205-2.205a11.925 11.925 0 0 0 4.507\n    1.841V32.9A1.1 1.1 0 0 0 16.9 34h2.2a1.1 1.1 0 0 0 1.1-1.1v-3.112a11.925 11.925 0 0 0 4.507-1.841l2.205 2.205a1.1\n    1.1 0 0 0 1.56 0l1.673-1.673a1.1 1.1 0 0 0 0-1.56l-2.205-2.205a11.934 11.934 0 0 0 1.842-4.507H32.9A1.1 1.1 0 0 0 34\n    19.1v-2.2a1.1 1.1 0 0 0-1.1-1.107zM22.414 18A4.414 4.414 0 1 1 18 13.586 4.414 4.414 0 0 1 22.414 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aP($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Settings" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Settings extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aP, create_fragment$aP, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Shapes.svelte generated by Svelte v3.24.1 */

function create_fragment$aQ(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M22.521 31.8a11.307 11.307 0 0 1-11.052-9.024l-.032-.16h-9.7a.256.256 0 0 1-.224-.131.246.246 0 0 1 0-.256L11.736\n    4.33a.261.261 0 0 1 .45 0l3.941 6.9.18-.12a11.279 11.279 0 1 1 6.214 20.69zm-9.085-8.934a9.38 9.38 0 1 0\n    3.789-10.09l-.153.1 5.342 9.349a.251.251 0 0 1 0 .256.257.257 0 0 1-.225.131h-8.818z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aQ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Shapes" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Shapes extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aQ, create_fragment$aQ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Share.svelte generated by Svelte v3.24.1 */

function create_fragment$aR(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 10h-6a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h3v16H6V14h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1\n    1h30a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			attr(path1, "d", "M10.8 8H16v11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h5.2a.8.8 0 0 0 .8-.8.787.787 0 0 0-.2-.527L18.351.144a.5.5 0 0 0-.7\n    0L10.2 6.668a.787.787 0 0 0-.2.532.8.8 0 0 0 .8.8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aR($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Share" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Share extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aR, create_fragment$aR, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShareAndroid.svelte generated by Svelte v3.24.1 */

function create_fragment$aS(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.464 24.227a4.459 4.459 0 0 0-3.157 1.3l-11.336-6.333a4.374 4.374 0 0 0 0-2.373l11.336-6.368a4.512 4.512 0 1\n    0-1.143-1.945l-11.319 6.359a4.473 4.473 0 1 0 0 6.282l11.319 6.327a4.472 4.472 0 1 0 4.3-3.249z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aS($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShareAndroid" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShareAndroid extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aS, create_fragment$aS, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShareCheck.svelte generated by Svelte v3.24.1 */

function create_fragment$aT(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.722 6.332L12 0 6.292 6.332A1 1 0 0 0 7.035 8H10v9.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V8h2.979a1 1 0 0 0\n    .743-1.668zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.127a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.005z");
			attr(path1, "d", "M14.7 27a12.272 12.272 0 0 1 .384-3H4V14h2v-4H1a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h13.75c-.026-.33-.05-.662-.05-1zM20\n    16.893a12.226 12.226 0 0 1 4-1.809V11a1 1 0 0 0-1-1h-5v4h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aT($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShareCheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShareCheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aT, create_fragment$aT, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShareLight.svelte generated by Svelte v3.24.1 */

function create_fragment$aU(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24.476 7.165L18 0l-6.46 7.165a.5.5 0 0 0 .371.835H16v11.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V8h4.105a.5.5 0 0 0\n    .371-.835z");
			attr(path1, "d", "M33 10h-7v2h6v20H4V12h6v-2H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aU($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShareLight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShareLight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aU, create_fragment$aU, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShareWindows.svelte generated by Svelte v3.24.1 */

function create_fragment$aV(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.174 16.724A13.773 13.773 0 0 0 31.9 12.26a7.712 7.712 0 0 1-2.736 2.45A10.216 10.216 0 0 1 28 23.955a5.236\n    5.236 0 1 0 2.327 2.7 13.676 13.676 0 0 0 2.847-9.931zM17.728 28.325a10.278 10.278 0 0 1-7.222-5.1 5.187 5.187 0 1\n    0-5.633.324 5.147 5.147 0 0 0 2.242.654 13.7 13.7 0 0 0 11.4 7.708 7.808 7.808 0 0 1-.787-3.586zM28.073 3.357a5.185\n    5.185 0 0 0-6.567 1.209A13.744 13.744 0 0 0 8.768 9.531a13.943 13.943 0 0 0-1.2 1.741 7.73 7.73 0 0 1\n    3.538.924c.117-.163.235-.326.362-.483a10.23 10.23 0 0 1 6.92-3.77 10.64 10.64 0 0 1 1.11-.059c.277 0\n    .552.016.826.038a5.184 5.184 0 1 0 7.746-4.565z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aV($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShareWindows" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShareWindows extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aV, create_fragment$aV, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Sharpen.svelte generated by Svelte v3.24.1 */

function create_fragment$aW(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 .4L6.428 33.5a.385.385 0 0 0 .372.5h22.4a.385.385 0 0 0 .368-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aW($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Sharpen" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Sharpen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aW, create_fragment$aW, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Shield.svelte generated by Svelte v3.24.1 */

function create_fragment$aX(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v13.1a15.608 15.608 0 0 0 5.857 12.187l5.674 4.355a.7.7 0 0 0 .937\n    0l5.674-4.355A15.608 15.608 0 0 0 30 16.1zM9.722 22.287A14.482 14.482 0 0 1 8 16V4h20z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aX($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Shield" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Shield extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aX, create_fragment$aX, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Ship.svelte generated by Svelte v3.24.1 */

function create_fragment$aY(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32 18l-.047-13.004a1 1 0 0 0-1-.996H22V1a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v3H5a1 1 0 0 0-1 1v13l13.973-2.994zM8\n    8h20v2H8zM35.217 21.826L18 18l2 18h9.044a.989.989 0 0 0 1-.848C30.585 30.106 36 30.962 36 26v-3.198a1 1 0 0\n    0-.783-.976zM0 22.802V26c0 4.962 5.415 4.106 5.956 9.152a.989.989 0 0 0 1 .848H18V18L.783 21.826a1 1 0 0 0-.783.976z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aY($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Ship" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Ship extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aY, create_fragment$aY, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Shop.svelte generated by Svelte v3.24.1 */

function create_fragment$aZ(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.94 16H1.06a.8.8 0 0 1-.769-1.02L3.793 2.725A1 1 0 0 1 4.754 2h26.492a1 1 0 0 1 .961.725L35.71 14.98a.8.8 0 0\n    1-.77 1.02zM30 18v6H14v-6h-2v14H6V18H4v14a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V18zM4 14h2L8 4H6zm8.5 0h2l1-10h-2zm8-10l1\n    10h2l-1-10zM30 4h-2l2 10h2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$aZ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Shop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Shop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$aZ, create_fragment$aZ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShoppingCart.svelte generated by Svelte v3.24.1 */

function create_fragment$a_(ctx) {
	let svg;
	let ellipse0;
	let ellipse0_cx_value;
	let ellipse0_cy_value;
	let ellipse0_rx_value;
	let ellipse0_ry_value;
	let ellipse1;
	let ellipse1_cx_value;
	let ellipse1_cy_value;
	let ellipse1_rx_value;
	let ellipse1_ry_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			ellipse0 = svg_element("ellipse");
			ellipse1 = svg_element("ellipse");
			path = svg_element("path");
			attr(ellipse0, "cx", ellipse0_cx_value = 10.445);
			attr(ellipse0, "cy", ellipse0_cy_value = 31.143);
			attr(ellipse0, "rx", ellipse0_rx_value = 2.667);
			attr(ellipse0, "ry", ellipse0_ry_value = 2.917);
			attr(ellipse1, "cx", ellipse1_cx_value = 25.778);
			attr(ellipse1, "cy", ellipse1_cy_value = 31.143);
			attr(ellipse1, "rx", ellipse1_rx_value = 2.667);
			attr(ellipse1, "ry", ellipse1_ry_value = 2.917);
			attr(path, "d", "M29.326 24H10.469l.762-2.6H28a1.331 1.331 0 0 0 1.307-1.071L33.974 7.66a1.334 1.334 0 0\n    0-1.308-1.595h-.126v-.03H6.5l-1.289-3.5A1.335 1.335 0 0 0 3.889 1.4H1.333a1.334 1.334 0 0 0 0 2.667h1.406L8.667\n    20l-1.294 5.075A1.569 1.569 0 0 0 8.667 27h20.666a1.589 1.589 0 0 0 1.334-1.6 1.4 1.4 0 0 0-1.341-1.4zM7.529\n    8.835H30.6l-3.693 9.9H11.174z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, ellipse0);
			append(svg, ellipse1);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShoppingCart" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShoppingCart extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a_, create_fragment$a_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShowAllLayers.svelte generated by Svelte v3.24.1 */

function create_fragment$a$(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.575 17.83L2.887 10.351c-.241-.123-.241-.323 0-.446l14.688-7.48a.943.943 0 0 1 .85 0L33.113\n    9.9c.241.123.241.323 0 .446L18.425 17.83a.936.936 0 0 1-.85 0zM33.114 25.905l-4.6-2.341L18 28.918 7.484 23.564l-4.6\n    2.341c-.241.123-.241.323 0 .446l14.691 7.479a.936.936 0 0 0 .85 0l14.689-7.479c.24-.123.24-.323 0-.446z");
			attr(path1, "d", "M33.114 17.905l-4.6-2.341L18 20.918 7.484 15.564l-4.6 2.341c-.241.123-.241.323 0 .446l14.691 7.479a.936.936 0 0 0\n    .85 0l14.689-7.479c.24-.123.24-.323 0-.446z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShowAllLayers" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShowAllLayers extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a$, create_fragment$a$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShowMenu.svelte generated by Svelte v3.24.1 */

function create_fragment$b0(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 28);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 16);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 28);
			attr(rect1, "x", rect1_x_value = 4);
			attr(rect1, "y", rect1_y_value = 6);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 28);
			attr(rect2, "x", rect2_x_value = 4);
			attr(rect2, "y", rect2_y_value = 26);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b0($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShowMenu" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShowMenu extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b0, create_fragment$b0, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ShowOneLayer.svelte generated by Svelte v3.24.1 */

function create_fragment$b1(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.113 17.905L25.68 14.12l7.433-3.769c.241-.123.241-.323 0-.446l-14.688-7.48a.98.98 0 0 0-.85 0L2.887\n    9.9c-.241.123-.241.323 0 .446l7.407 3.782-7.407 3.777c-.241.123-.241.323 0 .446l7.4 3.767-7.4\n    3.787c-.241.123-.241.323 0 .446l14.688 7.479a.971.971 0 0 0 .85 0l14.688-7.479c.241-.123.241-.323 0-.446l-7.43-3.771\n    7.43-3.783c.241-.123.241-.323 0-.446zM6.857 10.128L18 4.453l11.144 5.675L23.477 13l-5.052-2.572a.936.936 0 0 0-.85\n    0L12.5 13.011zm22.287 16L18 31.8 6.857 26.128l5.632-2.887 5.086 2.589a.936.936 0 0 0 .85 0l5.054-2.574z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ShowOneLayer" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ShowOneLayer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b1, create_fragment$b1, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Shuffle.svelte generated by Svelte v3.24.1 */

function create_fragment$b2(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M3 10h4.111l2.65 4.139 3.4-5.528-2.439-3.806a2 2 0 0 0-1.6-.8H3A1 1 0 0 0 2 5v4a1 1 0 0 0 1 1zM27.2.206A.688.688\n    0 0 0 26.705 0a.7.7 0 0 0-.7.7V4H21a2 2 0 0 0-1.6.806L7.111 24H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h6.118a2 2 0 0 0\n    1.6-.8L23.03 10H26v3.3a.7.7 0 0 0 .7.7.688.688 0 0 0 .49-.206l5.69-6.469a.5.5 0 0 0 0-.65z");
			attr(path1, "d", "M27.2 20.206a.688.688 0 0 0-.49-.206.7.7 0 0 0-.7.7V24h-2.98l-2.723-4.248-3.407 5.536 2.5 3.906A2 2 0 0 0 21\n    30h5v3.3a.7.7 0 0 0 .7.7.688.688 0 0 0 .49-.206l5.685-6.469a.5.5 0 0 0 0-.65z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Shuffle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Shuffle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b2, create_fragment$b2, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Slice.svelte generated by Svelte v3.24.1 */

function create_fragment$b3(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.242 8.868l-9.188-7.232a1 1 0 0 0-1.4.159l-4.505 6.294a.989.989 0 0 0 .138 1.293v.029l-.679.858a7.482 7.482 0\n    0 1-1.027 1.063l-2.808 2.384a7.519 7.519 0 0 0-1.309 1.445L.063 34.486l22.971-10.227 3.507-6.021a7.47 7.47 0 0 1\n    .6-.878l.9-1.133s.138.106.19.148a1.021 1.021 0 0 0 1.424-.161c.5-.627 4.754-5.935 4.754-5.935a1 1 0 0\n    0-.167-1.411zm-8.671 7.251a9.6 9.6 0 0 0-.758 1.112l-3.182 5.463L5.78 29.751 15.108 16.3a5.517 5.517 0 0 1\n    .96-1.058l2.807-2.384a9.469 9.469 0 0 0 1.3-1.347l.679-.858 5.613 4.334z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Slice" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Slice extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b3, create_fragment$b3, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Slow.svelte generated by Svelte v3.24.1 */

function create_fragment$b4(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.117 10.673a2.883 2.883 0 0 0-2.883 2.883 3.843 3.843 0 0 0 1.036 2.107l-5.77 9.5c-.012 0 1.167-10.723\n    1.167-10.723 2.055.223 2.788-1.429 2.788-2.731a2.883 2.883 0 0 0-5.766 0A2.347 2.347 0 0 0 25.047 14L24\n    24h-6.055A9.986 9.986 0 1 0 2 16c0 4.24 2.194 8.244 8.09 9.027-3.352 2.567-6.377 1.9-8.543 2.37C.131 27.7.712 30\n    2.162\n    30h29.529c1.652-.063.292-1.33-1.055-1.772-.827-.272-1.105-1.842-1.105-1.842-.242-.723-.968-1.184-1.523-1.653l4.527-8.482c.076.008.473.187.582.187a2.883\n    2.883 0 1 0 0-5.765z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Slow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Slow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b4, create_fragment$b4, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SmallCaps.svelte generated by Svelte v3.24.1 */

function create_fragment$b5(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M22.5 18a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V20h4v10h-1.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0\n    .5.5h5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H30V20h4v1.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5z");
			attr(path1, "d", "M27 4a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V8h-8v20h3a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1\n    1 0 0 1 1-1h3V8H4v3a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SmallCaps" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SmallCaps extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b5, create_fragment$b5, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Snapshot.svelte generated by Svelte v3.24.1 */

function create_fragment$b6(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M20 7.5V6h-2v6h2v-1.5a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5V14h-2a2 2 0 0\n    1-2-2V6a2 2 0 0 1 2-2h2V2.5a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5zm-5.073\n    19.02c-1.13-.1-1.148-1.009-1.148-2.145a10.338 10.338 0 0 0 2.428-6.159c0-3.73-2.123-6.216-5.178-6.216S5.85 14.486\n    5.85 18.216a10.339 10.339 0 0 0 2.429 6.159c0 1.136-.018 2.046-1.151 2.145-1.548.137-6.611 1.818-7.066\n    6.755A.686.686 0 0 0 .711 34h20.594a.688.688 0 0 0 .689-.687v-.038c-.456-4.937-5.519-6.62-7.067-6.755z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Snapshot" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Snapshot extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b6, create_fragment$b6, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SocialNetwork.svelte generated by Svelte v3.24.1 */

function create_fragment$b7(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.087 22.347v-8.694A3.117 3.117 0 0 0 29.066 8.2L21.12 3.235c0-.036.01-.069.01-.1a3.13 3.13 0 1 0-6.26 0c0\n    .036.009.069.01.1L6.934 8.2a3.086 3.086 0 0 0-1.456-.375 3.121 3.121 0 0 0-1.565 5.827v8.694A3.117 3.117 0 0 0 6.934\n    27.8l7.946 4.966c0 .036-.01.069-.01.1a3.13 3.13 0 0 0 6.26 0c0-.036-.009-.069-.01-.1l7.946-4.966a3.086 3.086 0 0 0\n    1.456.375 3.121 3.121 0 0 0 1.565-5.827zm-10.944-3.724a2.985 2.985 0 0 0-.016-1.237l7.184-4.046a3.16 3.16 0 0 0\n    1.776.788v7.72a3.171 3.171 0 0 0-1.794.8zm-13.424 4.02a3.175 3.175 0 0 0-1.806-.827v-7.723a3.162 3.162 0 0 0\n    1.74-.773l7.22 4.066a2.985 2.985 0 0 0-.016 1.237zM27.546 9.61a3.181 3.181 0 0 0-.311 1.354 3.233 3.233 0 0 0\n    .067.649l-7.194 4.052A3.165 3.165 0 0 0 19 15.031v-8.8A3.205 3.205 0 0 0 20.493 5.2zM15.521 5.193A3.2 3.2 0 0 0 17\n    6.238v8.793a3.165 3.165 0 0 0-1.108.634L8.672 11.6a3.15 3.15 0 0 0-.215-1.99zM8.376 26.342a2.578 2.578 0 0 0\n    .369-1.363 3.223 3.223 0 0 0-.059-.585l7.126-4.014a3.189 3.189 0 0 0 1.188.7v8.7a3.155 3.155 0 0 0-1.456\n    1.038zm12.09 4.473A3.18 3.18 0 0 0 19 29.775V21.08a3.189 3.189 0 0 0 1.188-.7l7.112 4.005a3.16 3.16 0 0 0 .249 2z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SocialNetwork" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SocialNetwork extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b7, create_fragment$b7, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SortOrderDown.svelte generated by Svelte v3.24.1 */

function create_fragment$b8(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 12);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 24);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 16);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 20);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 8);
			attr(path, "d", "M32 24h-2.007V9a.988.988 0 0 0-.987-1h-.992a1 1 0 0 0-1 1l-.007 15H25a.5.5 0 0 0-.5.5.49.49 0 0 0 .147.35l3.537\n    4.033a.5.5 0 0 0 .632 0l3.537-4.033a.49.49 0 0 0 .147-.35.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SortOrderDown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SortOrderDown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b8, create_fragment$b8, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SortOrderUp.svelte generated by Svelte v3.24.1 */

function create_fragment$b9(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 12);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 8);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 16);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 20);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 24);
			attr(path, "d", "M32 24h-2.007V9a.988.988 0 0 0-.987-1h-.992a1 1 0 0 0-1 1l-.007 15H25a.5.5 0 0 0-.5.5.49.49 0 0 0 .147.35l3.537\n    4.033a.5.5 0 0 0 .632 0l3.537-4.033a.49.49 0 0 0 .147-.35.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SortOrderUp" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SortOrderUp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b9, create_fragment$b9, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Spam.svelte generated by Svelte v3.24.1 */

function create_fragment$ba(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777zM18 18.188L36 4.665v-1.5A1.147 1.147 0 0 0\n    34.875 2H1.125A1.147 1.147 0 0 0 0 3.167v1.469zM11.165 15.938L0 7.512v16.683l11.165-8.257zM14.7 27a12.244 12.244 0 0\n    1 2.092-6.863c-.025-.018-.057-.024-.082-.043l-3.628-2.719L0 27.068v1.765A1.147 1.147 0 0 0 1.125 30h13.959a12.273\n    12.273 0 0 1-.384-3zM27 14.7a12.253 12.253 0 0 1 9 3.935V7.541l-9.577 7.188c.193-.009.382-.029.577-.029z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ba($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Spam" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Spam extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ba, create_fragment$ba, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Spellcheck.svelte generated by Svelte v3.24.1 */

function create_fragment$bb(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33.614 11.344l-1.455-1.133a1 1 0 0 0-1.4.175L17.124 27.9l-6.647-6.61a1 1 0 0 0-1.414 0l-1.325 1.325a1 1 0 0 0 0\n    1.414l8.926 8.9a1 1 0 0 0 1.5-.093l15.629-20.09a1 1 0 0 0-.179-1.402z");
			attr(path1, "d", "M28.977 6.887a4.8 4.8 0 0 0-1.784-.239 4.776 4.776 0 0 0-5.048 5.065A4.759 4.759 0 0 0 24\n    15.814l1.072-1.377a3.414 3.414 0 0 1-1.128-2.785 3.121 3.121 0 0 1 3.237-3.447 4.15 4.15 0 0 1\n    1.769.316c.059.014.119.014.119-.105V7.053a.161.161 0 0 0-.092-.166zm-9.741 4.42a2.357 2.357 0 0 0\n    .944-1.963c0-.959-.494-2.576-3.461-2.576-.975 0-2.248.029-2.727.045-.076.015-.09.06-.09.134v9.516a.115.115 0 0 0\n    .09.119c.539.016 1.514.029 2.682.029 2.4.016 3.986-1.123 3.986-3a2.439 2.439 0 0 0-1.424-2.304zM15.6 8.281c.283 0\n    .644-.015 1.078-.015 1.168 0 1.812.435 1.812 1.318a1.4 1.4 0 0 1-.568 1.215 10.977 10.977 0 0\n    0-1.26-.076H15.6zm1.033 6.862c-.4 0-.719-.014-1.033-.03v-2.892h1.242a3.848 3.848 0 0 1 .975.105 1.281 1.281 0 0 1\n    1.048 1.334c-.004 1.033-.902 1.483-2.236 1.483zM9.152 6.8H7.145c-.061 0-.09.045-.09.105a2.093 2.093 0 0\n    1-.119.78l-2.864 8.762c-.029.09 0 .135.09.135H5.6a.145.145 0 0 0 .15-.105l.779-2.518h3.3l.824 2.533a.132.132 0 0 0\n    .135.09h1.6c.09 0 .105-.045.09-.119l-3.22-9.576c-.016-.074-.045-.087-.106-.087zm-2.187 5.59c.42-1.379.959-3.117\n    1.2-4.121h.014c.256 1.064.929 3.117 1.215 4.121z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bb($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Spellcheck" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Spellcheck extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bb, create_fragment$bb, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Spin.svelte generated by Svelte v3.24.1 */

function create_fragment$bc(ctx) {
	let svg;
	let path0;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			path1 = svg_element("path");
			attr(path0, "d", "M24 15v3.054c-6.836.185-7.634.254-9.648-.039-3.137-.451-6.837-1.968-6.952-3.968C7.257 12 9.47 9.918 12.517\n    8.894A16.148 16.148 0 0 1 16 8.133V16h4V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3.022a18.64 18.64 0 0 0-4.167.672c-3.69\n    1.082-7.248 3.632-7.221 7.494.075 4.05 5.187 6.291 9.165 7.132 2.292.46 3.159.434 10.223.625V25a.5.5 0 0 0 .8.4L32\n    20l-7.2-5.4a.5.5 0 0 0-.8.4z");
			attr(circle0, "cx", circle0_cx_value = 22.9);
			attr(circle0, "cy", circle0_cy_value = 6.9);
			attr(circle0, "r", circle0_r_value = 1.1);
			attr(circle1, "cx", circle1_cx_value = 26.968);
			attr(circle1, "cy", circle1_cy_value = 7.371);
			attr(circle1, "r", circle1_r_value = 1.1);
			attr(circle2, "cx", circle2_cx_value = 30.9);
			attr(circle2, "cy", circle2_cy_value = 8.9);
			attr(circle2, "r", circle2_r_value = 1.1);
			attr(path1, "d", "M16 33a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-9h-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bc($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Spin" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Spin extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bc, create_fragment$bc, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SplitView.svelte generated by Svelte v3.24.1 */

function create_fragment$bd(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 32);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 14);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 32);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 14);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 2);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bd($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SplitView" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SplitView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bd, create_fragment$bd, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SpotHeal.svelte generated by Svelte v3.24.1 */

function create_fragment$be(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.728 3.272a6 6 0 0 0-8.485 0l-6.456 6.456L3.272 24.243a6 6 0 0 0 8.485 8.485l5.943-5.947 15.028-15.024a6 6 0 0\n    0 0-8.485zM19 11a2 2 0 1 1-2 2 2 2 0 0 1 2-2zm-6 10a2 2 0 1 1 2-2 2 2 0 0 1-2 2zm4 4a2 2 0 1 1 2-2 2 2 0 0 1-2\n    2zm6-6a2 2 0 1 1 2-2 2 2 0 0 1-2 2zM18.453 4.343l1.309-1.512A11.923 11.923 0 0 0 14.449.182l-.42 1.955a9.98 9.98 0 0\n    1 4.424 2.206zm-7.742-2.358L10.472 0h-.007a12.1 12.1 0 0 0-5.519 2.144H4.94L6.1 3.776a9.988 9.988 0 0 1\n    4.611-1.791zm-8.725 8.761A9.99 9.99 0 0 1 3.757 6.13l-1.63-1.159A11.958 11.958 0 0 0 0 10.514zm2.389 7.732a9.979\n    9.979 0 0 1-2.224-4.416L.2 14.49a11.933 11.933 0 0 0 2.671 5.3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$be($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SpotHeal" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SpotHeal extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$be, create_fragment$be, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Stadium.svelte generated by Svelte v3.24.1 */

function create_fragment$bf(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.19 15.46c-1.733-1.48-5.911-2.653-11.19-3.17V7.25l4.752-1.782a.5.5 0 0 0 0-.936L24 2.75V2.5a.5.5 0 0\n    0-.5-.5h-1a.47.47 0 0 0-.238.098A.47.47 0 0 0 22 2.5v9.64c-1.294-.083-2.62-.14-4-.14s-2.706.057-4\n    .14V5.25l4.752-1.782a.5.5 0 0 0 0-.936L14 .75V.5a.5.5 0 0 0-.5-.5h-1a.47.47 0 0 0-.238.098A.47.47 0 0 0 12\n    .5v11.79a36.611 36.611 0 0 0-8 1.574V7.25l4.752-1.782a.5.5 0 0 0 0-.936L4 2.75V2.5a.5.5 0 0 0-.5-.5h-1a.47.47 0 0\n    0-.238.098A.47.47 0 0 0 2 2.5v12.185a6.635 6.635 0 0 0-1.167.755A2.468 2.468 0 0 0 0 17.344V32c0 1.818 5.463 3.35\n    12.937 3.836A1.002 1.002 0 0 0 14 34.84v-3.33c0-1 .517-1.51 1.155-1.51h5.69A1.155 1.155 0 0 1 22 31.155v3.678a1.009\n    1.009 0 0 0 1.07 1.003C30.54 35.349 36 33.818 36 32V17.314a2.418 2.418 0 0 0-.81-1.854zm-1.944 2.473c-1.89\n    1.22-6.977 2.931-15.246 2.931-8.263 0-13.35-1.71-15.242-2.928a.61.61 0 0 1 .028-.993C4.338 15.975 8.737 14 18\n    14c9.316 0 13.681 1.972 15.22 2.942a.61.61 0 0 1 .026.991z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bf($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Stadium" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Stadium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bf, create_fragment$bf, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Stage.svelte generated by Svelte v3.24.1 */

function create_fragment$bg(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M8 27v-9a21.309 21.309 0 0 0 8-16H3a1 1 0 0 0-1 1v25h5a1 1 0 0 0 1-1z");
			attr(path1, "d", "M25.637 30V16.042l.875-.875a3.617 3.617 0 1 0-2.027-2.113l-8.556 8.875a.732.732 0 0 0 0 1.036L16.965 24A.732.732\n    0 0 0 18 24l4.707-5.029V30H2v3a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1v-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bg($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Stage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Stage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bg, create_fragment$bg, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Stamp.svelte generated by Svelte v3.24.1 */

function create_fragment$bh(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M25.273 15.333a2.728 2.728 0 0 0-5.455 0v5.333a2.728 2.728 0 0 0 5.455 0z");
			attr(path1, "d", "M36 5.556V4h-4.686c0 2.008-.8 2.182-1.777 2.182S27.759 6.008 27.759 4h-4.1c0 2.008-.8 2.182-1.778 2.182S20.105\n    6.008 20.105 4h-4.137c0 2.008-.8 2.182-1.778 2.182S12.413 6.008 12.413 4H8.16c0 2.008-.8 2.182-1.778 2.182S4.6 6.008\n    4.6 4H0v1.556c2.008 0 2.182.8 2.182 1.778S2.008 9.111 0 9.111v3.556c2.008 0 2.182.8 2.182 1.778S2.008 16.222 0\n    16.222v3.556c2.008 0 2.182.8 2.182 1.778S2.008 23.333 0 23.333v3.556c2.008 0 2.182.8 2.182 1.778S2.008 30.444 0\n    30.444V32h4.585c0-2.008.8-2.182 1.778-2.182s1.778.174 1.778 2.182h4.212c0-2.008.8-2.182 1.777-2.182s1.778.173 1.778\n    2.182H20.2c0-2.008.8-2.182 1.778-2.182s1.778.173 1.778 2.182h3.884c0-2.008.8-2.182 1.778-2.182S31.2 29.992 31.2\n    32H36v-1.556c-2.008 0-1.818-.8-1.818-1.778s-.19-1.778 1.818-1.778v-3.555c-2.008 0-2.182-.8-2.182-1.778s.173-1.778\n    2.182-1.778v-3.555c-2.008 0-2.182-.8-2.182-1.778s.173-1.778 2.182-1.778V9.111c-2.008 0-2.182-.8-2.182-1.778S33.992\n    5.556 36 5.556zm-19.818 9.777a6.365 6.365 0 0 1 12.728 0v5.333a6.365 6.365 0 0 1-12.728 0zM7.091\n    9.111h5.455v17.778H8.909V12.667H7.091z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bh($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Stamp" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Stamp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bh, create_fragment$bh, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Star.svelte generated by Svelte v3.24.1 */

function create_fragment$bi(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.477.593L22.8 12.029l12.212.578a.51.51 0 0 1 .3.908l-9.54 7.646 3.224 11.793a.51.51 0 0 1-.772.561L18\n    26.805l-10.22 6.71a.51.51 0 0 1-.772-.561l3.224-11.793-9.54-7.646a.51.51 0 0 1 .3-.908l12.208-.578L17.523.593a.51.51\n    0 0 1 .954 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bi($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Star" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Star extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bi, create_fragment$bi, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StarOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$bj(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.059 5.082l3.554 9.5 10.219.481-7.974 6.4 2.671 9.837-8.535-5.568-8.557 5.615 2.7-9.873-7.974-6.4\n    10.2-.489zm.023-4.259a.737.737 0 0 0-.7.479l-4.411 11.349-12.2.586a.75.75 0 0 0-.433 1.334l9.523 7.642-3.229\n    11.8a.752.752 0 0 0 .724.951.74.74 0 0 0 .41-.126L18 28.122l10.187 6.648a.742.742 0 0 0 .408.125.752.752 0 0 0\n    .725-.95l-3.189-11.732 9.528-7.653a.75.75 0 0 0-.434-1.334l-12.2-.575-4.24-11.34a.738.738 0 0 0-.703-.488z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bj($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StarOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StarOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bj, create_fragment$bj, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Starburst.svelte generated by Svelte v3.24.1 */

function create_fragment$bk(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18.1 3.325l2.52 7.087 6.793-3.229a.5.5 0 0 1 .666.666l-3.229 6.793 7.087 2.52a.5.5 0 0 1 0 .942l-7.087 2.52\n    3.229 6.793a.5.5 0 0 1-.666.666l-6.793-3.229-2.52 7.088a.5.5 0 0 1-.942 0l-2.52-7.087-6.789 3.229a.5.5 0 0\n    1-.666-.666l3.229-6.793L3.325 18.1a.5.5 0 0 1 0-.942l7.087-2.52-3.229-6.789a.5.5 0 0 1 .666-.666l6.793 3.229\n    2.52-7.087a.5.5 0 0 1 .938 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bk($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Starburst" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Starburst extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bk, create_fragment$bk, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StepBackward.svelte generated by Svelte v3.24.1 */

function create_fragment$bl(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 28);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 8);
			attr(rect, "x", rect_x_value = 26);
			attr(rect, "y", rect_y_value = 4);
			attr(path, "d", "M20 30.919V5.081a1 1 0 0 0-1.625-.781L2.226 17.219a1 1 0 0 0 0 1.562L18.375 31.7A1 1 0 0 0 20 30.919z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bl($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StepBackward" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StepBackward extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bl, create_fragment$bl, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StepBackwardCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$bm(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 18A16 16 0 1 0 18 2 16 16 0 0 0 2 18zm20-7a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-2a1 1 0 0\n    1-1-1zM7.6 17.219l8.775-7.019a1 1 0 0 1 1.625.783v14.034a1 1 0 0 1-1.625.781L7.6 18.781a1 1 0 0 1 0-1.562z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bm($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StepBackwardCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StepBackwardCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bm, create_fragment$bm, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StepForward.svelte generated by Svelte v3.24.1 */

function create_fragment$bn(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 28);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 8);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 4);
			attr(path, "d", "M16 30.919V5.081a1 1 0 0 1 1.625-.781l16.149 12.919a1 1 0 0 1 0 1.562L17.625 31.7A1 1 0 0 1 16 30.919z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bn($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StepForward" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StepForward extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bn, create_fragment$bn, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StepForwardCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$bo(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm-4 23a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V11a1 1 0 0 1 1-1h2a1 1 0 0 1 1\n    1zm14.4-6.219L19.625 25.8A1 1 0 0 1 18 25.017V10.983a1 1 0 0 1 1.625-.781l8.775 7.017a1 1 0 0 1 0 1.562z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bo($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StepForwardCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StepForwardCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bo, create_fragment$bo, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Stop.svelte generated by Svelte v3.24.1 */

function create_fragment$bp(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr(rect, "height", rect_height_value = 28);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 24);
			attr(rect, "x", rect_x_value = 6);
			attr(rect, "y", rect_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bp($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Stop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Stop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bp, create_fragment$bp, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StopCircle.svelte generated by Svelte v3.24.1 */

function create_fragment$bq(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm8 23a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1V11a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bq($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StopCircle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StopCircle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bq, create_fragment$bq, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Stopwatch.svelte generated by Svelte v3.24.1 */

function create_fragment$br(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2h1a1 1 0 0 0 0-2h-4a1 1 0 0 0 0 2h1v2h2z");
			attr(path1, "d", "M19 4a14.94 14.94 0 0 0-9.9 3.729L7.437 6.062l.708-.707A1 1 0 1 0 6.73 3.941l-.707.707-1.414 1.414-.709.708a1 1 0\n    0 0 1.416 1.414l.707-.707 1.669 1.668A15 15 0 1 0 19 4zm0 28a13 13 0 1 1 7.833-23.375l-8.925\n    8.925c-.021.021-.037.04-.057.062a1.858 1.858 0 1 0 2.619 2.635c.023-.021.046-.045.068-.067l8.913-8.912A13 13 0 0 1\n    19 32z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$br($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Stopwatch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Stopwatch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$br, create_fragment$br, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Straighten.svelte generated by Svelte v3.24.1 */

function create_fragment$bs(ctx) {
	let svg;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(circle0, "cx", circle0_cx_value = 7);
			attr(circle0, "cy", circle0_cy_value = 11);
			attr(circle0, "r", circle0_r_value = 1.3);
			attr(circle1, "cx", circle1_cx_value = 27);
			attr(circle1, "cy", circle1_cy_value = 11);
			attr(circle1, "r", circle1_r_value = 1.3);
			attr(circle2, "cx", circle2_cx_value = 17);
			attr(circle2, "cy", circle2_cy_value = 5);
			attr(circle2, "r", circle2_r_value = 1.3);
			attr(circle3, "cx", circle3_cx_value = 11);
			attr(circle3, "cy", circle3_cy_value = 7);
			attr(circle3, "r", circle3_r_value = 1.3);
			attr(circle4, "cx", circle4_cx_value = 23);
			attr(circle4, "cy", circle4_cy_value = 7);
			attr(circle4, "r", circle4_r_value = 1.3);
			attr(path0, "d", "M6 14H.5a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5H6zM33.5 14H28v12h5.5a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5zM17\n    18c1.807 0 4.983-1 4.983-2.983L21.965 14H12v1.041C12 17 15.18 18 17 18z");
			attr(path1, "d", "M24.1 14v1c0 3-3.234 5.1-7.1 5.1S9.9 18 9.9 15v-1H8v12h18V14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bs($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Straighten" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Straighten extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bs, create_fragment$bs, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StraightenOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$bt(ctx) {
	let svg;
	let path;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle0_r_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;
	let circle1_r_value;
	let circle2;
	let circle2_cx_value;
	let circle2_cy_value;
	let circle2_r_value;
	let circle3;
	let circle3_cx_value;
	let circle3_cy_value;
	let circle3_r_value;
	let circle4;
	let circle4_cx_value;
	let circle4_cy_value;
	let circle4_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			attr(path, "d", "M33.5 14H.5a.5.5 0 0 0-.5.5v13a.5.5 0 0 0 .5.5h33a.5.5 0 0 0 .5-.5v-13a.5.5 0 0 0-.5-.5zm-11.286\n    2l.018.968C22.232 19.05 18.9 20.1 17 20.1s-5.25-1.05-5.25-3.107V16zM6 26H2V16h4zm20 0H8V16h2v1c0 3 3.134 5 7 5s7-2\n    7-5v-1h2zm6 0h-4V16h4z");
			attr(circle0, "cx", circle0_cx_value = 7);
			attr(circle0, "cy", circle0_cy_value = 11);
			attr(circle0, "r", circle0_r_value = 1.3);
			attr(circle1, "cx", circle1_cx_value = 27);
			attr(circle1, "cy", circle1_cy_value = 11);
			attr(circle1, "r", circle1_r_value = 1.3);
			attr(circle2, "cx", circle2_cx_value = 17);
			attr(circle2, "cy", circle2_cy_value = 5);
			attr(circle2, "r", circle2_r_value = 1.3);
			attr(circle3, "cx", circle3_cx_value = 11);
			attr(circle3, "cy", circle3_cy_value = 7);
			attr(circle3, "r", circle3_r_value = 1.3);
			attr(circle4, "cx", circle4_cx_value = 23);
			attr(circle4, "cy", circle4_cy_value = 7);
			attr(circle4, "r", circle4_r_value = 1.3);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle0);
			append(svg, circle1);
			append(svg, circle2);
			append(svg, circle3);
			append(svg, circle4);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bt($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StraightenOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StraightenOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bt, create_fragment$bt, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/StrokeWidth.svelte generated by Svelte v3.24.1 */

function create_fragment$bu(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 32);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 8);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 32);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 22);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 32);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 12);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bu($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "StrokeWidth" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class StrokeWidth extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bu, create_fragment$bu, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Subscribe.svelte generated by Svelte v3.24.1 */

function create_fragment$bv(ctx) {
	let svg;
	let path0;
	let path1;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			rect = svg_element("rect");
			path2 = svg_element("path");
			attr(path0, "d", "M24.779 21.963L36 30.367V13.541l-11.221 8.422zM22.866 23.4l-3.576 2.694a2.172 2.172 0 0 1-2.58 0l-3.628-2.719L0\n    33.068A.981.981 0 0 0 1 34h34a.884.884 0 0 0 1-.756zM11.165 21.938L0 13.511v16.684l11.165-8.257z");
			attr(path1, "d", "M19.067.672a2 2 0 0 0-2.133 0L0 11.365V14h6V9a1 1 0 0 1 1-1h22a1 1 0 0 1 1 1v5h6v-2.665z");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 16);
			attr(rect, "x", rect_x_value = 10);
			attr(rect, "y", rect_y_value = 12);
			attr(path2, "d", "M21.83 20h-7.66a.5.5 0 0 1-.3-.1l-1.882-1.448a.25.25 0 0 1 .147-.452h11.73a.25.25 0 0 1 .152.448L22.135 19.9a.5.5\n    0 0 1-.305.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, rect);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bv($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Subscribe" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Subscribe extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bv, create_fragment$bv, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SubstractBackPath.svelte generated by Svelte v3.24.1 */

function create_fragment$bw(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 12h-7V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h7v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V13a1 1 0 0\n    0-1-1zm-9 10H6V6h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bw($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SubstractBackPath" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SubstractBackPath extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bw, create_fragment$bw, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SubstractFromSelection.svelte generated by Svelte v3.24.1 */

function create_fragment$bx(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24.16 5.443l1.028-1.777a15.947 15.947 0 0 0-5.4-1.606v2.066a13.883 13.883 0 0 1 4.372 1.317zM29.53\n    10.066l1.8-1.035a16.133 16.133 0 0 0-3.852-3.97L26.44 6.849a14.066 14.066 0 0 1 3.09 3.217zM31.933 16.663H34a15.91\n    15.91 0 0 0-1.379-5.291L30.83 12.4a13.9 13.9 0 0 1 1.103 4.263zM31.933 19.337a13.9 13.9 0 0 1-1.1 4.258l1.791\n    1.032A15.91 15.91 0 0 0 34 19.337zM26.44 29.151l1.033 1.788a16.131 16.131 0 0 0 3.852-3.97l-1.8-1.035a14.066 14.066\n    0 0 1-3.085 3.217zM19.785 31.874v2.066a15.947 15.947 0 0 0 5.4-1.606l-1.025-1.777a13.883 13.883 0 0 1-4.375\n    1.317zM12.538 30.894l-1.028 1.777A15.993 15.993 0 0 0 17.107 34v-2.045a13.937 13.937 0 0 1-4.569-1.061zM6.739\n    26.293l-1.8 1.035a16.132 16.132 0 0 0 4.214 4.062l1.026-1.775a14.071 14.071 0 0 1-3.44-3.322zM4.067 19.337H2a15.9\n    15.9 0 0 0 1.574 5.694L5.365 24a13.889 13.889 0 0 1-1.298-4.663zM5.365 12l-1.791-1.031A15.9 15.9 0 0 0 2\n    16.663h2.067A13.889 13.889 0 0 1 5.365 12zM10.184 6.384L9.158 4.609a16.132 16.132 0 0 0-4.214 4.062l1.8 1.035a14.073\n    14.073 0 0 1 3.44-3.322zM17.107 4.045V2a15.99 15.99 0 0 0-5.6 1.329l1.027 1.777a13.937 13.937 0 0 1 4.573-1.061zM28\n    19a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bx($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SubstractFromSelection" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SubstractFromSelection extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bx, create_fragment$bx, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SubtractFrontPath.svelte generated by Svelte v3.24.1 */

function create_fragment$by(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 12h-7V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h7v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V13a1 1 0 0\n    0-1-1zm-1 18H14V14h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$by($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SubtractFrontPath" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SubtractFrontPath extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$by, create_fragment$by, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SuccessMetric.svelte generated by Svelte v3.24.1 */

function create_fragment$bz(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 8);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 8);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 26);
			attr(rect1, "height", rect1_height_value = 24);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 8);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 10);
			attr(rect2, "height", rect2_height_value = 12);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 8);
			attr(rect2, "x", rect2_x_value = 24);
			attr(rect2, "y", rect2_y_value = 22);
			attr(path, "d", "M12 16H6.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H12zM7.768 6.27L12 8.979l-1.078 1.684-4.233-2.709a.5.5 0 0\n    1-.152-.691l.539-.842a.5.5 0 0 1 .692-.151zM16.63 8l-1.9-5.971a.25.25 0 0 0-.314-.163l-1.43.454a.25.25 0 0\n    0-.163.314L14.532 8zM24 16h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H24zM28.232 6.27L24 8.979l1.078 1.684\n    4.233-2.709a.5.5 0 0 0 .152-.691l-.539-.842a.5.5 0 0 0-.692-.151zM19.37 8l1.9-5.971a.25.25 0 0 1\n    .314-.163l1.43.454a.25.25 0 0 1 .163.314L21.468 8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bz($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SuccessMetric" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SuccessMetric extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bz, create_fragment$bz, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Summarize.svelte generated by Svelte v3.24.1 */

function create_fragment$bA(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 6);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 24);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 18);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 32);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 10);
			attr(path, "d", "M19.5 34a.5.5 0 0 0 .5-.5V30h2.793a.5.5 0 0 0 .354-.854L18 24l-5.146 5.146a.5.5 0 0 0 .354.854H16v3.5a.5.5 0 0 0\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bA($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Summarize" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Summarize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bA, create_fragment$bA, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Survey.svelte generated by Svelte v3.24.1 */

function create_fragment$bB(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M19.294 12.266a4.436 4.436 0 0 1-1.607 3.466c-.979.929-1.909 1.757-1.909 2.511a2.65 2.65 0 0 0 .4 1.381.108.108 0\n    0 1-.1.176H13.9a.419.419 0 0 1-.326-.1 2.744 2.744 0 0 1-.6-1.732c0-1.181.728-1.934 1.934-3.139.828-.829 1.3-1.356\n    1.3-2.134 0-.9-.6-1.532-2.134-1.532a6.379 6.379 0 0 0-3.164.828c-.1.05-.2 0-.2-.1V9.454c0-.1 0-.2.1-.251a7.974 7.974\n    0 0 1 3.817-.879c3.01 0 4.667 1.733 4.667 3.942z");
			attr(path1, "d", "M15.734 30H4V4h22v13.521l2-2V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v28a1 1 0 0 0 1 1h12.069zM35.645\n    20.685l-4.324-4.323a1.083 1.083 0 0 0-.678-.265 1.13 1.13 0 0 0-.7.3L18.711 27.639a.736.736 0 0 0-.188.315l-2.444\n    7.34c-.085.282.345.638.588.638a.231.231 0 0 0 .046-.005c.207-.048 6.26-2.118 7.344-2.444a.733.733 0 0 0\n    .31-.187L35.6 22.059a1.03 1.03 0 0 0 .3-.662.916.916 0 0 0-.255-.712zM18.039 33.973l1.978-5.519 3.54\n    3.531c-1.621.487-4.118 1.57-5.518 1.988z");
			attr(path2, "d", "M13.091 23.567a1.668 1.668 0 0 1 1.758-1.734 1.668 1.668 0 0 1 1.758 1.734 1.623 1.623 0 0 1-1.758 1.757 1.648\n    1.648 0 0 1-1.758-1.757z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bB($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Survey" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Survey extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bB, create_fragment$bB, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Switch.svelte generated by Svelte v3.24.1 */

function create_fragment$bC(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M36 18l-9.146-9.146a.5.5 0 0 0-.854.353V14H10V9.207a.5.5 0 0 0-.854-.354L0 18l9.146 9.146a.5.5 0 0 0\n    .854-.353V22h16v4.793a.5.5 0 0 0 .854.354z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bC($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Switch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Switch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bC, create_fragment$bC, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Sync.svelte generated by Svelte v3.24.1 */

function create_fragment$bD(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M21 16a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H10V3.735A.733.733 0 0 0 9.261 3a.718.718 0 0 0-.513.216l-8.559 7.8a.735.735\n    0 0 0 0 .984l8.559 8.784a.718.718 0 0 0 .513.216.733.733 0 0 0 .739-.735V16zM35.811 24l-8.559-8.784a.718.718 0 0\n    0-.513-.216.733.733 0 0 0-.739.735V20H15a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h11v4.265a.733.733 0 0 0 .739.735.718.718 0 0\n    0 .513-.216l8.559-7.8a.735.735 0 0 0 0-.984z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bD($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Sync" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Sync extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bD, create_fragment$bD, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/SyncRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$bE(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M22 13V7a1 1 0 0 0-1-1H10V1.207a.5.5 0 0 0-.854-.353L0 10l5.33 5.33a12.3 12.3 0 0 1 3.57-.53c.371 0 .736.023\n    1.1.056V14h11a1 1 0 0 0 1-1zm4.854-.146a.5.5 0 0 0-.854.353V18h-8.846a12.253 12.253 0 0 1 3.99 8H26v4.793a.5.5 0 0 0\n    .854.353L36 22zM8.9 18.2a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826 12.267a.5.5 0 0 1 0 .707l-1.752\n    1.752a.5.5 0 0 1-.707 0L8.9 29.559l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0 0 1 0-.707L6.441\n    27.1l-3.367-3.367a.5.5 0 0 1 0-.707l1.752-1.752a.5.5 0 0 1 .707 0L8.9 24.641l3.367-3.367a.5.5 0 0 1 .707 0l1.752\n    1.752a.5.5 0 0 1 0 .707L11.359 27.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bE($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "SyncRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class SyncRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bE, create_fragment$bE, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Table.svelte generated by Svelte v3.24.1 */

function create_fragment$bF(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM12 32H4v-4h8zm0-6H4v-4h8zm0-6H4v-4h8zm20\n    12H14v-4h18zm0-6H14v-4h18zm0-6H14v-4h18zm0-6H4V4h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bF($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Table" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Table extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bF, create_fragment$bF, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$bG(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.769 32H14v-4h.75c-.026-.331-.05-.662-.05-1s.023-.669.05-1H14v-4h1.769a12.338 12.338 0 0 1\n    1.124-2H14v-4h7.52a12.242 12.242 0 0 1 12.48.893V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h13.893a12.338\n    12.338 0 0 1-1.124-2zM4 4h28v10H4zm8 28H4v-4h8zm0-6H4v-4h8zm0-6H4v-4h8z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bG($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bG, create_fragment$bG, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableAndChart.svelte generated by Svelte v3.24.1 */

function create_fragment$bH(ctx) {
	let svg;
	let path;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(path, "d", "M33 20H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V21a1 1 0 0 0-1-1zM12 32H4v-4h8zm0-6H4v-4h8zm20\n    6H14v-4h18zm0-6H14v-4h18z");
			attr(rect0, "height", rect0_height_value = 16);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 8);
			attr(rect0, "x", rect0_x_value = 26);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 10);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 8);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 8);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 8);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 12);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bH($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableAndChart" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableAndChart extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bH, create_fragment$bH, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableColumnAddLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$bI(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9 18.1a8.9 8.9 0 1 0 8.9 8.9A8.9 8.9 0 0 0 9 18.1zm5 9.4a.5.5 0 0 1-.5.5H10v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28H4.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H8v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			attr(path1, "d", "M33 2H3a1 1 0 0 0-1 1v13.893a12.252 12.252 0 0 1 12-1.124V14h8v8h-1.769a12.154 12.154 0 0 1 .685\n    2H22v8h-1.769a12.236 12.236 0 0 1-1.124 2H33a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM22 12h-8V4h8zm10\n    20h-8v-8h8zm0-10h-8v-8h8zm0-10h-8V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bI($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableColumnAddLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableColumnAddLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bI, create_fragment$bI, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableColumnAddRight.svelte generated by Svelte v3.24.1 */

function create_fragment$bJ(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.1 27a8.9 8.9 0 1 0 8.9-8.9 8.9 8.9 0 0 0-8.9 8.9zm3.9-.5a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0\n    1 .5.5V26h3.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5z");
			attr(path1, "d", "M15.769 32H14v-8h1.084a12.154 12.154 0 0 1 .685-2H14v-8h8v1.769a12.252 12.252 0 0 1 12 1.124V3a1 1 0 0 0-1-1H3a1\n    1 0 0 0-1 1v30a1 1 0 0 0 1 1h13.893a12.236 12.236 0 0 1-1.124-2zM14 4h8v8h-8zm-2 28H4v-8h8zm0-10H4v-8h8zm0-10H4V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bJ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableColumnAddRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableColumnAddRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bJ, create_fragment$bJ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableColumnMerge.svelte generated by Svelte v3.24.1 */

function create_fragment$bK(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM12\n    32H4v-8h8zm0-10H4v-8h8zm0-10H4V4h8zm10 0h-8V4h8zm10 20h-8v-8h8zm0-10h-8v-8h8zm0-10h-8V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bK($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableColumnMerge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableColumnMerge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bK, create_fragment$bK, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableColumnRemoveCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$bL(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M8.1 27a8.9 8.9 0 1 0 8.9-8.9A8.9 8.9 0 0 0 8.1 27zm3.9-.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v1a.5.5 0 0\n    1-.5.5h-9a.5.5 0 0 1-.5-.5z");
			attr(path1, "d", "M33 2H1a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h5.893a12.139 12.139 0 0 1-1.123-2H2v-8h3.084a12.139 12.139 0 0 1\n    .684-2H2v-8h8v3.308a12.229 12.229 0 0 1 4-1.808V6h6v9.5a12.229 12.229 0 0 1 4 1.809V14h8v8h-3.768a12.139 12.139 0 0\n    1 .684 2H32v8h-3.769a12.139 12.139 0 0 1-1.123 2H33a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM10 12H2V4h8zm22 0h-8V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bL($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableColumnRemoveCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableColumnRemoveCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bL, create_fragment$bL, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableColumnSplit.svelte generated by Svelte v3.24.1 */

function create_fragment$bM(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM12 32H4V14h8zm0-20H4V4h8zm10\n    20h-8v-8h8zm0-10h-8v-8h8zm0-10h-8V4h8zm10 20h-8V14h8zm0-20h-8V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bM($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableColumnSplit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableColumnSplit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bM, create_fragment$bM, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$bN(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M17.292 28.438a3.522 3.522 0 0 1 .2-.438H12v-4h9.167l2-2H12v-4h15.167L29\n    16.172c.064-.065.138-.113.206-.172H12v-4h18v3.457a3.55 3.55 0 0 1 1.5-.407l.115-.006h.092c.1 0 .2.02.294.028V3a1 1 0\n    0 0-1-1H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h13.764zM4 4h26v6H4zm6 24H4v-4h6zm0-6H4v-4h6zm0-6H4v-4h6zM35.738\n    21.764l-3.506-3.5a.736.736 0 0 0-.526-.215h-.024a.838.838 0 0 0-.564.247L20.929 28.48a.62.62 0 0 0-.152.256l-2.661\n    6.631c-.069.229.28.517.477.517a.256.256 0 0 0 .037 0c.168-.038 5.755-2.4 6.634-2.661a.6.6 0 0 0\n    .252-.151l10.19-10.19a.834.834 0 0 0 .245-.537.74.74 0 0 0-.213-.581zM24.769 32.1c-1.314.4-3.928 1.862-5.064\n    2.2l2.195-5.068z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bN($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bN, create_fragment$bN, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableHistogram.svelte generated by Svelte v3.24.1 */

function create_fragment$bO(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM10 32H4v-4h6zm0-6H4v-4h6zm0-6H4v-4h6zm12\n    12H12v-4h10zm10-6H12v-4h20zm-6-6H12v-4h14zm6-6H4V4h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bO($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableHistogram" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableHistogram extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bO, create_fragment$bO, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableMergeCells.svelte generated by Svelte v3.24.1 */

function create_fragment$bP(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM4 4h8v8H4zm0 10h8v8H4zm0 18v-8h8v8zm10\n    0v-8h8v8zm18 0h-8v-8h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bP($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableMergeCells" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableMergeCells extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bP, create_fragment$bP, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableRowAddBottom.svelte generated by Svelte v3.24.1 */

function create_fragment$bQ(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.1 27a8.9 8.9 0 1 0 8.9-8.9 8.9 8.9 0 0 0-8.9 8.9zm3.9-.5a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0\n    1 .5.5V26h3.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5z");
			attr(path1, "d", "M14.7 27a12.238 12.238 0 0 1 1.069-5H14v-8h8v1.769a12.154 12.154 0 0 1 2-.685V14h8v1.769a12.236 12.236 0 0 1 2\n    1.124V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h13.893a12.229 12.229 0 0 1-2.193-7zM24 4h8v8h-8zM14\n    4h8v8h-8zm-2 18H4v-8h8zm0-10H4V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bQ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableRowAddBottom" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableRowAddBottom extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bQ, create_fragment$bQ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableRowAddTop.svelte generated by Svelte v3.24.1 */

function create_fragment$bR(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 17.9A8.9 8.9 0 1 0 18.1 9a8.9 8.9 0 0 0 8.9 8.9zm-5-9.4a.5.5 0 0 1 .5-.5H26V4.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1\n    .5.5V8h3.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V10h-3.5a.5.5 0 0 1-.5-.5z");
			attr(path1, "d", "M16.893 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V19.107a12.236 12.236 0 0 1-2\n    1.124V22h-8v-1.084a12.154 12.154 0 0 1-2-.685V22h-8v-8h1.769a12.252 12.252 0 0 1 1.124-12zM24 24h8v8h-8zm-10\n    0h8v8h-8zm-2-2H4v-8h8zm0 10H4v-8h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bR($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableRowAddTop" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableRowAddTop extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bR, create_fragment$bR, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableRowMerge.svelte generated by Svelte v3.24.1 */

function create_fragment$bS(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 3v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm30 21v8h-8v-8zm-10 0v8h-8v-8zm-10\n    0v8H4v-8zm0-10v8H4v-8zM32 4v8h-8V4zM22 4v8h-8V4zM12 4v8H4V4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bS($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableRowMerge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableRowMerge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bS, create_fragment$bS, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableRowRemoveCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$bT(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.9 19a8.9 8.9 0 1 0-8.9 8.9 8.9 8.9 0 0 0 8.9-8.9zm-3.9.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1\n    .5-.5h9a.5.5 0 0 1 .5.5z");
			attr(path1, "d", "M2 3v32a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1v-5.893a12.139 12.139 0 0 1-2 1.123V34h-8v-3.084a12.139 12.139 0 0\n    1-2-.684V34h-8v-8h3.308a12.229 12.229 0 0 1-1.808-4H6v-6h9.5a12.229 12.229 0 0 1 1.809-4H14V4h8v3.769a12.154 12.154\n    0 0 1 2-.685V4h8v3.769a12.108 12.108 0 0 1 2 1.123V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm10 23v8H4v-8zm0-22v8H4V4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bT($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableRowRemoveCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableRowRemoveCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bT, create_fragment$bT, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableRowSplit.svelte generated by Svelte v3.24.1 */

function create_fragment$bU(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM14 14h8v8h-8zm-2\n    18H4v-8h8zm0-10H4v-8h8zm0-10H4V4h8zm20 20H14v-8h18zm0-10h-8v-8h8zm0-10H14V4h18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bU($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableRowSplit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableRowSplit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bU, create_fragment$bU, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableSelectColumn.svelte generated by Svelte v3.24.1 */

function create_fragment$bV(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM4 4h6v8H4zm0 10h6v8H4zm0\n    18v-8h6v8zm10-2V6h8v24zm18 2h-6v-8h6zm0-10h-6v-8h6zm0-10h-6V4h6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bV($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableSelectColumn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableSelectColumn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bV, create_fragment$bV, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TableSelectRow.svelte generated by Svelte v3.24.1 */

function create_fragment$bW(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM22 4v6h-8V4zM4 4h8v6H4zm0 28v-6h8v6zm10\n    0v-6h8v6zm18 0h-8v-6h8zm-2-10H6v-8h24zm2-12h-8V4h8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bW($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TableSelectRow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TableSelectRow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bW, create_fragment$bW, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Tableau.svelte generated by Svelte v3.24.1 */

function create_fragment$bX(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 16.5h-4.5V12h-3v4.5H12v3h4.5V24h3v-4.5H24v-3zM21\n    3.75h-2.25V1.5h-1.5v2.25H15v1.5h2.25V7.5h1.5V5.25H21v-1.5zM21\n    30.75h-2.25V28.5h-1.5v2.25H15v1.5h2.25v2.25h1.5v-2.25H21v-1.5zM34.5\n    17.25h-2.25V15h-1.5v2.25H28.5v1.5h2.25V21h1.5v-2.25h2.25v-1.5zM7.5\n    17.25H5.25V15h-1.5v2.25H1.5v1.5h2.25V21h1.5v-2.25H7.5v-1.5zM31.2\n    8.175h-3.375V4.8h-2.25v3.375H22.2v2.25h3.375V13.8h2.25v-3.375H31.2v-2.25zM13.8\n    8.175h-3.375V4.8h-2.25v3.375H4.8v2.25h3.375V13.8h2.25v-3.375H13.8v-2.25zM31.2\n    25.575h-3.375V22.2h-2.25v3.375H22.2v2.25h3.375V31.2h2.25v-3.375H31.2v-2.25zM13.8\n    25.575h-3.375V22.2h-2.25v3.375H4.8v2.25h3.375V31.2h2.25v-3.375H13.8v-2.25z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bX($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Tableau" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Tableau extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bX, create_fragment$bX, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TagBold.svelte generated by Svelte v3.24.1 */

function create_fragment$bY(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6 4.508c0-.212.045-.339.279-.381C7.949 4.085 12.172 4 15.284 4c9.7 0 11.184 4.659 11.184 7.37a6.462 6.462 0 0\n    1-2.923 5.507A7.114 7.114 0 0 1 28 23.443C28 28.78 22.942 32 15.284 32c-4.038\n    0-7.195-.042-8.96-.085-.231-.042-.324-.169-.324-.339zm5.978 11.474h3.359a24.278 24.278 0 0 1 4.021.3 4.89 4.89 0 0 0\n    1.681-3.91c0-2.922-1.946-4.358-5.568-4.358-1.415 0-2.563.05-3.493.05zm0 11.971c.979.042 2.09.084 3.424.084 4.176.042\n    6.843-1.307 6.843-4.133 0-1.73-.888-3.122-3.2-3.669a12.249 12.249 0 0 0-3.023-.3h-4.044z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bY($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TagBold" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TagBold extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bY, create_fragment$bY, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TagItalic.svelte generated by Svelte v3.24.1 */

function create_fragment$bZ(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M17.682 31.663c-.041.213-.08.3-.282.3h-4.08c-.2\n    0-.279-.043-.24-.341l4.481-27.367c.041-.213.16-.255.281-.255h4.121c.24 0 .279.127.279.34z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$bZ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TagItalic" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TagItalic extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$bZ, create_fragment$bZ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TagUnderline.svelte generated by Svelte v3.24.1 */

function create_fragment$b_(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 22);
			attr(rect, "x", rect_x_value = 7);
			attr(rect, "y", rect_y_value = 30);
			attr(path, "d", "M22.5 4.012a.5.5 0 0 0-.5.5v13.5s.482 6.2-5 6.2c-5.459 0-5-6.2-5-6.2v-13.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0\n    0-.5.5v13.5c0 1.412-.141 10 9 10S26 19 26 17.988V4.512a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TagUnderline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TagUnderline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b_, create_fragment$b_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Target.svelte generated by Svelte v3.24.1 */

function create_fragment$b$(ctx) {
	let svg;
	let path;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr(path, "d", "M18 2a16 16 0 1 0 16 16A16 16 0 0 0 18 2zm0 26.2A10.2 10.2 0 1 1 28.2 18 10.2 10.2 0 0 1 18 28.2z");
			attr(circle, "cx", circle_cx_value = 18);
			attr(circle, "cy", circle_cy_value = 18);
			attr(circle, "r", circle_r_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Target" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Target extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b$, create_fragment$b$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Targeted.svelte generated by Svelte v3.24.1 */

function create_fragment$c0(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M17.225 15.281L12 10.056V6.847a2 2 0 0 0-.586-1.415L6.854.239A.5.5 0 0 0 6 .592L4.5 4.5.6 6.018a.5.5 0 0\n    0-.354.854l5.173 4.56A1.98 1.98 0 0 0 6.828 12h3.173l5.262 5.251a.693.693 0 0 0 .981 0l.981-.981a.693.693 0 0 0\n    0-.989zM19.328 14.243a3.057 3.057 0 0 1-.449 3.7l-.982.982a3.052 3.052 0 0 1-3.611.543 3.994 3.994 0 1 0\n    5.042-5.223z");
			attr(path1, "d", "M18 2.1a15.824 15.824 0 0 0-5.5 1l.675.781A4.343 4.343 0 0 1 14.379 6.9v1.659a10.24 10.24 0 1 1-5.833\n    5.863H6.855A4.339 4.339 0 0 1 3.827 13.2l-.747-.658A15.891 15.891 0 1 0 18 2.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c0($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Targeted" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Targeted extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c0, create_fragment$c0, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TaskList.svelte generated by Svelte v3.24.1 */

function create_fragment$c1(ctx) {
	let svg;
	let path0;
	let path1;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			attr(path0, "d", "M2 3v28a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm30 27H4V4h28z");
			attr(path1, "d", "M9.55 15.917a1 1 0 0 1-.679-.266l-2.077-1.917a1 1 0 0 1 1.357-1.47l1.311 1.211 4.28-5.039a1 1 0 1 1 1.524\n    1.3l-4.954 5.833a1 1 0 0 1-.7.351zM9.55 25.917a1 1 0 0 1-.679-.266l-2.077-1.917a1 1 0 0 1 1.357-1.47l1.311 1.211\n    4.28-5.039a1 1 0 1 1 1.524 1.3l-4.954 5.833a1 1 0 0 1-.7.351z");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 10);
			attr(rect0, "x", rect0_x_value = 18);
			attr(rect0, "y", rect0_y_value = 10);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 10);
			attr(rect1, "x", rect1_x_value = 18);
			attr(rect1, "y", rect1_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, rect0);
			append(svg, rect1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TaskList" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TaskList extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c1, create_fragment$c1, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Teapot.svelte generated by Svelte v3.24.1 */

function create_fragment$c2(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M26.047 11a11.1 11.1 0 0 0-6.675-3.136 2.211 2.211 0 0 0 .878-1.739 2.25 2.25 0 0 0-4.5 0 2.212 2.212 0 0 0 1.006\n    1.825A11.161 11.161 0 0 0 10.7 11zM27.819 14H8.475a16.416 16.416 0 0 0-1.419\n    4.159h-.033c-1.3-.537-1.123-.977-2.229-3.853-.637-1.656-2.65-1.866-3.383-2.033a.738.738 0 0\n    0-.82.409l-.446.892c-.2.4-.019 1 .43 1.034a1.508 1.508 0 0 1 1.284.745 9.735 9.735 0 0 1 .548 2.075c.216 1.177.413\n    3.367 1.58 4.835a7.3 7.3 0 0 0 3.289 2.225 12.642 12.642 0 0 0 5.254 7.285 1.531 1.531 0 0 0 .824.232H23.4a1.53 1.53\n    0 0 0 .824-.232 12.53 12.53 0 0 0 4.941-6.3c.1-.035.2-.069.288-.108a14.225 14.225 0 0 0 3.378-1.984 7.766 7.766 0 0\n    0 2.922-6.192A4.6 4.6 0 0 0 27.819 14zm4.206 7.091a8.2 8.2 0 0 1-2.166 1.573A14.006 14.006 0 0 0 30 20.75a15.235\n    15.235 0 0 0-.885-4.852c.866-.975 2.539-1.643 3.649-.63 1.603 1.461.482 4.518-.739 5.823z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Teapot" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Teapot extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c2, create_fragment$c2, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Temperature.svelte generated by Svelte v3.24.1 */

function create_fragment$c3(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 20.368V10h-4v10.368a6 6 0 1 0 4 0z");
			attr(path1, "d", "M18 1.8A4.2 4.2 0 0 1 22.2 6v12.941l.715.54A8.126 8.126 0 0 1 26.2 26a8.2 8.2 0 1 1-16.4 0 8.126 8.126 0 0 1\n    3.285-6.519l.715-.54V6A4.2 4.2 0 0 1 18 1.8zM18 0a6 6 0 0 0-6 6v12.045a10 10 0 1 0 12 0V6a6 6 0 0 0-6-6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Temperature" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Temperature extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c3, create_fragment$c3, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TestAB.svelte generated by Svelte v3.24.1 */

function create_fragment$c4(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4.819 21.782l-1.308 3.986a.236.236 0 0 1-.262.193H.87c-.143 0-.19-.072-.167-.242L5.6 11.563a3.743 3.743 0 0 0\n    .214-1.3c0-.1.048-.169.143-.169h3.311c.119 0 .143.024.167.145l5.5 15.509c.024.145 0 .217-.143.217h-2.669a.238.238 0\n    0 1-.238-.145L10.5 21.782zm4.925-2.633c-.5-1.594-1.618-4.952-2.094-6.643h-.024c-.381 1.619-1.332 4.445-2.046\n    6.643zM17.548 26.879c-.024.1-.071.121-.166.121h-1.975c-.119\n    0-.143-.048-.119-.145l4.687-17.707c.024-.1.048-.1.143-.1h2c.1 0 .119.024.1.121zM24\n    10.331c0-.121.024-.193.143-.217.856-.024 3.021-.072 4.615-.072 4.972 0 5.734 2.657 5.734 4.2a3.789 3.789 0 0 1-1.5\n    3.14 4.049 4.049 0 0 1 2.284 3.744c0 3.044-2.593 4.88-6.519 4.88-2.07 0-3.687-.024-4.591-.048a.183.183 0 0\n    1-.166-.19zm2.831 6.088h1.808a14.445 14.445 0 0 1 2.165.145 2.3 2.3 0 0 0 .9-1.908c0-1.425-1.047-2.126-3-2.126-.761\n    0-1.38.024-1.879.024zm0 7.1c.523.024 1.118.048 1.832.048 2.236.024 3.664-.749 3.664-2.367a2.021 2.021 0 0\n    0-1.713-2.1A6.169 6.169 0 0 0 29 18.931h-2.169z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TestAB" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TestAB extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c4, create_fragment$c4, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TestABEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$c5(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M4.819 17.782l-1.308 3.986a.236.236 0 0 1-.262.193H.87c-.143 0-.19-.072-.167-.242L5.6 7.563a3.743 3.743 0 0 0\n    .214-1.3c0-.1.048-.169.143-.169h3.311c.119 0 .143.024.167.145l5.5 15.509c.024.145 0 .217-.143.217h-2.669a.238.238 0\n    0 1-.238-.145L10.5 17.782zm4.925-2.633c-.5-1.594-1.618-4.952-2.094-6.643h-.024c-.381 1.619-1.332 4.445-2.046\n    6.643zM17.548 22.879c-.024.1-.071.121-.166.121h-1.975c-.119\n    0-.143-.048-.119-.145l4.687-17.707c.024-.1.048-.1.143-.1h2c.1 0 .119.024.1.121zM26.831 19.184v-4.253H29a6.171 6.171\n    0 0 1 1.618.169 2.417 2.417 0 0 1 1.042.548 3.169 3.169 0 0 1 2.279.919l1.261 1.265a4.651 4.651 0 0 0 .078-.7 4.05\n    4.05 0 0 0-2.284-3.745 3.789 3.789 0 0 0 1.5-3.14c0-1.546-.762-4.2-5.734-4.2-1.594\n    0-3.759.048-4.615.072-.119.024-.143.1-.143.218v15.431c0 .066.062.1.115.133zm0-10.631c.5 0 1.118-.024 1.88-.024 1.95\n    0 3 .7 3 2.126a2.3 2.3 0 0 1-.9 1.908 14.426 14.426 0 0 0-2.165-.145h-1.815z");
			attr(path1, "d", "M35.738 21.764l-3.506-3.506a.738.738 0 0 0-.527-.215h-.023a.833.833 0 0 0-.564.247L20.3 29.113a.607.607 0 0\n    0-.153.256l-2.027 6c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039 5.123-1.764 6-2.028a.6.6 0 0 0\n    .252-.151l10.821-10.829a.836.836 0 0 0 .246-.537.743.743 0 0 0-.214-.577zm-11.6 10.963c-1.314.395-3.3 1.229-4.431\n    1.568l1.56-4.431z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TestABEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TestABEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c5, create_fragment$c5, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TestABGear.svelte generated by Svelte v3.24.1 */

function create_fragment$c6(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4.847 17.782l-1.309 3.986a.236.236 0 0 1-.262.193H.9c-.143 0-.19-.072-.167-.242l4.9-14.156a3.743 3.743 0 0 0\n    .214-1.3c0-.1.048-.169.143-.169H9.3c.119 0 .143.024.167.145l5.5 15.509c.024.145 0 .217-.143.217H12.15a.238.238 0 0\n    1-.238-.145l-1.38-4.034zm4.925-2.633c-.5-1.594-1.618-4.952-2.094-6.643h-.024c-.381 1.619-1.332 4.445-2.046\n    6.643zM16.668 18.489c.009 0 .23-.314.387-.468l1-1a3.028 3.028 0 0 1 1.262-.747l2.924-11.1c.024-.1\n    0-.121-.095-.121h-2c-.1 0-.119 0-.144.1-.002-.005-3.484 13.366-3.334 13.336zM25.368 14.015h1.322a3.042 3.042 0 0 1\n    2.173.917h.161a6.171 6.171 0 0 1 1.618.169 2.111 2.111 0 0 1 1.445 1.05 3.033 3.033 0 0 1 1.913.866l1.008\n    1.008c.066.066.091.153.149.224a4.482 4.482 0 0 0 .149-1.118 4.05 4.05 0 0 0-2.284-3.745 3.789 3.789 0 0 0\n    1.5-3.14c0-1.546-.762-4.2-5.734-4.2-1.594 0-3.759.048-4.615.072-.119.024-.143.1-.143.218v8.006a3.024 3.024 0 0 1\n    1.338-.327zm1.491-5.461c.5 0 1.118-.024 1.88-.024 1.95 0 3 .7 3 2.126a2.3 2.3 0 0 1-.9 1.908 14.426 14.426 0 0\n    0-2.165-.145h-1.815zM34.952 24.678h-2.315a6.69 6.69 0 0 0-.977-2.373l1.648-1.648a.661.661 0 0 0 0-.935l-1-1a.661.661\n    0 0 0-.935 0l-1.648 1.648a6.693 6.693 0 0 0-2.373-.978v-2.316a.661.661 0 0 0-.661-.661h-1.324a.661.661 0 0\n    0-.661.661v2.315a6.692 6.692 0 0 0-2.373.978l-1.648-1.649a.661.661 0 0 0-.935 0l-1 1a.661.661 0 0 0 0 .935l1.65\n    1.65a6.69 6.69 0 0 0-.977 2.373H17.1a.661.661 0 0 0-.661.661v1.322a.661.661 0 0 0 .661.661h2.315A6.69 6.69 0 0 0\n    20.4 29.7l-1.648 1.648a.661.661 0 0 0 0 .935l1 1a.661.661 0 0 0 .935 0l1.648-1.648a6.692 6.692 0 0 0\n    2.373.977v2.315a.661.661 0 0 0 .661.661h1.322a.661.661 0 0 0 .661-.661V32.61a6.693 6.693 0 0 0 2.373-.977l1.648\n    1.648a.661.661 0 0 0 .935 0l1-1a.661.661 0 0 0 0-.935L31.66 29.7a6.69 6.69 0 0 0 .977-2.373h2.315a.661.661 0 0 0\n    .661-.661v-1.327a.661.661 0 0 0-.661-.661zM26.028 29.6a3.6 3.6 0 1 1 3.6-3.6 3.6 3.6 0 0 1-3.6 3.6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TestABGear" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TestABGear extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c6, create_fragment$c6, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TestABRemove.svelte generated by Svelte v3.24.1 */

function create_fragment$c7(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4.819 17.782l-1.308 3.986a.236.236 0 0 1-.262.193H.87c-.143 0-.19-.072-.167-.242L5.6 7.563a3.743 3.743 0 0 0\n    .214-1.3c0-.1.048-.169.143-.169h3.311c.119 0 .143.024.167.145l5.5 15.509c.024.145 0 .217-.143.217h-2.669a.238.238 0\n    0 1-.238-.145L10.5 17.782zm4.925-2.633c-.5-1.594-1.618-4.952-2.094-6.643h-.024c-.381 1.619-1.332 4.445-2.046\n    6.643zM15.407 23a12.315 12.315 0 0 1 3.454-5.1l3.35-12.723c.024-.1 0-.121-.095-.121h-2c-.1 0-.119 0-.144.1l-4.684\n    17.699c-.023.097 0 .145.119.145zM27 14.8a12.365 12.365 0 0 1 1.7.132h.3a6.171 6.171 0 0 1 1.618.169 2.329 2.329 0 0\n    1 1.174.666 12.28 12.28 0 0 1 3.4 2.173 4.723 4.723 0 0 0 .09-.81 4.05 4.05 0 0 0-2.284-3.745 3.789 3.789 0 0 0\n    1.5-3.14c0-1.546-.762-4.2-5.734-4.2-1.594 0-3.759.048-4.615.072-.119.024-.143.1-.143.218v8.852A12.291 12.291 0 0 1\n    27 14.8zm-.169-6.246c.5 0 1.118-.024 1.88-.024 1.95 0 3 .7 3 2.126a2.3 2.3 0 0 1-.9 1.908 14.426 14.426 0 0\n    0-2.165-.145h-1.815zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5.826 12.267a.5.5 0 0 1 0 .707l-1.752\n    1.752a.5.5 0 0 1-.707 0L27 29.459l-3.367 3.367a.5.5 0 0 1-.707 0l-1.752-1.752a.5.5 0 0 1 0-.707L24.541\n    27l-3.367-3.367a.5.5 0 0 1 0-.707l1.752-1.752a.5.5 0 0 1 .707 0L27 24.541l3.367-3.367a.5.5 0 0 1 .707 0l1.752\n    1.752a.5.5 0 0 1 0 .707L29.459 27z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TestABRemove" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TestABRemove extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c7, create_fragment$c7, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TestProfile.svelte generated by Svelte v3.24.1 */

function create_fragment$c8(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.338 32.3L23.864 20.824a12.012 12.012 0 1 0-3.04 3.04L32.3 35.338a2.155 2.155 0 0 0 3.04-3.04zM4 14a10 10 0 1\n    1 17.8 6.192c-.5-1.344-1.816-2.977-4.956-3.3a.777.777 0 0 1-.673-.78V14.99a.78.78 0 0 1 .2-.5 5.949 5.949 0 0 0\n    1.353-3.71c0-2.808-1.489-4.377-3.74-4.377S10.2 8.031 10.2 10.777a6.008 6.008 0 0 0 1.417 3.71.779.779 0 0 1\n    .2.5v1.121a.774.774 0 0 1-.675.781c-3.2.278-4.481 1.9-4.962 3.265A9.91 9.91 0 0 1 4 14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TestProfile" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TestProfile extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c8, create_fragment$c8, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Text.svelte generated by Svelte v3.24.1 */

function create_fragment$c9(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M5 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v20h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1\n    1 0 0 0-1-1h-3V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Text" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Text extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c9, create_fragment$c9, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$ca(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm4.9 10.4h-3.4v3.4a.5.5 0 0 1-.5.5h-2a.5.5 0 0\n    1-.5-.5v-3.4h-3.4a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5h3.4v-3.4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v3.4h3.4a.5.5 0 0\n    1 .5.5v2a.5.5 0 0 1-.5.5z");
			attr(path1, "d", "M16 27.1V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h8.172A10.82 10.82 0 0 1 16 27.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ca($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ca, create_fragment$ca, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextAlignCenter.svelte generated by Svelte v3.24.1 */

function create_fragment$cb(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 20);
			attr(rect0, "x", rect0_x_value = 8);
			attr(rect0, "y", rect0_y_value = 28);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 32);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 20);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 32);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 4);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 20);
			attr(rect3, "x", rect3_x_value = 8);
			attr(rect3, "y", rect3_y_value = 12);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cb($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextAlignCenter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextAlignCenter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cb, create_fragment$cb, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextAlignJustify.svelte generated by Svelte v3.24.1 */

function create_fragment$cc(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 28);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 28);
			attr(rect1, "x", rect1_x_value = 4);
			attr(rect1, "y", rect1_y_value = 12);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 28);
			attr(rect2, "x", rect2_x_value = 4);
			attr(rect2, "y", rect2_y_value = 20);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 28);
			attr(rect3, "x", rect3_x_value = 4);
			attr(rect3, "y", rect3_y_value = 28);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cc($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextAlignJustify" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextAlignJustify extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cc, create_fragment$cc, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextAlignLeft.svelte generated by Svelte v3.24.1 */

function create_fragment$cd(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 28);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 30);
			attr(rect1, "x", rect1_x_value = 4);
			attr(rect1, "y", rect1_y_value = 4);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 24);
			attr(rect2, "x", rect2_x_value = 4);
			attr(rect2, "y", rect2_y_value = 12);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 30);
			attr(rect3, "x", rect3_x_value = 4);
			attr(rect3, "y", rect3_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cd($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextAlignLeft" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextAlignLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cd, create_fragment$cd, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextAlignRight.svelte generated by Svelte v3.24.1 */

function create_fragment$ce(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 8);
			attr(rect0, "y", rect0_y_value = 28);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 30);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 4);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 24);
			attr(rect2, "x", rect2_x_value = 8);
			attr(rect2, "y", rect2_y_value = 12);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 30);
			attr(rect3, "x", rect3_x_value = 2);
			attr(rect3, "y", rect3_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ce($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextAlignRight" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextAlignRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ce, create_fragment$ce, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextBaselineShift.svelte generated by Svelte v3.24.1 */

function create_fragment$cf(ctx) {
	let svg;
	let path0;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M21.3 23.776L13.061 3c-.037-.129-.071-.16-.212-.16H9.412a.16.16 0 0 0-.176.16 3.073 3.073 0 0 1-.246 1.312L1.345\n    23.744c-.034.16.036.256.21.256H3.94c.175 0 .247-.064.281-.192L6.488 18h9.428l2.3 5.84a.317.317 0 0 0\n    .28.16h2.666c.176 0 .21-.1.138-.224zM11.167 5.017h.033c.665 2.176 3.345 8.9 4.117 10.983H7.091c1.333-3.521\n    3.479-8.935 4.076-10.983z");
			attr(rect0, "height", rect0_height_value = 2);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 21);
			attr(rect0, "x", rect0_x_value = 1);
			attr(rect0, "y", rect0_y_value = 26);
			attr(rect1, "height", rect1_height_value = 2);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 12);
			attr(rect1, "x", rect1_x_value = 23);
			attr(rect1, "y", rect1_y_value = 16);
			attr(path1, "d", "M33.537 11.728a9.194 9.194 0 0 0 .047 1.148c0 .048 0 .071-.047.1A9.872 9.872 0 0 1 29.065 14c-2.536\n    0-4.449-1.244-4.449-3.755 0-2.535 2.367-3.659 5.334-3.659.883 0 1.386.025\n    1.65.048V6.06c0-.74-.36-2.391-2.7-2.391a6.414 6.414 0 0 0-3.037.717.117.117 0 0 1-.166-.119V2.808a.21.21 0 0 1\n    .119-.191 7.9 7.9 0 0 1 3.391-.717c3.061 0 4.33 2.008 4.33 4.5zM31.6 8.212a11.4 11.4 0 0 0-1.58-.1c-2.32\n    0-3.444.79-3.444 2.129 0 1.076.743 2.129 2.846 2.129a5.614 5.614 0 0 0 2.178-.407zM33.871 25.166l-4-4a.5.5 0 0\n    0-.743 0l-4 4A.49.49 0 0 0 25 25.5a.5.5 0 0 0 .5.5H28v5.155a.845.845 0 0 0 .845.845h1.31a.845.845 0 0 0\n    .845-.845V26h2.5a.5.5 0 0 0 .5-.5.49.49 0 0 0-.129-.334z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cf($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextBaselineShift" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextBaselineShift extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cf, create_fragment$cf, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextBold.svelte generated by Svelte v3.24.1 */

function create_fragment$cg(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M1 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-2a1 1\n    0 0 0-1-1h-3V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cg($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextBold" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextBold extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cg, create_fragment$cg, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextBulleted.svelte generated by Svelte v3.24.1 */

function create_fragment$ch(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 6);
			attr(rect0, "rx", rect0_rx_value = 2.8);
			attr(rect0, "ry", rect0_ry_value = 2.8);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 6);
			attr(rect1, "rx", rect1_rx_value = 2.8);
			attr(rect1, "ry", rect1_ry_value = 2.8);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 4);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 2.8);
			attr(rect2, "ry", rect2_ry_value = 2.8);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 4);
			attr(rect2, "y", rect2_y_value = 26);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 22);
			attr(rect3, "x", rect3_x_value = 12);
			attr(rect3, "y", rect3_y_value = 28);
			attr(rect4, "height", rect4_height_value = 4);
			attr(rect4, "rx", rect4_rx_value = 1);
			attr(rect4, "ry", rect4_ry_value = 1);
			attr(rect4, "width", rect4_width_value = 22);
			attr(rect4, "x", rect4_x_value = 12);
			attr(rect4, "y", rect4_y_value = 16);
			attr(rect5, "height", rect5_height_value = 4);
			attr(rect5, "rx", rect5_rx_value = 1);
			attr(rect5, "ry", rect5_ry_value = 1);
			attr(rect5, "width", rect5_width_value = 22);
			attr(rect5, "x", rect5_x_value = 12);
			attr(rect5, "y", rect5_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ch($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextBulleted" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextBulleted extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ch, create_fragment$ch, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextBulletedAttach.svelte generated by Svelte v3.24.1 */

function create_fragment$ci(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M12 17v2a1 1 0 0 0 1 1h6.7l3.8-3.8c.074-.074.163-.127.24-.2H13a1 1 0 0 0-1 1zM33 4H13a1 1 0 0 0-1 1v2a1 1 0 0 0 1\n    1h20a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM7.2 26h-.4A2.8 2.8 0 0 0 4 28.8v.4A2.8 2.8 0 0 0 6.8 32h.4a2.8 2.8 0 0 0\n    2.8-2.8v-.4A2.8 2.8 0 0 0 7.2 26zm0-12h-.4A2.8 2.8 0 0 0 4 16.8v.4A2.8 2.8 0 0 0 6.8 20h.4a2.8 2.8 0 0 0\n    2.8-2.8v-.4A2.8 2.8 0 0 0 7.2 14zM13 28a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.844a9.442 9.442 0 0 1-1.279-4zM7.2 2h-.4A2.8\n    2.8 0 0 0 4 4.8v.4A2.8 2.8 0 0 0 6.8 8h.4A2.8 2.8 0 0 0 10 5.2v-.4A2.8 2.8 0 0 0 7.2 2zM36 28.071l-4.7 4.7a7 7 0 0\n    1-9.9-9.9l5.407-5.407a5 5 0 0 1 7.071 7.071l-5.407 5.407a3 3 0 0 1-4.242-4.242l4.7-4.7 1.414 1.414-4.7 4.7a1 1 0 0 0\n    1.414 1.414l5.407-5.407a3 3 0 0 0-4.243-4.243l-5.407 5.407a5 5 0 0 0 7.071 7.071l4.7-4.7z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ci($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextBulletedAttach" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextBulletedAttach extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ci, create_fragment$ci, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextBulletedHierarchy.svelte generated by Svelte v3.24.1 */

function create_fragment$cj(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 6);
			attr(rect0, "rx", rect0_rx_value = 2.8);
			attr(rect0, "ry", rect0_ry_value = 2.8);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "x", rect0_x_value = 4);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 6);
			attr(rect1, "rx", rect1_rx_value = 2.8);
			attr(rect1, "ry", rect1_ry_value = 2.8);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 12);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 2.8);
			attr(rect2, "ry", rect2_ry_value = 2.8);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 12);
			attr(rect2, "y", rect2_y_value = 26);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 14);
			attr(rect3, "x", rect3_x_value = 20);
			attr(rect3, "y", rect3_y_value = 28);
			attr(rect4, "height", rect4_height_value = 4);
			attr(rect4, "rx", rect4_rx_value = 1);
			attr(rect4, "ry", rect4_ry_value = 1);
			attr(rect4, "width", rect4_width_value = 14);
			attr(rect4, "x", rect4_x_value = 20);
			attr(rect4, "y", rect4_y_value = 16);
			attr(rect5, "height", rect5_height_value = 4);
			attr(rect5, "rx", rect5_rx_value = 1);
			attr(rect5, "ry", rect5_ry_value = 1);
			attr(rect5, "width", rect5_width_value = 22);
			attr(rect5, "x", rect5_x_value = 12);
			attr(rect5, "y", rect5_y_value = 4);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cj($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextBulletedHierarchy" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextBulletedHierarchy extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cj, create_fragment$cj, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextBulletedHierarchyExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$ck(ctx) {
	let svg;
	let path0;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.929 6.929 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			attr(rect0, "height", rect0_height_value = 6);
			attr(rect0, "rx", rect0_rx_value = 2.8);
			attr(rect0, "ry", rect0_ry_value = 2.8);
			attr(rect0, "width", rect0_width_value = 6);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 6);
			attr(rect1, "rx", rect1_rx_value = 2.8);
			attr(rect1, "ry", rect1_ry_value = 2.8);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 6);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 2.8);
			attr(rect2, "ry", rect2_ry_value = 2.8);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 6);
			attr(rect2, "y", rect2_y_value = 26);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 22);
			attr(rect3, "x", rect3_x_value = 8);
			attr(rect3, "y", rect3_y_value = 4);
			attr(path1, "d", "M27 16H15a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h3.515A10.975 10.975 0 0 1 27 16zM16.05 28H15a1 1 0 0 0-1 1v2a1 1 0 0 0 1\n    1h2.21a10.942 10.942 0 0 1-1.16-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ck($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextBulletedHierarchyExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextBulletedHierarchyExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ck, create_fragment$ck, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextColor.svelte generated by Svelte v3.24.1 */

function create_fragment$cl(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.059 27.869A6.854 6.854 0 0 1 16 24.548V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1\n    1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h5.162a6.948 6.948 0 0 1-.103-4.131z");
			attr(path1, "d", "M35.8 24.128c-1.156-4.61-5.8-6.14-8.685-5.777-2.516.316-4.366 1.172-4.4 2.557-.019.772.411 1.1 1.159\n    1.554.656.395 1.4.595.875 1.982-.321.856-1.849.467-2.517.485-2.212.057-5.058-.024-6.052 3.533A5.216 5.216 0 0 0 19\n    34.439a12.214 12.214 0 0 0 8.808.759c5.286-1.624 9.132-6.517 7.992-11.07zm-14.593 8.688a2.39 2.39 0 1 1 1.648-2.95\n    2.389 2.389 0 0 1-1.648 2.95zm5.576.738a2.239 2.239 0 1 1 1.544-2.764 2.239 2.239 0 0 1-1.544\n    2.764zm2.96-13.45a1.573 1.573 0 1 1-1.085 1.942 1.572 1.572 0 0 1 1.085-1.946zm1.544 10.784a1.89 1.89 0 1 1\n    1.3-2.334 1.891 1.891 0 0 1-1.3 2.334zm2.041-4.176a1.682 1.682 0 1 1 1.161-2.077 1.681 1.681 0 0 1-1.161 2.077z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cl($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextColor" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextColor extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cl, create_fragment$cl, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextDecrease.svelte generated by Svelte v3.24.1 */

function create_fragment$cm(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.9 27a8.9 8.9 0 1 0-8.9 8.9 8.9 8.9 0 0 0 8.9-8.9zm-3.863-2.171l-4.614 7.3a.5.5 0 0 1-.845 0l-4.614-7.3A.5.5 0\n    0 1 22.34 24h9.321a.5.5 0 0 1 .376.829z");
			attr(path1, "d", "M16 27.1V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h8.172A10.82 10.82 0 0 1 16 27.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cm($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextDecrease" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextDecrease extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cm, create_fragment$cm, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$cn(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 28V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h5.667zM35.645 20.685l-4.324-4.323a1.083 1.083 0 0 0-.678-.265 1.13 1.13 0\n    0 0-.7.3L18.711 27.639a.736.736 0 0 0-.188.315l-2.444 7.34c-.085.282.345.638.588.638a.231.231 0 0 0\n    .046-.005c.207-.048 6.26-2.118 7.344-2.444a.733.733 0 0 0 .31-.187L35.6 22.059a1.03 1.03 0 0 0 .3-.662.916.916 0 0\n    0-.255-.712zM18.039 33.973l1.978-5.519 3.54 3.531c-1.621.487-4.118 1.57-5.518 1.988z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cn($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cn, create_fragment$cn, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$co(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.935 6.935 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.526 4.252l-9.778-9.777a6.966 6.966 0 0 1 9.778 9.777z");
			attr(path1, "d", "M16.04 28S16 26.984 16 26V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1\n    1 0 0 0 1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h8.21a10.934 10.934 0 0 1-1.17-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$co($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$co, create_fragment$co, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextIncrease.svelte generated by Svelte v3.24.1 */

function create_fragment$cp(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM31.661 30H22.34a.5.5 0 0 1-.376-.829l4.614-7.3a.5.5 0 0 1\n    .845 0l4.614 7.3a.5.5 0 0 1-.376.829z");
			attr(path1, "d", "M16 27.1V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h8v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h8.172A10.82 10.82 0 0 1 16 27.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cp($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextIncrease" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextIncrease extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cp, create_fragment$cp, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextIndentDecrease.svelte generated by Svelte v3.24.1 */

function create_fragment$cq(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 8);
			attr(rect0, "y", rect0_y_value = 28);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 12);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 20);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 12);
			attr(rect2, "x", rect2_x_value = 20);
			attr(rect2, "y", rect2_y_value = 12);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 24);
			attr(rect3, "x", rect3_x_value = 8);
			attr(rect3, "y", rect3_y_value = 4);
			attr(path, "d", "M8 14v-3.328a.5.5 0 0 0-.866-.341L0 18l7.134 7.669A.5.5 0 0 0 8 25.328V22h7a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cq($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextIndentDecrease" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextIndentDecrease extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cq, create_fragment$cq, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextIndentIncrease.svelte generated by Svelte v3.24.1 */

function create_fragment$cr(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 24);
			attr(rect0, "x", rect0_x_value = 8);
			attr(rect0, "y", rect0_y_value = 28);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 12);
			attr(rect1, "x", rect1_x_value = 20);
			attr(rect1, "y", rect1_y_value = 20);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 12);
			attr(rect2, "x", rect2_x_value = 20);
			attr(rect2, "y", rect2_y_value = 12);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 24);
			attr(rect3, "x", rect3_x_value = 8);
			attr(rect3, "y", rect3_y_value = 4);
			attr(path, "d", "M8 14v-3.328a.5.5 0 0 1 .866-.341L16 18l-7.134 7.669A.5.5 0 0 1 8 25.328V22H1a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cr($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextIndentIncrease" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextIndentIncrease extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cr, create_fragment$cr, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextItalic.svelte generated by Svelte v3.24.1 */

function create_fragment$cs(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M7.919 4a1.561 1.561 0 0 0-1.351 1l-2.109 6a.685.685 0 0 0 .649 1h2a1.557 1.557 0 0 0 1.351-1l1.055-3h8l-7.028\n    20h-3a1.557 1.557 0 0 0-1.351 1l-.7 2a.685.685 0 0 0 .649 1h10a1.557 1.557 0 0 0 1.351-1l.7-2a.684.684 0 0\n    0-.649-1h-3l7.028-20h8l-1.055 3a.685.685 0 0 0 .649 1h2a1.557 1.557 0 0 0 1.351-1l2.109-6a.686.686 0 0 0-.649-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cs($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextItalic" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextItalic extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cs, create_fragment$cs, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextKerning.svelte generated by Svelte v3.24.1 */

function create_fragment$ct(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10.4 18.759c.6-2.106 1.945-6.7 4.51-14.287.054-.162.109-.216.243-.216H18.1c.134 0 .215.081.161.243l-6.188\n    17.312A.235.235 0 0 1 11.8 22H8.67a.239.239 0 0 1-.269-.162L2.054 4.5c-.054-.135 0-.243.161-.243h3.107a.187.187 0 0\n    1 .215.161c2.567 7.1 4.321 12.343 4.808 14.342zM28.418 4.417c-.026-.134-.054-.161-.189-.161h-3.754c-.107\n    0-.161.081-.161.189A4.132 4.132 0 0 1 24.07 5.9l-5.563 15.83c-.028.189.026.27.189.27h2.7a.267.267 0 0 0\n    .3-.216L22.954 18h6.913l1.333 3.838a.272.272 0 0 0 .271.162H34.5c.161 0 .189-.081.161-.243zm-2.052 2.54h.026c.541\n    1.89 2.1 6.481 2.664 8.264h-5.3c.813-2.457 2.178-6.455 2.61-8.264zM33.5 27H16v-2.5a.5.5 0 0 0-.5-.5.49.49 0 0\n    0-.331.129l-4 4a.5.5 0 0 0 0 .744l4 4A.49.49 0 0 0 15.5 33a.5.5 0 0 0 .5-.5V30h17.5a.5.5 0 0 0 .5-.5v-2a.5.5 0 0\n    0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ct($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextKerning" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextKerning extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ct, create_fragment$ct, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextLetteredLowerCase.svelte generated by Svelte v3.24.1 */

function create_fragment$cu(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 14);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 28);
			attr(path, "d", "M9.67 8.34c0 .3 0 .576.016.881 0 .031 0 .047-.032.063a7.338 7.338 0 0 1-3.23.72c-1.727 0-3.1-.8-3.1-2.558 0-1.7\n    1.6-2.495 3.68-2.495.607 0 .975.032 1.135.047v-.287c0-.431-.225-1.47-1.807-1.47a4.759 4.759 0 0 0-2.142.478.08.08 0\n    0 1-.114-.08V2.5a.158.158 0 0 1 .08-.144 5.831 5.831 0 0 1 2.416-.479 2.838 2.838 0 0 1 3.1 3.1zM8.135 6.2a8.486\n    8.486 0 0 0-1.055-.049c-1.519 0-2.225.478-2.225 1.3 0 .687.481 1.31 1.84 1.31a3.674 3.674 0 0 0 1.44-.271zM5.373\n    10.959c.09 0 .12 0 .12.09v3.516a4.638 4.638 0 0 1 1.629-.27 3.433 3.433 0 0 1 3.621 3.545 4.122 4.122 0 0 1-4.419\n    4.119 6.961 6.961 0 0 1-2.219-.317.159.159 0 0 1-.105-.136V11.049c0-.075.044-.09.105-.09zm1.493 4.6a3.462 3.462 0 0\n    0-1.373.241v4.8a3.611 3.611 0 0 0 .951.105 2.613 2.613 0 0 0 2.777-2.731 2.235 2.235 0 0 0-2.355-2.413zM9.908\n    33.62a.121.121 0 0 1-.08.129 5.351 5.351 0 0 1-1.838.256 3.9 3.9 0 0 1-4.174-4.03c0-2.367 1.776-4.093\n    4.43-4.093a4.37 4.37 0 0 1 1.582.191c.065.031.08.08.08.16L9.893 27.4c0 .1-.047.1-.112.08a3.906 3.906 0 0\n    0-1.519-.238 2.682 2.682 0 1 0 0 5.355 4.577 4.577 0 0 0 1.538-.192c.08-.031.111 0 .111.064z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cu($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextLetteredLowerCase" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextLetteredLowerCase extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cu, create_fragment$cu, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextLetteredUpperCase.svelte generated by Svelte v3.24.1 */

function create_fragment$cv(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 14);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 28);
			attr(path, "d", "M2 12.184c0-.107.015-.138.092-.153.673-.016 1.959-.031 3.26-.031C8.521 12 9.2 13.393 9.2 14.633a2.215 2.215 0 0\n    1-1.46 2.143v.031a2.361 2.361 0 0 1 1.837 2.311c0 1.9-1.638 2.878-4.424 2.878a82.978 82.978 0 0 1-3.046-.031.122.122\n    0 0 1-.107-.138zm2.128 3.842H5.46c1.224 0 1.607-.5 1.607-1.163 0-.827-.551-1.164-1.73-1.164-.6\n    0-1.071.015-1.209.031zm0 4.24c.168 0 .52.031 1.148.031 1.286 0 2.051-.337 2.051-1.286\n    0-.8-.49-1.255-1.852-1.255H4.128zM10.826 9.846C9.685 6.7 8.453 3.174 7.328.077A.116.116 0 0 0 7.2 0H4.724a.1.1 0 0\n    0-.108.108 2.764 2.764 0 0 1-.154.955c-.971 2.666-2.28 6.456-3.1 8.768-.031.107 0 .169.123.169h1.852a.167.167 0 0 0\n    .185-.139L4 8h4l.545 1.892A.138.138 0 0 0 8.7 10h2.034c.107 0 .138-.046.092-.154zm-4.87-8.028h.016c.256.922 1.19\n    3.175 1.649 4.431l-3.065.011C5 4.921 5.761 2.7 5.956 1.818zM7.642 24a5.7 5.7 0 0 1\n    2.1.313c.075.045.09.075.09.18v1.582c0 .134-.075.134-.135.1a5.045 5.045 0 0 0-1.985-.373 2.982 2.982 0 0 0-3.235\n    3.168A2.93 2.93 0 0 0 7.7 32.1a6.061 6.061 0 0 0 2.09-.358c.075-.03.119 0 .119.09v1.537c0\n    .105-.015.164-.119.209A6.15 6.15 0 0 1 7.328 34C4.657 34 2.3 32.522 2.3 29.03 2.3 26.179 4.388 24 7.642 24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cv($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextLetteredUpperCase" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextLetteredUpperCase extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cv, create_fragment$cv, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextNumbered.svelte generated by Svelte v3.24.1 */

function create_fragment$cw(ctx) {
	let svg;
	let path;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr(path, "d", "M4.42 29.688c-.076 0-.106-.03-.106-.107v-1.516c0-.092 0-.153.092-.153l.763-.007c1.073 0 1.654-.322 1.654-1.026\n    0-.674-.566-1.118-1.685-1.118a4.712 4.712 0 0 0-2.266.582c-.092.046-.106\n    0-.106-.061v-1.517c0-.092-.016-.122.076-.168A5.655 5.655 0 0 1 5.506 24c2.022 0 3.277 1.01 3.277 2.6a2.168 2.168 0 0\n    1-1.347 2.006A2.434 2.434 0 0 1 9.259 31c0 1.96-1.808 3-3.921 3a5.524 5.524 0 0\n    1-2.619-.505c-.092-.031-.092-.123-.092-.2v-1.653c0-.061.077-.092.139-.061a5.234 5.234 0 0 0 2.5.643c1.377 0\n    1.914-.567 1.914-1.287 0-.811-.582-1.256-1.854-1.256zM5.07 1.976a12.906 12.906 0 0\n    1-1.628.424c-.1.015-.136-.015-.136-.1V.98c0-.075.016-.12.106-.135a9.669 9.669 0 0 0 1.949-.77A.557.557 0 0 1 5.617\n    0H7.1c.075 0 .09.045.09.106v8.076h1.346c.106 0 .136.045.151.136v1.516c.015.121-.031.166-.121.166H3.627c-.106\n    0-.136-.045-.121-.136V8.318a.145.145 0 0 1 .166-.136h1.4zM2.514 22c-.1 0-.12-.045-.12-.135v-1.076a.214.214 0 0 1\n    .075-.2 36.9 36.9 0 0 0 2.812-2.528c1.181-1.151 1.7-1.895 1.7-2.733 0-.942-.769-1.493-1.906-1.493a5.366 5.366 0 0\n    0-2.407.658c-.09.045-.15.015-.15-.09v-1.476a.17.17 0 0 1 .09-.179A5.7 5.7 0 0 1 5.565 12 3 3 0 0 1 8.9 14.982a4.4\n    4.4 0 0 1-1.545 3.412 23.268 23.268 0 0 1-1.9 1.831c1.032 0 3.158-.028 4.04-.028.105 0 .12.03.105.135l-.445\n    1.548a.149.149 0 0 1-.165.12z");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 14);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 28);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cw($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextNumbered" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextNumbered extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cw, create_fragment$cw, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextParagraph.svelte generated by Svelte v3.24.1 */

function create_fragment$cx(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M13.4 4c-4.5 0-8.919 3.623-9.354 8.105A9.009 9.009 0 0 0 13 22c1.05 0 3-.075 3-.075V33.5a.5.5 0 0 0 .5.5h2a.5.5 0\n    0 0 .5-.5V7h6v26.5a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cx($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextParagraph" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextParagraph extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cx, create_fragment$cx, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextRomanLowercase.svelte generated by Svelte v3.24.1 */

function create_fragment$cy(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 14);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 28);
			attr(path, "d", "M10 2V.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V2zM8 4v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V4zM8 14v-1.5a.5.5 0 0\n    0-.5-.5h-1a.5.5 0 0 0-.5.5V14zM6 16v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V16zM12 14v-1.5a.5.5 0 0 0-.5-.5h-1a.5.5 0\n    0 0-.5.5V14zM10 16v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V16zM8 26v-1.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V26zM6\n    28v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V28zM12 26v-1.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V26zM10 28v5.5a.5.5 0 0\n    0 .5.5h1a.5.5 0 0 0 .5-.5V28zM4 26v-1.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V26zM2 28v5.5a.5.5 0 0 0 .5.5h1a.5.5 0 0\n    0 .5-.5V28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cy($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextRomanLowercase" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextRomanLowercase extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cy, create_fragment$cy, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextRomanUppercase.svelte generated by Svelte v3.24.1 */

function create_fragment$cz(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let rect6;
	let rect6_height_value;
	let rect6_rx_value;
	let rect6_ry_value;
	let rect6_width_value;
	let rect6_x_value;
	let rect6_y_value;
	let rect7;
	let rect7_height_value;
	let rect7_rx_value;
	let rect7_ry_value;
	let rect7_width_value;
	let rect7_x_value;
	let rect7_y_value;
	let rect8;
	let rect8_height_value;
	let rect8_rx_value;
	let rect8_ry_value;
	let rect8_width_value;
	let rect8_x_value;
	let rect8_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			rect6 = svg_element("rect");
			rect7 = svg_element("rect");
			rect8 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 14);
			attr(rect0, "y", rect0_y_value = 4);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 16);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 28);
			attr(rect3, "height", rect3_height_value = 10);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 2);
			attr(rect3, "x", rect3_x_value = 8);
			attr(rect4, "height", rect4_height_value = 10);
			attr(rect4, "rx", rect4_rx_value = 0.5);
			attr(rect4, "ry", rect4_ry_value = 0.5);
			attr(rect4, "width", rect4_width_value = 2);
			attr(rect4, "x", rect4_x_value = 10);
			attr(rect4, "y", rect4_y_value = 12);
			attr(rect5, "height", rect5_height_value = 10);
			attr(rect5, "rx", rect5_rx_value = 0.5);
			attr(rect5, "ry", rect5_ry_value = 0.5);
			attr(rect5, "width", rect5_width_value = 2);
			attr(rect5, "x", rect5_x_value = 6);
			attr(rect5, "y", rect5_y_value = 12);
			attr(rect6, "height", rect6_height_value = 10);
			attr(rect6, "rx", rect6_rx_value = 0.5);
			attr(rect6, "ry", rect6_ry_value = 0.5);
			attr(rect6, "width", rect6_width_value = 2);
			attr(rect6, "x", rect6_x_value = 10);
			attr(rect6, "y", rect6_y_value = 24);
			attr(rect7, "height", rect7_height_value = 10);
			attr(rect7, "rx", rect7_rx_value = 0.5);
			attr(rect7, "ry", rect7_ry_value = 0.5);
			attr(rect7, "width", rect7_width_value = 2);
			attr(rect7, "x", rect7_x_value = 6);
			attr(rect7, "y", rect7_y_value = 24);
			attr(rect8, "height", rect8_height_value = 10);
			attr(rect8, "rx", rect8_rx_value = 0.5);
			attr(rect8, "ry", rect8_ry_value = 0.5);
			attr(rect8, "width", rect8_width_value = 2);
			attr(rect8, "x", rect8_x_value = 2);
			attr(rect8, "y", rect8_y_value = 24);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, rect6);
			append(svg, rect7);
			append(svg, rect8);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cz($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextRomanUppercase" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextRomanUppercase extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cz, create_fragment$cz, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextSize.svelte generated by Svelte v3.24.1 */

function create_fragment$cA(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M13.5 18a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V20H8v10h1.5a.5.5 0 0 1 .5.5v1a.5.5 0 0\n    1-.5.5h-5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H6V20H2v1.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5z");
			attr(path1, "d", "M9 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v20h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1\n    1 0 0 0-1-1h-3V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cA($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextSize" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextSize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cA, create_fragment$cA, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextSizeAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$cB(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M13.5 18a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V20H8v10h1.5a.5.5 0 0 1 .5.5v1a.5.5 0 0\n    1-.5.5h-5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H6V20H2v1.473a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V18.5a.5.5 0 0 1\n    .5-.5zM20 18.522a10.973 10.973 0 0 1 4-2.095V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v6a1\n    1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm4.9 10.4h-3.4v3.4a.5.5 0 0\n    1-.5.5h-2a.5.5 0 0 1-.5-.5v-3.4h-3.4a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5h3.4v-3.4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1\n    .5.5v3.4h3.4a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cB($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextSizeAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextSizeAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cB, create_fragment$cB, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextSpaceAfter.svelte generated by Svelte v3.24.1 */

function create_fragment$cC(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 20);
			attr(rect0, "x", rect0_x_value = 14);
			attr(rect0, "y", rect0_y_value = 8);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 20);
			attr(rect1, "x", rect1_x_value = 14);
			attr(rect1, "y", rect1_y_value = 14);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 20);
			attr(rect2, "x", rect2_x_value = 14);
			attr(rect2, "y", rect2_y_value = 2);
			attr(path, "d", "M4 33.328a.5.5 0 0 0 .866.341L10 28l-5.134-5.669a.5.5 0 0 0-.866.341zM34 33V23a1 1 0 0 0-1-1H15a1 1 0 0 0-1\n    1v10a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1zm-2-1H16v-8h16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cC($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextSpaceAfter" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextSpaceAfter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cC, create_fragment$cC, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextSpaceBefore.svelte generated by Svelte v3.24.1 */

function create_fragment$cD(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 12);
			attr(rect0, "y", rect0_y_value = 24);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 12);
			attr(rect1, "y", rect1_y_value = 18);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 12);
			attr(rect2, "y", rect2_y_value = 30);
			attr(path, "d", "M2 2.672a.5.5 0 0 1 .866-.341L8 8l-5.134 5.669A.5.5 0 0 1 2 13.328zM33 2H13a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h20a1 1\n    0 0 0 1-1V3a1 1 0 0 0-1-1zm-1 10H14V4h18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cD($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextSpaceBefore" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextSpaceBefore extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cD, create_fragment$cD, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextStrikethrough.svelte generated by Svelte v3.24.1 */

function create_fragment$cE(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M23 28h-3v-6h-4v6h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zM31 4H5a1 1 0 0 0-1 1v6a1 1\n    0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v8h4V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 28);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 18);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cE($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextStrikethrough" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextStrikethrough extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cE, create_fragment$cE, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextStroke.svelte generated by Svelte v3.24.1 */

function create_fragment$cF(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M25 32H11a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h3V10h-4v3a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h26a1 1 0 0 1 1\n    1v7.973a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1V10h-4v16h3a1 1 0 0 1 1 1v4a1 1 0 0 1-1\n    1zm-13-4v2h12v-2h-4V8h8v4h2V5.96H6V12h2V8h8v20zM6 5v1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cF($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextStroke" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextStroke extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cF, create_fragment$cF, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextStyle.svelte generated by Svelte v3.24.1 */

function create_fragment$cG(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M7.976 23.3c.584 3.042 2.97 8.479 8.486 8.479 3.818 0 5.728-2.442 5.728-5.069\n    0-2.165-1.485-4.055-4.19-5.9l-1.591-1.01c-3.341-2.258-6.311-4.838-6.311-8.663 0-5.438 5.038-8.8 11.561-8.8a19.74\n    19.74 0 0 1 5.993.922c.955.276 1.644.553 2.174.737a63.223 63.223 0 0 0-.318\n    7.051l-1.856.138c-.477-2.9-1.75-7-6.417-7a4.806 4.806 0 0 0-5.091 4.747c0 2.258 1.485 3.733 4.3 5.484l1.591.967c3.66\n    2.3 6.683 4.839 6.683 8.986 0 5.807-5.728 9.309-12.834 9.309-4.4 0-8.115-1.567-9.653-2.857.053-1.06.053-3.641\n    0-7.327z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cG($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextStyle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextStyle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cG, create_fragment$cG, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextSubscript.svelte generated by Svelte v3.24.1 */

function create_fragment$cH(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M5 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h6v20h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1\n    1 0 0 0-1-1h-3V8h6v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM31.742 34c-.121 0-.16-.039-.16-.141v-8.054a8.128\n    8.128 0 0 1-2.1.72c-.119.02-.158 0-.158-.121v-1.7c0-.1.02-.141.119-.16a9.969 9.969 0 0 0 2.78-1.2.505.505 0 0 1\n    .3-.08H33.9c.08 0 .1.039.1.138v10.457c0 .1-.039.141-.119.141z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cH($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextSubscript" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextSubscript extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cH, create_fragment$cH, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextSuperscript.svelte generated by Svelte v3.24.1 */

function create_fragment$cI(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M3 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h6v20H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1 1\n    0 0 0-1-1h-3V8h6v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM31.742 12c-.121 0-.16-.039-.16-.141V3.805a8.128\n    8.128 0 0 1-2.1.72c-.119.02-.158 0-.158-.121v-1.7c0-.1.02-.141.119-.16a9.969 9.969 0 0 0 2.78-1.2.505.505 0 0 1\n    .3-.08H33.9c.08 0 .1.039.1.138v10.457c0 .1-.039.141-.119.141z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cI($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextSuperscript" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextSuperscript extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cI, create_fragment$cI, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextTracking.svelte generated by Svelte v3.24.1 */

function create_fragment$cJ(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M26.366 6.7c-.432 1.809-1.8 5.807-2.609 8.264h5.3c-.567-1.783-2.123-6.373-2.664-8.264z");
			attr(path1, "d", "M35.5 2H.5a.5.5 0 0 0-.5.5v21a.5.5 0 0 0 .5.5h35a.5.5 0 0 0 .5-.5v-21a.5.5 0 0 0-.5-.5zM12.073 21.555a.235.235 0\n    0 1-.269.189H8.67a.239.239 0 0 1-.269-.161L2.054 4.243C2 4.108 2.054 4 2.215 4h3.107a.187.187 0 0 1 .215.162C8.1\n    11.266 9.858 16.505 10.345 18.5h.055c.6-2.106 1.945-6.7 4.51-14.287.054-.162.109-.216.243-.216H18.1c.134 0\n    .215.081.161.243zm22.423.189h-3.025a.273.273 0 0 1-.271-.161l-1.333-3.839h-6.913l-1.261 3.784a.267.267 0 0\n    1-.3.216H18.7c-.163 0-.217-.081-.189-.27L24.07 5.648a4.111 4.111 0 0 0\n    .243-1.459c0-.108.055-.189.162-.189h3.754c.135 0 .163.027.189.162L34.657 21.5c.028.163 0 .244-.157.244zM32.723\n    30.15l-3.954-3.963a.432.432 0 0 0-.725.262v2.566H7.956v-2.566a.432.432 0 0 0-.725-.262L3.277 30.15a.5.5 0 0 0 0\n    .706l3.955 3.972a.432.432 0 0 0 .725-.263V32h20.087v2.565a.432.432 0 0 0 .725.263l3.955-3.972a.5.5 0 0 0-.001-.706z");
			attr(path2, "d", "M32.834 30.128l-4-4A.49.49 0 0 0 28.5 26a.5.5 0 0 0-.5.5V29H8v-2.5a.5.5 0 0 0-.5-.5.49.49 0 0 0-.331.129l-4\n    4a.5.5 0 0 0 0 .744l4 4A.49.49 0 0 0 7.5 35a.5.5 0 0 0 .5-.5V32h20v2.5a.5.5 0 0 0 .5.5.49.49 0 0 0\n    .331-.129l4-4a.5.5 0 0 0 0-.744z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cJ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextTracking" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextTracking extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cJ, create_fragment$cJ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TextUnderline.svelte generated by Svelte v3.24.1 */

function create_fragment$cK(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 28);
			attr(rect, "x", rect_x_value = 4);
			attr(rect, "y", rect_y_value = 32);
			attr(path, "d", "M5 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h8v18h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1\n    1 0 0 0-1-1h-3V8h8v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cK($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TextUnderline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TextUnderline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cK, create_fragment$cK, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ThumbDown.svelte generated by Svelte v3.24.1 */

function create_fragment$cL(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 18);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 6);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 6);
			attr(path, "d", "M31.077 21.89H21.11a63.859 63.859 0 0 1 .89 9.19c0 1.661-1.032 2.92-2 2.92a1.839 1.839 0 0 1-2-2 11.326 11.326 0\n    0 0-2.516-6.258A46.35 46.35 0 0 0 10 20.958V6s2.809.033 14 0a3.946 3.946 0 0 1 3.677 2.424l5.128 10.788a1.862 1.862\n    0 0 1-1.728 2.678z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cL($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ThumbDown" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ThumbDown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cL, create_fragment$cL, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ThumbDownOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$cM(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M25.458 6zM32.554 19.7L28.57 8.424A4.636 4.636 0 0 0 24.444 6H10a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v16a1 1 0 0 0 1\n    1h6a1 1 0 0 0 1-1v-.476c2.545 1.174 7.177 4.83 7.64 9.312A3.327 3.327 0 0 0 20.921 34c1.626 0 3.1-1.814\n    3.173-3.937a21.477 21.477 0 0 0-.8-6.081l6.55.01a3 3 0 0 0 2.71-4.292zM29.847 22h-9.5a15.051 15.051 0 0 1 1.746\n    8.063c-.052 1.2-.563 1.932-1.173 1.937a1.374 1.374 0 0\n    1-1.281-1.2c-.49-5.873-6.773-10.245-9.64-11.4V8l14.991-.02a1.842 1.842 0 0 1 1.742 1.232l4.017 11.356A1 1 0 0 1\n    29.847 22z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cM($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ThumbDownOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ThumbDownOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cM, create_fragment$cM, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ThumbUp.svelte generated by Svelte v3.24.1 */

function create_fragment$cN(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 18);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 6);
			attr(rect, "x", rect_x_value = 2);
			attr(rect, "y", rect_y_value = 14);
			attr(path, "d", "M30.967 14H21a54.94 54.94 0 0 0 1-9.08C22 3.259 20.968 2 20 2a1.839 1.839 0 0 0-2 2 11.326 11.326 0 0 1-2.516\n    6.258A46.35 46.35 0 0 1 10 15.042V30s2.809-.033 14 0a3.946 3.946 0 0 0 3.677-2.424l5.128-10.788A2 2 0 0 0 30.967 14z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cN($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ThumbUp" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ThumbUp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cN, create_fragment$cN, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ThumbUpOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$cO(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M29.844 12.008l-6.55.01a21.474 21.474 0 0 0 .8-6.08C24.023 3.814 22.547 2 20.921 2a3.327 3.327 0 0 0-3.281\n    3.164c-.471 4.555-5.253 8.263-7.768 9.373A.99.99 0 0 0 9 14H3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h6a1 1 0 0 0\n    1-1v-1h14.444a4.636 4.636 0 0 0 4.126-2.423L32.554 16.3a3 3 0 0 0-2.71-4.292zm.9 3.424l-4.012 11.356a1.842 1.842 0 0\n    1-1.742 1.232L10 28V16.6c2.867-1.153 9.15-5.525 9.64-11.4A1.374 1.374 0 0 1 20.921 4c.61 0 1.121.742 1.173\n    1.938A15.049 15.049 0 0 1 20.348 14h9.5a1 1 0 0 1 .901 1.432zM25.458 30z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cO($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ThumbUpOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ThumbUpOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cO, create_fragment$cO, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Tips.svelte generated by Svelte v3.24.1 */

function create_fragment$cP(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M28.8 10.613A10.572 10.572 0 0 0 17.986.3a11.349 11.349 0 0 0-2.169.21A11.033 11.033 0 0 0 7.2 10.69C7.2 16.148\n    12 19.044 12 24v2h12v-2c0-5 4.8-8.048 4.8-13.387zM12 28v2.367a1.5 1.5 0 0 0 .359.973l3.524 4.133a1.5 1.5 0 0 0\n    1.142.527h1.951a1.5 1.5 0 0 0 1.141-.527l3.525-4.133a1.5 1.5 0 0 0 .358-.973V28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cP($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Tips" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Tips extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cP, create_fragment$cP, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Train.svelte generated by Svelte v3.24.1 */

function create_fragment$cQ(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30 0H6a4 4 0 0 0-4 4v20a4 4 0 0 0 4 4h3.976L6.51 36h2.647l.867-2h15.952l.867 2h2.647l-3.466-8H30a4 4 0 0 0\n    4-4V4a4 4 0 0 0-4-4zM8 25a3 3 0 1 1 3-3 3 3 0 0 1-3 3zm2.89 7l1.734-4h10.752l1.734 4zM7 16a1 1 0 0 1-1-1V4h24v11a1 1\n    0 0 1-1 1zm21 9a3 3 0 1 1 3-3 3 3 0 0 1-3 3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cQ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Train" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Train extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cQ, create_fragment$cQ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TransferToPlatform.svelte generated by Svelte v3.24.1 */

function create_fragment$cR(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.117 15.924A5.006 5.006 0 0 0 11.9 12h.708l2.277 3.984 1.267-2.218-1.692-2.962A1.596 1.596 0 0 0 13.074\n    10H11.9a5.003 5.003 0 1 0-5.783 5.924zm23.766 4.152A5.006 5.006 0 0 0 24.1 24H22l-2.276-3.984-1.268 2.218L20\n    24.936l.16.28a1.556 1.556 0 0 0 1.35.784h2.59a5.003 5.003 0 1 0 5.783-5.924zM29 28a3 3 0 1 1 3-3 3 3 0 0 1-3\n    3zm-7-16h2.1a5 5 0 1 0 0-2h-2.59a1.556 1.556 0 0 0-1.35.784L12.608 24H11.9a5 5 0 1 0 0 2h1.174a1.596 1.596 0 0 0\n    1.386-.804zm7-4a3 3 0 1 1-3 3 3 3 0 0 1 3-3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cR($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TransferToPlatform" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TransferToPlatform extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cR, create_fragment$cR, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Transparency.svelte generated by Svelte v3.24.1 */

function create_fragment$cS(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 12h6v6h-6zM18 18h6v6h-6z");
			attr(path1, "d", "M31 4H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-1\n    8h-6v6h6v6h-6v6h-6v-6h-6v6H6v-6h6v-6H6v-6h6V6h6v5.98h6V6h6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cS($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Transparency" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Transparency extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cS, create_fragment$cS, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Trap.svelte generated by Svelte v3.24.1 */

function create_fragment$cT(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34.191 6.809a4.358 4.358 0 0 0-1.147-.727c-2.018-.85-10.257-4.282-14.618-4.829-4.122-.515-7.858 0-9.791\n    1.932S7.99 10.4 9.794 14.136a75.205 75.205 0 0 0 4.041 6.989L2.662 32.3a2.065 2.065 0 0 0 .105 2.934 2.066 2.066 0 0\n    0 2.935.106l10.129-10.131a3.7 3.7 0 0 0 2.69.982 8.968 8.968 0 0 0 3.359-.768 26.846 26.846 0 0 0 7.391-5.211 26.708\n    26.708 0 0 0 5.152-7.332c1.1-2.667 1.016-4.823-.232-6.071zm-1.615 5.311a21.774 21.774 0 0 1-4.748 6.709 21.774\n    21.774 0 0 1-6.709 4.748c-1.813.75-3.272.824-3.9.2s-.547-2.078.2-3.9a21.774 21.774 0 0 1 4.748-6.709 21.774 21.774 0\n    0 1 6.709-4.748 7.133 7.133 0 0 1 2.6-.619 1.8 1.8 0 0 1 1.3.418c.624.625.548 2.081-.2 3.9z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cT($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Trap" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Trap extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cT, create_fragment$cT, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TreeCollapse.svelte generated by Svelte v3.24.1 */

function create_fragment$cU(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4 5v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1zm6.5 15a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1\n    .5-.5h15a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cU($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TreeCollapse" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TreeCollapse extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cU, create_fragment$cU, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TreeCollapseAll.svelte generated by Svelte v3.24.1 */

function create_fragment$cV(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9 8h17V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5V9a1 1 0 0 1 1-1z");
			attr(path1, "d", "M10 11v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1zm4.5 13a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1\n    .5-.5h15a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cV($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TreeCollapseAll" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TreeCollapseAll extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cV, create_fragment$cV, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TreeExpand.svelte generated by Svelte v3.24.1 */

function create_fragment$cW(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4 5v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1zm21.5 15H20v5.5a.5.5 0 0 1-.5.5h-3a.5.5 0\n    0 1-.5-.5V20h-5.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5H16v-5.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5V16h5.5a.5.5 0 0 1\n    .5.5v3a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cW($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TreeExpand" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TreeExpand extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cW, create_fragment$cW, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TreeExpandAll.svelte generated by Svelte v3.24.1 */

function create_fragment$cX(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9 8h17V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h5V9a1 1 0 0 1 1-1z");
			attr(path1, "d", "M10 11v22a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V11a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1zm19.5 13H24v5.5a.5.5 0 0\n    1-.5.5h-3a.5.5 0 0 1-.5-.5V24h-5.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5H20v-5.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1\n    .5.5V20h5.5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cX($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TreeExpandAll" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TreeExpandAll extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cX, create_fragment$cX, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TrendInspect.svelte generated by Svelte v3.24.1 */

function create_fragment$cY(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M8.9 26.619l-1.6 1.79-3.687-7.227-3.545 2.659 1.405 2.384L2.659 25.2l4.5 8.25 3.955-5.28A14.015 14.015 0 0 1 8.9\n    26.619zM23.07 19.332L26 15.954a7.932 7.932 0 0 0-.673-3.155L23.4\n    15.077l-3.312-4.759c-.066-.025-.137-.042-.2-.064l-7.632 11.291a7.987 7.987 0 0 0 2.189 1.584l5.548-8.222zM31.015\n    10.875l4.849-5.443L33.88 3.6l-4.2 4.707a13.9 13.9 0 0 1 1.335 2.568z");
			attr(path1, "d", "M35.338 30.3l-7.474-7.474a12.013 12.013 0 1 0-3.04 3.04l7.476 7.472a2.155 2.155 0 0 0 3.04-3.04zM8 16a10 10 0 1 1\n    10 10A10 10 0 0 1 8 16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cY($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TrendInspect" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TrendInspect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cY, create_fragment$cY, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/TrimPath.svelte generated by Svelte v3.24.1 */

function create_fragment$cZ(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 20);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 20);
			attr(rect, "x", rect_x_value = 12);
			attr(rect, "y", rect_y_value = 12);
			attr(path, "d", "M10 10h14V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v18a1 1 0 0 0 1 1h5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$cZ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "TrimPath" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class TrimPath extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$cZ, create_fragment$cZ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Trophy.svelte generated by Svelte v3.24.1 */

function create_fragment$c_(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24.213 18.021a15.517 15.517 0 0 0 11.35-12.876A1 1 0 0 0 34.571 4h-6.706c.089-1.3.135-2.634.135-4H8c0 1.366.046\n    2.7.135 4H1.429a.993.993 0 0 0-.991 1.145 15.514 15.514 0 0 0 11.349 12.876A9.169 9.169 0 0 0 16\n    22v8c-3.144.82-5.866 2.849-6.682 6h17.364c-.816-3.151-3.538-5.18-6.682-6v-8a9.169 9.169 0 0 0 4.213-3.979zM33.4\n    6c-.839 2.9-2.582 7.347-7.945 9.526A35.182 35.182 0 0 0 27.688 6zM2.6 6h5.712a35.175 35.175 0 0 0 2.234 9.525C5.182\n    13.346 3.439 8.9 2.6 6z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c_($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Trophy" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Trophy extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c_, create_fragment$c_, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Type.svelte generated by Svelte v3.24.1 */

function create_fragment$c$(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M23.715 4.909h3.571A.721.721 0 0 0 28 4.182V2.727A.721.721 0 0 0 27.286 2h-3.817a2.831 2.831 0 0 0-2.02.852L18\n    6.364l-3.449-3.512A2.831 2.831 0 0 0 12.531 2H8.714A.721.721 0 0 0 8 2.727v1.455a.721.721 0 0 0 .714.727h3.572l3.791\n    4.364V22h-4.506a.721.721 0 0 0-.714.727v1.455a.721.721 0 0 0 .714.727h4.505v1.818l-3.791 4.364H8.714a.721.721 0 0\n    0-.714.727v1.455a.721.721 0 0 0 .714.727h3.817a2.831 2.831 0 0 0 2.02-.852L18 29.636l3.449 3.512a2.831 2.831 0 0 0\n    2.02.852h3.817a.721.721 0 0 0 .714-.727v-1.455a.721.721 0 0 0-.714-.727h-3.571l-3.792-4.364v-1.818h4.506a.721.721 0\n    0 0 .714-.727v-1.455a.721.721 0 0 0-.714-.727h-4.506V9.273z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c$($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Type" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Type extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c$, create_fragment$c$, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/USA.svelte generated by Svelte v3.24.1 */

function create_fragment$d0(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10.759 24.537c.155-1.229 1.871.729 1.945.785.452.335.8 1.021 1.36 1.211.266.09.564-.538.672-.488.958.445 2.095\n    2.823 3.011 3.019.807.172 1.435-2.763 3.135-3.173.627-.151 3.181.647 3.413.326.022-.03-.806-.646-.287-.888.045-.022\n    1.356-.64.912-.64.916 0 5.156.96 4.309 1.845a4.063 4.063 0 0 0 1.576 1.959c-.181.09-.088.366-.042.54\n    1.954-1.213-1.335-3.991-1.165-5.525.067-.6 2.671-4.169\n    2.993-3.931-.21.007.135-.354.121-.7-.08-.137-2.064-3.053-1.01-3.053-.214.368.544 1.928.533 1.925a10.079 10.079 0 0 1\n    .216-1.584c.567 0\n    .113-1.339.193-1.469.2-.327.72-.77.959-1.134s1.285-.579.486-1.428c-.59-.626.009-.755.323-1.421.155-.329\n    1.044-.69.983-1.342.012.127-1.389-1.507-1.2-1.469-1.945-.38-.406.844-.989 1.584a14.382 14.382 0 0 1-2.6\n    2.38c-.172.133-3.813 4.18-3.966 3.293.013.076.507-2.484-.275-2.012l-.344.512c-.388 0\n    .454-1.161-.18-1.368-1.428-.467-.522.559-1.07.559-1.227-.2.584 2.08-.388 2.686-1.14.45-.285-2.827-.471-3.039a2.583\n    2.583 0 0 1-.575.838c-.818-1.235 2.082-1.371 2.257-1.614-.065-.057-.908-.62-.8-.572.043.02-1.887.33-2 .373a.723.723\n    0 0 0 .344-.64c-.721-.32-1.047 1.039-1.5.64a8.068 8.068 0 0 1-.948.344c0-.252 1.41-1.151 1.347-1.247a15.362 15.362 0\n    0 1-3.139-.8A31.491 31.491 0 0 1 4.063 8.332c-.321.288.445.8-.03 1.075a8.942 8.942 0 0 1-1-.847c-.276.074-1.059\n    4.985-1.146 5.363-.034.146-1.115 4.194.065 3.468a3.292 3.292 0 0 0 .035.545.809.809 0 0 0-.243-.237c-1.338.944 2.164\n    4.281 2.8 4.667.568.348 6.166 2.606 6.222 2.171.058-.515-.019.092-.007 0zm23.126-12.746z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d0($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "USA" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class USA extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d0, create_fragment$d0, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Underline.svelte generated by Svelte v3.24.1 */

function create_fragment$d1(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 2);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 22);
			attr(rect, "x", rect_x_value = 7);
			attr(rect, "y", rect_y_value = 30);
			attr(path, "d", "M22.5 4.012a.5.5 0 0 0-.5.5v13.5s.482 6.2-5 6.2c-5.459 0-5-6.2-5-6.2v-13.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0\n    0-.5.5v13.5c0 1.412-.141 10 9 10S26 19 26 17.988V4.512a.5.5 0 0 0-.5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Underline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Underline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d1, create_fragment$d1, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Undo.svelte generated by Svelte v3.24.1 */

function create_fragment$d2(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M30.663 12.542A10.391 10.391 0 0 0 23.671 10H11V4.8a.8.8 0 0 0-.8-.8.787.787 0 0 0-.527.2l-7.529 7.449a.5.5 0 0 0\n    0 .7L9.668 19.8a.787.787 0 0 0 .527.2.8.8 0 0 0 .8-.8V14h12.882a6.139 6.139 0 0 1 6.223 5.8A5.889 5.889 0 0 1 24\n    26h-7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6.526a10.335 10.335 0 0 0 10.426-9.013 9.947 9.947 0 0 0-3.289-8.445z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Undo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Undo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d2, create_fragment$d2, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Ungroup.svelte generated by Svelte v3.24.1 */

function create_fragment$d3(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(rect, "height", rect_height_value = 7);
			attr(rect, "rx", rect_rx_value = 1);
			attr(rect, "ry", rect_ry_value = 1);
			attr(rect, "width", rect_width_value = 7);
			attr(rect, "x", rect_x_value = 20.5);
			attr(rect, "y", rect_y_value = 20.5);
			attr(path0, "d", "M35.5 18a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0-.5.5V14H18v-1.5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0\n    0-.5.5v5a.5.5 0 0 0 .5.5H14v12h-1.5a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 .5-.5V34h12v1.5a.5.5 0 0 0\n    .5.5h5a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5H34V18zM32 30h-1.5a.5.5 0 0 0-.5.5V32H18v-1.5a.5.5 0 0\n    0-.5-.5H16V18h1.5a.5.5 0 0 0 .5-.5V16h12v1.5a.5.5 0 0 0 .5.5H32z");
			attr(path1, "d", "M10 11a1 1 0 0 1 1-1h4.5v-.5a1 1 0 0 0-1-1h-5a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h.5z");
			attr(path2, "d", "M10 20H6v-1.5a.5.5 0 0 0-.5-.5H4V6h1.5a.5.5 0 0 0 .5-.5V4h12v1.5a.5.5 0 0 0 .5.5H20v4h2V6h1.5a.5.5 0 0 0\n    .5-.5v-5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0-.5.5V2H6V.5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0-.5.5v5a.5.5 0 0 0\n    .5.5H2v12H.5a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 .5-.5V22h4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Ungroup" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Ungroup extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d3, create_fragment$d3, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Unlink.svelte generated by Svelte v3.24.1 */

function create_fragment$d4(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M11.136 9.523l-1.496 1.44-5.328-5.24 1.496-1.439 5.328 5.239zM31.801 30.277l-1.496 1.439-5.299-5.334 1.495-1.439\n    5.3 5.334zM11.057 1.8h2.314v4.629h-2.314zM1.8 11.057h4.629v2.314H1.8zM29.571 22.629H34.2v2.314h-4.629zM22.629\n    29.571h2.314V34.2h-2.314zM18.053 23.708l-5.84 5.878a4.1 4.1 0 1 1-5.8-5.8l5.858-5.859-2.171-2.173-5.861 5.858A7.176\n    7.176 0 0 0 14.388 31.76l5.841-5.874zM17.912 12.256l5.81-5.777a4.1 4.1 0 0 1 5.8 5.8l-5.793 5.793 2.171 2.174\n    5.8-5.793A7.176 7.176 0 1 0 21.547 4.3l-5.807 5.78z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Unlink" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Unlink extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d4, create_fragment$d4, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Unmerge.svelte generated by Svelte v3.24.1 */

function create_fragment$d5(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M27.2 20.206a.688.688 0 0 0-.49-.206.7.7 0 0 0-.7.7V24H20V10h6v3.3a.7.7 0 0 0 .7.7.688.688 0 0 0\n    .49-.206l5.69-6.469a.5.5 0 0 0 0-.65L27.2.206A.688.688 0 0 0 26.705 0a.7.7 0 0 0-.7.7V4H15a1 1 0 0 0-1 1v9H3a1 1 0 0\n    0-1 1v4a1 1 0 0 0 1 1h11v9a1 1 0 0 0 1 1h11v3.3a.7.7 0 0 0 .7.7.688.688 0 0 0 .49-.206l5.685-6.469a.5.5 0 0 0 0-.65z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Unmerge" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Unmerge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d5, create_fragment$d5, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UploadToCloud.svelte generated by Svelte v3.24.1 */

function create_fragment$d6(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 33a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-9h-4zM29.572 11.143a6.449 6.449 0 0 0-.726.041 8.144 8.144 0 1\n    0-15.922-3.236 6.862 6.862 0 0 0-8.407 8.394A3.857 3.857 0 1 0 3.857 24H16v-6h-4.3a.7.7 0 0 1-.7-.7.685.685 0 0 1\n    .207-.49l6.468-5.685a.5.5 0 0 1 .65 0l6.468 5.685a.685.685 0 0 1 .207.49.7.7 0 0 1-.7.7H20v6h9.572a6.429 6.429 0 0 0\n    0-12.857z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UploadToCloud" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UploadToCloud extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d6, create_fragment$d6, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UploadToCloudOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$d7(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M29.286 9.471a8.787 8.787 0 0 0-17.019-3.042 7.722 7.722 0 0 0-7.689 7.4 5.224 5.224 0 0 0-3.545 5.544A5.346\n    5.346 0 0 0 6.41 24h5.09a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H6.4a3.336 3.336 0 0 1-3.391-3.041 3.214 3.214 0 0 1\n    3.209-3.388h.359v-1.428a5.719 5.719 0 0 1 7.2-5.519 6.787 6.787 0 1 1 13.268 2.7 5.357 5.357 0 1 1 .6\n    10.68H24.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h2.9a7.517 7.517 0 0 0 7.547-6.484 7.368 7.368 0 0 0-5.661-8.049z");
			attr(path1, "d", "M13.5 18H16v15a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V18h2.5a.5.5 0 0 0 .5-.5.489.489 0 0 0-.117-.317l-4.519-5.023a.5.5 0\n    0 0-.728 0l-4.519 5.02a.489.489 0 0 0-.117.32.5.5 0 0 0 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UploadToCloudOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UploadToCloudOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d7, create_fragment$d7, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/User.svelte generated by Svelte v3.24.1 */

function create_fragment$d8(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.949 34a.993.993 0 0 0 1-1.053c-.661-7.184-8.027-9.631-10.278-9.827C22.026 22.977 22 21.652 22 20c0 0\n    3.532-3.943 3.532-8.958C25.532 5.617 22.445 2 18 2s-7.532 3.617-7.532 9.042C10.468 16.057 14 20 14 20c0 1.652-.026\n    2.977-1.674 3.12-2.251.2-9.617 2.643-10.278 9.827a.993.993 0 0 0 1 1.053z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "User" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class User extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d8, create_fragment$d8, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserActivity.svelte generated by Svelte v3.24.1 */

function create_fragment$d9(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2h.086a1 1 0 0 1 .707.293l8.914 8.914a1 1 0 0 1 .293.707V12H20z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm6.986\n    18h-15.96c-.01-.121-.026-.6-.026-.727 0-1.105.7-3.908 5.173-4.265a.723.723 0 0 0 .668-.707v-1.016a.673.673 0 0\n    0-.2-.455 6.345 6.345 0 0 1-1.841-3.58 4.359 4.359 0 0 1 4.185-4.45 4.347 4.347 0 0 1 4.215 4.45 6.358 6.358 0 0\n    1-1.853 3.58.678.678 0 0 0-.2.455v1.021a.726.726 0 0 0 .666.706c4.393.409 5.183 3.2 5.183\n    4.261.004.127-.01.727-.01.727z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserActivity" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserActivity extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d9, create_fragment$d9, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$da(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16 27a11.013 11.013 0 0 1 5.761-9.67 13.413 13.413 0 0 0 1.727-6.288C23.488 5.617 20.4 2 15.956 2s-7.532\n    3.617-7.532 9.042c0 5.015 3.532 8.958 3.532 8.958 0 1.652-.026 2.977-1.673 3.12C8.031 23.316.666 25.763 0\n    32.947A.993.993 0 0 0 1 34h17.522A10.944 10.944 0 0 1 16 27z");
			attr(path1, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm4.9 10.5h-3.4v3.4a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-3.4h-3.4a.5.5 0 0\n    1-.5-.5v-2a.5.5 0 0 1 .5-.5h3.4v-3.4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v3.4h3.4a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$da($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$da, create_fragment$da, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserAdmin.svelte generated by Svelte v3.24.1 */

function create_fragment$db(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M13.62 25.92a12.287 12.287 0 0 1 5.427-10.2 1.48 1.48 0 0 1 .331-.753 10.775 10.775 0 0 0 1.962-3.679 9.906 9.906\n    0 0 0 .577-3.146 10.792 10.792 0 0 0-.517-3.428A6.358 6.358 0 0 0 14.961 0a6.8 6.8 0 0 0-4.05 1.229 6.032 6.032 0 0\n    0-1.3 1.33A9.021 9.021 0 0 0 7.963 8.1a9.453 9.453 0 0 0 .276 2.133 10.975 10.975 0 0 0 2.261 4.774 1.443 1.443 0 0\n    1 .367.93c.031.837.083 1.466.083 2.032a1.431 1.431 0 0 1-1.25 1.444c-8.366.728-9.673 6.45-9.673 8.707 0 .251.048\n    1.526.048 1.526H14.2a12.284 12.284 0 0 1-.58-3.726z");
			attr(path1, "d", "M35.23 24.541h-2.415a6.98 6.98 0 0 0-1.02-2.476l1.72-1.72a.69.69 0 0 0 0-.975l-1.045-1.045a.69.69 0 0 0-.975\n    0l-1.72 1.72a6.983 6.983 0 0 0-2.475-1.02V16.61a.69.69 0 0 0-.69-.69h-1.38a.69.69 0 0 0-.69.69v2.415a6.983 6.983 0 0\n    0-2.475 1.02l-1.72-1.72a.69.69 0 0 0-.975 0l-1.045 1.045a.69.69 0 0 0 0 .975l1.72 1.72a6.98 6.98 0 0 0-1.02\n    2.476H16.61a.69.69 0 0 0-.69.69v1.379a.69.69 0 0 0 .69.69h2.415a6.98 6.98 0 0 0 1.02 2.476l-1.72 1.72a.689.689 0 0 0\n    0 .975l1.045 1.045a.69.69 0 0 0 .975 0l1.72-1.72a6.983 6.983 0 0 0 2.475 1.02v2.414a.69.69 0 0 0 .69.69h1.38a.69.69\n    0 0 0 .69-.69v-2.415a6.983 6.983 0 0 0 2.475-1.02l1.72 1.72a.69.69 0 0 0 .975 0l1.045-1.045a.689.689 0 0 0\n    0-.975l-1.72-1.72a6.98 6.98 0 0 0 1.02-2.476h2.415a.69.69 0 0 0 .69-.69V25.23a.69.69 0 0 0-.69-.689zm-9.31 4.975a3.6\n    3.6 0 1 1 3.6-3.6 3.6 3.6 0 0 1-3.6 3.599z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$db($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserAdmin" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserAdmin extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$db, create_fragment$db, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserArrow.svelte generated by Svelte v3.24.1 */

function create_fragment$dc(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10.874 19.622a.5.5 0 0 0-.874.332V24H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h7v3.818a.5.5 0 0 0 .874.332L18 27zM26.255\n    19.775a1.438 1.438 0 0 1-1.244-1.443v-2.083a1.441 1.441 0 0 1 .367-.93 11 11 0 0 0\n    2.5-6.866c0-5.2-2.756-8.1-6.919-8.1s-7 3.018-7 8.1a11.124 11.124 0 0 0 2.645 6.893 1.388 1.388 0 0 1\n    .344.9v2.126a1.4 1.4 0 0 1-1.368 1.394L22.569 27l-2.99 3h16.357l.011-1.526c0-2.163-1.478-7.865-9.692-8.699z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dc($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserArrow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserArrow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dc, create_fragment$dc, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserCheckedOut.svelte generated by Svelte v3.24.1 */

function create_fragment$dd(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M15.5 27a11.474 11.474 0 0 1 4.776-9.316 15.017 15.017 0 0 0 3.307-8.642C23.583 3.616 20.495 0 16.05 0S8.519\n    3.616 8.519 9.042A15.034 15.034 0 0 0 12.05 18c0 1.652-.026 2.976-1.674 3.12-2.252.2-9.617 2.644-10.278 9.826a1 1 0\n    0 0 .944 1.053L1.1 32h15.557a11.432 11.432 0 0 1-1.156-5z");
			attr(path1, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm5 10.814a.5.5 0 0 1-.854.354L29.05 27.07l-4.636 4.636a.5.5 0 0 1-.707\n    0l-1.414-1.414a.5.5 0 0 1 0-.707l4.636-4.636-2.097-2.096a.5.5 0 0 1 .354-.854h6.527a.287.287 0 0 1 .287.287z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dd($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserCheckedOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserCheckedOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dd, create_fragment$dd, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserDeveloper.svelte generated by Svelte v3.24.1 */

function create_fragment$de(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12.518 29.409a2 2 0 0 1 0-2.828l6.1-6.1a2.606 2.606 0 0 1 1.525-.706 14.84 14.84 0 0 0 3.343-8.731C23.488 5.617\n    20.4 2 15.956 2s-7.532 3.617-7.532 9.042c0 5.015 3.532 8.958 3.532 8.958 0 1.652-.026 2.977-1.673 3.12-2.257.2-9.6\n    2.653-10.239 9.869A.948.948 0 0 0 1.008 34h16.1zM29.289 23.712L33.58 28l-4.286 4.286a.432.432 0 0 0 0\n    .608l.729.728a.429.429 0 0 0 .607 0l4.915-4.914a1 1 0 0 0 0-1.415l-4.92-4.919a.429.429 0 0 0-.607\n    0l-.729.728a.432.432 0 0 0 0 .61z");
			attr(path1, "d", "M21.748 32.288L17.458 28l4.286-4.286a.432.432 0 0 0 0-.608l-.729-.728a.429.429 0 0 0-.607 0l-4.915 4.912a1 1 0 0\n    0 0 1.415l4.919 4.919a.43.43 0 0 0 .608 0l.728-.728a.43.43 0 0 0 0-.608zM24.8 34.417l3.412-13.335a.474.474 0 0\n    0-.439-.6h-.942a.46.46 0 0 0-.44.354L22.98 34.169a.473.473 0 0 0 .439.6h.942a.459.459 0 0 0 .439-.352z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$de($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserDeveloper" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserDeveloper extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$de, create_fragment$de, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserEdit.svelte generated by Svelte v3.24.1 */

function create_fragment$df(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M35.631 21.88l-3.506-3.506a.739.739 0 0 0-.527-.215h-.023a.834.834 0 0 0-.564.247L20.189 29.229a.607.607 0 0\n    0-.153.256l-2.027 6c-.069.229.279.517.476.517a.313.313 0 0 0 .037 0c.168-.039 5.123-1.764 6-2.028a.6.6 0 0 0\n    .252-.151L35.6 22.994a.836.836 0 0 0 .246-.537.743.743 0 0 0-.215-.577zm-11.6 10.963c-1.314.395-3.3 1.229-4.431\n    1.568l1.56-4.431zM17.775 27.622a3.835 3.835 0 0 1 .891-1.4l5.765-5.764a13.934 13.934 0 0 0-4.255-1 1.431 1.431 0 0\n    1-1.248-1.444c0-.721.043-1.016.084-2.116a1.441 1.441 0 0 1 .366-.93 10.775 10.775 0 0 0 1.962-3.678 9.908 9.908 0 0\n    0 .577-3.146 10.792 10.792 0 0 0-.517-3.43A6.358 6.358 0 0 0 14.961 0a6.8 6.8 0 0 0-4.05 1.229 6.031 6.031 0 0 0-1.3\n    1.33A9.022 9.022 0 0 0 7.963 8.1a9.448 9.448 0 0 0 .276 2.133 10.971 10.971 0 0 0 2.261 4.774 1.444 1.444 0 0 1\n    .367.93c.031.837.083 1.466.083 2.032a1.431 1.431 0 0 1-1.25 1.444c-8.366.728-9.673 6.45-9.673 8.707 0 .251.048\n    1.526.048 1.526h16.889z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$df($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserEdit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserEdit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$df, create_fragment$df, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$dg(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M14.7 27a12.266 12.266 0 0 1 4.311-9.342v-1.409a1.441 1.441 0 0 1 .367-.93 11 11 0 0 0\n    2.5-6.866c0-5.2-2.756-8.1-6.919-8.1s-7 3.018-7 8.1a11.121 11.121 0 0 0 2.622 6.866 1.443 1.443 0 0 1\n    .367.93v2.074A1.431 1.431 0 0 1 9.7 19.767C1.338 20.5.031 26.217.031 28.474c0 .251.048 1.484.048 1.484h14.994A12.288\n    12.288 0 0 1 14.7 27zM27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20.2 27a6.749 6.749 0 0 1\n    1.289-3.957l9.468 9.468A6.78 6.78 0 0 1 20.2 27zm12.311 3.957l-9.468-9.468a6.78 6.78 0 0 1 9.468 9.468z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dg($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dg, create_fragment$dg, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$dh(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M26.922 20.476c-1.441-.125-1.464-1.284-1.464-2.729a13.151 13.151 0 0 0 3.09-7.837c0-4.746-2.7-7.91-6.589-7.91a6.3\n    6.3 0 0 0-2.679.574c3.206 1.69 5.24 5.28 5.24 9.9a15.6 15.6 0 0 1-2.42 7.949.861.861 0 0 0 .474 1.288A13.488 13.488\n    0 0 1 31.779 30h3.257a.871.871 0 0 0 .879-.922c-.579-6.289-7.023-8.43-8.993-8.602z");
			attr(path1, "d", "M28.973 34a.931.931 0 0 0 .941-.988c-.62-6.734-7.525-9.028-9.636-9.212-1.544-.134-1.569-1.377-1.569-2.925a14.093\n    14.093 0 0 0 3.311-8.4C22.02 7.391 19.126 4 14.959 4S7.9 7.391 7.9 12.477a14.093 14.093 0 0 0 3.311 8.4c0 1.548-.025\n    2.791-1.569 2.925-2.113.182-9.018 2.476-9.642 9.21A.931.931 0 0 0 .945 34z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dh($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserGroup" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserGroup extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dh, create_fragment$dh, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserLock.svelte generated by Svelte v3.24.1 */

function create_fragment$di(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14 25.013a2.737 2.737 0 0 1 1.833-2.86c0-3.219 2.049-4.882 3.108-5.964a10.942 10.942 0 0 0\n    2.939-7.736c0-5.2-2.756-8.1-6.919-8.1s-7 3.018-7 8.1a11.121 11.121 0 0 0 2.622 6.866 1.443 1.443 0 0 1\n    .367.93v2.074a1.431 1.431 0 0 1-1.25 1.444C1.338 20.5.031 26.217.031 28.474.031 28.725 0 30 0 30h14z");
			attr(path1, "d", "M32.987 24.013l-1 .038v-.718a7.205 7.205 0 0 0-6.567-7.323 6.94 6.94 0 0 0-7.313 6.93v1.111l-1.094-.039a1 1 0 0\n    0-1.012 1V35a1 1 0 0 0 1 1H33a1 1 0 0 0 1-1v-9.987a1 1 0 0 0-1.013-1zM20.882 22.94a4.164 4.164 0 1 1 8.328\n    0v1.111h-8.328zm5.552 8.482v1.928a.694.694 0 0 1-.694.694h-1.388a.694.694 0 0 1-.694-.694v-1.928a2.082 2.082 0 1 1\n    2.776 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$di($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserLock" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserLock extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$di, create_fragment$di, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UserShare.svelte generated by Svelte v3.24.1 */

function create_fragment$dj(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.807 17.242l.2-.227v-.766a1.441 1.441 0 0 1 .367-.93 11 11 0 0 0 2.5-6.866c0-5.2-2.756-8.1-6.919-8.1s-7\n    3.018-7 8.1a11.121 11.121 0 0 0 2.622 6.866 1.443 1.443 0 0 1 .367.93v2.074A1.431 1.431 0 0 1 9.7 19.767C1.338\n    20.5.031 26.217.031 28.474c0 .251.048 1.484.048 1.484H14V22a2 2 0 0 1 2-2h1.97s-.118-1.93.837-2.758zM31.722\n    18.331L26 12l-5.708 6.331A1 1 0 0 0 21.035 20H24v7.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V20h2.979a1 1 0 0 0\n    .743-1.669z");
			attr(path1, "d", "M32 22v10H20V22h-3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V23a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dj($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UserShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UserShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dj, create_fragment$dj, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UsersAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$dk(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27c0-5.649 2.959-7.639 4.646-9.639a11 11 0 0 0 2.5-6.866c0-5.2-2.756-8.1-6.919-8.1s-7 3.018-7 8.1a11.121\n    11.121 0 0 0 2.622 6.865 1.439 1.439 0 0 1 .367.93v2.074a1.431 1.431 0 0 1-1.248 1.444C1.307 22.537 0 28.259 0\n    30.516c0 .25.029 3.237.048 3.484h16.845a12.236 12.236 0 0 1-2.193-7zM23.287 15.273A12.282 12.282 0 0 1 27 14.7c.129\n    0 .255.015.383.019a12.724 12.724 0 0 0 1.011-4.771c0-4.354-2.569-7.552-6.451-7.552-.232 0-.444.042-.668.062a10.93\n    10.93 0 0 1 2.974 8.042 13.2 13.2 0 0 1-.962 4.773z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0 1-.5.5H28v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0\n    1-.5-.5V28h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5H26v-3.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V26h3.5a.5.5 0 0 1\n    .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dk($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UsersAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UsersAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dk, create_fragment$dk, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UsersExclude.svelte generated by Svelte v3.24.1 */

function create_fragment$dl(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.7 27c0-5.649 2.959-7.639 4.646-9.639a11 11 0 0 0 2.5-6.866c0-5.2-2.756-8.1-6.919-8.1s-7 3.018-7 8.1a11.121\n    11.121 0 0 0 2.622 6.865 1.439 1.439 0 0 1 .367.93v2.074a1.431 1.431 0 0 1-1.248 1.444C1.307 22.537 0 28.259 0\n    30.516c0 .25.029 3.237.048 3.484h16.845a12.236 12.236 0 0 1-2.193-7zM23.287 15.273A12.282 12.282 0 0 1 27 14.7c.129\n    0 .255.015.383.019a12.724 12.724 0 0 0 1.011-4.771c0-4.354-2.569-7.552-6.451-7.552-.232 0-.444.042-.668.062a10.93\n    10.93 0 0 1 2.974 8.042 13.2 13.2 0 0 1-.962 4.773z");
			attr(path1, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM20 27a6.934 6.934 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 20 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dl($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UsersExclude" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UsersExclude extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dl, create_fragment$dl, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UsersLock.svelte generated by Svelte v3.24.1 */

function create_fragment$dm(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M23.683 14.13a7.886 7.886 0 0 1 1.843-.118 9.64 9.64 0 0 1 1.98.368 12.619 12.619 0 0 0\n    .886-4.433c0-4.61-2.88-7.923-7.148-7.518a10.914 10.914 0 0 1 3 8.066 12.623 12.623 0 0 1-.561 3.635zM14 25.013a3.005\n    3.005 0 0 1 2.141-2.875 8.929 8.929 0 0 1 4.574-6.981 10.908 10.908 0 0 0 1.134-4.657c0-5.2-2.756-8.1-6.919-8.1s-7\n    3.018-7 8.1a11.121 11.121 0 0 0 2.622 6.865 1.439 1.439 0 0 1 .367.93v2.074a1.431 1.431 0 0 1-1.248 1.444C1.307\n    22.537 0 28.259 0 30.516c0 .25.029 3.237.048 3.484H14z");
			attr(path1, "d", "M33 24h-.955v-1.008a7 7 0 0 0-14 0V24H17a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V25a1 1 0 0 0-1-1zm-6.566\n    7.422v1.928a.694.694 0 0 1-.694.694h-1.388a.694.694 0 0 1-.694-.694v-1.928a2.082 2.082 0 1 1 2.776 0zM29.545\n    24h-9v-1.008a4.5 4.5 0 0 1 9 0z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dm($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UsersLock" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UsersLock extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dm, create_fragment$dm, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/UsersShare.svelte generated by Svelte v3.24.1 */

function create_fragment$dn(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20.585 21.839c-.184-.025-.138-.044-.33-.064a1.437 1.437 0 0 1-1.244-1.443v-2.083a1.443 1.443 0 0 1 .367-.93 11\n    11 0 0 0 2.5-6.866c0-5.2-2.755-8.1-6.919-8.1s-7 3.018-7 8.1a11.12 11.12 0 0 0 2.622 6.865 1.443 1.443 0 0 1\n    .367.93v2.074A1.431 1.431 0 0 1 9.7 21.767c-8.366.728-9.673 6.45-9.673 8.707 0 .251.029 3.237.048\n    3.484h12.953a13.334 13.334 0 0 1 7.557-12.119z");
			attr(path1, "d", "M21.411 18.625v.875a16.132 16.132 0 0 1 3.407.887c.4-.081.805-.166 1.235-.216v-1.293a2.552 2.552 0 0 1\n    .161-.794v-.909a1.533 1.533 0 0 1 .342-.867 12.147 12.147 0 0 0 1.869-6.4c0-4.354-2.57-7.552-6.452-7.552-.232\n    0-.445.042-.668.062a10.93 10.93 0 0 1 2.975 8.037 13.46 13.46 0 0 1-2.869 8.17z");
			attr(path2, "d", "M28.053 22.059v-3.181a.636.636 0 0 1 1.086-.45L36 25.877l-6.86 7.449a.636.636 0 0 1-1.086-.45v-3.229a11.687\n    11.687 0 0 0-11.916 4.632.45.45 0 0 1-.811-.26c-.001-1.919 2.191-11.96 12.726-11.96z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dn($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "UsersShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class UsersShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dn, create_fragment$dn, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Variable.svelte generated by Svelte v3.24.1 */

function create_fragment$do(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10.909 10.692c-.093-.123-.06-.278.155-.278h3.691c.216 0 .278.033.371.215l2.922\n    5.325h.062l3.077-5.385c.093-.155.123-.155.278-.155h3.26c.186 0 .248.093.156.248-1.078 1.721-3.448 5.508-4.648\n    7.2a399.724 399.724 0 0 0 4.956 7.479c.123.123.06.246-.156.246H21.25a.446.446 0 0 1-.4-.246l-3.077-5.354h-.03L14.572\n    25.4c-.062.122-.125.185-.338.185h-3.295a.173.173 0 0 1-.153-.278c1.293-1.937 3.415-5.322 4.738-7.262zm-1.77\n    21.025a.991.991 0 0 0 .237-1.359A22.447 22.447 0 0 1 5.577 18a22.445 22.445 0 0 1 3.8-12.358.991.991 0 0\n    0-.238-1.359l-1.223-.872a1.015 1.015 0 0 0-1.428.253A25.936 25.936 0 0 0 2.077 18a25.942 25.942 0 0 0 4.411 14.337\n    1.014 1.014 0 0 0 1.428.253zm18.945.873a1.014 1.014 0 0 0 1.428-.253A25.942 25.942 0 0 0 33.923 18a25.936 25.936 0 0\n    0-4.411-14.336 1.015 1.015 0 0 0-1.428-.253l-1.222.872a.991.991 0 0 0-.238 1.359A22.445 22.445 0 0 1 30.423\n    18a22.447 22.447 0 0 1-3.8 12.358.991.991 0 0 0 .237 1.359z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$do($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Variable" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Variable extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$do, create_fragment$do, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VectorDraw.svelte generated by Svelte v3.24.1 */

function create_fragment$dp(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33.134 11.26l-8.416-8.414a1.068 1.068 0 0 0-1.51 0l-3.717 3.716a1.052 1.052 0 0 0-.147 1.289l8.42\n    8.42.008-.017.186.183a1.066 1.066 0 0 0 1.509 0l3.667-3.666a1.066 1.066 0 0 0 0-1.511zM17.462 9.383l-7.877 3.628a2 2\n    0 0 0-1.011 1.051L1.979 29.973a1 1 0 0 0 .216 1.09l.523.523 8.156-8.157a1.619 1.619 0 0 1-.037-.254 2 2 0 1 1 2 2\n    1.684 1.684 0 0 1-.276-.04l-8.147 8.148.592.592a1 1 0 0 0 1.09.217l15.913-6.6a2 2 0 0 0 1.05-1.011l3.628-7.876z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dp($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VectorDraw" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VectorDraw extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dp, create_fragment$dp, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VideoCheckedOut.svelte generated by Svelte v3.24.1 */

function create_fragment$dq(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M27 18a9 9 0 1 0 9 9 9 9 0 0 0-9-9zm5 10.814a.5.5 0 0 1-.854.354L29.05 27.07l-4.636 4.636a.5.5 0 0 1-.707\n    0l-1.414-1.414a.5.5 0 0 1 0-.707l4.636-4.636-2.097-2.096a.5.5 0 0 1 .354-.854h6.527a.287.287 0 0 1 .287.287z");
			attr(path1, "d", "M15.5 27a11.47 11.47 0 0 1 4.353-9H12.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h11c.023 0 .037.022.06.025A11.45\n    11.45 0 0 1 26 15.55v-2.344a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v2.703a11.389 11.389 0 0 1 2 .747V5a1 1 0 0 0-1-1H5a1\n    1 0 0 0-1 1v26a1 1 0 0 0 1 1h11.656a11.432 11.432 0 0 1-1.156-5zM26 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0\n    0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm-16 23a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1\n    .5.5zm0-6.706a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6.588a.5.5 0 0\n    1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM10 9.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5\n    0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dq($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VideoCheckedOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VideoCheckedOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dq, create_fragment$dq, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VideoFilled.svelte generated by Svelte v3.24.1 */

function create_fragment$dr(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M4 5v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1zm6 24.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6.706a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1\n    .5-.5h3a.5.5 0 0 1 .5.5zm0-6.588a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM10\n    9.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM23.5 18h-11a.5.5 0 0 1-.5-.5v-1a.5.5\n    0 0 1 .5-.5h11a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5zM30 29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1\n    .5-.5h3a.5.5 0 0 1 .5.5zm0-6.706a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1\n    .5.5zm0-6.588a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM30 9.5a.5.5 0 0\n    1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dr($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VideoFilled" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VideoFilled extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dr, create_fragment$dr, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VideoOutline.svelte generated by Svelte v3.24.1 */

function create_fragment$ds(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M31 4H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zM10 29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6.706a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1\n    .5-.5h3a.5.5 0 0 1 .5.5zm0-6.588a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM10\n    9.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM24 30H12V20h12zm0-14H12V6h12zm6\n    13.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6.706a.5.5 0 0 1-.5.5h-3a.5.5 0 0\n    1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zm0-6.588a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1\n    .5-.5h3a.5.5 0 0 1 .5.5zM30 9.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$ds($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VideoOutline" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VideoOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$ds, create_fragment$ds, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewAllTags.svelte generated by Svelte v3.24.1 */

function create_fragment$dt(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 4);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 10);
			attr(rect1, "y", rect1_y_value = 2);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 4);
			attr(rect2, "x", rect2_x_value = 2);
			attr(rect2, "y", rect2_y_value = 10);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 22);
			attr(rect3, "x", rect3_x_value = 10);
			attr(rect3, "y", rect3_y_value = 10);
			attr(rect4, "height", rect4_height_value = 4);
			attr(rect4, "rx", rect4_rx_value = 1);
			attr(rect4, "ry", rect4_ry_value = 1);
			attr(rect4, "width", rect4_width_value = 4);
			attr(rect4, "x", rect4_x_value = 2);
			attr(rect4, "y", rect4_y_value = 18);
			attr(rect5, "height", rect5_height_value = 4);
			attr(rect5, "rx", rect5_rx_value = 1);
			attr(rect5, "ry", rect5_ry_value = 1);
			attr(rect5, "width", rect5_width_value = 4);
			attr(rect5, "x", rect5_x_value = 2);
			attr(rect5, "y", rect5_y_value = 26);
			attr(path, "d", "M35.668 26.106l-9.88-9.879a.772.772 0 0 0-.546-.227h-8.47a.772.772 0 0 0-.772.772v8.471a.772.772 0 0 0\n    .226.546l9.879 9.88a.772.772 0 0 0 1.092 0l8.471-8.469a.772.772 0 0 0 0-1.094zM20.4 22.948a2.548 2.548 0 1 1\n    2.548-2.548 2.548 2.548 0 0 1-2.548 2.548zM14.294 27.2c-.332-.332-.223-.756-.353-1.2H11a1 1 0 0 0-1 1v2a1 1 0 0 0 1\n    1h6.091zM14 18h-3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h3z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dt($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewAllTags" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewAllTags extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dt, create_fragment$dt, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewBiWeek.svelte generated by Svelte v3.24.1 */

function create_fragment$du(ctx) {
	let svg;
	let path;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			attr(path, "d", "M35 6h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h32a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 26H4V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h4z");
			attr(rect0, "height", rect0_height_value = 4);
			attr(rect0, "rx", rect0_rx_value = 0.5);
			attr(rect0, "ry", rect0_ry_value = 0.5);
			attr(rect0, "width", rect0_width_value = 22);
			attr(rect0, "x", rect0_x_value = 8);
			attr(rect0, "y", rect0_y_value = 14);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 8);
			attr(rect1, "y", rect1_y_value = 22);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect0);
			append(svg, rect1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$du($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewBiWeek" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewBiWeek extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$du, create_fragment$du, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewCard.svelte generated by Svelte v3.24.1 */

function create_fragment$dv(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 33a1 1 0 0 0 1 1h7V18H2zM3 2a1 1 0 0 0-1 1v11h8V2zM26 34h7a1 1 0 0 0 1-1v-5h-8zM33 2h-7v6h8V3a1 1 0 0\n    0-1-1zM14 22h8v12h-8zM14 2h8v16h-8zM26 12h8v12h-8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dv($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewCard" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewCard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dv, create_fragment$dv, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewColumn.svelte generated by Svelte v3.24.1 */

function create_fragment$dw(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 34H3a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h7zM14 2h8v32h-8zM33 34h-7V2h7a1 1 0 0 1 1 1v30a1 1 0 0 1-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dw($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewColumn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewColumn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dw, create_fragment$dw, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewDay.svelte generated by Svelte v3.24.1 */

function create_fragment$dx(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M18.332 28c-.216 0-.288-.076-.288-.264v-8.95a13.766 13.766 0 0 1-3.709 1.325c-.216.037-.288\n    0-.288-.227v-3.2c0-.188.036-.263.216-.3a16.954 16.954 0 0 0 4.937-2.233.913.913 0 0 1 .54-.151h2.06c.143 0\n    .18.076.18.264v13.472c0 .188-.073.264-.216.264z");
			attr(path1, "d", "M35 6h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h32a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 26H4V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dx($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewDay" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewDay extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dx, create_fragment$dx, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewDetail.svelte generated by Svelte v3.24.1 */

function create_fragment$dy(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M35.191 32.143L30.646 27.6a9.066 9.066 0 1 0-3.046 3.046l4.545 4.545a2.044 2.044 0 0 0 3.048 0 2.195 2.195 0 0\n    0-.002-3.048zM17.412 22.98a5.568 5.568 0 1 1 5.568 5.567 5.568 5.568 0 0 1-5.568-5.567z");
			attr(path1, "d", "M12.878 28H6V6h22v6.878a11.323 11.323 0 0 1 4 3.309V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v28a1 1 0 0 0 1\n    1h13.188a11.324 11.324 0 0 1-3.31-4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dy($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewDetail" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewDetail extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dy, create_fragment$dy, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewGrid.svelte generated by Svelte v3.24.1 */

function create_fragment$dz(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 10H2V3a1 1 0 0 1 1-1h7zM14 2h8v8h-8zM34 10h-8V2h7a1 1 0 0 1 1 1zM2 14h8v8H2zM14 14h8v8h-8zM26 14h8v8h-8zM10\n    34H3a1 1 0 0 1-1-1v-7h8zM14 26h8v8h-8zM33 34h-7v-8h8v7a1 1 0 0 1-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dz($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewGrid" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewGrid extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dz, create_fragment$dz, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewList.svelte generated by Svelte v3.24.1 */

function create_fragment$dA(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let rect4;
	let rect4_height_value;
	let rect4_rx_value;
	let rect4_ry_value;
	let rect4_width_value;
	let rect4_x_value;
	let rect4_y_value;
	let rect5;
	let rect5_height_value;
	let rect5_rx_value;
	let rect5_ry_value;
	let rect5_width_value;
	let rect5_x_value;
	let rect5_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			rect4 = svg_element("rect");
			rect5 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 8);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 8);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 4);
			attr(rect1, "rx", rect1_rx_value = 0.5);
			attr(rect1, "ry", rect1_ry_value = 0.5);
			attr(rect1, "width", rect1_width_value = 22);
			attr(rect1, "x", rect1_x_value = 12);
			attr(rect1, "y", rect1_y_value = 4);
			attr(rect2, "height", rect2_height_value = 4);
			attr(rect2, "rx", rect2_rx_value = 0.5);
			attr(rect2, "ry", rect2_ry_value = 0.5);
			attr(rect2, "width", rect2_width_value = 22);
			attr(rect2, "x", rect2_x_value = 12);
			attr(rect2, "y", rect2_y_value = 16);
			attr(rect3, "height", rect3_height_value = 4);
			attr(rect3, "rx", rect3_rx_value = 0.5);
			attr(rect3, "ry", rect3_ry_value = 0.5);
			attr(rect3, "width", rect3_width_value = 22);
			attr(rect3, "x", rect3_x_value = 12);
			attr(rect3, "y", rect3_y_value = 28);
			attr(rect4, "height", rect4_height_value = 8);
			attr(rect4, "rx", rect4_rx_value = 1);
			attr(rect4, "ry", rect4_ry_value = 1);
			attr(rect4, "width", rect4_width_value = 8);
			attr(rect4, "x", rect4_x_value = 2);
			attr(rect4, "y", rect4_y_value = 14);
			attr(rect5, "height", rect5_height_value = 8);
			attr(rect5, "rx", rect5_rx_value = 1);
			attr(rect5, "ry", rect5_ry_value = 1);
			attr(rect5, "width", rect5_width_value = 8);
			attr(rect5, "x", rect5_x_value = 2);
			attr(rect5, "y", rect5_y_value = 26);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, rect4);
			append(svg, rect5);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dA($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewList" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewList extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dA, create_fragment$dA, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewRow.svelte generated by Svelte v3.24.1 */

function create_fragment$dB(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M34 10H2V3a1 1 0 0 1 1-1h30a1 1 0 0 1 1 1zM2 14h32v8H2zM33 34H3a1 1 0 0 1-1-1v-7h32v7a1 1 0 0 1-1 1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dB($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewRow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewRow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dB, create_fragment$dB, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewSingle.svelte generated by Svelte v3.24.1 */

function create_fragment$dC(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 2H3a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zm-3 28H6V6h24z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dC($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewSingle" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewSingle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dC, create_fragment$dC, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewStack.svelte generated by Svelte v3.24.1 */

function create_fragment$dD(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			attr(rect0, "height", rect0_height_value = 14);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 32);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 2);
			attr(rect1, "height", rect1_height_value = 14);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 32);
			attr(rect1, "x", rect1_x_value = 2);
			attr(rect1, "y", rect1_y_value = 20);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dD($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewStack" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewStack extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dD, create_fragment$dD, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewWeek.svelte generated by Svelte v3.24.1 */

function create_fragment$dE(ctx) {
	let svg;
	let path;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr(path, "d", "M35 6h-5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3H12V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v26a1 1 0 0 0 1\n    1h32a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zm-1 26H4V8h4v1a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V8h14v1a1 1 0 0 0 1 1h2a1 1 0 0 0\n    1-1V8h4z");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 22);
			attr(rect, "x", rect_x_value = 8);
			attr(rect, "y", rect_y_value = 14);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, rect);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dE($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewWeek" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewWeek extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dE, create_fragment$dE, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ViewedMarkAs.svelte generated by Svelte v3.24.1 */

function create_fragment$dF(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M22.794 15.554A5 5 0 0 0 23.063 14a4.691 4.691 0 0 0-.175-1.2 2.623 2.623 0 0 1-2.221 1.279A2.667 2.667 0 0 1 18\n    11.417a2.631 2.631 0 0 1 1.35-2.269 4.916 4.916 0 0 0-1.35-.21 5.052 5.052 0 0 0-.272 10.1 12.3 12.3 0 0 1\n    5.066-3.484z");
			attr(path1, "d", "M15.477 22.831A9.207 9.207 0 1 1 27.225 14c0 .276-.057.537-.081.807a12.227 12.227 0 0 1 5.894 1.583 4.365 4.365 0\n    0 0 .712-2.03c0-2.364-4.214-7.341-9.137-9.78A14.978 14.978 0 0 0 18 2.937c-8.664 0-15.75 8.625-15.75 11.424 0 2.626\n    5.729 8.868 12.683 10.372a12.177 12.177 0 0 1 .544-1.902z");
			attr(path2, "d", "M27 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm-2.338 14.312l-4.128-4.128a.5.5 0 0 1\n    0-.707l1.036-1.036a.5.5 0 0 1 .707 0l2.731 2.731 6.106-6.106a.5.5 0 0 1 .707 0l1.043 1.043a.5.5 0 0 1 0 .707l-7.5\n    7.5a.5.5 0 0 1-.702-.004z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dF($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ViewedMarkAs" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ViewedMarkAs extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dF, create_fragment$dF, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Vignette.svelte generated by Svelte v3.24.1 */

function create_fragment$dG(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M31 4H5a1 1 0 0 0-1 1v26a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm-1 26H6V6h24z");
			attr(path1, "d", "M28 15.632V8h-7.632A10.283 10.283 0 0 1 28 15.632zM15.632 8H8v7.632A10.283 10.283 0 0 1 15.632 8zM8\n    20.368V28h7.632A10.283 10.283 0 0 1 8 20.368zM20.368 28H28v-7.632A10.283 10.283 0 0 1 20.368 28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dG($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Vignette" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Vignette extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dG, create_fragment$dG, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Visibility.svelte generated by Svelte v3.24.1 */

function create_fragment$dH(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M24.613 8.58A14.972 14.972 0 0 0 18 6.937c-8.664 0-15.75 8.625-15.75 11.423 0 3 7.458 10.7 15.686 10.7 8.3 0\n    15.814-7.706 15.814-10.7 0-2.36-4.214-7.341-9.137-9.78zM18 27.225A9.225 9.225 0 1 1 27.225 18 9.225 9.225 0 0 1 18\n    27.225z");
			attr(path1, "d", "M20.667 18.083A2.667 2.667 0 0 1 18 15.417a2.632 2.632 0 0 1 1.35-2.27 4.939 4.939 0 0 0-1.35-.209A5.063 5.063 0\n    1 0 23.063 18a4.713 4.713 0 0 0-.175-1.2 2.625 2.625 0 0 1-2.221 1.283z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dH($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Visibility" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Visibility extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dH, create_fragment$dH, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VisibilityOff.svelte generated by Svelte v3.24.1 */

function create_fragment$dI(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M14.573 9.44A9.215 9.215 0 0 1 26.56 21.427l2.945 2.945c2.595-2.189 4.245-4.612 4.245-6.012\n    0-2.364-4.214-7.341-9.137-9.78A14.972 14.972 0 0 0 18 6.937a14.36 14.36 0 0 0-4.989.941z");
			attr(path1, "d", "M33.794 32.058L22.328 20.592A5.022 5.022 0 0 0 23.062 18a4.712 4.712 0 0 0-.174-1.2 2.625 2.625 0 0 1-2.221\n    1.278A2.667 2.667 0 0 1 18 15.417a2.632 2.632 0 0 1 1.35-2.27 4.945 4.945 0 0 0-1.35-.209 5.022 5.022 0 0\n    0-2.592.734L3.942 2.206a.819.819 0 0 0-1.157 0l-.578.579a.817.817 0 0 0 0 1.157l6.346 6.346c-3.816 2.74-6.3\n    6.418-6.3 8.072 0 3 7.458 10.7 15.686 10.7a16.455 16.455 0 0 0 7.444-1.948l6.679 6.679a.817.817 0 0 0 1.157\n    0l.578-.578a.818.818 0 0 0-.003-1.155zM18 27.225a9.2 9.2 0 0 1-7.321-14.811l2.994 2.994A5.008 5.008 0 0 0 12.938 18\n    5.062 5.062 0 0 0 18 23.063a5.009 5.009 0 0 0 2.592-.736l2.994 2.994A9.144 9.144 0 0 1 18 27.225z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dI($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VisibilityOff" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VisibilityOff extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dI, create_fragment$dI, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Visit.svelte generated by Svelte v3.24.1 */

function create_fragment$dJ(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M33 4H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h2.314a8.995 8.995 0 0 1 1.949-2H4V10h28v18h-3.437a9.453 9.453 0 0 1 2.024\n    2H33a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z");
			attr(path1, "d", "M21.213 27.051v-1.674a1.159 1.159 0 0 1 .295-.747 8.842 8.842 0 0 0\n    2.01-5.517c0-4.175-2.214-6.508-5.56-6.508s-5.623 2.425-5.623 6.508a8.936 8.936 0 0 0 2.107 5.517 1.159 1.159 0 0 1\n    .295.747v1.667a1.15 1.15 0 0 1-1 1.16c-6.722.585-7.727 5.183-7.727 7 0\n    .2-.007.8-.007.8H30v-.8c0-1.738-1.187-6.32-7.788-6.99a1.155 1.155 0 0 1-.999-1.163z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dJ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Visit" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Visit extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dJ, create_fragment$dJ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VisitShare.svelte generated by Svelte v3.24.1 */

function create_fragment$dK(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M2 8h26v2.71l2 2.213V3a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h2.154A8.266 8.266 0 0 1 5.4 24H2z");
			attr(path1, "d", "M31.722 18.331L26 12l-5.708 6.331A1 1 0 0 0 21.035 20H24v7.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V20h2.979a1 1 0 0\n    0 .743-1.669zM4 32l10-.008V22a2 2 0 0 1 2-2h2.233a2.988 2.988 0 0 1\n    .574-3.008l1.217-1.35c-.174-3.5-2.132-5.463-5.054-5.463-3.062 0-5.147 2.219-5.147 5.956a8.179 8.179 0 0 0 1.928\n    5.049 1.061 1.061 0 0 1 .27.684v1.525a1.053 1.053 0 0 1-.918 1.062c-6.152.535-7.085 4.879-7.085 6.538z");
			attr(path2, "d", "M32 22v10H20V22h-3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V23a1 1 0 0 0-1-1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dK($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VisitShare" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VisitShare extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dK, create_fragment$dK, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VoiceOver.svelte generated by Svelte v3.24.1 */

function create_fragment$dL(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M23.8 7.2a6.8 6.8 0 0 0-13.6 0v13.6a6.8 6.8 0 1 0 13.6 0z");
			attr(path1, "d", "M28 21v-4.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V21a9 9 0 1 1-18 0v-4.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5V21c0\n    5.725 5.357 11 10 11v2H8.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h17a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H18v-2.058c4.643\n    0 10-5.216 10-10.942z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dL($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VoiceOver" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VoiceOver extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dL, create_fragment$dL, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VolumeMute.svelte generated by Svelte v3.24.1 */

function create_fragment$dM(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M12 27a10.983 10.983 0 0 1 4-8.478V5a.726.726 0 0 0-1.194-.571l-6.639 6.8c-.439.447-.726.845-1.422.845H1a1 1 0 0\n    0-1 1V23a1 1 0 0 0 1 1h5.745c.7 0 1 .411 1.422.845l4.005 4.1A11.013 11.013 0 0 1 12 27z");
			attr(path1, "d", "M23 18.1a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zM16 27a6.929 6.929 0 0 1 1.475-4.252l9.777 9.777A6.966 6.966\n    0 0 1 16 27zm12.525 4.252l-9.777-9.777a6.966 6.966 0 0 1 9.777 9.777z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dM($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VolumeMute" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VolumeMute extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dM, create_fragment$dM, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VolumeOne.svelte generated by Svelte v3.24.1 */

function create_fragment$dN(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.745 12.073H1a1 1 0 0 0-1 1V23a1 1 0 0 0 1 1h5.745a1.428 1.428 0 0 1 .931.345l7.13 7.259A.727.727 0 0 0 16\n    31.029V5a.726.726 0 0 0-1.194-.571l-7.127 7.3a1.44 1.44 0 0 1-.934.344zM22.04 18a6.935 6.935 0 0 1-1.407 4.192.98.98\n    0 0 0 .086 1.288l.016.016a.992.992 0 0 0 1.487-.09 8.955 8.955 0 0 0-.022-10.853.992.992 0 0\n    0-1.484-.087l-.015.016a.982.982 0 0 0-.085 1.292A6.943 6.943 0 0 1 22.04 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dN($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VolumeOne" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VolumeOne extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dN, create_fragment$dN, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VolumeThree.svelte generated by Svelte v3.24.1 */

function create_fragment$dO(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M6.745 12.073H1a1 1 0 0 0-1 1V23a1 1 0 0 0 1 1h5.745a1.428 1.428 0 0 1 .931.345l7.13 7.259A.727.727 0 0 0 16\n    31.029V5a.726.726 0 0 0-1.194-.571l-7.127 7.3a1.44 1.44 0 0 1-.934.344zM22.04 18a6.935 6.935 0 0 1-1.407 4.192.98.98\n    0 0 0 .086 1.288l.016.016a.992.992 0 0 0 1.487-.09 8.955 8.955 0 0 0-.022-10.853.992.992 0 0\n    0-1.484-.087l-.015.016a.982.982 0 0 0-.085 1.292A6.943 6.943 0 0 1 22.04 18z");
			attr(path1, "d", "M28.04 18a12.938 12.938 0 0 1-3.115 8.435.973.973 0 0 0 .063 1.317l.014.014a1 1 0 0 0 1.474-.069 14.98 14.98 0 0\n    0-.026-19.429 1 1 0 0 0-1.469-.068l-.014.015a.977.977 0 0 0-.067 1.319A12.937 12.937 0 0 1 28.04 18z");
			attr(path2, "d", "M34.04 18a18.92 18.92 0 0 1-4.823 12.642 1 1 0 0 0 .024 1.375l.014.015a.982.982 0 0 0 1.422-.023A20.865 20.865 0\n    0 0 35.983 18a20.871 20.871 0 0 0-5.326-14.035.985.985 0 0 0-1.424-.02l-.015.014a1 1 0 0 0-.02 1.375A18.922 18.922 0\n    0 1 34.04 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dO($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VolumeThree" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VolumeThree extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dO, create_fragment$dO, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/VolumeTwo.svelte generated by Svelte v3.24.1 */

function create_fragment$dP(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M6.745 12.073H1a1 1 0 0 0-1 1V23a1 1 0 0 0 1 1h5.745a1.428 1.428 0 0 1 .931.345l7.13 7.259A.727.727 0 0 0 16\n    31.029V5a.726.726 0 0 0-1.194-.571l-7.127 7.3a1.44 1.44 0 0 1-.934.344zM22.04 18a6.935 6.935 0 0 1-1.407 4.192.98.98\n    0 0 0 .086 1.288l.016.016a.992.992 0 0 0 1.487-.09 8.955 8.955 0 0 0-.022-10.853.992.992 0 0\n    0-1.484-.087l-.015.016a.982.982 0 0 0-.085 1.292A6.943 6.943 0 0 1 22.04 18z");
			attr(path1, "d", "M28.04 18a12.938 12.938 0 0 1-3.115 8.435.973.973 0 0 0 .063 1.317l.014.014a1 1 0 0 0 1.474-.069 14.98 14.98 0 0\n    0-.026-19.429 1 1 0 0 0-1.469-.068l-.014.015a.977.977 0 0 0-.067 1.319A12.937 12.937 0 0 1 28.04 18z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dP($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "VolumeTwo" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class VolumeTwo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dP, create_fragment$dP, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Watch.svelte generated by Svelte v3.24.1 */

function create_fragment$dQ(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M8 6a1.914 1.914 0 0 0-2 2v20a2.02 2.02 0 0 0 2 2 2.112 2.112 0 0 1 2 2v3a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-3a2.112\n    2.112 0 0 1 2-2 2.021 2.021 0 0 0 2-2V16h1a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-1V8a1.987 1.987 0 0 0-2.083-2A1.947 1.947\n    0 0 1 26 4V1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v3a1.875 1.875 0 0 1-2 2zm18 4v16H10V10z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dQ($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Watch" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Watch extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dQ, create_fragment$dQ, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/WebPage.svelte generated by Svelte v3.24.1 */

function create_fragment$dR(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M2 5v26a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1zm30 25H4V10h28z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dR($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "WebPage" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class WebPage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dR, create_fragment$dR, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/WebPages.svelte generated by Svelte v3.24.1 */

function create_fragment$dS(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M6 9v24a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm26 23H8V14h24z");
			attr(path1, "d", "M4 6h26V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h1z");
			attr(path2, "d", "M6 9v24a1 1 0 0 0 1 1h26a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm26 23H8V14h24z");
			attr(path3, "d", "M4 6h26V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v24a1 1 0 0 0 1 1h1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dS($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "WebPages" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class WebPages extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dS, create_fragment$dS, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Workflow.svelte generated by Svelte v3.24.1 */

function create_fragment$dT(ctx) {
	let svg;
	let rect0;
	let rect0_height_value;
	let rect0_rx_value;
	let rect0_ry_value;
	let rect0_width_value;
	let rect0_x_value;
	let rect0_y_value;
	let rect1;
	let rect1_height_value;
	let rect1_rx_value;
	let rect1_ry_value;
	let rect1_width_value;
	let rect1_x_value;
	let rect1_y_value;
	let rect2;
	let rect2_height_value;
	let rect2_rx_value;
	let rect2_ry_value;
	let rect2_width_value;
	let rect2_x_value;
	let rect2_y_value;
	let rect3;
	let rect3_height_value;
	let rect3_rx_value;
	let rect3_ry_value;
	let rect3_width_value;
	let rect3_x_value;
	let rect3_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			path = svg_element("path");
			attr(rect0, "height", rect0_height_value = 11.2);
			attr(rect0, "rx", rect0_rx_value = 1);
			attr(rect0, "ry", rect0_ry_value = 1);
			attr(rect0, "width", rect0_width_value = 8);
			attr(rect0, "x", rect0_x_value = 2);
			attr(rect0, "y", rect0_y_value = 12);
			attr(rect1, "height", rect1_height_value = 6);
			attr(rect1, "rx", rect1_rx_value = 1);
			attr(rect1, "ry", rect1_ry_value = 1);
			attr(rect1, "width", rect1_width_value = 6);
			attr(rect1, "x", rect1_x_value = 28);
			attr(rect1, "y", rect1_y_value = 4);
			attr(rect2, "height", rect2_height_value = 6);
			attr(rect2, "rx", rect2_rx_value = 1);
			attr(rect2, "ry", rect2_ry_value = 1);
			attr(rect2, "width", rect2_width_value = 6);
			attr(rect2, "x", rect2_x_value = 28);
			attr(rect2, "y", rect2_y_value = 14);
			attr(rect3, "height", rect3_height_value = 6);
			attr(rect3, "rx", rect3_rx_value = 1);
			attr(rect3, "ry", rect3_ry_value = 1);
			attr(rect3, "width", rect3_width_value = 6);
			attr(rect3, "x", rect3_x_value = 28);
			attr(rect3, "y", rect3_y_value = 24);
			attr(path, "d", "M26 7.5v-1a.5.5 0 0 0-.5-.5h-7a.5.5 0 0 0-.5.5V16h-5.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5H18v9.5a.5.5 0 0 0\n    .5.5h7a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H20v-8h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5H20V8h5.5a.5.5 0 0 0\n    .5-.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect0);
			append(svg, rect1);
			append(svg, rect2);
			append(svg, rect3);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dT($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Workflow" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Workflow extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dT, create_fragment$dT, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/WorkflowAdd.svelte generated by Svelte v3.24.1 */

function create_fragment$dU(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 4h-4a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1zm0 10h-4a.986.986 0 0 0-.95.753 12.22\n    12.22 0 0 1 5.95 2.14V15a1 1 0 0 0-1-1zm-7.5-8h-7a.5.5 0 0 0-.5.5V16h-5.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0\n    .5.5H18v.635A12.326 12.326 0 0 1 21.52 16H20V8h5.5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM9 12H3a1 1 0 0 0-1 1v9.2a1\n    1 0 0 0 1 1h6a1 1 0 0 0 1-1V13a1 1 0 0 0-1-1zM27.1 18.2a8.9 8.9 0 1 0 8.9 8.9 8.9 8.9 0 0 0-8.9-8.9zm5 9.4a.5.5 0 0\n    1-.5.5h-3.5v3.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-3.5h-3.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3.5v-3.5a.5.5 0 0\n    1 .5-.5h1a.5.5 0 0 1 .5.5v3.5h3.5a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dU($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "WorkflowAdd" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class WorkflowAdd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dU, create_fragment$dU, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/Wrench.svelte generated by Svelte v3.24.1 */

function create_fragment$dV(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M32.235 27.526L20.857 16.148c-3.622-3.654-1.234-8.6-4.67-12.037-2.953-2.953-8.75-2.2-10.072-1.364A.146.146 0 0 0\n    6.141 3l6.238 3.1a.367.367 0 0 1 .2.3l.29 3.655a.742.742 0 0 1-.339.683l-3.085 1.975a.37.37 0 0 1-.364.019L2.8\n    9.608a.145.145 0 0 0-.212.09c-.152 1 1.24 4.055 3.124 5.94 3.144 3.144 7.818 1.561 9.911 3.654L26.75 32.448a3.758\n    3.758 0 0 0 .395.467 3.706 3.706 0 0 0 5.5-.284 3.849 3.849 0 0 0-.41-5.105z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dV($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Wrench" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Wrench extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dV, create_fragment$dV, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ZoomIn.svelte generated by Svelte v3.24.1 */

function create_fragment$dW(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M21.5 14H18v-3.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V14h-3.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5H14v3.5a.5.5 0 0 0\n    .5.5h3a.5.5 0 0 0 .5-.5V18h3.5a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5z");
			attr(path1, "d", "M35.173 32.215L27.256 24.3a14.031 14.031 0 1 0-2.956 2.957l7.916 7.916a2.1 2.1 0 0 0 2.958-2.958zM6 16a10 10 0 1\n    1 10 10A10 10 0 0 1 6 16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dW($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ZoomIn" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ZoomIn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dW, create_fragment$dW, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/ZoomOut.svelte generated by Svelte v3.24.1 */

function create_fragment$dX(ctx) {
	let svg;
	let rect;
	let rect_height_value;
	let rect_rx_value;
	let rect_ry_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "height", rect_height_value = 4);
			attr(rect, "rx", rect_rx_value = 0.5);
			attr(rect, "ry", rect_ry_value = 0.5);
			attr(rect, "width", rect_width_value = 12);
			attr(rect, "x", rect_x_value = 10);
			attr(rect, "y", rect_y_value = 14);
			attr(path, "d", "M35.173 32.215L27.256 24.3a14.031 14.031 0 1 0-2.956 2.957l7.916 7.916a2.1 2.1 0 0 0 2.958-2.958zM6 16a10 10 0 1\n    1 10 10A10 10 0 0 1 6 16z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$dX($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "ZoomOut" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class ZoomOut extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$dX, create_fragment$dX, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

export { _123 as Icon123, _3DMaterials as Icon3DMaterials, ABC as IconABC, AEMScreens as IconAEMScreens, Actions as IconActions, AdDisplay as IconAdDisplay, AdPrint as IconAdPrint, Add as IconAdd, AddCircle as IconAddCircle, AddTo as IconAddTo, AddToSelection as IconAddToSelection, Airplane as IconAirplane, Alert as IconAlert, AlertAdd as IconAlertAdd, AlertCheck as IconAlertCheck, AlertCircle as IconAlertCircle, AlertCircleFilled as IconAlertCircleFilled, Algorithm as IconAlgorithm, Alias as IconAlias, AlignBottom as IconAlignBottom, AlignCenter as IconAlignCenter, AlignLeft as IconAlignLeft, AlignMiddle as IconAlignMiddle, AlignRight as IconAlignRight, AlignTop as IconAlignTop, Amusementpark as IconAmusementpark, Anchor as IconAnchor, AnchorSelect as IconAnchorSelect, Annotate as IconAnnotate, AnnotatePen as IconAnnotatePen, Answer as IconAnswer, AnswerFavorite as IconAnswerFavorite, App as IconApp, AppRefresh as IconAppRefresh, AppleFiles as IconAppleFiles, ApplicationDelivery as IconApplicationDelivery, ApproveReject as IconApproveReject, Apps as IconApps, Archive as IconArchive, ArchiveRemove as IconArchiveRemove, ArrowDown as IconArrowDown, ArrowLeft as IconArrowLeft, ArrowRight as IconArrowRight, ArrowUp as IconArrowUp, ArrowUpRight as IconArrowUpRight, Artboard as IconArtboard, Article as IconArticle, Asset as IconAsset, AssetCheck as IconAssetCheck, AssetsAdded as IconAssetsAdded, AssetsDownloaded as IconAssetsDownloaded, AssetsExpired as IconAssetsExpired, AssetsLinkedPublished as IconAssetsLinkedPublished, AssetsModified as IconAssetsModified, AssetsPublished as IconAssetsPublished, Asterisk as IconAsterisk, At as IconAt, Attach as IconAttach, AttachmentExclude as IconAttachmentExclude, Attributes as IconAttributes, Audio as IconAudio, AutomatedSegment as IconAutomatedSegment, Back as IconBack, Back30Seconds as IconBack30Seconds, BackAndroid as IconBackAndroid, Beaker as IconBeaker, BeakerCheck as IconBeakerCheck, BeakerShare as IconBeakerShare, Bell as IconBell, BidRule as IconBidRule, BidRuleAdd as IconBidRuleAdd, Blower as IconBlower, Blur as IconBlur, Book as IconBook, Bookmark as IconBookmark, BookmarkSingle as IconBookmarkSingle, BookmarkSingleOutline as IconBookmarkSingleOutline, BookmarkSmall as IconBookmarkSmall, BookmarkSmallOutline as IconBookmarkSmallOutline, Boolean as IconBoolean, Border as IconBorder, Box as IconBox, BoxAdd as IconBoxAdd, BoxExport as IconBoxExport, BoxImport as IconBoxImport, Brackets as IconBrackets, BracketsSquare as IconBracketsSquare, Branch1 as IconBranch1, Branch2 as IconBranch2, Branch3 as IconBranch3, BranchCircle as IconBranchCircle, BreadcrumbNavigation as IconBreadcrumbNavigation, Breakdown as IconBreakdown, BreakdownAdd as IconBreakdownAdd, Briefcase as IconBriefcase, Browse as IconBrowse, Brush as IconBrush, Bug as IconBug, Building as IconBuilding, BulkEditUsers as IconBulkEditUsers, Button as IconButton, CCLibrary as IconCCLibrary, Calculator as IconCalculator, Calendar as IconCalendar, CalendarAdd as IconCalendarAdd, CalendarLocked as IconCalendarLocked, CalendarUnlocked as IconCalendarUnlocked, CallCenter as IconCallCenter, Camera as IconCamera, CameraFlip as IconCameraFlip, CameraRefresh as IconCameraRefresh, Campaign as IconCampaign, CampaignAdd as IconCampaignAdd, CampaignClose as IconCampaignClose, CampaignDelete as IconCampaignDelete, CampaignEdit as IconCampaignEdit, Cancel as IconCancel, Capitals as IconCapitals, Captcha as IconCaptcha, Car as IconCar, Card as IconCard, Channel as IconChannel, Chat as IconChat, ChatAdd as IconChatAdd, CheckPause as IconCheckPause, Checkmark as IconCheckmark, CheckmarkCircle as IconCheckmarkCircle, CheckmarkCircleOutline as IconCheckmarkCircleOutline, ChevronDoubleLeft as IconChevronDoubleLeft, ChevronDoubleRight as IconChevronDoubleRight, ChevronDown as IconChevronDown, ChevronLeft as IconChevronLeft, ChevronRight as IconChevronRight, ChevronUp as IconChevronUp, ChevronUpDown as IconChevronUpDown, Circle as IconCircle, ClassicGridView as IconClassicGridView, Clock as IconClock, ClockCheck as IconClockCheck, CloneStamp as IconCloneStamp, Close as IconClose, CloseCaptions as IconCloseCaptions, CloseCircle as IconCloseCircle, Cloud as IconCloud, CloudDisconnected as IconCloudDisconnected, CloudError as IconCloudError, CloudOutline as IconCloudOutline, Code as IconCode, Collection as IconCollection, CollectionAdd as IconCollectionAdd, CollectionAddTo as IconCollectionAddTo, CollectionCheck as IconCollectionCheck, CollectionEdit as IconCollectionEdit, CollectionExclude as IconCollectionExclude, CollectionLink as IconCollectionLink, ColorFill as IconColorFill, ColorPalette as IconColorPalette, ColorWheel as IconColorWheel, ColumnSettings as IconColumnSettings, ColumnTwoA as IconColumnTwoA, ColumnTwoB as IconColumnTwoB, ColumnTwoC as IconColumnTwoC, Comment as IconComment, Compare as IconCompare, Compass as IconCompass, Condition as IconCondition, ConfidenceFour as IconConfidenceFour, ConfidenceOne as IconConfidenceOne, ConfidenceThree as IconConfidenceThree, ConfidenceTwo as IconConfidenceTwo, Contrast as IconContrast, ConversionFunnel as IconConversionFunnel, Copy as IconCopy, CoverImage as IconCoverImage, CreditCard as IconCreditCard, Crop as IconCrop, CropLightning as IconCropLightning, CropRotate as IconCropRotate, Crosshairs as IconCrosshairs, Curate as IconCurate, Cut as IconCut, Dashboard as IconDashboard, Data as IconData, DataAdd as IconDataAdd, DataBook as IconDataBook, DataCheck as IconDataCheck, DataCorrelated as IconDataCorrelated, DataDownload as IconDataDownload, DataEdit as IconDataEdit, DataMapping as IconDataMapping, DataRefresh as IconDataRefresh, DataRemove as IconDataRemove, DataSettings as IconDataSettings, DataUnavailable as IconDataUnavailable, DataUpload as IconDataUpload, DataUser as IconDataUser, Date as IconDate, DateInput as IconDateInput, Deduplication as IconDeduplication, Delegate as IconDelegate, Delete as IconDelete, DeleteOutline as IconDeleteOutline, Demographic as IconDemographic, Deselect as IconDeselect, DeselectCircular as IconDeselectCircular, DesktopAndMobile as IconDesktopAndMobile, DeviceDesktop as IconDeviceDesktop, DeviceLaptop as IconDeviceLaptop, DevicePhone as IconDevicePhone, DevicePhoneRefresh as IconDevicePhoneRefresh, DevicePreview as IconDevicePreview, DeviceRotateLandscape as IconDeviceRotateLandscape, DeviceRotatePortrait as IconDeviceRotatePortrait, DeviceTV as IconDeviceTV, DeviceTablet as IconDeviceTablet, Devices as IconDevices, DistributeBottomEdge as IconDistributeBottomEdge, DistributeHorizontalCenter as IconDistributeHorizontalCenter, DistributeHorizontally as IconDistributeHorizontally, DistributeLeftEdge as IconDistributeLeftEdge, DistributeRightEdge as IconDistributeRightEdge, DistributeSpaceHoriz as IconDistributeSpaceHoriz, DistributeSpaceVert as IconDistributeSpaceVert, DistributeTopEdge as IconDistributeTopEdge, DistributeVerticalCenter as IconDistributeVerticalCenter, DistributeVertically as IconDistributeVertically, Divide as IconDivide, DividePath as IconDividePath, Document as IconDocument, DocumentFragment as IconDocumentFragment, DocumentFragmentGroup as IconDocumentFragmentGroup, DocumentOutline as IconDocumentOutline, DocumentRefresh as IconDocumentRefresh, Dolly as IconDolly, Download as IconDownload, DownloadFromCloud as IconDownloadFromCloud, DownloadFromCloudOutline as IconDownloadFromCloudOutline, Draft as IconDraft, DragHandle as IconDragHandle, Draw as IconDraw, Dropdown as IconDropdown, Duplicate as IconDuplicate, Edit as IconEdit, EditCircle as IconEditCircle, EditExclude as IconEditExclude, EditIn as IconEditIn, EditInLight as IconEditInLight, Education as IconEducation, Effects as IconEffects, Efficient as IconEfficient, Ellipse as IconEllipse, Email as IconEmail, EmailCancel as IconEmailCancel, EmailCheck as IconEmailCheck, EmailExclude as IconEmailExclude, EmailExcludeOutline as IconEmailExcludeOutline, EmailGear as IconEmailGear, EmailGearOutline as IconEmailGearOutline, EmailKey as IconEmailKey, EmailKeyOutline as IconEmailKeyOutline, EmailLightning as IconEmailLightning, EmailNotification as IconEmailNotification, EmailOutline as IconEmailOutline, EmailRefresh as IconEmailRefresh, EmailSchedule as IconEmailSchedule, Engagement as IconEngagement, Erase as IconErase, Event as IconEvent, EventExclude as IconEventExclude, EventShare as IconEventShare, Events as IconEvents, ExcludeOverlap as IconExcludeOverlap, Experience as IconExperience, ExperienceAdd as IconExperienceAdd, ExperienceAddTo as IconExperienceAddTo, ExperienceExport as IconExperienceExport, ExperienceImport as IconExperienceImport, Export as IconExport, ExportOriginal as IconExportOriginal, Exposure as IconExposure, Extension as IconExtension, FacebookCoverImage as IconFacebookCoverImage, Fast as IconFast, FastForward as IconFastForward, FastForwardCircle as IconFastForwardCircle, Feature as IconFeature, Feed as IconFeed, FeedAdd as IconFeedAdd, FeedManagement as IconFeedManagement, Feedback as IconFeedback, FileAdd as IconFileAdd, FileCSV as IconFileCSV, FileCampaign as IconFileCampaign, FileChart as IconFileChart, FileCheckedOut as IconFileCheckedOut, FileCode as IconFileCode, FileData as IconFileData, FileEmail as IconFileEmail, FileExcel as IconFileExcel, FileFolder as IconFileFolder, FileGear as IconFileGear, FileGlobe as IconFileGlobe, FileHTML as IconFileHTML, FileImportant as IconFileImportant, FileJson as IconFileJson, FileKey as IconFileKey, FileMobile as IconFileMobile, FilePDF as IconFilePDF, FileShare as IconFileShare, FileSingleWebPage as IconFileSingleWebPage, FileSpace as IconFileSpace, FileTemplate as IconFileTemplate, FileTxt as IconFileTxt, FileUser as IconFileUser, FileWord as IconFileWord, FileWorkflow as IconFileWorkflow, FileXML as IconFileXML, FileZip as IconFileZip, FilingCabinet as IconFilingCabinet, Filmroll as IconFilmroll, FilmrollAutoAdd as IconFilmrollAutoAdd, Filter as IconFilter, FilterAdd as IconFilterAdd, FilterCheck as IconFilterCheck, FilterDelete as IconFilterDelete, FilterEdit as IconFilterEdit, FilterHeart as IconFilterHeart, FilterRemove as IconFilterRemove, FilterStar as IconFilterStar, FindAndReplace as IconFindAndReplace, Flag as IconFlag, FlagExclude as IconFlagExclude, FlashAuto as IconFlashAuto, FlashOff as IconFlashOff, FlashOn as IconFlashOn, Flashlight as IconFlashlight, FlashlightOff as IconFlashlightOff, FlashlightOn as IconFlashlightOn, FlipHorizontal as IconFlipHorizontal, FlipVertical as IconFlipVertical, Folder as IconFolder, Folder2Color as IconFolder2Color, FolderAdd as IconFolderAdd, FolderAddTo as IconFolderAddTo, FolderArchive as IconFolderArchive, FolderDelete as IconFolderDelete, FolderGear as IconFolderGear, FolderLocked as IconFolderLocked, FolderOpen as IconFolderOpen, FolderOpenOutline as IconFolderOpenOutline, FolderOutline as IconFolderOutline, FolderRemove as IconFolderRemove, FolderSearch as IconFolderSearch, FolderUser as IconFolderUser, Follow as IconFollow, FollowOff as IconFollowOff, ForPlacementOnly as IconForPlacementOnly, Forecast as IconForecast, Form as IconForm, Forward as IconForward, FullScreen as IconFullScreen, FullScreenExit as IconFullScreenExit, Function as IconFunction, Game as IconGame, Gauge1 as IconGauge1, Gauge2 as IconGauge2, Gauge3 as IconGauge3, Gauge4 as IconGauge4, Gauge5 as IconGauge5, Gears as IconGears, GearsAdd as IconGearsAdd, GearsDelete as IconGearsDelete, GearsEdit as IconGearsEdit, GenderFemale as IconGenderFemale, GenderMale as IconGenderMale, Gift as IconGift, Globe as IconGlobe, GlobeCheck as IconGlobeCheck, GlobeClock as IconGlobeClock, GlobeEnter as IconGlobeEnter, GlobeExit as IconGlobeExit, GlobeGrid as IconGlobeGrid, GlobeOutline as IconGlobeOutline, GlobeRemove as IconGlobeRemove, GlobeSearch as IconGlobeSearch, GlobeStrike as IconGlobeStrike, GlobeStrikeClock as IconGlobeStrikeClock, Gradient as IconGradient, GraphArea as IconGraphArea, GraphAreaStacked as IconGraphAreaStacked, GraphBarHorizontal as IconGraphBarHorizontal, GraphBarHorizontalAdd as IconGraphBarHorizontalAdd, GraphBarHorizontalStacked as IconGraphBarHorizontalStacked, GraphBarVertical as IconGraphBarVertical, GraphBarVerticalAdd as IconGraphBarVerticalAdd, GraphBarVerticalStacked as IconGraphBarVerticalStacked, GraphBubble as IconGraphBubble, GraphBullet as IconGraphBullet, GraphConfidenceBands as IconGraphConfidenceBands, GraphDonut as IconGraphDonut, GraphDonutAdd as IconGraphDonutAdd, GraphGantt as IconGraphGantt, GraphHistogram as IconGraphHistogram, GraphPathing as IconGraphPathing, GraphPie as IconGraphPie, GraphProfitCurve as IconGraphProfitCurve, GraphScatter as IconGraphScatter, GraphStream as IconGraphStream, GraphStreamRanked as IconGraphStreamRanked, GraphStreamRankedAdd as IconGraphStreamRankedAdd, GraphSunburst as IconGraphSunburst, GraphTree as IconGraphTree, GraphTrend as IconGraphTrend, GraphTrendAdd as IconGraphTrendAdd, GraphTrendAlert as IconGraphTrendAlert, Graphic as IconGraphic, Group as IconGroup, Hammer as IconHammer, Hand as IconHand, Hand0 as IconHand0, Hand1 as IconHand1, Hand2 as IconHand2, Hand3 as IconHand3, Hand4 as IconHand4, Heal as IconHeal, Heart as IconHeart, Help as IconHelp, HelpOutline as IconHelpOutline, Histogram as IconHistogram, History as IconHistory, Home as IconHome, Homepage as IconHomepage, HotFixes as IconHotFixes, HotelBed as IconHotelBed, IdentityService as IconIdentityService, Image as IconImage, ImageAdd as IconImageAdd, ImageAlbum as IconImageAlbum, ImageAutoMode as IconImageAutoMode, ImageCarousel as IconImageCarousel, ImageCheck as IconImageCheck, ImageCheckedOut as IconImageCheckedOut, ImageMapCircle as IconImageMapCircle, ImageMapPolygon as IconImageMapPolygon, ImageMapRectangle as IconImageMapRectangle, ImageNext as IconImageNext, ImageProfile as IconImageProfile, ImageSearch as IconImageSearch, ImageText as IconImageText, Images as IconImages, Import as IconImport, Inbox as IconInbox, Individual as IconIndividual, Info as IconInfo, InfoOutline as IconInfoOutline, IntersectOverlap as IconIntersectOverlap, InvertAdj as IconInvertAdj, Journey as IconJourney, JourneyAction as IconJourneyAction, JourneyData as IconJourneyData, JourneyEvent as IconJourneyEvent, JourneyEvent2 as IconJourneyEvent2, JourneyReports as IconJourneyReports, JourneyVoyager as IconJourneyVoyager, JumpToTop as IconJumpToTop, Key as IconKey, KeyClock as IconKeyClock, KeyExclude as IconKeyExclude, Keyboard as IconKeyboard, Label as IconLabel, LabelExclude as IconLabelExclude, Labels as IconLabels, Landscape as IconLandscape, Launch as IconLaunch, Layers as IconLayers, LayersBackward as IconLayersBackward, LayersBringToFront as IconLayersBringToFront, LayersForward as IconLayersForward, LayersSendToBack as IconLayersSendToBack, Light as IconLight, Line as IconLine, LineHeight as IconLineHeight, LinearGradient as IconLinearGradient, Link as IconLink, LinkCheck as IconLinkCheck, LinkGlobe as IconLinkGlobe, LinkNav as IconLinkNav, LinkOff as IconLinkOff, LinkOut as IconLinkOut, LinkOutLight as IconLinkOutLight, LinkPage as IconLinkPage, LinkUser as IconLinkUser, Location as IconLocation, LocationBasedDate as IconLocationBasedDate, LocationBasedEvent as IconLocationBasedEvent, LocationContribution as IconLocationContribution, LockClosed as IconLockClosed, LockOpen as IconLockOpen, LogOut as IconLogOut, Login as IconLogin, Looks as IconLooks, LoupeView as IconLoupeView, MBox as IconMBox, MagicWand as IconMagicWand, Magnify as IconMagnify, Mailbox as IconMailbox, MapView as IconMapView, MarginBottom as IconMarginBottom, MarginLeft as IconMarginLeft, MarginRight as IconMarginRight, MarginTop as IconMarginTop, MarketingActivities as IconMarketingActivities, Maximize as IconMaximize, Measure as IconMeasure, Menu as IconMenu, Merge as IconMerge, MergeLayers as IconMergeLayers, Messenger as IconMessenger, Minimize as IconMinimize, MobileServices as IconMobileServices, ModernGridView as IconModernGridView, Money as IconMoney, Monitoring as IconMonitoring, Moon as IconMoon, More as IconMore, MoreCircle as IconMoreCircle, MoreSmall as IconMoreSmall, MoreSmallList as IconMoreSmallList, MoreSmallListVert as IconMoreSmallListVert, MoreVertical as IconMoreVertical, Move as IconMove, MoveLeftRight as IconMoveLeftRight, MoveTo as IconMoveTo, MoveUpDown as IconMoveUpDown, MovieCamera as IconMovieCamera, Multiple as IconMultiple, MultipleAdd as IconMultipleAdd, MultipleCheck as IconMultipleCheck, MultipleExclude as IconMultipleExclude, NamingOrder as IconNamingOrder, NewItem as IconNewItem, News as IconNews, NewsAdd as IconNewsAdd, NoEdit as IconNoEdit, Note as IconNote, NoteAdd as IconNoteAdd, OS as IconOS, Offer as IconOffer, OfferDelete as IconOfferDelete, OnAir as IconOnAir, OpenIn as IconOpenIn, OpenInLight as IconOpenInLight, OpenRecent as IconOpenRecent, OpenRecentOutline as IconOpenRecentOutline, Orbit as IconOrbit, Organisations as IconOrganisations, Organize as IconOrganize, OutlinePath as IconOutlinePath, PaddingBottom as IconPaddingBottom, PaddingLeft as IconPaddingLeft, PaddingRight as IconPaddingRight, PaddingTop as IconPaddingTop, PageBreak as IconPageBreak, PageExclude as IconPageExclude, PageGear as IconPageGear, PageRule as IconPageRule, PageShare as IconPageShare, PageTag as IconPageTag, PagesExclude as IconPagesExclude, Pan as IconPan, Panel as IconPanel, Paste as IconPaste, PasteHTML as IconPasteHTML, PasteList as IconPasteList, PasteText as IconPasteText, Pattern as IconPattern, Pause as IconPause, PauseCircle as IconPauseCircle, Pawn as IconPawn, Pending as IconPending, PeopleGroup as IconPeopleGroup, PersonalizationField as IconPersonalizationField, Perspective as IconPerspective, PinOff as IconPinOff, PinOn as IconPinOn, Pivot as IconPivot, PlatformDataMapping as IconPlatformDataMapping, Play as IconPlay, PlayCircle as IconPlayCircle, Plug as IconPlug, Polygon as IconPolygon, PolygonSelect as IconPolygonSelect, PopIn as IconPopIn, Portrait as IconPortrait, Preset as IconPreset, Preview as IconPreview, Print as IconPrint, PrintPreview as IconPrintPreview, Project as IconProject, ProjectAdd as IconProjectAdd, ProjectEdit as IconProjectEdit, ProjectNameEdit as IconProjectNameEdit, Promote as IconPromote, Properties as IconProperties, PropertiesCopy as IconPropertiesCopy, PublishCheck as IconPublishCheck, PublishPending as IconPublishPending, PublishReject as IconPublishReject, PublishRemove as IconPublishRemove, PublishSchedule as IconPublishSchedule, PushNotification as IconPushNotification, Question as IconQuestion, QuickSelect as IconQuickSelect, RSS as IconRSS, RadialGradient as IconRadialGradient, Rail as IconRail, RailBottom as IconRailBottom, RailLeft as IconRailLeft, RailRight as IconRailRight, RailRightClose as IconRailRightClose, RailRightOpen as IconRailRightOpen, RailTop as IconRailTop, RangeMask as IconRangeMask, RealTimeCustomerProfile as IconRealTimeCustomerProfile, RectSelect as IconRectSelect, Rectangle as IconRectangle, Redo as IconRedo, Refresh as IconRefresh, RegionSelect as IconRegionSelect, Relevance as IconRelevance, Remove as IconRemove, RemoveCircle as IconRemoveCircle, Rename as IconRename, Reorder as IconReorder, Replay as IconReplay, Replies as IconReplies, Reply as IconReply, ReplyAll as IconReplyAll, Report as IconReport, ReportAdd as IconReportAdd, Resize as IconResize, Retweet as IconRetweet, Reuse as IconReuse, Revenue as IconRevenue, Revert as IconRevert, Rewind as IconRewind, RewindCircle as IconRewindCircle, Ribbon as IconRibbon, RotateCCW as IconRotateCCW, RotateCCWBold as IconRotateCCWBold, RotateCW as IconRotateCW, RotateCWBold as IconRotateCWBold, RotateLeft as IconRotateLeft, RotateLeftOutline as IconRotateLeftOutline, RotateRight as IconRotateRight, RotateRightOutline as IconRotateRightOutline, SMS as IconSMS, SMSKey as IconSMSKey, SMSLightning as IconSMSLightning, SMSRefresh as IconSMSRefresh, SQLQuery as IconSQLQuery, Sampler as IconSampler, Sandbox as IconSandbox, SaveAsFloppy as IconSaveAsFloppy, SaveFloppy as IconSaveFloppy, SaveTo as IconSaveTo, SaveToLight as IconSaveToLight, Scribble as IconScribble, Search as IconSearch, Seat as IconSeat, SeatAdd as IconSeatAdd, Segmentation as IconSegmentation, Segments as IconSegments, Select as IconSelect, SelectAdd as IconSelectAdd, SelectBox as IconSelectBox, SelectBoxAll as IconSelectBoxAll, SelectCircular as IconSelectCircular, SelectContainer as IconSelectContainer, SelectGear as IconSelectGear, SelectIntersect as IconSelectIntersect, SelectSubstract as IconSelectSubstract, Selection as IconSelection, SelectionChecked as IconSelectionChecked, SelectionMove as IconSelectionMove, Send as IconSend, SentimentNegative as IconSentimentNegative, SentimentNeutral as IconSentimentNeutral, SentimentPositive as IconSentimentPositive, Separator as IconSeparator, Servers as IconServers, Settings as IconSettings, Shapes as IconShapes, Share as IconShare, ShareAndroid as IconShareAndroid, ShareCheck as IconShareCheck, ShareLight as IconShareLight, ShareWindows as IconShareWindows, Sharpen as IconSharpen, Shield as IconShield, Ship as IconShip, Shop as IconShop, ShoppingCart as IconShoppingCart, ShowAllLayers as IconShowAllLayers, ShowMenu as IconShowMenu, ShowOneLayer as IconShowOneLayer, Shuffle as IconShuffle, Slice as IconSlice, Slow as IconSlow, SmallCaps as IconSmallCaps, Snapshot as IconSnapshot, SocialNetwork as IconSocialNetwork, SortOrderDown as IconSortOrderDown, SortOrderUp as IconSortOrderUp, Spam as IconSpam, Spellcheck as IconSpellcheck, Spin as IconSpin, SplitView as IconSplitView, SpotHeal as IconSpotHeal, Stadium as IconStadium, Stage as IconStage, Stamp as IconStamp, Star as IconStar, StarOutline as IconStarOutline, Starburst as IconStarburst, StepBackward as IconStepBackward, StepBackwardCircle as IconStepBackwardCircle, StepForward as IconStepForward, StepForwardCircle as IconStepForwardCircle, Stop as IconStop, StopCircle as IconStopCircle, Stopwatch as IconStopwatch, Straighten as IconStraighten, StraightenOutline as IconStraightenOutline, StrokeWidth as IconStrokeWidth, Subscribe as IconSubscribe, SubstractBackPath as IconSubstractBackPath, SubstractFromSelection as IconSubstractFromSelection, SubtractFrontPath as IconSubtractFrontPath, SuccessMetric as IconSuccessMetric, Summarize as IconSummarize, Survey as IconSurvey, Switch as IconSwitch, Sync as IconSync, SyncRemove as IconSyncRemove, Table as IconTable, TableAdd as IconTableAdd, TableAndChart as IconTableAndChart, TableColumnAddLeft as IconTableColumnAddLeft, TableColumnAddRight as IconTableColumnAddRight, TableColumnMerge as IconTableColumnMerge, TableColumnRemoveCenter as IconTableColumnRemoveCenter, TableColumnSplit as IconTableColumnSplit, TableEdit as IconTableEdit, TableHistogram as IconTableHistogram, TableMergeCells as IconTableMergeCells, TableRowAddBottom as IconTableRowAddBottom, TableRowAddTop as IconTableRowAddTop, TableRowMerge as IconTableRowMerge, TableRowRemoveCenter as IconTableRowRemoveCenter, TableRowSplit as IconTableRowSplit, TableSelectColumn as IconTableSelectColumn, TableSelectRow as IconTableSelectRow, Tableau as IconTableau, TagBold as IconTagBold, TagItalic as IconTagItalic, TagUnderline as IconTagUnderline, Target as IconTarget, Targeted as IconTargeted, TaskList as IconTaskList, Teapot as IconTeapot, Temperature as IconTemperature, TestAB as IconTestAB, TestABEdit as IconTestABEdit, TestABGear as IconTestABGear, TestABRemove as IconTestABRemove, TestProfile as IconTestProfile, Text as IconText, TextAdd as IconTextAdd, TextAlignCenter as IconTextAlignCenter, TextAlignJustify as IconTextAlignJustify, TextAlignLeft as IconTextAlignLeft, TextAlignRight as IconTextAlignRight, TextBaselineShift as IconTextBaselineShift, TextBold as IconTextBold, TextBulleted as IconTextBulleted, TextBulletedAttach as IconTextBulletedAttach, TextBulletedHierarchy as IconTextBulletedHierarchy, TextBulletedHierarchyExclude as IconTextBulletedHierarchyExclude, TextColor as IconTextColor, TextDecrease as IconTextDecrease, TextEdit as IconTextEdit, TextExclude as IconTextExclude, TextIncrease as IconTextIncrease, TextIndentDecrease as IconTextIndentDecrease, TextIndentIncrease as IconTextIndentIncrease, TextItalic as IconTextItalic, TextKerning as IconTextKerning, TextLetteredLowerCase as IconTextLetteredLowerCase, TextLetteredUpperCase as IconTextLetteredUpperCase, TextNumbered as IconTextNumbered, TextParagraph as IconTextParagraph, TextRomanLowercase as IconTextRomanLowercase, TextRomanUppercase as IconTextRomanUppercase, TextSize as IconTextSize, TextSizeAdd as IconTextSizeAdd, TextSpaceAfter as IconTextSpaceAfter, TextSpaceBefore as IconTextSpaceBefore, TextStrikethrough as IconTextStrikethrough, TextStroke as IconTextStroke, TextStyle as IconTextStyle, TextSubscript as IconTextSubscript, TextSuperscript as IconTextSuperscript, TextTracking as IconTextTracking, TextUnderline as IconTextUnderline, ThumbDown as IconThumbDown, ThumbDownOutline as IconThumbDownOutline, ThumbUp as IconThumbUp, ThumbUpOutline as IconThumbUpOutline, Tips as IconTips, Train as IconTrain, TransferToPlatform as IconTransferToPlatform, Transparency as IconTransparency, Trap as IconTrap, TreeCollapse as IconTreeCollapse, TreeCollapseAll as IconTreeCollapseAll, TreeExpand as IconTreeExpand, TreeExpandAll as IconTreeExpandAll, TrendInspect as IconTrendInspect, TrimPath as IconTrimPath, Trophy as IconTrophy, Type as IconType, USA as IconUSA, Underline as IconUnderline, Undo as IconUndo, Ungroup as IconUngroup, Unlink as IconUnlink, Unmerge as IconUnmerge, UploadToCloud as IconUploadToCloud, UploadToCloudOutline as IconUploadToCloudOutline, User as IconUser, UserActivity as IconUserActivity, UserAdd as IconUserAdd, UserAdmin as IconUserAdmin, UserArrow as IconUserArrow, UserCheckedOut as IconUserCheckedOut, UserDeveloper as IconUserDeveloper, UserEdit as IconUserEdit, UserExclude as IconUserExclude, UserGroup as IconUserGroup, UserLock as IconUserLock, UserShare as IconUserShare, UsersAdd as IconUsersAdd, UsersExclude as IconUsersExclude, UsersLock as IconUsersLock, UsersShare as IconUsersShare, Variable as IconVariable, VectorDraw as IconVectorDraw, VideoCheckedOut as IconVideoCheckedOut, VideoFilled as IconVideoFilled, VideoOutline as IconVideoOutline, ViewAllTags as IconViewAllTags, ViewBiWeek as IconViewBiWeek, ViewCard as IconViewCard, ViewColumn as IconViewColumn, ViewDay as IconViewDay, ViewDetail as IconViewDetail, ViewGrid as IconViewGrid, ViewList as IconViewList, ViewRow as IconViewRow, ViewSingle as IconViewSingle, ViewStack as IconViewStack, ViewWeek as IconViewWeek, ViewedMarkAs as IconViewedMarkAs, Vignette as IconVignette, Visibility as IconVisibility, VisibilityOff as IconVisibilityOff, Visit as IconVisit, VisitShare as IconVisitShare, VoiceOver as IconVoiceOver, VolumeMute as IconVolumeMute, VolumeOne as IconVolumeOne, VolumeThree as IconVolumeThree, VolumeTwo as IconVolumeTwo, Watch as IconWatch, WebPage as IconWebPage, WebPages as IconWebPages, Workflow as IconWorkflow, WorkflowAdd as IconWorkflowAdd, Wrench as IconWrench, ZoomIn as IconZoomIn, ZoomOut as IconZoomOut };
