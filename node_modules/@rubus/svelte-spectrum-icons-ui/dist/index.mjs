function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function children(element) {
    return Array.from(element.childNodes);
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

/* src/AlertMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8.564 1.289L.2 16.256A.5.5 0 00.636 17h16.728a.5.5 0 00.436-.744L9.436 1.289a.5.5 0 00-.872 0zM10 14.75a.25.25\n      0 01-.25.25h-1.5a.25.25 0 01-.25-.25v-1.5a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25zm0-3a.25.25 0\n      01-.25.25h-1.5a.25.25 0 01-.25-.25v-6a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M10.563 2.206l-9.249 16.55a.5.5 0 00.436.744h18.5a.5.5 0 00.436-.744l-9.251-16.55a.5.5 0 00-.872 0zm1.436\n      15.044a.25.25 0 01-.25.25h-1.5a.25.25 0 01-.25-.25v-1.5a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25zm0-3.5a.25.25 0\n      01-.25.25h-1.5a.25.25 0 01-.25-.25v-6a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag = 14;

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "AlertMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class AlertMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/AlertSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$1(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M6.66 1.003L.157 12.643a.389.389 0 00.339.58h13.01a.389.389 0 00.34-.58L7.338 1.004a.389.389 0 00-.678 0zm1.118\n      10.47a.194.194 0 01-.195.194H6.417a.194.194 0 01-.195-.195v-1.166a.194.194 0 01.195-.195h1.166a.194.194 0\n      01.195.195zm0-2.334a.194.194 0 01-.195.194H6.417a.194.194 0 01-.195-.194V4.472a.194.194 0\n      01.195-.194h1.166a.194.194 0 01.195.194z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$1(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8.564 1.289L.2 16.256A.5.5 0 00.636 17h16.728a.5.5 0 00.436-.744L9.436 1.289a.5.5 0 00-.872 0zM10 14.75a.25.25\n      0 01-.25.25h-1.5a.25.25 0 01-.25-.25v-1.5a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25zm0-3a.25.25 0\n      01-.25.25h-1.5a.25.25 0 01-.25-.25v-6a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$1(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$1;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$1
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$1
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$1) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$1) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$1 = 14;

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "AlertSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class AlertSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowDownSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$2(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.99 6.01a1 1 0 00-1.707-.707L5 6.586V1a1 1 0 00-2 0v5.586L1.717 5.303A1 1 0 10.303 6.717l2.99 2.98a1 1 0\n      001.414 0l2.99-2.98a.997.997 0 00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$2(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.99 7.01a1 1 0 00-1.707-.707L6 8.586V1.01a1 1 0 00-2 0v7.576L1.717 6.303A1 1 0 10.303 7.717l3.99 3.98a1 1 0\n      001.414 0l3.99-3.98a.997.997 0 00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$2(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$2;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$2
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$2
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$2) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$2) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$2 = 14;

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ArrowDownSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ArrowDownSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowLeftMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$3(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M12.99 4H3.414l2.283-2.283A1 1 0 104.283.303l-3.98 3.99a1 1 0 000 1.414l3.98 3.99a1 1 0 101.414-1.414L3.414\n      6h9.576a1 1 0 100-2z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$3(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M16.99 6H3.414l4.283-4.283A1 1 0 106.283.303l-5.98 5.99a1 1 0 000 1.414l5.98 5.99a1 1 0 101.414-1.414L3.414\n      8H16.99a1 1 0 000-2z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$3(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$3;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$3
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$3
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$3) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$3) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$3 = 14;

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ArrowLeftMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ArrowLeftMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ArrowUpSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$4(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.99 3.99a1 1 0 01-1.707.707L5 3.414V9a1 1 0 01-2 0V3.414L1.717 4.697A1 1 0 11.303 3.283l2.99-2.98a1 1 0\n      011.414 0l2.99 2.98a.997.997 0 01.293.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (43:2) {#if scale === 'L'}
function create_if_block$4(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.99 4.99a1 1 0 01-1.707.707L6 3.414v7.576a1 1 0 01-2 0V3.414L1.717 5.697A1 1 0 11.303 4.283l3.99-3.98a1 1 0\n      011.414 0l3.99 3.98a.997.997 0 01.293.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$4(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$4;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$4
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$4
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$4) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$4) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$4 = 14;

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ArrowUpSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ArrowUpSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/Asterisk.svelte generated by Svelte v3.24.1 */

function create_if_block_1$5(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M6.573 6.558c.056.055.092.13 0 .204l-1.148.74c-.093.056-.13.02-.167-.073L3.832 4.947l-1.87\n      2.055c-.02.037-.075.074-.13 0l-.889-.926c-.092-.055-.074-.111 0-.167l2.111-1.76-2.408-.906c-.037\n      0-.092-.074-.055-.167l.63-1.259a.097.097 0 01.166-.036l2.111 1.37.13-2.704a.097.097 0 01.111-.11L5.277.54c.092 0\n      .11.037.092.13l-.722 2.647 2.444-.74c.056-.038.111-.038.148.073l.241 1.37c.019.093 0 .13-.074.13l-2.556.204z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$5(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.867 7.872c.061.062.103.145 0 .228l-1.283.827c-.104.061-.145.02-.186-.083L4.804 6.07l-2.09\n      2.297c-.021.042-.083.083-.145 0l-.994-1.035c-.103-.062-.082-.124 0-.186l2.36-1.966-2.691-1.014c-.042\n      0-.104-.083-.062-.186l.703-1.41a.11.11 0 01.187-.04L4.43 4.06l.145-3.02A.109.109 0 014.7.917l1.718.227c.104 0\n      .124.042.104.145l-.808 2.96 2.734-.828c.061-.042.124-.042.165.082l.27 1.532c.02.103 0 .145-.084.145l-2.856.227z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$5(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$5;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$5
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$5
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$5) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$5) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$5 = 14;

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "Asterisk" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class Asterisk extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/CheckmarkMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$6(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4.5 10a1.022 1.022 0 01-.799-.384l-2.488-3a1 1 0 011.576-1.233L4.5 7.376l4.712-5.991a1 1 0 111.576 1.23l-5.51\n      7A.978.978 0 014.5 10z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$6(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M6 14a1 1 0 01-.789-.385l-4-5a1 1 0 111.577-1.23L6 11.376l7.213-8.99a1 1 0 111.576 1.23l-8 10a1 1 0\n      01-.789.384z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$6(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$6;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$6;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$6
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$6
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$6) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$6) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$6 = 14;

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CheckmarkMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CheckmarkMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/CheckmarkSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$7(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M3.788 9A.999.999 0 013 8.615l-2.288-3a1 1 0 111.576-1.23l1.5 1.991 3.924-4.991a1 1 0 111.576 1.23l-4.712\n    6A.999.999 0 013.788 9z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$7(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4.5 11a.999.999 0 01-.788-.385l-3-4a1 1 0 111.576-1.23L4.5 8.376l5.212-6.99a1 1 0 111.576 1.23l-6 8A.999.999 0\n    014.5 11z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$7(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$7;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$7;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$7
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$7
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$7) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$7) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$7 = 14;

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CheckmarkSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CheckmarkSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronDownMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$8(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.99 1.01A1 1 0 008.283.303L5 3.586 1.717.303A1 1 0 10.303 1.717l3.99 3.98a1 1 0 001.414 0l3.99-3.98a.997.997 0\n    00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$8(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.99 1.51a1 1 0 00-1.707-.707L6 5.086 1.717.803A1 1 0 10.303 2.217l4.99 4.99a1 1 0 001.414 0l4.99-4.99a.997.997\n    0 00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$8(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$8;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$8
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$8
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$8) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$8) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$8 = 14;

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronDownMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronDownMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronDownSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$9(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4 5.5a.747.747 0 00.53-.22c.607-.577 1.97-2.038 3.24-3.24A.75.75 0 106.71.98L4 3.69 1.29.98A.75.75 0 10.23\n    2.04l3.24 3.24A.747.747 0 004 5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$9(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5 7a.747.747 0 00.53-.22l4.24-4.24a.75.75 0 10-1.06-1.06L5 5.19 1.29 1.48A.75.75 0 10.23 2.54l4.24 4.24A.747.747\n    0 005 7z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$9(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$9;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$9;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$9
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$9
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$9) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$9) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$9 = 14;

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronDownSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronDownSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronLeftLarge.svelte generated by Svelte v3.24.1 */

function create_if_block_1$a(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.605 13.843L3.55 8l6.056-5.84A1.248 1.248 0 107.876.363L.882 7.1a1.243 1.243 0 00.003 1.797l6.988 6.742a1.248\n    1.248 0 101.732-1.796z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$a(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M12.109 17.853l-8.066-7.849 8.066-7.84a1.243 1.243 0 00.381-.894 1.24 1.24 0 00-2.12-.894L1.379 9.108a1.246 1.246\n    0 00.003 1.79l8.99 8.744a1.247 1.247 0 101.738-1.789z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$a(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$a;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$a;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$a
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$a
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$a) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$a) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$a = 14;

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronLeftLarge" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronLeftLarge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronLeftMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$b(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.697 8.283L2.414 5l3.283-3.283A1 1 0 104.283.303l-3.98 3.99a1 1 0 000 1.414l3.98 3.99a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$b(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.197 10.283L2.914 6l4.283-4.283A1 1 0 105.783.303l-4.99 4.99a1 1 0 000 1.414l4.99 4.99a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$b(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$b;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$b;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$b
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$b
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$b) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$b) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$b = 14;

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronLeftMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronLeftMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronRightLarge.svelte generated by Svelte v3.24.1 */

function create_if_block_1$c(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.5 8a1.241 1.241 0 00-.386-.897L4.128.36a1.248 1.248 0 10-1.733 1.797L8.45 8l-6.058 5.84a1.248 1.248 0 101.733\n    1.797L11.117 8.9A1.245 1.245 0 0011.5 8z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$c(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M15 10.004a1.243 1.243 0 00-.38-.894L5.631.364a1.249 1.249 0 10-1.741 1.79l8.066 7.85-8.069 7.847a1.249 1.249 0\n    001.741 1.79l8.992-8.74a1.246 1.246 0 00.379-.897z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$c(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$c;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$c;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$c
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$c
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$c) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$c) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$c = 14;

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronRightLarge" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronRightLarge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronRightMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$d(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.99 5a.997.997 0 00-.293-.707L1.717.303A1 1 0 10.303 1.717L3.586 5 .303 8.283a1 1 0 101.414\n    1.414l3.98-3.99A.997.997 0 005.99 5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$d(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.5 6a.997.997 0 00-.293-.707L2.217.303A1 1 0 10.803 1.717L5.086 6 .803 10.283a1 1 0 101.414\n    1.414l4.99-4.99A.997.997 0 007.5 6z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$d(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$d;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$d;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$d
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$d
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$d) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$d) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$d = 14;

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronRightMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronRightMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronRightSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$e(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.5 4a.747.747 0 00-.22-.53C4.703 2.862 3.242 1.5 2.04.23A.75.75 0 10.98 1.29L3.69 4 .98 6.71a.75.75 0 101.06\n    1.06l3.24-3.24A.747.747 0 005.5 4z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$e(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7 5a.747.747 0 00-.22-.53L2.54.23a.75.75 0 10-1.06 1.06L5.19 5 1.48 8.71a.75.75 0 101.06 1.06l4.24-4.24A.747.747\n    0 007 5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$e(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$e;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$e;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$e
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$e
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$e) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$e) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$e = 14;

function instance$e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronRightSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronRightSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/ChevronUpSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$f(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4 .5a.747.747 0 00-.53.22C2.862 1.297 1.5 2.758.23 3.96a.75.75 0 101.06 1.06L4 2.31l2.71 2.71a.75.75 0\n    101.06-1.06L4.53.72A.747.747 0 004 .5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$f(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5 1a.747.747 0 00-.53.22L.23 5.46a.75.75 0 101.06 1.06L5 2.81l3.71 3.71a.75.75 0 101.06-1.06L5.53 1.22A.747.747\n    0 005 1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$f(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$f;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$f;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$f
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$f
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$f) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$f) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$f = 14;

function instance$f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronUpSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronUpSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/CornerTriangle.svelte generated by Svelte v3.24.1 */

function create_if_block_1$g(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4.74.01a.25.25 0 00-.177.073l-4.48 4.48a.25.25 0 00.177.427h4.48a.25.25 0 00.25-.25V.26a.25.25 0 00-.25-.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$g(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.74.01a.25.25 0 00-.177.073l-5.48 5.48a.25.25 0 00.177.427h5.48a.25.25 0 00.25-.25V.26a.25.25 0 00-.25-.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$g(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$g;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$g;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$g
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$g
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$g) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$g) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$g = 14;

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CornerTriangle" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CornerTriangle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/CrossLarge.svelte generated by Svelte v3.24.1 */

function create_if_block_1$h(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.697 10.283L7.414 6l4.283-4.283A1 1 0 1010.283.303L6 4.586 1.717.303A1 1 0 10.303 1.717L4.586 6 .303 10.283a1\n    1 0 101.414 1.414L6 7.414l4.283 4.283a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$h(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M15.697 14.283L9.414 8l6.283-6.283A1 1 0 1014.283.303L8 6.586 1.717.303A1 1 0 10.303 1.717L6.586 8 .303 14.283a1\n    1 0 101.414 1.414L8 9.414l6.283 6.283a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$h(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$h;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$h;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$h
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$h
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$h) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$h) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$h = 14;

function instance$h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CrossLarge" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CrossLarge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/CrossMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$i(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.77 6.71L5.06 4l2.71-2.71A.75.75 0 106.71.23L4 2.94 1.29.23A.75.75 0 10.23 1.29L2.94 4 .23 6.71a.75.75 0\n      101.06 1.06L4 5.06l2.71 2.71a.75.75 0 101.06-1.06z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (43:2) {#if scale === 'L'}
function create_if_block$i(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.77 8.71L6.06 5l3.71-3.71A.75.75 0 108.71.23L5 3.94 1.29.23A.75.75 0 10.23 1.29L3.94 5 .23 8.71a.75.75 0\n      101.06 1.06L5 6.06l3.71 3.71a.75.75 0 101.06-1.06z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$i(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$i;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$i;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$i
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$i
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$i) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$i) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$i = 14;

function instance$i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CrossMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CrossMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/CrossSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$j(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.317 6.433L4.884 4l2.433-2.433a.625.625 0 10-.884-.884L4 3.116 1.567.683a.625.625 0 10-.884.884L3.116 4 .683\n    6.433a.625.625 0 10.884.884L4 4.884l2.433 2.433a.625.625 0 00.884-.884z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$j(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.317 8.433L5.884 5l3.433-3.433a.625.625 0 10-.884-.884L5 4.116 1.567.683a.625.625 0 10-.884.884C.83 1.713 2.77\n    3.657 4.116 5L.683 8.433a.625.625 0 10.884.884L5 5.884l3.433 3.433a.625.625 0 00.884-.884z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$j(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$j;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$j;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$j
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$j
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$j) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$j) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$j = 14;

function instance$j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CrossSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CrossSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/DashSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$k(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8 4H2a1 1 0 000 2h6a1 1 0 000-2z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$k(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M10.99 5H1.01a1 1 0 000 2h9.98a1 1 0 100-2z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$k(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$k;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$k;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$k
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$k
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$k) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$k) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$k = 14;

function instance$k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "DashSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class DashSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/DoubleGripper.svelte generated by Svelte v3.24.1 */

function create_if_block_1$l(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M15.49 3H.51a.5.5 0 100 1h14.98a.5.5 0 100-1zM.51 1h14.98a.5.5 0 000-1H.51a.5.5 0 000 1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$l(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M19.49 4H.51a.5.5 0 100 1h18.98a.5.5 0 000-1zM.51 1h18.98a.5.5 0 000-1H.51a.5.5 0 000 1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$l(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$l;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$l;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$l
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$l
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$l) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$l) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$l = 14;

function instance$l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "DoubleGripper" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class DoubleGripper extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/FolderBreadcrumb.svelte generated by Svelte v3.24.1 */

function create_if_block_1$m(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M16.5 4l-7.166.004-1.652-1.7A1 1 0 006.965 2H2a1 1 0 00-1 1v11.5a.5.5 0 00.5.5h15a.5.5 0 00.5-.5v-10a.5.5 0\n    00-.5-.5zM2 3h4.965l1.943 2H2zm10.354 5.854l-3 3a.5.5 0 01-.707 0l-3-3a.5.5 0 01.707-.707L9 10.793l2.646-2.646a.5.5\n    0 01.707.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$m(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M19.5 6l-9.166.004-1.668-1.7A.998.998 0 007.946 4H3a1 1 0 00-1 1v13a.5.5 0 00.5.5h17a.5.5 0 00.5-.5V6.5a.5.5 0\n    00-.5-.5zm-16-.5h4.237l1.964 2H3.5zm11.544 6.044l-3.5 3.5a.77.77 0 01-1.088 0l-3.5-3.5a.77.77 0 011.088-1.088L11\n    13.41l2.956-2.955a.77.77 0 011.088 1.088z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$m(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$m;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$m;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$m
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$m
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$m) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$m) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$m = 14;

function instance$m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "FolderBreadcrumb" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class FolderBreadcrumb extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/HelpMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$n(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm1.3 12.3a1.222 1.222 0 01-.3.9 1.223 1.223 0 01-.9.3 1.2 1.2 0 010-2.4c.8 0 1.3.5\n    1.2 1.2zm.1-4.5c-.4.4-.8.8-.8 1.2a1.135 1.135 0 00.3.8v.1a.098.098 0 01-.096.1H8.4a.229.229 0 01-.2-.1 1.666 1.666 0\n    01-.4-1.1 2.772 2.772 0 011-1.7 2.772 2.772 0 001-1.7c0-.5-.4-1.1-1.4-1.1a5.018 5.018 0 00-2 .4h-.2V4.3c0-.1\n    0-.2.1-.2a6.183 6.183 0 012.4-.5c1.9 0 3.1 1.1 3.1 2.7a3.704 3.704 0 01-1.4 2.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$n(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm-.007 14.681a1.145 1.145 0 01-1.227-1.215 1.159 1.159 0\n    011.115-1.201q.056-.002.112.001a1.159 1.159 0 011.226 1.088q.003.056.001.112a1.127 1.127 0 01-1.227\n    1.215zm1.981-6.63c-.684.642-1.344 1.215-1.333 1.736a2.275 2.275 0 00.176.732.25.25 0 01-.232.343h-1.26a.3.3 0\n    01-.228-.069 1.886 1.886 0 01-.421-1.2c0-.816.508-1.336 1.35-2.17.578-.573.911-.937.911-1.475\n    0-.625-.421-1.059-1.49-1.059a5.337 5.337 0 00-2 .473.249.249 0 01-.347-.23v-1.24a.5.5 0 01.3-.459 6.413 6.413 0\n    012.434-.5c2.1.006 3.261 1.2 3.261 2.725a3.053 3.053 0 01-1.121 2.393z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$n(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$n;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$n;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$n
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$n
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$n) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$n) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$n = 14;

function instance$n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "HelpMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class HelpMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/HelpSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$o(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7 .778A6.222 6.222 0 1013.222 7 6.222 6.222 0 007 .778zm.018 10.452a1.046 1.046 0 11-.08-2.091q.04-.002.08\n      0a1.019 1.019 0 011.087.946q.003.046.002.092a1.004 1.004 0 01-1.09\n      1.053zm1.387-4.985l-.078.078c-.307.322-.655.687-.655.913a1.078 1.078 0 00.14.525l.056.108-.044.167a.24.24 0\n      01-.221.147H6.56a.338.338 0 01-.252-.091 1.6 1.6 0 01-.329-.982 2.378 2.378 0\n      01.864-1.61c.078-.086.156-.164.224-.234.245-.252.395-.416.395-.59 0-.119 0-.483-.695-.483a2.3 2.3 0\n      00-1.229.357.233.233 0 01-.254-.008l-.092-.066-.022-.175V3.174a.342.342 0 01.156-.319A3.216 3.216 0 017\n      2.425a1.985 1.985 0 012.14 2.051 2.385 2.385 0 01-.735 1.769z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (43:2) {#if scale === 'L'}
function create_if_block$o(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm.023 13.438a1.345 1.345 0 01-.104-2.688q.052-.002.104 0a1.31 1.31 0 011.397\n      1.217q.004.059.003.118a1.291 1.291 0 01-1.4 1.353zm1.783-6.409l-.1.1c-.395.414-.842.884-.842 1.175a1.386 1.386 0\n      00.179.674l.073.139-.057.215a.308.308 0 01-.284.189H8.436a.434.434 0 01-.325-.117 2.056 2.056 0\n      01-.422-1.262A3.058 3.058 0 018.8 7.071c.1-.11.2-.21.288-.3.314-.325.507-.535.507-.758 0-.154\n      0-.622-.893-.622a2.958 2.958 0 00-1.58.459.3.3 0 01-.327-.01l-.118-.085-.028-.225V4.081a.44.44 0 01.2-.41A4.135\n      4.135 0 019 3.119a2.552 2.552 0 012.751 2.636 3.067 3.067 0 01-.944 2.274z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$o(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$o;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$o;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$o
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$o
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$o) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$o) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$o = 14;

function instance$o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "HelpSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class HelpSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/InfoMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$p(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm-.15 2.15a1.359 1.359 0 011.431 1.283q.004.064.001.129A1.332 1.332 0 018.85\n    5.994a1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM11 13.5a.5.5 0 01-.5.5h-3a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5H8V9h-.5a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h2a.5.5 0 01.5.5V12h.5a.5.5 0 01.5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$p(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm-.15 2.65a1.359 1.359 0 011.431 1.283q.004.064.001.129a1.332 1.332 0 01-1.432\n    1.432 1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM13.5 16a.5.5 0 01-.5.5H9a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5h1v-4H9a.5.5 0 01-.5-.5V9a.5.5 0 01.5-.5h2.5a.5.5 0 01.5.5v5.5h1a.5.5 0 01.5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$p(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$p;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$p;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$p
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$p
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$p) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$p) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$p = 14;

function instance$p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "InfoMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class InfoMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/InfoSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$q(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7 .778A6.222 6.222 0 1013.222 7 6.222 6.222 0 007 .778zM6.883 2.45a1.057 1.057 0 011.113.998q.003.05.001.1a1.036\n    1.036 0 01-1.114 1.114A1.052 1.052 0 015.77 3.547 1.057 1.057 0 016.784 2.45q.05-.002.1.001zm1.673 8.05a.389.389 0\n    01-.39.389H5.834a.389.389 0 01-.389-.389v-.778a.389.389 0 01.39-.389h.388V7h-.389a.389.389 0\n    01-.389-.389v-.778a.389.389 0 01.39-.389h1.555a.389.389 0 01.389.39v3.5h.389a.389.389 0 01.389.388z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$q(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm-.15 2.15a1.359 1.359 0 011.431 1.283q.004.064.001.129A1.332 1.332 0 018.85\n    5.994a1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM11 13.5a.5.5 0 01-.5.5h-3a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5H8V9h-.5a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h2a.5.5 0 01.5.5V12h.5a.5.5 0 01.5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$q(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$q;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$q;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$q
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$q
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$q) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$q) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$q = 14;

function instance$q($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "InfoSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class InfoSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/Magnifier.svelte generated by Svelte v3.24.1 */

function create_if_block_1$r(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M15.77 14.71l-4.534-4.535a6.014 6.014 0 10-1.06 1.06l4.533 4.535a.75.75 0 101.061-1.06zM6.5 11A4.5 4.5 0 1111 6.5\n    4.505 4.505 0 016.5 11z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$r(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M19.77 18.71l-5.464-5.464a7.503 7.503 0 10-1.06 1.06l5.463 5.464a.75.75 0 101.061-1.06zM2.5 8.5a6 6 0 116 6 6.007\n    6.007 0 01-6-6z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$r(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$r;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$r;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$r
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$r
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$r) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$r) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$r = 14;

function instance$r($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "Magnifier" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class Magnifier extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/More.svelte generated by Svelte v3.24.1 */

function create_if_block_1$s(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 7.1A1.9 1.9 0 117.1 9 1.9 1.9 0 019 7.1zm6 0A1.9 1.9 0 1113.1 9 1.9 1.9 0 0115 7.1zm-12 0A1.9 1.9 0 111.1 9\n    1.9 1.9 0 013 7.1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$s(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 8.95A2.05 2.05 0 118.95 11 2.05 2.05 0 0111 8.95zm6 0A2.05 2.05 0 1114.95 11 2.05 2.05 0 0117 8.95zm-12\n    0A2.05 2.05 0 112.95 11 2.05 2.05 0 015 8.95z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$s(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$s;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$s;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$s
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$s
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$s) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$s) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$s = 14;

function instance$s($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "More" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class More extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/SkipLeft.svelte generated by Svelte v3.24.1 */

function create_if_block_1$t(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8.697 8.283L5.414 5l3.283-3.283A1 1 0 107.283.303l-3.99 3.99a1 1 0 000 1.414l3.99 3.99a1 1 0 101.414-1.414zM1\n      .01a1 1 0 00-1 1v7.98a1 1 0 002 0V1.01a1 1 0 00-1-1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (46:2) {#if scale === 'L'}
function create_if_block$t(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.697 10.283L5.414 6l4.283-4.283A1 1 0 108.283.303l-4.99 4.99a1 1 0 000 1.414l4.99 4.99a1 1 0 101.414-1.414zM1\n      .01a1 1 0 00-1 1v9.98a1 1 0 002 0V1.01a1 1 0 00-1-1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$t(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$t;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$t;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$t
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$t
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$t) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$t) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$t = 14;

function instance$t($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "SkipLeft" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class SkipLeft extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/SkipRight.svelte generated by Svelte v3.24.1 */

function create_if_block_1$u(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8 .01a1 1 0 00-1 1v7.98a1 1 0 102 0V1.01a1 1 0 00-1-1zM6 5a.997.997 0 00-.293-.707L1.717.303A1 1 0 10.303\n    1.717L3.586 5 .303 8.283a1 1 0 101.414 1.414l3.99-3.99A.997.997 0 006 5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$u(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 .01a1 1 0 00-1 1v9.98a1 1 0 102 0V1.01a1 1 0 00-1-1zM7 6a.997.997 0 00-.293-.707L1.717.303A1 1 0 10.303\n    1.717L4.586 6 .303 10.283a1 1 0 101.414 1.414l4.99-4.99A.997.997 0 007 6z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$u(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$u;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$u;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$u
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$u
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$u) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$u) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$u = 14;

function instance$u($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "SkipRight" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class SkipRight extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/Star.svelte generated by Svelte v3.24.1 */

function create_if_block_1$v(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.241.3l2.161 5.715 6.106.289a.255.255 0 01.147.454l-4.77 3.823 1.612 5.9a.255.255 0 01-.386.28L9.002 13.4l-5.11\n    3.358a.255.255 0 01-.386-.28l1.612-5.9-4.77-3.821A.255.255 0 01.495 6.3l6.107-.285L8.763.3a.255.255 0 01.478 0z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$v(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.361 1.68l2.259 5.975a.257.257 0 00.228.166l6.381.3a.386.386 0 01.223.686L15.467 12.8a.257.257 0\n    00-.087.268l1.684 6.162a.386.386 0 01-.584.424l-5.34-3.506a.257.257 0 00-.282 0l-5.34 3.506a.386.386 0\n    01-.584-.424l1.686-6.158a.257.257 0 00-.087-.268L1.548 8.809a.386.386 0 01.223-.686l6.381-.3a.257.257 0\n    00.228-.166l2.259-5.977a.386.386 0 01.722 0z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$v(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$v;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$v;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$v
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$v
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$v) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$v) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$v = 14;

function instance$v($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "Star" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class Star extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/StarOutline.svelte generated by Svelte v3.24.1 */

function create_if_block_1$w(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.031 2.541l1.777 4.753 5.11.241-3.987 3.2 1.336 4.913-4.266-2.782-4.282 2.808 1.352-4.937-3.987-3.2\n    5.1-.245zM9.042.412a.369.369 0 00-.349.239L6.486 6.326l-6.1.293a.375.375 0 00-.217.667l4.762 3.821L3.318 17a.376.376\n    0 00.362.475.371.371 0 00.2-.063l5.121-3.351 5.095 3.324a.371.371 0 00.2.062.376.376 0 00.363-.475l-1.595-5.866\n    4.767-3.826a.375.375 0 00-.217-.667l-6.1-.287L9.393.655a.369.369 0 00-.351-.243z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$w(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 4.9l1.231 3.255A1.777 1.777 0 0013.809 9.3l3.476.165-2.715 2.18a1.777 1.777 0 00-.6 1.855l.918\n    3.357-2.909-1.91a1.777 1.777 0 00-1.951 0l-2.909 1.91.914-3.357a1.778 1.778 0 00-.6-1.856L4.715 9.469 8.191\n    9.3a1.777 1.777 0 001.578-1.142zm0-3.458a.448.448 0 00-.426.294L8.35 7.621a.26.26 0 01-.231.168l-6.282.3a.455.455 0\n    00-.263.81l4.907 3.933a.26.26 0 01.088.271l-1.657 6.064a.457.457 0 00.44.577.45.45 0 00.249-.076l5.257-3.452a.26.26\n    0 01.285 0l5.257 3.451a.45.45 0 00.249.076.457.457 0 00.44-.577L15.43 13.1a.26.26 0 01.088-.271L20.426 8.9a.455.455\n    0 00-.263-.81l-6.282-.3a.26.26 0 01-.231-.168l-2.224-5.883A.448.448 0 0011 1.445z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$w(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$w;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$w;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$w
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$w
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$w) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$w) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$w = 14;

function instance$w($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "StarOutline" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class StarOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/SuccessMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$x(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm5.333 4.54l-6.324 8.13a.6.6 0 01-.437.23h-.037a.6.6 0 01-.425-.176l-3.893-3.9a.6.6\n    0 010-.849l.663-.663a.6.6 0 01.848 0L7.4 10.991l5.256-6.754a.6.6 0 01.843-.1l.728.566a.6.6 0 01.106.837z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$x(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm5.638 5.609L10.1 15.652a.5.5 0 01-.742.038L5.086 11.5a.5.5 0\n    010-.707l.707-.707a.5.5 0 01.707 0L9.6 13.1l5.486-6.751a.5.5 0 01.7-.073l.776.631a.5.5 0 01.076.702z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$x(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$x;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$x;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$x
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$x
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$x) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$x) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$x = 14;

function instance$x($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "SuccessMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class SuccessMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/SuccessSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$y(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7 .778A6.222 6.222 0 1013.222 7 6.222 6.222 0 007 .778zm4.148 3.53l-4.919 6.324a.467.467 0\n    01-.34.18h-.028a.467.467 0 01-.331-.138L2.502 7.641a.467.467 0 010-.66l.516-.516a.467.467 0 01.66 0l2.078 2.084\n    4.088-5.254a.467.467 0 01.655-.078l.566.44a.467.467 0 01.083.652z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$y(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm5.333 4.54l-6.324 8.13a.6.6 0 01-.437.23h-.037a.6.6 0 01-.425-.176l-3.893-3.9a.6.6\n    0 010-.849l.663-.663a.6.6 0 01.848 0L7.4 10.991l5.256-6.754a.6.6 0 01.843-.1l.728.566a.6.6 0 01.106.837z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$y(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$y;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$y;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$y
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$y
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$y) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$y) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$y = 14;

function instance$y($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "SuccessSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class SuccessSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* src/TripleGripper.svelte generated by Svelte v3.24.1 */

function create_if_block_1$z(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.49 6H.51a.5.5 0 100 1h8.98a.5.5 0 000-1zM9.49 3H.51a.5.5 0 100 1h8.98a.5.5 0 000-1zM.51 1h8.98a.5.5 0\n    000-1H.51a.5.5 0 000 1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$z(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.49 8H.51a.5.5 0 100 1h10.98a.5.5 0 100-1zM11.49 4H.51a.5.5 0 100 1h10.98a.5.5 0 000-1zM.51 1h10.98a.5.5 0\n    000-1H.51a.5.5 0 000 1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$z(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$z;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$z;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$z
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$z
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$z) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$z) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$z = 14;

function instance$z($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "TripleGripper" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class TripleGripper extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

export { AlertMedium as IconAlertMedium, AlertSmall as IconAlertSmall, ArrowDownSmall as IconArrowDownSmall, ArrowLeftMedium as IconArrowLeftMedium, ArrowUpSmall as IconArrowUpSmall, Asterisk as IconAsterisk, CheckmarkMedium as IconCheckmarkMedium, CheckmarkSmall as IconCheckmarkSmall, ChevronDownMedium as IconChevronDownMedium, ChevronDownSmall as IconChevronDownSmall, ChevronLeftLarge as IconChevronLeftLarge, ChevronLeftMedium as IconChevronLeftMedium, ChevronRightLarge as IconChevronRightLarge, ChevronRightMedium as IconChevronRightMedium, ChevronRightSmall as IconChevronRightSmall, ChevronUpSmall as IconChevronUpSmall, CornerTriangle as IconCornerTriangle, CrossLarge as IconCrossLarge, CrossMedium as IconCrossMedium, CrossSmall as IconCrossSmall, DashSmall as IconDashSmall, DoubleGripper as IconDoubleGripper, FolderBreadcrumb as IconFolderBreadcrumb, HelpMedium as IconHelpMedium, HelpSmall as IconHelpSmall, InfoMedium as IconInfoMedium, InfoSmall as IconInfoSmall, Magnifier as IconMagnifier, More as IconMore, SkipLeft as IconSkipLeft, SkipRight as IconSkipRight, Star as IconStar, StarOutline as IconStarOutline, SuccessMedium as IconSuccessMedium, SuccessSmall as IconSuccessSmall, TripleGripper as IconTripleGripper };
