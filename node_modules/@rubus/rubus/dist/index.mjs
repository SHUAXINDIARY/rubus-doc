function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +
        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}
class HtmlTag {
    constructor(anchor = null) {
        this.a = anchor;
        this.e = this.n = null;
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.h(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

/* src/packages/Accordion/Accordion.svelte generated by Svelte v3.24.1 */

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
	let div_levels = [/*$$restProps*/ ctx[0], { class: "spectrum-Accordion" }, { role: "region" }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				{ class: "spectrum-Accordion" },
				{ role: "region" }
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
	};

	return [$$restProps, $$scope, $$slots];
}

class Accordion extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/AlertMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8.564 1.289L.2 16.256A.5.5 0 00.636 17h16.728a.5.5 0 00.436-.744L9.436 1.289a.5.5 0 00-.872 0zM10 14.75a.25.25\n      0 01-.25.25h-1.5a.25.25 0 01-.25-.25v-1.5a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25zm0-3a.25.25 0\n      01-.25.25h-1.5a.25.25 0 01-.25-.25v-6a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M10.563 2.206l-9.249 16.55a.5.5 0 00.436.744h18.5a.5.5 0 00.436-.744l-9.251-16.55a.5.5 0 00-.872 0zm1.436\n      15.044a.25.25 0 01-.25.25h-1.5a.25.25 0 01-.25-.25v-1.5a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25zm0-3.5a.25.25 0\n      01-.25.25h-1.5a.25.25 0 01-.25-.25v-6a.25.25 0 01.25-.25h1.5a.25.25 0 01.25.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$1(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag = 14;

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "AlertMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class AlertMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ArrowDownSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$1(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.99 6.01a1 1 0 00-1.707-.707L5 6.586V1a1 1 0 00-2 0v5.586L1.717 5.303A1 1 0 10.303 6.717l2.99 2.98a1 1 0\n      001.414 0l2.99-2.98a.997.997 0 00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$1(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.99 7.01a1 1 0 00-1.707-.707L6 8.586V1.01a1 1 0 00-2 0v7.576L1.717 6.303A1 1 0 10.303 7.717l3.99 3.98a1 1 0\n      001.414 0l3.99-3.98a.997.997 0 00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$2(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$1;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$1
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$1
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$1) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$1) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$1 = 14;

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ArrowDownSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ArrowDownSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ArrowUpSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$2(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.99 3.99a1 1 0 01-1.707.707L5 3.414V9a1 1 0 01-2 0V3.414L1.717 4.697A1 1 0 11.303 3.283l2.99-2.98a1 1 0\n      011.414 0l2.99 2.98a.997.997 0 01.293.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (43:2) {#if scale === 'L'}
function create_if_block$2(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.99 4.99a1 1 0 01-1.707.707L6 3.414v7.576a1 1 0 01-2 0V3.414L1.717 5.697A1 1 0 11.303 4.283l3.99-3.98a1 1 0\n      011.414 0l3.99 3.98a.997.997 0 01.293.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$3(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$2;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$2
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$2
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$2) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$2) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$2 = 14;

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ArrowUpSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ArrowUpSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/Asterisk.svelte generated by Svelte v3.24.1 */

function create_if_block_1$3(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M6.573 6.558c.056.055.092.13 0 .204l-1.148.74c-.093.056-.13.02-.167-.073L3.832 4.947l-1.87\n      2.055c-.02.037-.075.074-.13 0l-.889-.926c-.092-.055-.074-.111 0-.167l2.111-1.76-2.408-.906c-.037\n      0-.092-.074-.055-.167l.63-1.259a.097.097 0 01.166-.036l2.111 1.37.13-2.704a.097.097 0 01.111-.11L5.277.54c.092 0\n      .11.037.092.13l-.722 2.647 2.444-.74c.056-.038.111-.038.148.073l.241 1.37c.019.093 0 .13-.074.13l-2.556.204z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$3(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.867 7.872c.061.062.103.145 0 .228l-1.283.827c-.104.061-.145.02-.186-.083L4.804 6.07l-2.09\n      2.297c-.021.042-.083.083-.145 0l-.994-1.035c-.103-.062-.082-.124 0-.186l2.36-1.966-2.691-1.014c-.042\n      0-.104-.083-.062-.186l.703-1.41a.11.11 0 01.187-.04L4.43 4.06l.145-3.02A.109.109 0 014.7.917l1.718.227c.104 0\n      .124.042.104.145l-.808 2.96 2.734-.828c.061-.042.124-.042.165.082l.27 1.532c.02.103 0 .145-.084.145l-2.856.227z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$4(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$3;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$3
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$3
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$3) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$3) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$3 = 14;

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "Asterisk" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class Asterisk extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CheckmarkMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$4(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4.5 10a1.022 1.022 0 01-.799-.384l-2.488-3a1 1 0 011.576-1.233L4.5 7.376l4.712-5.991a1 1 0 111.576 1.23l-5.51\n      7A.978.978 0 014.5 10z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$4(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M6 14a1 1 0 01-.789-.385l-4-5a1 1 0 111.577-1.23L6 11.376l7.213-8.99a1 1 0 111.576 1.23l-8 10a1 1 0\n      01-.789.384z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$5(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$4;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$4
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$4
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$4) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$4) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$4 = 14;

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CheckmarkMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CheckmarkMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CheckmarkSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$5(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M3.788 9A.999.999 0 013 8.615l-2.288-3a1 1 0 111.576-1.23l1.5 1.991 3.924-4.991a1 1 0 111.576 1.23l-4.712\n    6A.999.999 0 013.788 9z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$5(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4.5 11a.999.999 0 01-.788-.385l-3-4a1 1 0 111.576-1.23L4.5 8.376l5.212-6.99a1 1 0 111.576 1.23l-6 8A.999.999 0\n    014.5 11z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$6(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$5;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$5
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$5
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$5) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$5) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$5 = 14;

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CheckmarkSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CheckmarkSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ChevronDownMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$6(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.99 1.01A1 1 0 008.283.303L5 3.586 1.717.303A1 1 0 10.303 1.717l3.99 3.98a1 1 0 001.414 0l3.99-3.98a.997.997 0\n    00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$6(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.99 1.51a1 1 0 00-1.707-.707L6 5.086 1.717.803A1 1 0 10.303 2.217l4.99 4.99a1 1 0 001.414 0l4.99-4.99a.997.997\n    0 00.293-.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$7(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$6;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$6;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$6
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$6
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$6) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$6) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$6 = 14;

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronDownMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronDownMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ChevronDownSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$7(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4 5.5a.747.747 0 00.53-.22c.607-.577 1.97-2.038 3.24-3.24A.75.75 0 106.71.98L4 3.69 1.29.98A.75.75 0 10.23\n    2.04l3.24 3.24A.747.747 0 004 5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$7(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5 7a.747.747 0 00.53-.22l4.24-4.24a.75.75 0 10-1.06-1.06L5 5.19 1.29 1.48A.75.75 0 10.23 2.54l4.24 4.24A.747.747\n    0 005 7z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$8(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$7;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$7;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$7
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$7
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$7) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$7) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$7 = 14;

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronDownSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronDownSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ChevronLeftMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$8(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.697 8.283L2.414 5l3.283-3.283A1 1 0 104.283.303l-3.98 3.99a1 1 0 000 1.414l3.98 3.99a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$8(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.197 10.283L2.914 6l4.283-4.283A1 1 0 105.783.303l-4.99 4.99a1 1 0 000 1.414l4.99 4.99a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$9(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$8;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$8
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$8
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$8) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$8) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$8 = 14;

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronLeftMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronLeftMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ChevronRightMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$9(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.99 5a.997.997 0 00-.293-.707L1.717.303A1 1 0 10.303 1.717L3.586 5 .303 8.283a1 1 0 101.414\n    1.414l3.98-3.99A.997.997 0 005.99 5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$9(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.5 6a.997.997 0 00-.293-.707L2.217.303A1 1 0 10.803 1.717L5.086 6 .803 10.283a1 1 0 101.414\n    1.414l4.99-4.99A.997.997 0 007.5 6z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$a(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$9;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$9;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$9
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$9
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$9) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$9) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$9 = 14;

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronRightMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronRightMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ChevronRightSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$a(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.5 4a.747.747 0 00-.22-.53C4.703 2.862 3.242 1.5 2.04.23A.75.75 0 10.98 1.29L3.69 4 .98 6.71a.75.75 0 101.06\n    1.06l3.24-3.24A.747.747 0 005.5 4z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$a(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7 5a.747.747 0 00-.22-.53L2.54.23a.75.75 0 10-1.06 1.06L5.19 5 1.48 8.71a.75.75 0 101.06 1.06l4.24-4.24A.747.747\n    0 007 5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$b(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$a;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$a;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$a
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$a
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$a) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$a) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$a = 14;

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronRightSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronRightSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/ChevronUpSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$b(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4 .5a.747.747 0 00-.53.22C2.862 1.297 1.5 2.758.23 3.96a.75.75 0 101.06 1.06L4 2.31l2.71 2.71a.75.75 0\n    101.06-1.06L4.53.72A.747.747 0 004 .5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$b(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5 1a.747.747 0 00-.53.22L.23 5.46a.75.75 0 101.06 1.06L5 2.81l3.71 3.71a.75.75 0 101.06-1.06L5.53 1.22A.747.747\n    0 005 1z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$c(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$b;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$b;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$b
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$b
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$b) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$b) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$b = 14;

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "ChevronUpSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class ChevronUpSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CornerTriangle.svelte generated by Svelte v3.24.1 */

function create_if_block_1$c(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M4.74.01a.25.25 0 00-.177.073l-4.48 4.48a.25.25 0 00.177.427h4.48a.25.25 0 00.25-.25V.26a.25.25 0 00-.25-.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$c(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M5.74.01a.25.25 0 00-.177.073l-5.48 5.48a.25.25 0 00.177.427h5.48a.25.25 0 00.25-.25V.26a.25.25 0 00-.25-.25z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$d(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$c;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$c;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$c
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$c
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$c) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$c) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$c = 14;

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CornerTriangle" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CornerTriangle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CrossLarge.svelte generated by Svelte v3.24.1 */

function create_if_block_1$d(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.697 10.283L7.414 6l4.283-4.283A1 1 0 1010.283.303L6 4.586 1.717.303A1 1 0 10.303 1.717L4.586 6 .303 10.283a1\n    1 0 101.414 1.414L6 7.414l4.283 4.283a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$d(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M15.697 14.283L9.414 8l6.283-6.283A1 1 0 1014.283.303L8 6.586 1.717.303A1 1 0 10.303 1.717L6.586 8 .303 14.283a1\n    1 0 101.414 1.414L8 9.414l6.283 6.283a1 1 0 101.414-1.414z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$e(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$d;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$d;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$d
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$d
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$d) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$d) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$d = 14;

function instance$e($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CrossLarge" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CrossLarge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CrossMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$e(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.77 6.71L5.06 4l2.71-2.71A.75.75 0 106.71.23L4 2.94 1.29.23A.75.75 0 10.23 1.29L2.94 4 .23 6.71a.75.75 0\n      101.06 1.06L4 5.06l2.71 2.71a.75.75 0 101.06-1.06z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (43:2) {#if scale === 'L'}
function create_if_block$e(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.77 8.71L6.06 5l3.71-3.71A.75.75 0 108.71.23L5 3.94 1.29.23A.75.75 0 10.23 1.29L3.94 5 .23 8.71a.75.75 0\n      101.06 1.06L5 6.06l3.71 3.71a.75.75 0 101.06-1.06z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$f(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$e;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$e;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$e
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$e
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$e) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$e) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$e = 14;

function instance$f($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CrossMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CrossMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CrossSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$f(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7.317 6.433L4.884 4l2.433-2.433a.625.625 0 10-.884-.884L4 3.116 1.567.683a.625.625 0 10-.884.884L3.116 4 .683\n    6.433a.625.625 0 10.884.884L4 4.884l2.433 2.433a.625.625 0 00.884-.884z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$f(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.317 8.433L5.884 5l3.433-3.433a.625.625 0 10-.884-.884L5 4.116 1.567.683a.625.625 0 10-.884.884C.83 1.713 2.77\n    3.657 4.116 5L.683 8.433a.625.625 0 10.884.884L5 5.884l3.433 3.433a.625.625 0 00.884-.884z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$g(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$f;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$f;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$f
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$f
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$f) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$f) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$f = 14;

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CrossSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CrossSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/DashSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$g(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M8 4H2a1 1 0 000 2h6a1 1 0 000-2z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$g(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M10.99 5H1.01a1 1 0 000 2h9.98a1 1 0 100-2z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$h(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$g;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$g;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$g
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$g
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$g) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$g) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$g = 14;

function instance$h($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "DashSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class DashSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/FolderBreadcrumb.svelte generated by Svelte v3.24.1 */

function create_if_block_1$h(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M16.5 4l-7.166.004-1.652-1.7A1 1 0 006.965 2H2a1 1 0 00-1 1v11.5a.5.5 0 00.5.5h15a.5.5 0 00.5-.5v-10a.5.5 0\n    00-.5-.5zM2 3h4.965l1.943 2H2zm10.354 5.854l-3 3a.5.5 0 01-.707 0l-3-3a.5.5 0 01.707-.707L9 10.793l2.646-2.646a.5.5\n    0 01.707.707z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$h(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M19.5 6l-9.166.004-1.668-1.7A.998.998 0 007.946 4H3a1 1 0 00-1 1v13a.5.5 0 00.5.5h17a.5.5 0 00.5-.5V6.5a.5.5 0\n    00-.5-.5zm-16-.5h4.237l1.964 2H3.5zm11.544 6.044l-3.5 3.5a.77.77 0 01-1.088 0l-3.5-3.5a.77.77 0 011.088-1.088L11\n    13.41l2.956-2.955a.77.77 0 011.088 1.088z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$i(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$h;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$h;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$h
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$h
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$h) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$h) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$h = 14;

function instance$i($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "FolderBreadcrumb" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class FolderBreadcrumb extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/HelpMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$i(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm1.3 12.3a1.222 1.222 0 01-.3.9 1.223 1.223 0 01-.9.3 1.2 1.2 0 010-2.4c.8 0 1.3.5\n    1.2 1.2zm.1-4.5c-.4.4-.8.8-.8 1.2a1.135 1.135 0 00.3.8v.1a.098.098 0 01-.096.1H8.4a.229.229 0 01-.2-.1 1.666 1.666 0\n    01-.4-1.1 2.772 2.772 0 011-1.7 2.772 2.772 0 001-1.7c0-.5-.4-1.1-1.4-1.1a5.018 5.018 0 00-2 .4h-.2V4.3c0-.1\n    0-.2.1-.2a6.183 6.183 0 012.4-.5c1.9 0 3.1 1.1 3.1 2.7a3.704 3.704 0 01-1.4 2.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$i(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm-.007 14.681a1.145 1.145 0 01-1.227-1.215 1.159 1.159 0\n    011.115-1.201q.056-.002.112.001a1.159 1.159 0 011.226 1.088q.003.056.001.112a1.127 1.127 0 01-1.227\n    1.215zm1.981-6.63c-.684.642-1.344 1.215-1.333 1.736a2.275 2.275 0 00.176.732.25.25 0 01-.232.343h-1.26a.3.3 0\n    01-.228-.069 1.886 1.886 0 01-.421-1.2c0-.816.508-1.336 1.35-2.17.578-.573.911-.937.911-1.475\n    0-.625-.421-1.059-1.49-1.059a5.337 5.337 0 00-2 .473.249.249 0 01-.347-.23v-1.24a.5.5 0 01.3-.459 6.413 6.413 0\n    012.434-.5c2.1.006 3.261 1.2 3.261 2.725a3.053 3.053 0 01-1.121 2.393z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$j(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$i;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$i;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$i
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$i
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$i) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$i) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$i = 14;

function instance$j($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "HelpMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class HelpMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/HelpSmall.svelte generated by Svelte v3.24.1 */

function create_if_block_1$j(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M7 .778A6.222 6.222 0 1013.222 7 6.222 6.222 0 007 .778zm.018 10.452a1.046 1.046 0 11-.08-2.091q.04-.002.08\n      0a1.019 1.019 0 011.087.946q.003.046.002.092a1.004 1.004 0 01-1.09\n      1.053zm1.387-4.985l-.078.078c-.307.322-.655.687-.655.913a1.078 1.078 0 00.14.525l.056.108-.044.167a.24.24 0\n      01-.221.147H6.56a.338.338 0 01-.252-.091 1.6 1.6 0 01-.329-.982 2.378 2.378 0\n      01.864-1.61c.078-.086.156-.164.224-.234.245-.252.395-.416.395-.59 0-.119 0-.483-.695-.483a2.3 2.3 0\n      00-1.229.357.233.233 0 01-.254-.008l-.092-.066-.022-.175V3.174a.342.342 0 01.156-.319A3.216 3.216 0 017\n      2.425a1.985 1.985 0 012.14 2.051 2.385 2.385 0 01-.735 1.769z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (43:2) {#if scale === 'L'}
function create_if_block$j(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm.023 13.438a1.345 1.345 0 01-.104-2.688q.052-.002.104 0a1.31 1.31 0 011.397\n      1.217q.004.059.003.118a1.291 1.291 0 01-1.4 1.353zm1.783-6.409l-.1.1c-.395.414-.842.884-.842 1.175a1.386 1.386 0\n      00.179.674l.073.139-.057.215a.308.308 0 01-.284.189H8.436a.434.434 0 01-.325-.117 2.056 2.056 0\n      01-.422-1.262A3.058 3.058 0 018.8 7.071c.1-.11.2-.21.288-.3.314-.325.507-.535.507-.758 0-.154\n      0-.622-.893-.622a2.958 2.958 0 00-1.58.459.3.3 0 01-.327-.01l-.118-.085-.028-.225V4.081a.44.44 0 01.2-.41A4.135\n      4.135 0 019 3.119a2.552 2.552 0 012.751 2.636 3.067 3.067 0 01-.944 2.274z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$k(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$j;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$j;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$j
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$j
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$j) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$j) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$j = 14;

function instance$k($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "HelpSmall" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class HelpSmall extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/InfoMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$k(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm-.15 2.15a1.359 1.359 0 011.431 1.283q.004.064.001.129A1.332 1.332 0 018.85\n    5.994a1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM11 13.5a.5.5 0 01-.5.5h-3a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5H8V9h-.5a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h2a.5.5 0 01.5.5V12h.5a.5.5 0 01.5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$k(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm-.15 2.65a1.359 1.359 0 011.431 1.283q.004.064.001.129a1.332 1.332 0 01-1.432\n    1.432 1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM13.5 16a.5.5 0 01-.5.5H9a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5h1v-4H9a.5.5 0 01-.5-.5V9a.5.5 0 01.5-.5h2.5a.5.5 0 01.5.5v5.5h1a.5.5 0 01.5.5z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$l(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$k;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$k;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$k
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$k
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$k) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$k) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$k = 14;

function instance$l($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "InfoMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class InfoMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/Magnifier.svelte generated by Svelte v3.24.1 */

function create_if_block_1$l(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M15.77 14.71l-4.534-4.535a6.014 6.014 0 10-1.06 1.06l4.533 4.535a.75.75 0 101.061-1.06zM6.5 11A4.5 4.5 0 1111 6.5\n    4.505 4.505 0 016.5 11z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$l(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M19.77 18.71l-5.464-5.464a7.503 7.503 0 10-1.06 1.06l5.463 5.464a.75.75 0 101.061-1.06zM2.5 8.5a6 6 0 116 6 6.007\n    6.007 0 01-6-6z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$m(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$l;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$l;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$l
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$l
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$l) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$l) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$l = 14;

function instance$m($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "Magnifier" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class Magnifier extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/Star.svelte generated by Svelte v3.24.1 */

function create_if_block_1$m(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.241.3l2.161 5.715 6.106.289a.255.255 0 01.147.454l-4.77 3.823 1.612 5.9a.255.255 0 01-.386.28L9.002 13.4l-5.11\n    3.358a.255.255 0 01-.386-.28l1.612-5.9-4.77-3.821A.255.255 0 01.495 6.3l6.107-.285L8.763.3a.255.255 0 01.478 0z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$m(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11.361 1.68l2.259 5.975a.257.257 0 00.228.166l6.381.3a.386.386 0 01.223.686L15.467 12.8a.257.257 0\n    00-.087.268l1.684 6.162a.386.386 0 01-.584.424l-5.34-3.506a.257.257 0 00-.282 0l-5.34 3.506a.386.386 0\n    01-.584-.424l1.686-6.158a.257.257 0 00-.087-.268L1.548 8.809a.386.386 0 01.223-.686l6.381-.3a.257.257 0\n    00.228-.166l2.259-5.977a.386.386 0 01.722 0z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$n(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$m;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$m;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$m
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$m
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$m) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$m) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$m = 14;

function instance$n($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "Star" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class Star extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/StarOutline.svelte generated by Svelte v3.24.1 */

function create_if_block_1$n(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9.031 2.541l1.777 4.753 5.11.241-3.987 3.2 1.336 4.913-4.266-2.782-4.282 2.808 1.352-4.937-3.987-3.2\n    5.1-.245zM9.042.412a.369.369 0 00-.349.239L6.486 6.326l-6.1.293a.375.375 0 00-.217.667l4.762 3.821L3.318 17a.376.376\n    0 00.362.475.371.371 0 00.2-.063l5.121-3.351 5.095 3.324a.371.371 0 00.2.062.376.376 0 00.363-.475l-1.595-5.866\n    4.767-3.826a.375.375 0 00-.217-.667l-6.1-.287L9.393.655a.369.369 0 00-.351-.243z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$n(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 4.9l1.231 3.255A1.777 1.777 0 0013.809 9.3l3.476.165-2.715 2.18a1.777 1.777 0 00-.6 1.855l.918\n    3.357-2.909-1.91a1.777 1.777 0 00-1.951 0l-2.909 1.91.914-3.357a1.778 1.778 0 00-.6-1.856L4.715 9.469 8.191\n    9.3a1.777 1.777 0 001.578-1.142zm0-3.458a.448.448 0 00-.426.294L8.35 7.621a.26.26 0 01-.231.168l-6.282.3a.455.455 0\n    00-.263.81l4.907 3.933a.26.26 0 01.088.271l-1.657 6.064a.457.457 0 00.44.577.45.45 0 00.249-.076l5.257-3.452a.26.26\n    0 01.285 0l5.257 3.451a.45.45 0 00.249.076.457.457 0 00.44-.577L15.43 13.1a.26.26 0 01.088-.271L20.426 8.9a.455.455\n    0 00-.263-.81l-6.282-.3a.26.26 0 01-.231-.168l-2.224-5.883A.448.448 0 0011 1.445z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$o(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$n;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$n;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$n
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$n
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$n) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$n) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$n = 14;

function instance$o($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "StarOutline" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class StarOutline extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/SuccessMedium.svelte generated by Svelte v3.24.1 */

function create_if_block_1$o(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm5.333 4.54l-6.324 8.13a.6.6 0 01-.437.23h-.037a.6.6 0 01-.425-.176l-3.893-3.9a.6.6\n    0 010-.849l.663-.663a.6.6 0 01.848 0L7.4 10.991l5.256-6.754a.6.6 0 01.843-.1l.728.566a.6.6 0 01.106.837z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[10](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding_1*/ ctx[10](null);
		}
	};
}

// (45:2) {#if scale === 'L'}
function create_if_block$o(ctx) {
	let path_1;

	return {
		c() {
			path_1 = svg_element("path");
			attr(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm5.638 5.609L10.1 15.652a.5.5 0 01-.742.038L5.086 11.5a.5.5 0\n    010-.707l.707-.707a.5.5 0 01.707 0L9.6 13.1l5.486-6.751a.5.5 0 01.7-.073l.776.631a.5.5 0 01.076.702z");
		},
		m(target, anchor) {
			insert(target, path_1, anchor);
			/*path_1_binding*/ ctx[9](path_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(path_1);
			/*path_1_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$p(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$o;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$o;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[8],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$o
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$o
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || flag$o) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || flag$o) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};
}

let flag$o = 14;

function instance$p($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "SuccessMedium" } = $$props;
	let path;
	let sw;
	let sh;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class SuccessMedium extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});
	}
}

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset).
 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function}  A new, throttled, function.
 */
function throttle$1 (delay, noTrailing, callback, debounceMode) {
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */
  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  } // `noTrailing` defaults to falsy.


  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      /*
       * In throttle mode, if `delay` time has been exceeded, execute
       * `callback`.
       */
      exec();
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

function getEventsAction(component) {
  return (node) => {
    const events = Object.keys(component.$$.callbacks);
    const listeners = [];

    events.forEach((event) => listeners.push(listen(node, event, (e) => bubble(component, e))));

    return {
      destroy: () => {
        listeners.forEach((listener) => listener());
      },
    };
  };
}

/* src/packages/Accordion/AccordionItem.svelte generated by Svelte v3.24.1 */
const get_accordion_item_content_slot_changes = dirty => ({});
const get_accordion_item_content_slot_context = ctx => ({});

function create_fragment$q(ctx) {
	let div1;
	let h3;
	let button;
	let button_id_value;
	let button_aria_controls_value;
	let t0;
	let iconchevronrightmedium;
	let t1;
	let div0;
	let div0_id_value;
	let div0_aria_labelledby_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				width: /*isOpen*/ ctx[2] && /*iconWidth*/ ctx[4],
				height: /*isOpen*/ ctx[2] && /*iconHeight*/ ctx[5],
				scale: /*large*/ ctx[6] ? "L" : "M",
				focusable: "false",
				"aria-hidden": "true",
				className: "spectrum-Accordion-itemIndicator"
			}
		});

	const accordion_item_content_slot_template = /*$$slots*/ ctx[10]["accordion-item-content"];
	const accordion_item_content_slot = create_slot(accordion_item_content_slot_template, ctx, /*$$scope*/ ctx[9], get_accordion_item_content_slot_context);

	let div1_levels = [
		/*$$restProps*/ ctx[8],
		{ class: "spectrum-Accordion-item" },
		{ role: "presentation" }
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			h3 = element("h3");
			button = element("button");
			if (default_slot) default_slot.c();
			t0 = space();
			create_component(iconchevronrightmedium.$$.fragment);
			t1 = space();
			div0 = element("div");
			if (accordion_item_content_slot) accordion_item_content_slot.c();
			attr(button, "class", "spectrum-Accordion-itemHeader");
			attr(button, "type", "button");
			attr(button, "id", button_id_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-header");
			attr(button, "aria-controls", button_aria_controls_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-content");
			attr(button, "aria-expanded", "true");
			attr(h3, "class", "spectrum-Accordion-itemHeading");
			attr(div0, "class", "spectrum-Accordion-itemContent");
			attr(div0, "role", "region");
			attr(div0, "id", div0_id_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-content");
			attr(div0, "aria-labelledby", div0_aria_labelledby_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-header");
			set_attributes(div1, div1_data);
			toggle_class(div1, "is-disabled", /*disabled*/ ctx[1]);
			toggle_class(div1, "is-open", /*isOpen*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, h3);
			append(h3, button);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append(h3, t0);
			mount_component(iconchevronrightmedium, h3, null);
			append(div1, t1);
			append(div1, div0);

			if (accordion_item_content_slot) {
				accordion_item_content_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[11](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(h3, "click", switchStatus),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[7].call(null, div1))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*selfIndex*/ 1 && button_id_value !== (button_id_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-header")) {
				attr(button, "id", button_id_value);
			}

			if (!current || dirty & /*selfIndex*/ 1 && button_aria_controls_value !== (button_aria_controls_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-content")) {
				attr(button, "aria-controls", button_aria_controls_value);
			}

			const iconchevronrightmedium_changes = {};
			if (dirty & /*isOpen, iconWidth*/ 20) iconchevronrightmedium_changes.width = /*isOpen*/ ctx[2] && /*iconWidth*/ ctx[4];
			if (dirty & /*isOpen, iconHeight*/ 36) iconchevronrightmedium_changes.height = /*isOpen*/ ctx[2] && /*iconHeight*/ ctx[5];
			if (dirty & /*large*/ 64) iconchevronrightmedium_changes.scale = /*large*/ ctx[6] ? "L" : "M";
			iconchevronrightmedium.$set(iconchevronrightmedium_changes);

			if (accordion_item_content_slot) {
				if (accordion_item_content_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(accordion_item_content_slot, accordion_item_content_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_accordion_item_content_slot_changes, get_accordion_item_content_slot_context);
				}
			}

			if (!current || dirty & /*selfIndex*/ 1 && div0_id_value !== (div0_id_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-content")) {
				attr(div0, "id", div0_id_value);
			}

			if (!current || dirty & /*selfIndex*/ 1 && div0_aria_labelledby_value !== (div0_aria_labelledby_value = "spectrum-accordion-item-" + /*selfIndex*/ ctx[0] + "-header")) {
				attr(div0, "aria-labelledby", div0_aria_labelledby_value);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				{ class: "spectrum-Accordion-item" },
				{ role: "presentation" }
			]));

			toggle_class(div1, "is-disabled", /*disabled*/ ctx[1]);
			toggle_class(div1, "is-open", /*isOpen*/ ctx[2]);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(iconchevronrightmedium.$$.fragment, local);
			transition_in(accordion_item_content_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(iconchevronrightmedium.$$.fragment, local);
			transition_out(accordion_item_content_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			destroy_component(iconchevronrightmedium);
			if (accordion_item_content_slot) accordion_item_content_slot.d(detaching);
			/*div1_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function switchStatus(event) {
	let heading = event.target.closest(".spectrum-Accordion-itemHeading");

	if (heading) {
		let item = event.target.closest(".spectrum-Accordion-item");
		let isDisabled = item.classList.contains("is-disabled");

		if (!isDisabled) {
			item.classList.toggle("is-open");
			event.preventDefault();
		}
	}
}

function instance$q($$self, $$props, $$invalidate) {
	const omit_props_names = ["selfIndex","disabled","isOpen"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { selfIndex = 0 } = $$props;
	let { disabled = false } = $$props;
	let { isOpen = false } = $$props;
	const eventsListen = getEventsAction(current_component);
	const observer = new index(getIconScale);
	let accordionItem;

	afterUpdate(() => {
		throttle$1(500, observer.observe(accordionItem));
	});

	onDestroy(() => {
		observer.unobserve(accordionItem);
	});

	let iconWidth;
	let iconHeight;
	let large = false;

	function getIconScale() {
		$$invalidate(4, iconWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-75")));
		$$invalidate(5, iconHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-125")));

		if (iconWidth == 6) {
			$$invalidate(6, large = false);
		} else {
			$$invalidate(6, large = true);
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			accordionItem = $$value;
			$$invalidate(3, accordionItem);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("selfIndex" in $$new_props) $$invalidate(0, selfIndex = $$new_props.selfIndex);
		if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("isOpen" in $$new_props) $$invalidate(2, isOpen = $$new_props.isOpen);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	return [
		selfIndex,
		disabled,
		isOpen,
		accordionItem,
		iconWidth,
		iconHeight,
		large,
		eventsListen,
		$$restProps,
		$$scope,
		$$slots,
		div1_binding
	];
}

class AccordionItem extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$q, safe_not_equal, { selfIndex: 0, disabled: 1, isOpen: 2 });
	}
}

/* src/packages/ActionGroup/ActionGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$r(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-ActionGroup");
			attr(div, "style", /*styleCssText*/ ctx[5]);
			toggle_class(div, "spectrum-ActionGroup--justified", /*variants*/ ctx[1] === "justified");
			toggle_class(div, "spectrum-ActionGroup--vertical", /*orientation*/ ctx[0] === "vertical");
			toggle_class(div, "spectrum-ActionGroup--quiet", /*isQuiet*/ ctx[2]);
			toggle_class(div, "spectrum-ActionGroup--compact", /*isCompact*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[12](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			if (!current || dirty & /*styleCssText*/ 32) {
				attr(div, "style", /*styleCssText*/ ctx[5]);
			}

			if (dirty & /*variants*/ 2) {
				toggle_class(div, "spectrum-ActionGroup--justified", /*variants*/ ctx[1] === "justified");
			}

			if (dirty & /*orientation*/ 1) {
				toggle_class(div, "spectrum-ActionGroup--vertical", /*orientation*/ ctx[0] === "vertical");
			}

			if (dirty & /*isQuiet*/ 4) {
				toggle_class(div, "spectrum-ActionGroup--quiet", /*isQuiet*/ ctx[2]);
			}

			if (dirty & /*isCompact*/ 8) {
				toggle_class(div, "spectrum-ActionGroup--compact", /*isCompact*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[12](null);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let { orientation = "horizontal" } = $$props;
	let { variants = "general" } = $$props;
	let { dimension = "" } = $$props;
	let { onlyIcon = false } = $$props;
	let { isQuiet = false } = $$props;
	let { isCompact = false } = $$props;
	let { emphasized = false } = $$props;
	let { disabled = false } = $$props;
	let actionGroup;

	function addChildClassName() {
		let buttonClassName = [
			" spectrum-ActionGroup-item",
			isQuiet && "spectrum-ActionButton--quiet",
			emphasized && "spectrum-ActionButton--emphasized"
		].filter(Boolean).join(" ");

		if (actionGroup) {
			const buttonItem = actionGroup.getElementsByClassName("spectrum-ActionButton");

			if (buttonItem.length !== 0) {
				for (let index = 0; index < buttonItem.length; index++) {
					if (disabled) {
						buttonItem[index].setAttribute("disabled", disabled);
					}

					buttonItem[index].className = buttonItem[index].className + buttonClassName;
				}
			}

			if (onlyIcon && variants === "general") {
				const buttonWrapItem = actionGroup.getElementsByClassName("spectrum-Button-wrap");

				if (buttonWrapItem.length !== 0) {
					for (let index = 0; index < buttonWrapItem.length; index++) {
						buttonWrapItem[index].className = buttonWrapItem[index].className + " rubus-button-wrap";
					}
				}
			}
		}
	}

	afterUpdate(() => {
		addChildClassName();
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			actionGroup = $$value;
			$$invalidate(4, actionGroup);
		});
	}

	$$self.$$set = $$props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$props.orientation);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("dimension" in $$props) $$invalidate(6, dimension = $$props.dimension);
		if ("onlyIcon" in $$props) $$invalidate(7, onlyIcon = $$props.onlyIcon);
		if ("isQuiet" in $$props) $$invalidate(2, isQuiet = $$props.isQuiet);
		if ("isCompact" in $$props) $$invalidate(3, isCompact = $$props.isCompact);
		if ("emphasized" in $$props) $$invalidate(8, emphasized = $$props.emphasized);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*variants, orientation, dimension*/ 67) {
			 $$invalidate(5, styleCssText = [
				variants === "justified" && orientation === "horizontal" && `width:var(--spectrum-global-dimension-${dimension}, var(--spectrum-alias-${dimension}))`,
				variants === "justified" && orientation === "vertical" && `height:var(--spectrum-global-dimension-${dimension}, var(--spectrum-alias-${dimension}))`
			].filter(Boolean).join(" "));
		}
	};

	return [
		orientation,
		variants,
		isQuiet,
		isCompact,
		actionGroup,
		styleCssText,
		dimension,
		onlyIcon,
		emphasized,
		disabled,
		$$scope,
		$$slots,
		div_binding
	];
}

class ActionGroup extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
			orientation: 0,
			variants: 1,
			dimension: 6,
			onlyIcon: 7,
			isQuiet: 2,
			isCompact: 3,
			emphasized: 8,
			disabled: 9
		});
	}
}

/* src/packages/ButtonGroup/ButtonIconWrap.svelte generated by Svelte v3.24.1 */

function add_css() {
	var style = element("style");
	style.id = "svelte-eg0wja-style";
	style.textContent = ".wrap-layout.svelte-eg0wja{display:flex;align-items:center}[dir=\"ltr\"] .rubus-button-wrap{width:var(--spectrum-global-dimension-size-150);height:var(--spectrum-global-dimension-size-225);margin-left:calc(var(--spectrum-global-dimension-size-50) * -1)}[dir=\"rtl\"] .rubus-button-wrap{width:var(--spectrum-global-dimension-size-150);height:var(--spectrum-global-dimension-size-225);margin-right:calc(var(--spectrum-global-dimension-size-50) * -1)}[dir=\"ltr\"] .rubus-button-label-wrap{margin-left:var(--spectrum-global-dimension-size-40)}[dir=\"rtl\"] .rubus-button-label-wrap{margin-right:var(--spectrum-global-dimension-size-40)}";
	append(document.head, style);
}

const get_button_icon_hold_slot_changes = dirty => ({});
const get_button_icon_hold_slot_context = ctx => ({});
const get_button_wrap_label_slot_changes = dirty => ({});
const get_button_wrap_label_slot_context = ctx => ({});

function create_fragment$s(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let div2;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
	const button_wrap_label_slot_template = /*$$slots*/ ctx[2]["button-wrap-label"];
	const button_wrap_label_slot = create_slot(button_wrap_label_slot_template, ctx, /*$$scope*/ ctx[1], get_button_wrap_label_slot_context);
	const button_icon_hold_slot_template = /*$$slots*/ ctx[2]["button-icon-hold"];
	const button_icon_hold_slot = create_slot(button_icon_hold_slot_template, ctx, /*$$scope*/ ctx[1], get_button_icon_hold_slot_context);

	return {
		c() {
			div1 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			div0 = element("div");
			if (button_wrap_label_slot) button_wrap_label_slot.c();
			t1 = space();
			div2 = element("div");
			if (button_icon_hold_slot) button_icon_hold_slot.c();
			attr(div0, "class", "rubus-button-label-wrap");
			attr(div1, "class", "spectrum-Button-wrap wrap-layout svelte-eg0wja");
			toggle_class(div1, "rubus-button-wrap", /*onlyIcon*/ ctx[0]);
			attr(div2, "class", "spectrum-ActionButton-hold");
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(div1, t0);
			append(div1, div0);

			if (button_wrap_label_slot) {
				button_wrap_label_slot.m(div0, null);
			}

			insert(target, t1, anchor);
			insert(target, div2, anchor);

			if (button_icon_hold_slot) {
				button_icon_hold_slot.m(div2, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (button_wrap_label_slot) {
				if (button_wrap_label_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(button_wrap_label_slot, button_wrap_label_slot_template, ctx, /*$$scope*/ ctx[1], dirty, get_button_wrap_label_slot_changes, get_button_wrap_label_slot_context);
				}
			}

			if (dirty & /*onlyIcon*/ 1) {
				toggle_class(div1, "rubus-button-wrap", /*onlyIcon*/ ctx[0]);
			}

			if (button_icon_hold_slot) {
				if (button_icon_hold_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(button_icon_hold_slot, button_icon_hold_slot_template, ctx, /*$$scope*/ ctx[1], dirty, get_button_icon_hold_slot_changes, get_button_icon_hold_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(button_wrap_label_slot, local);
			transition_in(button_icon_hold_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(button_wrap_label_slot, local);
			transition_out(button_icon_hold_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			if (button_wrap_label_slot) button_wrap_label_slot.d(detaching);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			if (button_icon_hold_slot) button_icon_hold_slot.d(detaching);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let { onlyIcon = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("onlyIcon" in $$props) $$invalidate(0, onlyIcon = $$props.onlyIcon);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [onlyIcon, $$scope, $$slots];
}

class ButtonIconWrap extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-eg0wja-style")) add_css();
		init(this, options, instance$s, create_fragment$s, safe_not_equal, { onlyIcon: 0 });
	}
}

/* src/packages/ButtonGroup/ButtonGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$t(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-ButtonGroup");
			toggle_class(div, "spectrum-ButtonGroup--vertical", /*orientation*/ ctx[0] == "vertical");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[6](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (dirty & /*orientation*/ 1) {
				toggle_class(div, "spectrum-ButtonGroup--vertical", /*orientation*/ ctx[0] == "vertical");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[6](null);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	Promise.resolve().then(function () { return indexVars; });
	let { orientation = "horizontal" } = $$props;
	let { variant = "" } = $$props;
	let { disabled = false } = $$props;
	let buttonGroup;

	function addChildClassName() {
		let buttonClassName = [" spectrum-ButtonGroup-item", variant && `spectrum-Button--${variant}`].filter(Boolean).join(" ");

		if (buttonGroup) {
			const selectedItem = buttonGroup.getElementsByClassName("spectrum-Button");

			if (selectedItem.length !== 0) {
				for (let index = 0; index < selectedItem.length; index++) {
					if (disabled) {
						selectedItem[index].setAttribute("disabled", disabled);
					}

					selectedItem[index].className = selectedItem[index].className + buttonClassName;
				}
			}
		}
	}

	onMount(() => {
		addChildClassName();
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			buttonGroup = $$value;
			$$invalidate(1, buttonGroup);
		});
	}

	$$self.$$set = $$props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$props.orientation);
		if ("variant" in $$props) $$invalidate(2, variant = $$props.variant);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [orientation, buttonGroup, variant, disabled, $$scope, $$slots, div_binding];
}

class ButtonGroup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$t, create_fragment$t, safe_not_equal, { orientation: 0, variant: 2, disabled: 3 });
	}
}

/* src/packages/Button/Button.svelte generated by Svelte v3.24.1 */

function add_css$1() {
	var style = element("style");
	style.id = "svelte-kjl9gy-style";
	style.textContent = ".not-allowed:disabled{cursor:not-allowed}";
	append(document.head, style);
}

const get_button_icon_slot_changes_1 = dirty => ({});
const get_button_icon_slot_context_1 = ctx => ({});
const get_button_icon_slot_changes = dirty => ({});
const get_button_icon_slot_context = ctx => ({});

// (137:0) {:else}
function create_else_block_1(ctx) {
	let button;
	let current_block_type_index;
	let if_block;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_2, create_else_block_2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*exterior*/ ctx[3] == "clear" || /*exterior*/ ctx[3] == "logic-or" || /*exterior*/ ctx[3] == "logic-and") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let button_levels = [/*buttonProps*/ ctx[4], { "aria-label": /*ariaLabel*/ ctx[0] }];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = element("button");
			if_block.c();
			set_attributes(button, button_data);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[5].call(null, button));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(button, null);
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				dirty & /*buttonProps*/ 16 && /*buttonProps*/ ctx[4],
				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

// (126:0) {#if href}
function create_if_block$p(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$p, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*exterior*/ ctx[3] == "clear" || /*exterior*/ ctx[3] == "logic-or" || /*exterior*/ ctx[3] == "logic-and") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		/*buttonProps*/ ctx[4],
		{ "aria-label": /*ariaLabel*/ ctx[0] },
		{ href: /*href*/ ctx[1] },
		{ target: /*target*/ ctx[2] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if_block.c();
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[5].call(null, a));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(a, null);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*buttonProps*/ 16 && /*buttonProps*/ ctx[4],
				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] },
				(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
				(!current || dirty & /*target*/ 4) && { target: /*target*/ ctx[2] }
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

// (141:4) {:else}
function create_else_block_2(ctx) {
	let t;
	let span;
	let span_class_value;
	let current;
	const button_icon_slot_template = /*$$slots*/ ctx[17]["button-icon"];
	const button_icon_slot = create_slot(button_icon_slot_template, ctx, /*$$scope*/ ctx[16], get_button_icon_slot_context_1);
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (button_icon_slot) button_icon_slot.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();

			attr(span, "class", span_class_value = "spectrum-" + (/*exterior*/ ctx[3] == "action"
			? "ActionButton"
			: "Button") + "-label");
		},
		m(target, anchor) {
			if (button_icon_slot) {
				button_icon_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (button_icon_slot) {
				if (button_icon_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(button_icon_slot, button_icon_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_button_icon_slot_changes_1, get_button_icon_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (!current || dirty & /*exterior*/ 8 && span_class_value !== (span_class_value = "spectrum-" + (/*exterior*/ ctx[3] == "action"
			? "ActionButton"
			: "Button") + "-label")) {
				attr(span, "class", span_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(button_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(button_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (button_icon_slot) button_icon_slot.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (139:4) {#if exterior == 'clear' || exterior == 'logic-or' || exterior == 'logic-and'}
function create_if_block_2(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (130:4) {:else}
function create_else_block(ctx) {
	let t;
	let span;
	let span_class_value;
	let current;
	const button_icon_slot_template = /*$$slots*/ ctx[17]["button-icon"];
	const button_icon_slot = create_slot(button_icon_slot_template, ctx, /*$$scope*/ ctx[16], get_button_icon_slot_context);
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (button_icon_slot) button_icon_slot.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();

			attr(span, "class", span_class_value = "spectrum-" + (/*exterior*/ ctx[3] == "action"
			? "ActionButton"
			: "Button") + "-label");
		},
		m(target, anchor) {
			if (button_icon_slot) {
				button_icon_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (button_icon_slot) {
				if (button_icon_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(button_icon_slot, button_icon_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_button_icon_slot_changes, get_button_icon_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (!current || dirty & /*exterior*/ 8 && span_class_value !== (span_class_value = "spectrum-" + (/*exterior*/ ctx[3] == "action"
			? "ActionButton"
			: "Button") + "-label")) {
				attr(span, "class", span_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(button_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(button_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (button_icon_slot) button_icon_slot.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (128:4) {#if exterior == 'clear' || exterior == 'logic-or' || exterior == 'logic-and'}
function create_if_block_1$p(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$u(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$p, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"tabindex","disabled","id","ariaLabel","href","target","type","exterior","variant","isQuiet","isSelected","isSmall","emphasized","notAllowed"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { tabindex = 0 } = $$props;
	let { disabled = false } = $$props;
	let { id = "" } = $$props;
	let { ariaLabel = "button" } = $$props;
	let { href = "" } = $$props;
	let { target = "" } = $$props;
	let { type = "button" } = $$props;
	let { exterior = "general" } = $$props;
	let { variant = "cta" } = $$props;
	let { isQuiet = false } = $$props;
	let { isSelected = false } = $$props;
	let { isSmall = false } = $$props;
	let { emphasized = false } = $$props;
	let { notAllowed = false } = $$props;
	const eventsListen = getEventsAction(current_component);
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("tabindex" in $$new_props) $$invalidate(6, tabindex = $$new_props.tabindex);
		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
		if ("ariaLabel" in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(2, target = $$new_props.target);
		if ("type" in $$new_props) $$invalidate(9, type = $$new_props.type);
		if ("exterior" in $$new_props) $$invalidate(3, exterior = $$new_props.exterior);
		if ("variant" in $$new_props) $$invalidate(10, variant = $$new_props.variant);
		if ("isQuiet" in $$new_props) $$invalidate(11, isQuiet = $$new_props.isQuiet);
		if ("isSelected" in $$new_props) $$invalidate(12, isSelected = $$new_props.isSelected);
		if ("isSmall" in $$new_props) $$invalidate(13, isSmall = $$new_props.isSmall);
		if ("emphasized" in $$new_props) $$invalidate(14, emphasized = $$new_props.emphasized);
		if ("notAllowed" in $$new_props) $$invalidate(15, notAllowed = $$new_props.notAllowed);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	let buttonProps;

	$$self.$$.update = () => {
		 $$invalidate(4, buttonProps = {
			id,
			type,
			role: "button",
			tabindex,
			disabled,
			...$$restProps,
			class: [
				exterior === "general" && "spectrum-Button",
				exterior === "general" && `spectrum-Button--${variant}`,
				exterior === "general" && isQuiet && `spectrum-Button--quiet`,
				exterior === "clear" && "spectrum-ClearButton",
				exterior === "clear" && `spectrum-ClearButton--${variant}`,
				exterior === "clear" && (isSmall
				? "spectrum-ClearButton--small"
				: "spectrum-ClearButton--medium"),
				exterior === "logic-or" && "spectrum-LogicButton spectrum-LogicButton--or",
				exterior === "logic-and" && "spectrum-LogicButton spectrum-LogicButton--and",
				exterior === "action" && "spectrum-ActionButton",
				exterior === "action" && isQuiet && `spectrum-ActionButton--quiet`,
				exterior === "action" && emphasized && "spectrum-ActionButton--emphasized",
				isSelected && "is-selected",
				disabled && notAllowed && "not-allowed",
				`${$$restProps.class}`
			].filter(Boolean).join(" ")
		});
	};

	return [
		ariaLabel,
		href,
		target,
		exterior,
		buttonProps,
		eventsListen,
		tabindex,
		disabled,
		id,
		type,
		variant,
		isQuiet,
		isSelected,
		isSmall,
		emphasized,
		notAllowed,
		$$scope,
		$$slots
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-kjl9gy-style")) add_css$1();

		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
			tabindex: 6,
			disabled: 7,
			id: 8,
			ariaLabel: 0,
			href: 1,
			target: 2,
			type: 9,
			exterior: 3,
			variant: 10,
			isQuiet: 11,
			isSelected: 12,
			isSmall: 13,
			emphasized: 14,
			notAllowed: 15
		});
	}
}

function getRect(element) {
  var rect = element.getBoundingClientRect();
  var top = window.innerHeight || document.documentElement.clientTop;
  var left = window.innerWidth || document.documentElement.clientLeft;

  return {
    top: rect.top - top,
    bottom: Math.abs(rect.bottom - top),
    left: rect.left - left,
    right: Math.abs(rect.right - left),
    x: rect.x,
    y: rect.y,
    width: rect.width || element.offsetWidth,
    height: rect.height || element.offsetHeight,
  };
}

function getInTheBoxPosition(prevNode, targetNode) {
  let posWidth = 0;
  let posHeight = 0;
  let childNodesList = prevNode.childNodes;
  let targetIndex = Array.prototype.indexOf.call(targetNode.parentNode.childNodes, targetNode);

  if (targetIndex) {
    for (let index = 0; index < targetIndex; index++) {
      if (childNodesList[index].tagName) {
        posWidth = getRect(childNodesList[index]).width + posWidth;
        posHeight = getRect(childNodesList[index]).height + posHeight;
      }
    }
  }

  return [posWidth.toFixed(2), posHeight.toFixed(2)];
}

/* src/packages/Popover/Popover.svelte generated by Svelte v3.24.1 */

function add_css$2() {
	var style = element("style");
	style.id = "svelte-1gi5kx1-style";
	style.textContent = ".rubus-Popover-registering{height:var(--spectrum-global-dimension-size-75)}.spectrum-Popover{background-color:var(--spectrum-popover-background-color, var(--spectrum-global-color-gray-50));border-color:var(--spectrum-popover-border-color, var(--spectrum-alias-border-color-dark));box-shadow:0 1px 4px var(--spectrum-popover-shadow-color, var(--spectrum-alias-dropshadow-color))}.spectrum-Popover{z-index:100}.spectrum-Popover{visibility:hidden;opacity:0;transition:transform var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      opacity var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      visibility 0ms linear var(--spectrum-global-animation-duration-100, 130ms);pointer-events:none}.spectrum-Popover.is-open{visibility:visible;opacity:1;transition-delay:0ms;pointer-events:auto}.spectrum-Popover{display:inline-flex;flex-direction:column;box-sizing:border-box;min-width:var(--spectrum-global-dimension-size-400);min-height:var(--spectrum-global-dimension-size-400);position:absolute;border-style:solid;border-width:var(--spectrum-popover-border-size, var(--spectrum-alias-border-size-thin));border-radius:var(--spectrum-popover-border-radius, var(--spectrum-alias-border-radius-regular));outline:none}.spectrum-Popover-tip{position:absolute;overflow:hidden;width:calc(var(--spectrum-popover-tip-width, var(--spectrum-global-dimension-size-250)) + 1px);height:calc(\n      var(--spectrum-popover-tip-width, var(--spectrum-global-dimension-size-250)) / 2 +\n        var(--spectrum-popover-border-size, var(--spectrum-alias-border-size-thin))\n    )}.spectrum-Popover-tip{position:absolute;overflow:hidden;width:calc(var(--spectrum-popover-tip-width, var(--spectrum-global-dimension-size-250)) + 1px);height:calc(\n      var(--spectrum-popover-tip-width, var(--spectrum-global-dimension-size-250)) / 2 +\n        var(--spectrum-popover-border-size, var(--spectrum-alias-border-size-thin))\n    )}.spectrum-Popover-tip::after{content:\"\";width:var(--spectrum-popover-tip-width, var(--spectrum-global-dimension-size-250));height:var(--spectrum-popover-tip-width, var(--spectrum-global-dimension-size-250));border-width:var(--spectrum-popover-border-size, var(--spectrum-alias-border-size-thin));border-style:solid;position:absolute;transform:rotate(45deg);top:-18px}.spectrum-Popover--dialog{min-width:270px;padding:30px 29px}.spectrum-Popover .spectrum-Dialog-header,.spectrum-Popover .spectrum-Dialog-footer,.spectrum-Popover .spectrum-Dialog-wrapper{background-color:transparent}.spectrum-Popover .spectrum-Popover-tip::after{background-color:var(--spectrum-popover-background-color, var(--spectrum-global-color-gray-50));border-color:var(--spectrum-popover-border-color, var(--spectrum-alias-border-color-dark));box-shadow:-1px -1px 4px var(--spectrum-popover-shadow-color, var(--spectrum-alias-dropshadow-color))}.rubus-Popover--bottomRight{transform:translate(0, calc(-0.8 * var(--rubus-action-menu-button-height)))}.rubus-Popover-quiet--bottomRight{transform:translate(\n      calc(-1 * var(--spectrum-global-dimension-size-125)),\n      calc(-0.8 * var(--rubus-action-menu-button-height))\n    )}.rubus-Popover--bottomRight.is-open{transform:translate(0, 0)}.rubus-Popover-quiet--bottomRight.is-open{transform:translate(calc(-1 * var(--spectrum-global-dimension-size-125)), 0)}.rubus-Popover--bottomLeft{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width)),\n      calc(-0.8 * var(--rubus-action-menu-button-height))\n    )}.rubus-Popover--bottomLeft.is-open{transform:translate(calc(-1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width)), 0)}.rubus-Popover-quiet--bottomLeft{transform:translate(\n      calc(\n        -1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-125)\n      ),\n      calc(-0.8 * var(--rubus-action-menu-button-height))\n    )}.rubus-Popover-quiet--bottomLeft.is-open{transform:translate(\n      calc(\n        -1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-125)\n      ),\n      0\n    )}.rubus-Popover--topLeft{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width)),\n      calc(\n        -0.8 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-dropdown-flyout-menu-offset-y, var(--spectrum-global-dimension-size-75)))\n      )\n    )}.rubus-Popover--topLeft.is-open{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width)),\n      calc(\n        -1 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-global-dimension-size-75) * 2)\n      )\n    )}.rubus-Popover-quiet--topLeft{transform:translate(\n      calc(\n        -1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-125)\n      ),\n      calc(\n        -0.8 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-dropdown-flyout-menu-offset-y, var(--spectrum-global-dimension-size-75)))\n      )\n    )}.rubus-Popover-quiet--topLeft.is-open{transform:translate(\n      calc(\n        -1 * var(--rubus-action-menu-popover-width) + var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-125)\n      ),\n      calc(\n        -1 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-global-dimension-size-75) * 2)\n      )\n    )}.rubus-Popover--topRight{transform:translate(\n      0,\n      calc(\n        -0.8 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-dropdown-flyout-menu-offset-y, var(--spectrum-global-dimension-size-75)))\n      )\n    )}.rubus-Popover--topRight.is-open{transform:translate(\n      0,\n      calc(\n        -1 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-global-dimension-size-75) * 2)\n      )\n    )}.rubus-Popover-quiet--topRight{transform:translate(\n      calc(-1 * var(--spectrum-global-dimension-size-125)),\n      calc(\n        -0.8 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-dropdown-flyout-menu-offset-y, var(--spectrum-global-dimension-size-75)))\n      )\n    )}.rubus-Popover-quiet--topRight.is-open{transform:translate(\n      calc(-1 * var(--spectrum-global-dimension-size-125)),\n      calc(\n        -1 * (var(--rubus-action-menu-button-height) + var(--rubus-action-menu-popover-height) +\n              var(--spectrum-global-dimension-size-75) * 2)\n      )\n    )}.rubus-Popover--leftTop{transform:translate(\n      calc(-0.8 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover-quiet--leftTop{transform:translate(\n      calc(-0.8 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75) + var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover--leftTop.is-open{transform:translate(\n      calc(-1 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover-quiet--leftTop.is-open{transform:translate(\n      calc(-1 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75) + var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover--rightTop{transform:translate(\n      calc(0.8 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover--rightTop.is-open{transform:translate(\n      calc(1 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover-quiet--rightTop{transform:translate(\n      calc(0.8 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75) + var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover-quiet--rightTop.is-open{transform:translate(\n      calc(1 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-popover-height) - var(--spectrum-global-dimension-size-75) + var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover--rightBottom{transform:translate(\n      calc(0.8 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover--rightBottom.is-open{transform:translate(\n      calc(1 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover-quiet--rightBottom{transform:translate(\n      calc(0.8 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75) - var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover-quiet--rightBottom.is-open{transform:translate(\n      calc(1 * (var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75) - var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover--leftBottom{transform:translate(\n      calc(-0.8 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover-quiet--leftBottom{transform:translate(\n      calc(-0.8 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75) - var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover--leftBottom.is-open{transform:translate(\n      calc(-1 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(-1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover-quiet--leftBottom.is-open{transform:translate(\n      calc(-1 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75))),\n      calc(\n        -1 * var(--rubus-action-menu-button-height) - var(--spectrum-global-dimension-size-75) - var(--spectrum-global-dimension-size-50)\n      )\n    )}.rubus-Popover--centerBottom{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) / 2 + var(--rubus-action-menu-button-width) / 2),\n      calc(-1 * var(--spectrum-global-dimension-size-75))\n    )}.rubus-Popover--centerBottom.is-open{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) / 2 + var(--rubus-action-menu-button-width) / 2),\n      var(--spectrum-global-dimension-size-75)\n    )}.spectrum--large .rubus-Popover--centerBottom.is-open{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) / 2 + var(--rubus-action-menu-button-width) / 2),\n      var(--spectrum-global-dimension-size-125)\n    )}.spectrum--medium .rubus-Popover--centerBottom .spectrum-Popover-tip{top:calc(-0.961 * var(--spectrum-global-dimension-size-130))}.spectrum--large .rubus-Popover--centerBottom .spectrum-Popover-tip{top:calc(-1 * var(--spectrum-global-dimension-size-125))}.rubus-Popover--centerBottom .spectrum-Popover-tip{left:calc((var(--rubus-action-menu-popover-width) - var(--rubus-action-menu-popover-tip-width)) / 2);transform:rotate(180deg)}.rubus-Popover--centerTop{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) / 2 + var(--rubus-action-menu-button-width) / 2),\n      calc(\n        -0.8 * (var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n              var(--rubus-action-menu-popover-tip-height) + (var(--spectrum-global-dimension-size-75)))\n      )\n    )}.spectrum--medium .rubus-Popover--centerTop.is-open{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) / 2 + var(--rubus-action-menu-button-width) / 2),\n      calc(\n        -1 * (var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n              var(--rubus-action-menu-popover-tip-height) + (var(--spectrum-global-dimension-size-75)))\n      )\n    )}.spectrum--large .rubus-Popover--centerTop.is-open{transform:translate(\n      calc(-1 * var(--rubus-action-menu-popover-width) / 2 + var(--rubus-action-menu-button-width) / 2),\n      calc(\n        -1 * (var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n              var(--rubus-action-menu-popover-tip-height) + var(--spectrum-global-dimension-size-175))\n      )\n    )}.spectrum--medium .rubus-Popover--centerTop .spectrum-Popover-tip{bottom:calc(-0.961 * var(--spectrum-global-dimension-size-130))}.spectrum--large .rubus-Popover--centerTop .spectrum-Popover-tip{bottom:calc(-1 * var(--spectrum-global-dimension-size-125))}.rubus-Popover--centerTop .spectrum-Popover-tip{left:calc((var(--rubus-action-menu-popover-width) - var(--rubus-action-menu-popover-tip-width)) / 2);transform:rotate(0)}.rubus-Popover--centerLeft{transform:translate(\n      calc(-0.8 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75) * 2)),\n      calc(\n        -1 * ((\n                var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n                  var(--rubus-action-menu-popover-tip-height)\n              ) / 2)\n      )\n    )}.spectrum--medium .rubus-Popover--centerLeft.is-open{transform:translate(\n      calc(-1 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-75) * 2)),\n      calc(\n        -1 * ((\n                var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n                  var(--rubus-action-menu-popover-tip-height)\n              ) / 2)\n      )\n    )}.spectrum--large .rubus-Popover--centerLeft.is-open{transform:translate(\n      calc(-1 * (var(--rubus-action-menu-popover-width) + var(--spectrum-global-dimension-size-115) * 2)),\n      calc(\n        -1 * ((\n                var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n                  var(--rubus-action-menu-popover-tip-height)\n              ) / 1.9)\n      )\n    )}.spectrum--medium .rubus-Popover--centerLeft .spectrum-Popover-tip{top:calc((var(--rubus-action-menu-popover-height) - var(--rubus-action-menu-popover-tip-height)) / 2);right:calc(-0.99 * var(--spectrum-global-dimension-size-200));transform:rotate(-90deg)}.spectrum--large .rubus-Popover--centerLeft .spectrum-Popover-tip{top:calc((var(--rubus-action-menu-popover-height) - var(--rubus-action-menu-popover-tip-height)) / 2);right:calc(-0.972 * var(--spectrum-global-dimension-size-200));transform:rotate(-90deg)}.rubus-Popover--centerRight{transform:translate(\n      calc(\n        0.8 * var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75) +\n          var(--rubus-action-menu-popover-tip-width) / 3\n      ),\n      calc(\n        -1 * ((\n                var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n                  var(--rubus-action-menu-popover-tip-height)\n              ) / 2)\n      )\n    )}.spectrum--medium .rubus-Popover--centerRight.is-open{transform:translate(\n      calc(\n        var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-75) +\n          var(--rubus-action-menu-popover-tip-width) / 3\n      ),\n      calc(\n        -1 * ((\n                var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n                  var(--rubus-action-menu-popover-tip-height)\n              ) / 2)\n      )\n    )}.spectrum--large .rubus-Popover--centerRight.is-open{transform:translate(\n      calc(var(--rubus-action-menu-button-width) + var(--spectrum-global-dimension-size-115) * 2),\n      calc(\n        -1 * ((\n                var(--rubus-action-menu-popover-height) + var(--rubus-action-menu-button-height) +\n                  var(--rubus-action-menu-popover-tip-height)\n              ) / 1.9)\n      )\n    )}.spectrum--medium .rubus-Popover--centerRight .spectrum-Popover-tip{top:calc((var(--rubus-action-menu-popover-height) - var(--rubus-action-menu-popover-tip-height)) / 2);left:calc(-0.99 * var(--spectrum-global-dimension-size-200));transform:rotate(90deg)}.spectrum--large .rubus-Popover--centerRight .spectrum-Popover-tip{top:calc((var(--rubus-action-menu-popover-height) - var(--rubus-action-menu-popover-tip-height)) / 2);left:calc(-0.972 * var(--spectrum-global-dimension-size-200));transform:rotate(90deg)}";
	append(document.head, style);
}

// (617:34) 
function create_if_block_1$q(ctx) {
	let div1;
	let div0;
	let t0;
	let t1;
	let div2;
	let t2;
	let div3;
	let current;
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(/*title*/ ctx[4]);
			t1 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			t2 = space();
			div3 = element("div");
			attr(div0, "class", "spectrum-Dialog-title");
			attr(div1, "class", "spectrum-Dialog-header");
			attr(div2, "class", "spectrum-Dialog-content");
			attr(div3, "class", "spectrum-Popover-tip");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, t0);
			insert(target, t1, anchor);
			insert(target, div2, anchor);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			insert(target, t2, anchor);
			insert(target, div3, anchor);
			/*div3_binding*/ ctx[11](div3);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*title*/ 16) set_data(t0, /*title*/ ctx[4]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t2);
			if (detaching) detach(div3);
			/*div3_binding*/ ctx[11](null);
		}
	};
}

// (615:2) {#if variants === 'menu'}
function create_if_block$q(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$v(ctx) {
	let div0;
	let t;
	let div1;
	let current_block_type_index;
	let if_block;
	let div1_class_value;
	let current;
	const if_block_creators = [create_if_block$q, create_if_block_1$q];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[1] === "menu") return 0;
		if (/*variants*/ ctx[1] === "dialog") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div0 = element("div");
			t = space();
			div1 = element("div");
			if (if_block) if_block.c();
			attr(div0, "class", "rubus-Popover-registering");

			attr(div1, "class", div1_class_value = "spectrum-Popover rubus-Popover--" + (/*popverPosition*/ ctx[2] == "auto"
			? /*popverPositionAuto*/ ctx[5]
			: /*popverPosition*/ ctx[2]) + "\n    " + (/*isQuiet*/ ctx[3] && /*variants*/ ctx[1] === "menu"
			? `rubus-Popover-quiet--${/*popverPosition*/ ctx[2] == "auto"
				? /*popverPositionAuto*/ ctx[5]
				: /*popverPosition*/ ctx[2]}`
			: ``) + "\n    " + /*$$restProps*/ ctx[8].class);

			toggle_class(div1, "is-open", /*isOpen*/ ctx[0]);
			toggle_class(div1, "spectrum-Popover--dialog", /*variants*/ ctx[1] === "dialog");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t, anchor);
			insert(target, div1, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div1, null);
			}

			/*div1_binding*/ ctx[12](div1);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div1, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty & /*popverPosition, popverPositionAuto, isQuiet, variants, $$restProps*/ 302 && div1_class_value !== (div1_class_value = "spectrum-Popover rubus-Popover--" + (/*popverPosition*/ ctx[2] == "auto"
			? /*popverPositionAuto*/ ctx[5]
			: /*popverPosition*/ ctx[2]) + "\n    " + (/*isQuiet*/ ctx[3] && /*variants*/ ctx[1] === "menu"
			? `rubus-Popover-quiet--${/*popverPosition*/ ctx[2] == "auto"
				? /*popverPositionAuto*/ ctx[5]
				: /*popverPosition*/ ctx[2]}`
			: ``) + "\n    " + /*$$restProps*/ ctx[8].class)) {
				attr(div1, "class", div1_class_value);
			}

			if (dirty & /*popverPosition, popverPositionAuto, isQuiet, variants, $$restProps, isOpen*/ 303) {
				toggle_class(div1, "is-open", /*isOpen*/ ctx[0]);
			}

			if (dirty & /*popverPosition, popverPositionAuto, isQuiet, variants, $$restProps, variants*/ 302) {
				toggle_class(div1, "spectrum-Popover--dialog", /*variants*/ ctx[1] === "dialog");
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t);
			if (detaching) detach(div1);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			/*div1_binding*/ ctx[12](null);
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	const omit_props_names = ["isOpen","variants","popverPosition","isQuiet","title"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { isOpen = false } = $$props;
	let { variants = "menu" } = $$props;
	let { popverPosition = "auto" } = $$props;
	let { isQuiet = false } = $$props;
	let { title = "Popover Title" } = $$props;
	let popverPositionAuto = "bottomRight";
	let popover;
	let popoverTip;
	let menuButton;
	let menuButtonWidth;
	let menuButtonHeight;
	let popoverWidth;
	let popoverHeight;
	let popoverTipWidth;
	let popoverTipHeight;

	onMount(() => {
		setCssVar();
	});

	afterUpdate(() => {
		autoPlace();
	});

	function setCssVar() {
		if (!popover.parentElement.querySelector("#rubus-ActionSource")) {
			return;
		}

		menuButton = getRect(popover.parentElement.querySelector("#rubus-ActionSource"));
		menuButtonWidth = menuButton && menuButton.width;
		menuButtonHeight = menuButton && menuButton.height;
		popoverWidth = popover && popover.offsetWidth;
		popoverHeight = popover && popover.offsetHeight;
		popoverTipWidth = popoverTip && popoverTip.offsetWidth;
		popoverTipHeight = popoverTip && popoverTip.offsetHeight;
		popover.parentElement.style.setProperty("--rubus-action-menu-button-width", menuButtonWidth + `px`);
		popover.parentElement.style.setProperty("--rubus-action-menu-button-height", menuButtonHeight + `px`);
		popover.parentElement.style.setProperty("--rubus-action-menu-popover-width", popoverWidth + `px`);
		popover.parentElement.style.setProperty("--rubus-action-menu-popover-height", popoverHeight + `px`);
		popover.parentElement.style.setProperty("--rubus-action-menu-popover-tip-width", popoverTipWidth + `px`);
		popover.parentElement.style.setProperty("--rubus-action-menu-popover-tip-height", popoverTipHeight + `px`);
	}

	function autoPlace() {
		if (variants == "menu") {
			switch (popverPosition == "auto") {
				case menuButton.x > popoverWidth && menuButton.y > popoverHeight && menuButton.right < popoverWidth && menuButton.bottom < popoverHeight:
					$$invalidate(5, popverPositionAuto = "topLeft");
					break;
				case menuButton.x < popoverWidth && menuButton.y > popoverHeight && menuButton.right > popoverWidth && menuButton.bottom < popoverHeight:
					$$invalidate(5, popverPositionAuto = "topRight");
					break;
				case menuButton.right < popoverWidth && menuButton.x > popoverWidth:
					$$invalidate(5, popverPositionAuto = "bottomLeft");
					break;
				default:
					$$invalidate(5, popverPositionAuto = "bottomRight");
			}
		}

		if (variants == "dialog") {
			switch (popverPosition == "auto") {
				case menuButton.x > popoverWidth && menuButton.right < popoverWidth:
					$$invalidate(5, popverPositionAuto = "centerLeft");
					break;
				case menuButton.x < popoverWidth && menuButton.right > popoverWidth:
					$$invalidate(5, popverPositionAuto = "centerRight");
					break;
				case menuButton.x > popoverWidth && menuButton.y > popoverHeight && menuButton.right > popoverWidth && menuButton.bottom < popoverHeight:
					$$invalidate(5, popverPositionAuto = "centerTop");
					break;
				default:
					$$invalidate(5, popverPositionAuto = "centerBottom");
			}
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			popoverTip = $$value;
			$$invalidate(7, popoverTip);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			popover = $$value;
			$$invalidate(6, popover);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("variants" in $$new_props) $$invalidate(1, variants = $$new_props.variants);
		if ("popverPosition" in $$new_props) $$invalidate(2, popverPosition = $$new_props.popverPosition);
		if ("isQuiet" in $$new_props) $$invalidate(3, isQuiet = $$new_props.isQuiet);
		if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	return [
		isOpen,
		variants,
		popverPosition,
		isQuiet,
		title,
		popverPositionAuto,
		popover,
		popoverTip,
		$$restProps,
		$$scope,
		$$slots,
		div3_binding,
		div1_binding
	];
}

class Popover extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1gi5kx1-style")) add_css$2();

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			isOpen: 0,
			variants: 1,
			popverPosition: 2,
			isQuiet: 3,
			title: 4
		});
	}
}

/* src/packages/ActionMenu/ActionMenu.svelte generated by Svelte v3.24.1 */

function add_css$3() {
	var style = element("style");
	style.id = "svelte-rymvhj-style";
	style.textContent = ".rubus-action-menu{position:relative;display:inline-block}";
	append(document.head, style);
}

// (135:6) <div slot="button-wrap-label">
function create_button_wrap_label_slot(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*menuLabel*/ ctx[1]);
			attr(div, "slot", "button-wrap-label");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*menuLabel*/ 2) set_data(t, /*menuLabel*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (137:8) {#if holdEduce}
function create_if_block$r(ctx) {
	let iconcornertriangle;
	let current;
	iconcornertriangle = new CornerTriangle({});

	return {
		c() {
			create_component(iconcornertriangle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcornertriangle, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconcornertriangle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcornertriangle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcornertriangle, detaching);
		}
	};
}

// (136:6) <div slot="button-icon-hold">
function create_button_icon_hold_slot(ctx) {
	let div;
	let current;
	let if_block = /*holdEduce*/ ctx[8] && create_if_block$r();

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "slot", "button-icon-hold");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*holdEduce*/ ctx[8]) {
				if (if_block) {
					if (dirty & /*holdEduce*/ 256) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$r();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

// (133:4) <ButtonIconWrap onlyIcon={menuLabel == '' ? true : false}>
function create_default_slot_1(ctx) {
	let t0;
	let t1;
	let current;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			if (default_slot) default_slot.c();
			t0 = space();
			t1 = space();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (122:2) <Button     exterior="action"     on:click={showPopover}     isSelected={isOpen}     on:mousedown={showPopoverLongPress}     on:mouseup={hidePopoverLongPress}     id="rubus-ActionSource"     {isQuiet}     {emphasized}     {tabindex}     {disabled}>
function create_default_slot(ctx) {
	let buttoniconwrap;
	let current;

	buttoniconwrap = new ButtonIconWrap({
			props: {
				onlyIcon: /*menuLabel*/ ctx[1] == "" ? true : false,
				$$slots: {
					default: [create_default_slot_1],
					"button-icon-hold": [create_button_icon_hold_slot],
					"button-wrap-label": [create_button_wrap_label_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(buttoniconwrap.$$.fragment);
		},
		m(target, anchor) {
			mount_component(buttoniconwrap, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const buttoniconwrap_changes = {};
			if (dirty & /*menuLabel*/ 2) buttoniconwrap_changes.onlyIcon = /*menuLabel*/ ctx[1] == "" ? true : false;

			if (dirty & /*$$scope, holdEduce, menuLabel*/ 262402) {
				buttoniconwrap_changes.$$scope = { dirty, ctx };
			}

			buttoniconwrap.$set(buttoniconwrap_changes);
		},
		i(local) {
			if (current) return;
			transition_in(buttoniconwrap.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(buttoniconwrap.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(buttoniconwrap, detaching);
		}
	};
}

function create_fragment$w(ctx) {
	let div;
	let button;
	let t;
	let popover;
	let current;

	button = new Button({
			props: {
				exterior: "action",
				isSelected: /*isOpen*/ ctx[0],
				id: "rubus-ActionSource",
				isQuiet: /*isQuiet*/ ctx[4],
				emphasized: /*emphasized*/ ctx[5],
				tabindex: /*tabindex*/ ctx[6],
				disabled: /*disabled*/ ctx[7],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*showPopover*/ ctx[10]);
	button.$on("mousedown", /*showPopoverLongPress*/ ctx[11]);
	button.$on("mouseup", /*hidePopoverLongPress*/ ctx[12]);

	popover = new Popover({
			props: {
				isOpen: /*isOpen*/ ctx[0],
				popverPosition: /*popverPosition*/ ctx[2],
				variants: /*variants*/ ctx[3],
				isQuiet: /*isQuiet*/ ctx[4]
			}
		});

	let div_levels = [{ class: "rubus-action-menu" }, /*$$restProps*/ ctx[13]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			t = space();
			create_component(popover.$$.fragment);
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			append(div, t);
			mount_component(popover, div, null);
			/*div_binding*/ ctx[17](div);
			current = true;
		},
		p(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*isOpen*/ 1) button_changes.isSelected = /*isOpen*/ ctx[0];
			if (dirty & /*isQuiet*/ 16) button_changes.isQuiet = /*isQuiet*/ ctx[4];
			if (dirty & /*emphasized*/ 32) button_changes.emphasized = /*emphasized*/ ctx[5];
			if (dirty & /*tabindex*/ 64) button_changes.tabindex = /*tabindex*/ ctx[6];
			if (dirty & /*disabled*/ 128) button_changes.disabled = /*disabled*/ ctx[7];

			if (dirty & /*$$scope, menuLabel, holdEduce*/ 262402) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const popover_changes = {};
			if (dirty & /*isOpen*/ 1) popover_changes.isOpen = /*isOpen*/ ctx[0];
			if (dirty & /*popverPosition*/ 4) popover_changes.popverPosition = /*popverPosition*/ ctx[2];
			if (dirty & /*variants*/ 8) popover_changes.variants = /*variants*/ ctx[3];
			if (dirty & /*isQuiet*/ 16) popover_changes.isQuiet = /*isQuiet*/ ctx[4];
			popover.$set(popover_changes);

			set_attributes(div, div_data = get_spread_update(div_levels, [
				{ class: "rubus-action-menu" },
				dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13]
			]));
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(popover.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			transition_out(popover.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
			destroy_component(popover);
			/*div_binding*/ ctx[17](null);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"menuLabel","popverPosition","variants","isQuiet","emphasized","tabindex","disabled","isOpen","holdEduce","autoFold","educeDuration"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { menuLabel = "" } = $$props;
	let { popverPosition = "auto" } = $$props;
	let { variants = "menu" } = $$props;
	let { isQuiet = false } = $$props;
	let { emphasized = false } = $$props;
	let { tabindex = 0 } = $$props;
	let { disabled = false } = $$props;
	let { isOpen = false } = $$props;
	let { holdEduce = false } = $$props;
	let { autoFold = true } = $$props;
	let { educeDuration = 1000 } = $$props;
	let timer;
	let actionMenu;

	function showPopover() {
		if (holdEduce) {
			return;
		} else {
			$$invalidate(0, isOpen = !isOpen);
		}
	}

	function showPopoverLongPress() {
		timer = setTimeout(
			() => {
				$$invalidate(0, isOpen = !isOpen);
			},
			educeDuration
		);
	}

	function hidePopoverLongPress() {
		clearTimeout(timer);
	}

	onMount(() => {
		window && window.addEventListener("click", listenForOtherClicks);
		window && window.addEventListener("keyup", listenForOtherClicks);
	});

	function listenForOtherClicks(e) {
		if (!autoFold) {
			return;
		}

		if (actionMenu && !actionMenu.contains(e.target)) {
			$$invalidate(0, isOpen = false);
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			actionMenu = $$value;
			$$invalidate(9, actionMenu);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("menuLabel" in $$new_props) $$invalidate(1, menuLabel = $$new_props.menuLabel);
		if ("popverPosition" in $$new_props) $$invalidate(2, popverPosition = $$new_props.popverPosition);
		if ("variants" in $$new_props) $$invalidate(3, variants = $$new_props.variants);
		if ("isQuiet" in $$new_props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("emphasized" in $$new_props) $$invalidate(5, emphasized = $$new_props.emphasized);
		if ("tabindex" in $$new_props) $$invalidate(6, tabindex = $$new_props.tabindex);
		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("holdEduce" in $$new_props) $$invalidate(8, holdEduce = $$new_props.holdEduce);
		if ("autoFold" in $$new_props) $$invalidate(14, autoFold = $$new_props.autoFold);
		if ("educeDuration" in $$new_props) $$invalidate(15, educeDuration = $$new_props.educeDuration);
		if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	return [
		isOpen,
		menuLabel,
		popverPosition,
		variants,
		isQuiet,
		emphasized,
		tabindex,
		disabled,
		holdEduce,
		actionMenu,
		showPopover,
		showPopoverLongPress,
		hidePopoverLongPress,
		$$restProps,
		autoFold,
		educeDuration,
		$$slots,
		div_binding,
		$$scope
	];
}

class ActionMenu extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-rymvhj-style")) add_css$3();

		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
			menuLabel: 1,
			popverPosition: 2,
			variants: 3,
			isQuiet: 4,
			emphasized: 5,
			tabindex: 6,
			disabled: 7,
			isOpen: 0,
			holdEduce: 8,
			autoFold: 14,
			educeDuration: 15
		});
	}
}

/* src/packages/Alert/Alert.svelte generated by Svelte v3.24.1 */
const get_alert_content_slot_changes = dirty => ({});
const get_alert_content_slot_context = ctx => ({});
const get_alert_header_slot_changes = dirty => ({});
const get_alert_header_slot_context = ctx => ({});

// (98:32) 
function create_if_block_4(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Alert-icon",
				focusable: "false",
				"aria-hidden": "true",
				width: /*iconSize*/ ctx[4],
				height: /*iconSize*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconalertmedium_changes = {};
			if (dirty & /*iconSize*/ 16) iconalertmedium_changes.width = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconalertmedium_changes.height = /*iconSize*/ ctx[4];
			iconalertmedium.$set(iconalertmedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (91:31) 
function create_if_block_3(ctx) {
	let iconhelpmedium;
	let current;

	iconhelpmedium = new HelpMedium({
			props: {
				className: "spectrum-Alert-icon",
				focusable: "false",
				"aria-hidden": "true",
				width: /*iconSize*/ ctx[4],
				height: /*iconSize*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(iconhelpmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconhelpmedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconhelpmedium_changes = {};
			if (dirty & /*iconSize*/ 16) iconhelpmedium_changes.width = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconhelpmedium_changes.height = /*iconSize*/ ctx[4];
			iconhelpmedium.$set(iconhelpmedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconhelpmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconhelpmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconhelpmedium, detaching);
		}
	};
}

// (84:34) 
function create_if_block_2$1(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Alert-icon",
				focusable: "false",
				"aria-hidden": "true",
				width: /*iconSize*/ ctx[4],
				height: /*iconSize*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconalertmedium_changes = {};
			if (dirty & /*iconSize*/ 16) iconalertmedium_changes.width = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconalertmedium_changes.height = /*iconSize*/ ctx[4];
			iconalertmedium.$set(iconalertmedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (77:34) 
function create_if_block_1$r(ctx) {
	let iconsuccessmedium;
	let current;

	iconsuccessmedium = new SuccessMedium({
			props: {
				className: "spectrum-Alert-icon",
				focusable: "false",
				"aria-hidden": "true",
				width: /*iconSize*/ ctx[4],
				height: /*iconSize*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(iconsuccessmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsuccessmedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconsuccessmedium_changes = {};
			if (dirty & /*iconSize*/ 16) iconsuccessmedium_changes.width = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconsuccessmedium_changes.height = /*iconSize*/ ctx[4];
			iconsuccessmedium.$set(iconsuccessmedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconsuccessmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsuccessmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsuccessmedium, detaching);
		}
	};
}

// (70:2) {#if variants == 'info'}
function create_if_block$s(ctx) {
	let iconinfomedium;
	let current;

	iconinfomedium = new InfoMedium({
			props: {
				className: "spectrum-Alert-icon",
				focusable: "false",
				"aria-hidden": "true",
				width: /*iconSize*/ ctx[4],
				height: /*iconSize*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(iconinfomedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconinfomedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconinfomedium_changes = {};
			if (dirty & /*iconSize*/ 16) iconinfomedium_changes.width = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconinfomedium_changes.height = /*iconSize*/ ctx[4];
			iconinfomedium.$set(iconinfomedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconinfomedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconinfomedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconinfomedium, detaching);
		}
	};
}

// (107:30) {title}
function fallback_block_1(ctx) {
	let t;

	return {
		c() {
			t = text(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (110:31) {content}
function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text(/*content*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*content*/ 4) set_data(t, /*content*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$x(ctx) {
	let div3;
	let current_block_type_index;
	let if_block;
	let t0;
	let div0;
	let t1;
	let div1;
	let t2;
	let div2;
	let div3_class_value;
	let current;

	const if_block_creators = [
		create_if_block$s,
		create_if_block_1$r,
		create_if_block_2$1,
		create_if_block_3,
		create_if_block_4
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[0] == "info") return 0;
		if (/*variants*/ ctx[0] == "success") return 1;
		if (/*variants*/ ctx[0] == "warning") return 2;
		if (/*variants*/ ctx[0] == "help") return 3;
		if (/*variants*/ ctx[0] == "error") return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const alert_header_slot_template = /*$$slots*/ ctx[10]["alert-header"];
	const alert_header_slot = create_slot(alert_header_slot_template, ctx, /*$$scope*/ ctx[9], get_alert_header_slot_context);
	const alert_header_slot_or_fallback = alert_header_slot || fallback_block_1(ctx);
	const alert_content_slot_template = /*$$slots*/ ctx[10]["alert-content"];
	const alert_content_slot = create_slot(alert_content_slot_template, ctx, /*$$scope*/ ctx[9], get_alert_content_slot_context);
	const alert_content_slot_or_fallback = alert_content_slot || fallback_block(ctx);
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	return {
		c() {
			div3 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");
			if (alert_header_slot_or_fallback) alert_header_slot_or_fallback.c();
			t1 = space();
			div1 = element("div");
			if (alert_content_slot_or_fallback) alert_content_slot_or_fallback.c();
			t2 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "spectrum-Alert-header");
			attr(div1, "class", "spectrum-Alert-content");
			attr(div2, "class", "spectrum-Alert-footer");
			attr(div3, "class", div3_class_value = "spectrum-Alert spectrum-Alert--" + /*variants*/ ctx[0]);
			attr(div3, "style", /*styleCssText*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div3, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div3, null);
			}

			append(div3, t0);
			append(div3, div0);

			if (alert_header_slot_or_fallback) {
				alert_header_slot_or_fallback.m(div0, null);
			}

			append(div3, t1);
			append(div3, div1);

			if (alert_content_slot_or_fallback) {
				alert_content_slot_or_fallback.m(div1, null);
			}

			append(div3, t2);
			append(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			/*div3_binding*/ ctx[11](div3);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div3, t0);
				} else {
					if_block = null;
				}
			}

			if (alert_header_slot) {
				if (alert_header_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(alert_header_slot, alert_header_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_alert_header_slot_changes, get_alert_header_slot_context);
				}
			} else {
				if (alert_header_slot_or_fallback && alert_header_slot_or_fallback.p && dirty & /*title*/ 2) {
					alert_header_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (alert_content_slot) {
				if (alert_content_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(alert_content_slot, alert_content_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_alert_content_slot_changes, get_alert_content_slot_context);
				}
			} else {
				if (alert_content_slot_or_fallback && alert_content_slot_or_fallback.p && dirty & /*content*/ 4) {
					alert_content_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*variants*/ 1 && div3_class_value !== (div3_class_value = "spectrum-Alert spectrum-Alert--" + /*variants*/ ctx[0])) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*styleCssText*/ 32) {
				attr(div3, "style", /*styleCssText*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(alert_header_slot_or_fallback, local);
			transition_in(alert_content_slot_or_fallback, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(alert_header_slot_or_fallback, local);
			transition_out(alert_content_slot_or_fallback, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (alert_header_slot_or_fallback) alert_header_slot_or_fallback.d(detaching);
			if (alert_content_slot_or_fallback) alert_content_slot_or_fallback.d(detaching);
			if (default_slot) default_slot.d(detaching);
			/*div3_binding*/ ctx[11](null);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	let { variants = "info" } = $$props;
	let { title = "Alert title" } = $$props;
	let { content = "This is a default text." } = $$props;
	let { maxWidth = "" } = $$props;
	let { minWidth = "" } = $$props;
	let { minHeight = "" } = $$props;
	let alert;
	let iconSize = 18;
	const observer = new index(getIconScale);

	afterUpdate(() => {
		throttle$1(500, observer.observe(alert));
	});

	onDestroy(() => {
		observer.unobserve(alert);
	});

	function getIconScale() {
		$$invalidate(4, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-225")));
	}

	let { $$slots = {}, $$scope } = $$props;

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			alert = $$value;
			$$invalidate(3, alert);
		});
	}

	$$self.$$set = $$props => {
		if ("variants" in $$props) $$invalidate(0, variants = $$props.variants);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("content" in $$props) $$invalidate(2, content = $$props.content);
		if ("maxWidth" in $$props) $$invalidate(6, maxWidth = $$props.maxWidth);
		if ("minWidth" in $$props) $$invalidate(7, minWidth = $$props.minWidth);
		if ("minHeight" in $$props) $$invalidate(8, minHeight = $$props.minHeight);
		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*maxWidth, minWidth, minHeight*/ 448) {
			 $$invalidate(5, styleCssText = [
				maxWidth && `max-width:var(--spectrum-global-dimension-${maxWidth});`,
				minWidth && `min-width:var(--spectrum-global-dimension-${minWidth});`,
				minHeight && `min-height:var(--spectrum-global-dimension-${minWidth});`
			].filter(Boolean).join(" "));
		}
	};

	return [
		variants,
		title,
		content,
		alert,
		iconSize,
		styleCssText,
		maxWidth,
		minWidth,
		minHeight,
		$$scope,
		$$slots,
		div3_binding
	];
}

class Alert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			variants: 0,
			title: 1,
			content: 2,
			maxWidth: 6,
			minWidth: 7,
			minHeight: 8
		});
	}
}

/* src/packages/Asset/Asset.svelte generated by Svelte v3.24.1 */

function create_if_block_3$1(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (52:33) 
function create_if_block_2$2(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "class", "spectrum-Asset-folderBackground");
			attr(path0, "d", "M3,29.5c-1.4,0-2.5-1.1-2.5-2.5V5c0-1.4,1.1-2.5,2.5-2.5h10.1c0.5,0,1,0.2,1.4,0.6l3.1,3.1c0.2,0.2,0.4,0.3,0.7,0.3H29c1.4,0,2.5,1.1,2.5,2.5v18c0,1.4-1.1,2.5-2.5,2.5H3z");
			attr(path1, "class", "spectrum-Asset-folderOutline");
			attr(path1, "d", "M29,6H18.3c-0.1,0-0.2,0-0.4-0.2l-3.1-3.1C14.4,2.3,13.8,2,13.1,2H3C1.3,2,0,3.3,0,5v22c0,1.6,1.3,3,3,3h26c1.7,0,3-1.4,3-3V9C32,7.3,30.7,6,29,6z\n        M31,27c0,1.1-0.9,2-2,2H3c-1.1,0-2-0.9-2-2V7h28c1.1,0,2,0.9,2,2V27z");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "class", "spectrum-Asset-folder");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (41:31) 
function create_if_block_1$s(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "class", "spectrum-Asset-fileBackground");
			attr(path0, "d", "M24,126c-5.5,0-10-4.5-10-10V12c0-5.5,4.5-10,10-10h61.5c2.1,0,4.1,0.8,5.6,2.3l20.5,20.4c1.5,1.5,2.4,3.5,2.4,5.7V116c0,5.5-4.5,10-10,10H24z");
			attr(path1, "class", "spectrum-Asset-fileOutline");
			attr(path1, "d", "M113.1,23.3L92.6,2.9C90.7,1,88.2,0,85.5,0H24c-6.6,0-12,5.4-12,12v104c0,6.6,5.4,12,12,12h80c6.6,0,12-5.4,12-12V30.4C116,27.8,114.9,25.2,113.1,23.3z\n        M90,6l20.1,20H92c-1.1,0-2-0.9-2-2V6z\n        M112,116c0,4.4-3.6,8-8,8H24c-4.4,0-8-3.6-8-8V12c0-4.4,3.6-8,8-8h61.5c0.2,0,0.3,0,0.5,0v20c0,3.3,2.7,6,6,6h20c0,0.1,0,0.3,0,0.4V116z");
			attr(svg, "viewBox", "0 0 128 128");
			attr(svg, "class", "spectrum-Asset-file");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (35:2) {#if variants == 'image'}
function create_if_block$t(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "spectrum-Asset-image");
			attr(img, "alt", /*imgAlt*/ ctx[1]);
			if (img.src !== (img_src_value = /*imgUrl*/ ctx[0])) attr(img, "src", img_src_value);
			set_style(img, "max-width", "75%");
			set_style(img, "max-height", "75%");
			set_style(img, "object-fit", "contain");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*imgAlt*/ 2) {
				attr(img, "alt", /*imgAlt*/ ctx[1]);
			}

			if (dirty & /*imgUrl*/ 1 && img.src !== (img_src_value = /*imgUrl*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

function create_fragment$y(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$t, create_if_block_1$s, create_if_block_2$2, create_if_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[2] == "image") return 0;
		if (/*variants*/ ctx[2] == "file") return 1;
		if (/*variants*/ ctx[2] == "folder") return 2;
		if (/*variants*/ ctx[2] == "customize") return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "spectrum-Asset");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			/*div_binding*/ ctx[6](div);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			/*div_binding*/ ctx[6](null);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	let { imgUrl = "" } = $$props;
	let { imgAlt = "Asset image" } = $$props;
	let { variants = "image" } = $$props;
	let asset;

	onMount(() => {
		if (variants == "customize") {
			asset.children[0].classList.add(`spectrum-Asset-file`);
			asset.children[0].children[0] && asset.children[0].children[0].classList.add("spectrum-Asset-fileOutline");
			asset.children[0].children[1] && asset.children[0].children[1].classList.add("spectrum-Asset-fileBackground");
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			asset = $$value;
			$$invalidate(3, asset);
		});
	}

	$$self.$$set = $$props => {
		if ("imgUrl" in $$props) $$invalidate(0, imgUrl = $$props.imgUrl);
		if ("imgAlt" in $$props) $$invalidate(1, imgAlt = $$props.imgAlt);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [imgUrl, imgAlt, variants, asset, $$scope, $$slots, div_binding];
}

class Asset extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$y, create_fragment$y, safe_not_equal, { imgUrl: 0, imgAlt: 1, variants: 2 });
	}
}

/* src/packages/AssetList/AssetList.svelte generated by Svelte v3.24.1 */

function create_fragment$z(ctx) {
	let ul;
	let current;
	const default_slot_template = /*$$slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", "spectrum-AssetList");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$z($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, $$slots];
}

class AssetList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});
	}
}

const viewBoxes = {
  M: "0 0 36 36",
  L: "0 0 48 48",
};

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/Document.svelte generated by Svelte v3.24.1 */

function create_fragment$A(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 11V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V12h-9a1 1 0 0 1-1-1z");
			attr(path1, "d", "M22 2h.086a1 1 0 0 1 .707.293l6.914 6.914a1 1 0 0 1 .293.707V10h-8z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$A($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Document" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Document extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileCSV.svelte generated by Svelte v3.24.1 */

function create_fragment$B(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-8.208 16.959a.727.727 0 0\n    1-.792-.723V29.9a.65.65 0 0 1 .457-.672c1.424-.25 3.136-1.268 3.136-2.631a4.332 4.332 0 1 1 5.069-4.268 8.336 8.336\n    0 0 1-7.87 8.63z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$B($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileCSV" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileCSV extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileCode.svelte generated by Svelte v3.24.1 */

function create_fragment$C(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-4.433 15.225a.257.257 0 0\n    1-.209.408h-2.744a.257.257 0 0 1-.206-.1l-3.461-4.618 3.461-4.615a.256.256 0 0 1 .206-.1h2.744a.257.257 0 0 1\n    .209.407l-3.505 4.31zm2.766 1.844h-1.866a.514.514 0 0 1-.495-.652l3.745-13.412a.515.515 0 0 1 .5-.376h1.863a.514.514\n    0 0 1 .495.652l-3.747 13.413a.514.514 0 0 1-.494.376zm7.258-1.539a.26.26 0 0 1-.206.1h-2.743a.257.257 0 0\n    1-.209-.408l3.505-4.31-3.505-4.31a.257.257 0 0 1 .209-.407h2.744a.259.259 0 0 1 .206.1l3.461 4.615z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileCode" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileCode extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileHTML.svelte generated by Svelte v3.24.1 */

function create_fragment$D(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7.888\n    16.4h-2.8v-4h-3.2v4h-2.8V19.6h2.8v4h3.2v-4h2.8zm-10.953-1.09a.257.257 0 0 1-.209.407h-2.744a.256.256 0 0\n    1-.206-.1L9.315 25l3.461-4.615a.256.256 0 0 1 .206-.1h2.744a.257.257 0 0 1 .209.407L12.43 25z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileHTML" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileHTML extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileJson.svelte generated by Svelte v3.24.1 */

function create_fragment$E(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm-2.977 3.765a.454.454 0 0\n    1-.463.445l-1.03.084a.43.43 0 0 0-.456.401v3.083a3.97 3.97 0 0 1-1.201 2.213 4.127 4.127 0 0 1 1.201\n    2.231v3.09a.44.44 0 0 0 .464.407H15.6a.454.454 0 0 1 .464.445v1.52a.454.454 0 0 1-.464.445h-.553c-2.047\n    0-3.139-1.72-3.139-3.685v-2.316a1.939 1.939 0 0 0-.957-1.79.38.38 0 0 1 .005-.686 1.913 1.913 0 0 0\n    .952-1.8c0-.543-.008-.565-.017-2.28-.01-1.97 1.085-3.669 3.139-3.669l.53-.084a.454.454 0 0 1 .462.444zm9.025\n    6.573a1.96 1.96 0 0 0-.98 1.79v2.316c0 1.964-1.07 3.685-3.116 3.685h-.597a.454.454 0 0 1-.463-.444v-1.521a.454.454 0\n    0 1 .463-.445h1.107a.44.44 0 0 0 .464-.408v-3.089a4.127 4.127 0 0 1 1.201-2.231 3.97 3.97 0 0\n    1-1.201-2.213v-3.083a.43.43 0 0 0-.456-.4h-1.083a.454.454 0 0 1-.463-.445v-1.502a.454.454 0 0 1 .463-.445h.582c2.054\n    0 3.126 1.699 3.116 3.669-.008 1.715-.017 1.737-.017 2.28a1.933 1.933 0 0 0 .975 1.8.38.38 0 0 1 .005.686z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileJson" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileJson extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileTxt.svelte generated by Svelte v3.24.1 */

function create_fragment$F(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7 15.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0\n    1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5zm0-4a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5\n    0 0 1 .5.5zm0-4a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileTxt" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileTxt extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileXML.svelte generated by Svelte v3.24.1 */

function create_fragment$G(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1V14zm7.069 16.752h-1.931a.612.612 0 0\n    1-.59-.344s-1.41-2.4-1.908-3.271c-.6 1.1-1.215 2.213-1.83 3.289a.566.566 0 0 1-.533.325h-1.839a.476.476 0 0\n    1-.406-.725l2.94-4.8-2.872-4.757a.476.476 0 0 1 .407-.723H19.4a.67.67 0 0 1 .584.342l1.8 3.2L23.49 20.1a.67.67 0 0 1\n    .59-.353h1.786a.476.476 0 0 1 .406.724l-2.83 4.63 3.032 4.926a.476.476 0 0 1-.405.725zM14.62 29.028a.257.257 0 0\n    1-.209.408h-2.744a.257.257 0 0 1-.206-.1L8 24.718l3.461-4.618a.256.256 0 0 1 .206-.1h2.744a.257.257 0 0 1\n    .209.407l-3.505 4.31z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileXML" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileXML extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/FileZip.svelte generated by Svelte v3.24.1 */

function create_fragment$H(ctx) {
	let svg;
	let path0;
	let path1;
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			attr(path0, "d", "M20 2v10h10L20 2z");
			attr(path1, "d", "M19 14a1 1 0 0 1-1-1V2h-4v15.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V2H7a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h5v-3.5a.5.5\n    0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V34h15a1 1 0 0 0 1-1V14zm-1 13a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V17a1 1 0 0 1\n    1-1h1v4h6v-4h1a1 1 0 0 1 1 1z");
			attr(circle, "cx", circle_cx_value = 13);
			attr(circle, "cy", circle_cy_value = 24);
			attr(circle, "r", circle_r_value = 2.186);
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, circle);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "FileZip" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class FileZip extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-workflow/src/Folder.svelte generated by Svelte v3.24.1 */

function create_fragment$I(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	let svg_levels = [
		{
			viewBox: svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]
		},
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[6],
		{
			width: svg_width_value = /*width*/ ctx[1] !== "100%"
			? /*width*/ ctx[1]
			: /*autoScale*/ ctx[5]
		},
		{
			height: svg_height_value = /*height*/ ctx[2] !== "100%"
			? /*height*/ ctx[2]
			: /*autoScale*/ ctx[5]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M33 8l-14.332.008-3.3-3.4A2 2 0 0 0 13.929 4H4a2 2 0 0 0-2 2v23a1 1 0 0 0 1 1h30a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zM4\n    6h9.929l3.887 4H4z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*scale*/ 1 && svg_viewBox_value !== (svg_viewBox_value = viewBoxes[/*scale*/ ctx[0]]) && { viewBox: svg_viewBox_value },
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*width, autoScale*/ 34 && svg_width_value !== (svg_width_value = /*width*/ ctx[1] !== "100%"
				? /*width*/ ctx[1]
				: /*autoScale*/ ctx[5]) && { width: svg_width_value },
				dirty & /*height, autoScale*/ 36 && svg_height_value !== (svg_height_value = /*height*/ ctx[2] !== "100%"
				? /*height*/ ctx[2]
				: /*autoScale*/ ctx[5]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 8 && svg_class_value !== (svg_class_value = "spectrum-Icon spectrum-Icon-workflow " + /*className*/ ctx[3]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","width","height","className","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { scale = "M" } = $$props;
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { className = "" } = $$props;
	let { ariaLabel = "Folder" } = $$props;
	let autoScale = 18;

	afterUpdate(() => {
		let rootClassName = document && document.documentElement.className;

		if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
			$$invalidate(5, autoScale = 22);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("width" in $$new_props) $$invalidate(1, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
		if ("className" in $$new_props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	return [scale, width, height, className, ariaLabel, autoScale, $$restProps];
}

class Folder extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
			scale: 0,
			width: 1,
			height: 2,
			className: 3,
			ariaLabel: 4
		});
	}
}

/* src/packages/Checkbox/Checkbox.svelte generated by Svelte v3.24.1 */

const { document: document_1 } = globals;

function add_css$4() {
	var style = element("style");
	style.id = "svelte-1ysd195-style";
	style.textContent = ".readonly{pointer-events:none}";
	append(document_1.head, style);
}

// (143:0) {:else}
function create_else_block$1(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_4$1(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_3$2(ctx);
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let label_levels = [
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot) default_slot.c();
			attr(input, "type", "checkbox");
			attr(input, "class", "spectrum-Checkbox-input");
			attr(input, "id", /*id*/ ctx[7]);
			attr(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.__value = /*value*/ ctx[8];
			input.value = input.__value;
			if (/*checked*/ ctx[0] === void 0 || /*indeterminate*/ ctx[1] === void 0) add_render_callback(() => /*input_change_handler*/ ctx[19].call(input));
			attr(span0, "class", "spectrum-Checkbox-box");
			attr(span1, "class", "spectrum-Checkbox-label");
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, input);
			/*input_binding_1*/ ctx[18](input);
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			append(label, t0);
			append(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append(label, t2);
			append(label, span1);

			if (default_slot) {
				default_slot.m(span1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[19]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[13].call(null, label))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (!current || dirty & /*value*/ 256) {
				input.__value = /*value*/ ctx[8];
				input.value = input.__value;
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*indeterminate*/ 2) {
				input.indeterminate = /*indeterminate*/ ctx[1];
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			/*input_binding_1*/ ctx[18](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (100:0) {#if readonly}
function create_if_block$u(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let current;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_2$3(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_1$t(ctx);
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const default_slot_or_fallback = default_slot || fallback_block$1();

	let label_levels = [
		{ title: /*title*/ ctx[9] },
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(input, "type", "checkbox");
			attr(input, "class", "spectrum-Checkbox-input");
			attr(input, "id", /*id*/ ctx[7]);
			attr(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.value = /*value*/ ctx[8];
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			attr(span0, "class", "spectrum-Checkbox-box");
			attr(span1, "class", "spectrum-Checkbox-label");
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, input);
			/*input_binding*/ ctx[17](input);
			append(label, t0);
			append(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append(label, t2);
			append(label, span1);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (!current || dirty & /*value*/ 256) {
				input.value = /*value*/ ctx[8];
			}

			if (!current || dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (!current || dirty & /*indeterminate*/ 2) {
				input.indeterminate = /*indeterminate*/ ctx[1];
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$t(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*title*/ 512) && { title: /*title*/ ctx[9] },
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			/*input_binding*/ ctx[17](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (163:6) {#if checked}
function create_if_block_4$1(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};
}

// (172:6) {#if indeterminate}
function create_if_block_3$2(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(icondashsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};
}

// (120:6) {#if checked}
function create_if_block_2$3(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};
}

// (129:6) {#if indeterminate}
function create_if_block_1$t(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(icondashsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};
}

// (140:12) Checkbox
function fallback_block$1(ctx) {
	let t;

	return {
		c() {
			t = text("Checkbox");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$J(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$u, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*readonly*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"checked","disabled","isInvalid","isQuiet","indeterminate","readonly","name","id","value","title"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { indeterminate = false } = $$props;
	let { readonly = false } = $$props;
	let { name = "" } = $$props;
	let { id = "checkbox-" + Math.random().toString(24) } = $$props;
	let { value = "" } = $$props;
	let { title = "" } = $$props;
	let checkbox;
	let iconSize = 10;
	let large = false;
	const eventsListen = getEventsAction(current_component);
	const observer = new index(getIconScale);

	afterUpdate(() => {
		throttle$1(500, observer.observe(checkbox));
	});

	onDestroy(() => {
		observer.unobserve(checkbox);
	});

	function getIconScale() {
		$$invalidate(11, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-125")));

		if (iconSize == 10) {
			$$invalidate(12, large = false);
		} else {
			$$invalidate(12, large = true);
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_change_handler() {
		checked = this.checked;
		indeterminate = this.indeterminate;
		$$invalidate(0, checked);
		$$invalidate(1, indeterminate);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$new_props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$new_props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$new_props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$new_props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$new_props) $$invalidate(9, title = $$new_props.title);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	return [
		checked,
		indeterminate,
		disabled,
		isInvalid,
		isQuiet,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		$$restProps,
		$$scope,
		$$slots,
		input_binding,
		input_binding_1,
		input_change_handler
	];
}

class Checkbox extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1.getElementById("svelte-1ysd195-style")) add_css$4();

		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
			checked: 0,
			disabled: 2,
			isInvalid: 3,
			isQuiet: 4,
			indeterminate: 1,
			readonly: 5,
			name: 6,
			id: 7,
			value: 8,
			title: 9
		});
	}
}

/* src/packages/AssetList/AssetListItem.svelte generated by Svelte v3.24.1 */

function add_css$5() {
	var style = element("style");
	style.id = "svelte-1suyta4-style";
	style.textContent = "[dir=\"ltr\"] .spectrum-AssetList-itemSelector{margin-right:0 !important}[dir=\"rtl\"] .spectrum-AssetList-itemSelector{margin-left:0 !important}.spectrum-AssetList-item-disabled{pointer-events:none}.spectrum-AssetList-itemThumbnail-disabled,.spectrum-AssetList-itemLabel-disabled{color:var(--spectrum-alias-icon-color-disabled)}.spectrum-AssetList-item>.spectrum-AssetList-itemSelector-files{visibility:hidden}.spectrum-AssetList-item:hover>.spectrum-AssetList-itemSelector-files{visibility:visible}.is-selected>.spectrum-AssetList-itemSelector-files{visibility:visible}";
	append(document.head, style);
}

// (109:2) {#if exterior === 'branches'}
function create_if_block_10(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[12].call(null, value);
	}

	let checkbox_props = {
		isQuiet: true,
		class: "spectrum-AssetList-itemSelector",
		disabled: /*disabled*/ ctx[6]
	};

	if (/*isSelected*/ ctx[0] !== void 0) {
		checkbox_props.checked = /*isSelected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*disabled*/ 64) checkbox_changes.disabled = /*disabled*/ ctx[6];

			if (!updating_checked && dirty & /*isSelected*/ 1) {
				updating_checked = true;
				checkbox_changes.checked = /*isSelected*/ ctx[0];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

// (135:31) 
function create_if_block_9(ctx) {
	let iconfilecode;
	let current;

	iconfilecode = new FileCode({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfilecode.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfilecode, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfilecode_changes = {};
			if (dirty & /*disabled*/ 64) iconfilecode_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfilecode.$set(iconfilecode_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfilecode.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfilecode.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfilecode, detaching);
		}
	};
}

// (132:31) 
function create_if_block_8(ctx) {
	let iconfilejson;
	let current;

	iconfilejson = new FileJson({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfilejson.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfilejson, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfilejson_changes = {};
			if (dirty & /*disabled*/ 64) iconfilejson_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfilejson.$set(iconfilejson_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfilejson.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfilejson.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfilejson, detaching);
		}
	};
}

// (129:30) 
function create_if_block_7(ctx) {
	let iconfiletxt;
	let current;

	iconfiletxt = new FileTxt({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfiletxt.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfiletxt, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfiletxt_changes = {};
			if (dirty & /*disabled*/ 64) iconfiletxt_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfiletxt.$set(iconfiletxt_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfiletxt.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfiletxt.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfiletxt, detaching);
		}
	};
}

// (126:30) 
function create_if_block_6(ctx) {
	let iconfilezip;
	let current;

	iconfilezip = new FileZip({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfilezip.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfilezip, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfilezip_changes = {};
			if (dirty & /*disabled*/ 64) iconfilezip_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfilezip.$set(iconfilezip_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfilezip.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfilezip.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfilezip, detaching);
		}
	};
}

// (123:30) 
function create_if_block_5(ctx) {
	let iconfilexml;
	let current;

	iconfilexml = new FileXML({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfilexml.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfilexml, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfilexml_changes = {};
			if (dirty & /*disabled*/ 64) iconfilexml_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfilexml.$set(iconfilexml_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfilexml.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfilexml.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfilexml, detaching);
		}
	};
}

// (120:31) 
function create_if_block_4$2(ctx) {
	let iconfilehtml;
	let current;

	iconfilehtml = new FileHTML({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfilehtml.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfilehtml, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfilehtml_changes = {};
			if (dirty & /*disabled*/ 64) iconfilehtml_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfilehtml.$set(iconfilehtml_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfilehtml.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfilehtml.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfilehtml, detaching);
		}
	};
}

// (117:30) 
function create_if_block_3$3(ctx) {
	let iconfilecsv;
	let current;

	iconfilecsv = new FileCSV({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfilecsv.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfilecsv, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfilecsv_changes = {};
			if (dirty & /*disabled*/ 64) iconfilecsv_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfilecsv.$set(iconfilecsv_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfilecsv.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfilecsv.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfilecsv, detaching);
		}
	};
}

// (114:33) 
function create_if_block_2$4(ctx) {
	let iconfolder;
	let current;

	iconfolder = new Folder({
			props: {
				className: "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`)
			}
		});

	return {
		c() {
			create_component(iconfolder.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfolder, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfolder_changes = {};
			if (dirty & /*disabled*/ 64) iconfolder_changes.className = "spectrum-AssetList-itemThumbnail " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemThumbnail-disabled`);
			iconfolder.$set(iconfolder_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfolder.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfolder.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfolder, detaching);
		}
	};
}

// (112:2) {#if variants == 'image'}
function create_if_block_1$u(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "spectrum-AssetList-itemThumbnail");
			attr(img, "alt", /*imgAlt*/ ctx[2]);
			if (img.src !== (img_src_value = /*imgUrl*/ ctx[1])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*imgAlt*/ 4) {
				attr(img, "alt", /*imgAlt*/ ctx[2]);
			}

			if (dirty & /*imgUrl*/ 2 && img.src !== (img_src_value = /*imgUrl*/ ctx[1])) {
				attr(img, "src", img_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (140:10) {label}
function fallback_block$2(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 128) set_data(t, /*label*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (142:2) {#if exterior === 'files' && !isBranch}
function create_if_block$v(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding_1(value) {
		/*checkbox_checked_binding_1*/ ctx[13].call(null, value);
	}

	let checkbox_props = {
		class: "spectrum-AssetList-itemSelector spectrum-AssetList-itemSelector-files",
		isQuiet: true,
		disabled: /*disabled*/ ctx[6]
	};

	if (/*isSelected*/ ctx[0] !== void 0) {
		checkbox_props.checked = /*isSelected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*disabled*/ 64) checkbox_changes.disabled = /*disabled*/ ctx[6];

			if (!updating_checked && dirty & /*isSelected*/ 1) {
				updating_checked = true;
				checkbox_changes.checked = /*isSelected*/ ctx[0];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

function create_fragment$K(ctx) {
	let li;
	let t0;
	let current_block_type_index;
	let if_block1;
	let t1;
	let span;
	let span_class_value;
	let t2;
	let t3;
	let iconchevronrightmedium;
	let current;
	let if_block0 = /*exterior*/ ctx[3] === "branches" && create_if_block_10(ctx);

	const if_block_creators = [
		create_if_block_1$u,
		create_if_block_2$4,
		create_if_block_3$3,
		create_if_block_4$2,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[4] == "image") return 0;
		if (/*variants*/ ctx[4] == "folder") return 1;
		if (/*variants*/ ctx[4] == "csv") return 2;
		if (/*variants*/ ctx[4] == "html") return 3;
		if (/*variants*/ ctx[4] == "xml") return 4;
		if (/*variants*/ ctx[4] == "zip") return 5;
		if (/*variants*/ ctx[4] == "txt") return 6;
		if (/*variants*/ ctx[4] == "json") return 7;
		if (/*variants*/ ctx[4] == "code") return 8;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);
	let if_block2 = /*exterior*/ ctx[3] === "files" && !/*isBranch*/ ctx[8] && create_if_block$v(ctx);

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				className: "spectrum-UIIcon-ChevronRightMedium spectrum-AssetList-itemChildIndicator",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			create_component(iconchevronrightmedium.$$.fragment);
			attr(span, "class", span_class_value = "spectrum-AssetList-itemLabel " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemLabel-disabled`));
			attr(li, "class", "spectrum-AssetList-item");
			attr(li, "tabindex", /*tabindex*/ ctx[5]);
			toggle_class(li, "is-selectable", /*isSelectable*/ ctx[9]);
			toggle_class(li, "is-selected", /*isSelected*/ ctx[0]);
			toggle_class(li, "is-branch", /*isBranch*/ ctx[8]);
			toggle_class(li, "spectrum-AssetList-item-disabled", /*disabled*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append(li, t0);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(li, null);
			}

			append(li, t1);
			append(li, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			append(li, t2);
			if (if_block2) if_block2.m(li, null);
			append(li, t3);
			mount_component(iconchevronrightmedium, li, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*exterior*/ ctx[3] === "branches") {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*exterior*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_10(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(li, t1);
				} else {
					if_block1 = null;
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 128) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*disabled*/ 64 && span_class_value !== (span_class_value = "spectrum-AssetList-itemLabel " + (/*disabled*/ ctx[6] && `spectrum-AssetList-itemLabel-disabled`))) {
				attr(span, "class", span_class_value);
			}

			if (/*exterior*/ ctx[3] === "files" && !/*isBranch*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*exterior, isBranch*/ 264) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$v(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(li, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*tabindex*/ 32) {
				attr(li, "tabindex", /*tabindex*/ ctx[5]);
			}

			if (dirty & /*isSelectable*/ 512) {
				toggle_class(li, "is-selectable", /*isSelectable*/ ctx[9]);
			}

			if (dirty & /*isSelected*/ 1) {
				toggle_class(li, "is-selected", /*isSelected*/ ctx[0]);
			}

			if (dirty & /*isBranch*/ 256) {
				toggle_class(li, "is-branch", /*isBranch*/ ctx[8]);
			}

			if (dirty & /*disabled*/ 64) {
				toggle_class(li, "spectrum-AssetList-item-disabled", /*disabled*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot_or_fallback, local);
			transition_in(if_block2);
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot_or_fallback, local);
			transition_out(if_block2);
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block0) if_block0.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (if_block2) if_block2.d();
			destroy_component(iconchevronrightmedium);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let { imgUrl = "" } = $$props;
	let { imgAlt = "Asset list item image" } = $$props;
	let { exterior = "branches" } = $$props;
	let { variants = "folder" } = $$props;
	let { isSelected = false } = $$props;
	let { tabindex = "0" } = $$props;
	let { disabled = false } = $$props;
	let { label = "" } = $$props;
	let { isBranch = false } = $$props;
	let { isSelectable = true } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	function checkbox_checked_binding(value) {
		isSelected = value;
		$$invalidate(0, isSelected);
	}

	function checkbox_checked_binding_1(value) {
		isSelected = value;
		$$invalidate(0, isSelected);
	}

	$$self.$$set = $$props => {
		if ("imgUrl" in $$props) $$invalidate(1, imgUrl = $$props.imgUrl);
		if ("imgAlt" in $$props) $$invalidate(2, imgAlt = $$props.imgAlt);
		if ("exterior" in $$props) $$invalidate(3, exterior = $$props.exterior);
		if ("variants" in $$props) $$invalidate(4, variants = $$props.variants);
		if ("isSelected" in $$props) $$invalidate(0, isSelected = $$props.isSelected);
		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$props.tabindex);
		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
		if ("label" in $$props) $$invalidate(7, label = $$props.label);
		if ("isBranch" in $$props) $$invalidate(8, isBranch = $$props.isBranch);
		if ("isSelectable" in $$props) $$invalidate(9, isSelectable = $$props.isSelectable);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		isSelected,
		imgUrl,
		imgAlt,
		exterior,
		variants,
		tabindex,
		disabled,
		label,
		isBranch,
		isSelectable,
		$$scope,
		$$slots,
		checkbox_checked_binding,
		checkbox_checked_binding_1
	];
}

class AssetListItem extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1suyta4-style")) add_css$5();

		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
			imgUrl: 1,
			imgAlt: 2,
			exterior: 3,
			variants: 4,
			isSelected: 0,
			tabindex: 5,
			disabled: 6,
			label: 7,
			isBranch: 8,
			isSelectable: 9
		});
	}
}

/* src/packages/Avatar/Avatar.svelte generated by Svelte v3.24.1 */

function create_fragment$L(ctx) {
	let img;
	let img_class_value;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", img_class_value = "spectrum-Avatar " + /*$$restProps*/ ctx[3].class);
			if (img.src !== (img_src_value = /*imgUrl*/ ctx[0])) attr(img, "src", img_src_value);
			attr(img, "alt", /*imgAlt*/ ctx[1]);
			toggle_class(img, "is-disabled", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$$restProps*/ 8 && img_class_value !== (img_class_value = "spectrum-Avatar " + /*$$restProps*/ ctx[3].class)) {
				attr(img, "class", img_class_value);
			}

			if (dirty & /*imgUrl*/ 1 && img.src !== (img_src_value = /*imgUrl*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*imgAlt*/ 2) {
				attr(img, "alt", /*imgAlt*/ ctx[1]);
			}

			if (dirty & /*$$restProps, disabled*/ 12) {
				toggle_class(img, "is-disabled", /*disabled*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	const omit_props_names = ["imgUrl","imgAlt","disabled"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { imgUrl = "" } = $$props;
	let { imgAlt = "Avatar image" } = $$props;
	let { disabled = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("imgUrl" in $$new_props) $$invalidate(0, imgUrl = $$new_props.imgUrl);
		if ("imgAlt" in $$new_props) $$invalidate(1, imgAlt = $$new_props.imgAlt);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
	};

	return [imgUrl, imgAlt, disabled, $$restProps];
}

class Avatar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$L, create_fragment$L, safe_not_equal, { imgUrl: 0, imgAlt: 1, disabled: 2 });
	}
}

/**
 * @param {Element} el
 * @returns {void}
 */
function setPositionedAccording(el) {
  el.parentElement.style.setProperty(`position`, `relative`);
}

/**
 * @param {Element} el
 * @param {string} slotName
 * @param {string} className
 * @returns {void}
 */
function advanceAddClassName(el, slotName, className) {
  let targetChild = el.children;
  if (targetChild) {
    for (let index = 0; index < targetChild.length; index++) {
      if (slotName && targetChild[index].slot && targetChild[index].slot == slotName) {
        targetChild[index].classList.add(className);
      }
    }
  }
}

/* src/packages/Banner/Banner.svelte generated by Svelte v3.24.1 */

function create_fragment$M(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let t2;
	let div2_class_value;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			div1 = element("div");
			t2 = text(/*content*/ ctx[1]);
			attr(div0, "class", "spectrum-Banner-header");
			attr(div1, "class", "spectrum-Banner-content");
			attr(div2, "class", div2_class_value = "spectrum-Banner spectrum-Banner--" + /*variants*/ ctx[2]);
			attr(div2, "style", /*styleCssText*/ ctx[5]);
			toggle_class(div2, "spectrum-Banner--corner", /*corner*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, t0);
			append(div2, t1);
			append(div2, div1);
			append(div1, t2);
			/*div2_binding*/ ctx[9](div2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);
			if (dirty & /*content*/ 2) set_data(t2, /*content*/ ctx[1]);

			if (dirty & /*variants*/ 4 && div2_class_value !== (div2_class_value = "spectrum-Banner spectrum-Banner--" + /*variants*/ ctx[2])) {
				attr(div2, "class", div2_class_value);
			}

			if (dirty & /*styleCssText*/ 32) {
				attr(div2, "style", /*styleCssText*/ ctx[5]);
			}

			if (dirty & /*variants, corner*/ 12) {
				toggle_class(div2, "spectrum-Banner--corner", /*corner*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			/*div2_binding*/ ctx[9](null);
		}
	};
}

function instance$M($$self, $$props, $$invalidate) {
	let { title = "" } = $$props;
	let { content = "" } = $$props;
	let { maxWidth = "size-2000" } = $$props;
	let { minWidth = "" } = $$props;
	let { minHeight = "" } = $$props;
	let { variants = "info" } = $$props;
	let { corner = false } = $$props;
	let banner;

	onMount(() => {
		corner && setPositionedAccording(banner);
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			banner = $$value;
			$$invalidate(4, banner);
		});
	}

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("content" in $$props) $$invalidate(1, content = $$props.content);
		if ("maxWidth" in $$props) $$invalidate(6, maxWidth = $$props.maxWidth);
		if ("minWidth" in $$props) $$invalidate(7, minWidth = $$props.minWidth);
		if ("minHeight" in $$props) $$invalidate(8, minHeight = $$props.minHeight);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("corner" in $$props) $$invalidate(3, corner = $$props.corner);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*maxWidth, minWidth, minHeight*/ 448) {
			 $$invalidate(5, styleCssText = [
				maxWidth && `max-width:var(--spectrum-global-dimension-${maxWidth});`,
				minWidth && `min-width:var(--spectrum-global-dimension-${minWidth});`,
				minHeight && `min-height:var(--spectrum-global-dimension-${minWidth});`
			].filter(Boolean).join(" "));
		}
	};

	return [
		title,
		content,
		variants,
		corner,
		banner,
		styleCssText,
		maxWidth,
		minWidth,
		minHeight,
		div2_binding
	];
}

class Banner extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$M, create_fragment$M, safe_not_equal, {
			title: 0,
			content: 1,
			maxWidth: 6,
			minWidth: 7,
			minHeight: 8,
			variants: 2,
			corner: 3
		});
	}
}

/* src/packages/BarLoader/BarLoader.svelte generated by Svelte v3.24.1 */

function create_else_block$2(ctx) {
	let div1;
	let div0;
	let t;
	let div2;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			div2 = element("div");
			attr(div0, "class", "spectrum-BarLoader-fill");
			set_style(div0, "width", /*value*/ ctx[0] + "%");
			attr(div1, "class", "spectrum-BarLoader-track");
			attr(div2, "class", "spectrum-BarLoader-label");
			div2.hidden = "";
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			insert(target, t, anchor);
			insert(target, div2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 1) {
				set_style(div0, "width", /*value*/ ctx[0] + "%");
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (detaching) detach(t);
			if (detaching) detach(div2);
		}
	};
}

// (62:2) {#if variants}
function create_if_block$w(ctx) {
	let div0;
	let t0;
	let t1;
	let t2;
	let div2;
	let div1;
	let if_block = !/*loading*/ ctx[7] && create_if_block_1$v(ctx);

	return {
		c() {
			div0 = element("div");
			t0 = text(/*label*/ ctx[3]);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			attr(div0, "class", "spectrum-BarLoader-label");
			attr(div1, "class", "spectrum-BarLoader-fill");
			set_style(div1, "width", /*value*/ ctx[0] + "%");
			attr(div2, "class", "spectrum-BarLoader-track");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, t0);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t2, anchor);
			insert(target, div2, anchor);
			append(div2, div1);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 8) set_data(t0, /*label*/ ctx[3]);

			if (!/*loading*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$v(ctx);
					if_block.c();
					if_block.m(t2.parentNode, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*value*/ 1) {
				set_style(div1, "width", /*value*/ ctx[0] + "%");
			}
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t2);
			if (detaching) detach(div2);
		}
	};
}

// (64:4) {#if !loading}
function create_if_block_1$v(ctx) {
	let div;
	let t_value = /*value*/ ctx[0] + `%` + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "spectrum-BarLoader-percentage");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 1 && t_value !== (t_value = /*value*/ ctx[0] + `%` + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$N(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[4]) return create_if_block$w;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "spectrum-BarLoader");
			attr(div, "value", /*value*/ ctx[0]);
			attr(div, "role", "progressbar");
			attr(div, "aria-valuenow", /*value*/ ctx[0]);
			attr(div, "aria-valuemin", /*minValue*/ ctx[1]);
			attr(div, "aria-valuemax", /*maxValue*/ ctx[2]);
			toggle_class(div, "spectrum-BarLoader--small", /*isSmall*/ ctx[5]);
			toggle_class(div, "spectrum-BarLoader--sideLabel", /*variants*/ ctx[4] == "side-label");
			toggle_class(div, "spectrum-BarLoader--overBackground", /*overBackground*/ ctx[6]);
			toggle_class(div, "spectrum-BarLoader--indeterminate", /*loading*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*value*/ 1) {
				attr(div, "value", /*value*/ ctx[0]);
			}

			if (dirty & /*value*/ 1) {
				attr(div, "aria-valuenow", /*value*/ ctx[0]);
			}

			if (dirty & /*minValue*/ 2) {
				attr(div, "aria-valuemin", /*minValue*/ ctx[1]);
			}

			if (dirty & /*maxValue*/ 4) {
				attr(div, "aria-valuemax", /*maxValue*/ ctx[2]);
			}

			if (dirty & /*isSmall*/ 32) {
				toggle_class(div, "spectrum-BarLoader--small", /*isSmall*/ ctx[5]);
			}

			if (dirty & /*variants*/ 16) {
				toggle_class(div, "spectrum-BarLoader--sideLabel", /*variants*/ ctx[4] == "side-label");
			}

			if (dirty & /*overBackground*/ 64) {
				toggle_class(div, "spectrum-BarLoader--overBackground", /*overBackground*/ ctx[6]);
			}

			if (dirty & /*loading*/ 128) {
				toggle_class(div, "spectrum-BarLoader--indeterminate", /*loading*/ ctx[7]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$N($$self, $$props, $$invalidate) {
	let { value = 50 } = $$props;
	let { minValue = 0 } = $$props;
	let { maxValue = 100 } = $$props;
	let { label = "Loading" } = $$props;
	let { variants = "" } = $$props;
	let { isSmall = false } = $$props;
	let { overBackground = false } = $$props;
	let { loading = false } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("minValue" in $$props) $$invalidate(1, minValue = $$props.minValue);
		if ("maxValue" in $$props) $$invalidate(2, maxValue = $$props.maxValue);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("variants" in $$props) $$invalidate(4, variants = $$props.variants);
		if ("isSmall" in $$props) $$invalidate(5, isSmall = $$props.isSmall);
		if ("overBackground" in $$props) $$invalidate(6, overBackground = $$props.overBackground);
		if ("loading" in $$props) $$invalidate(7, loading = $$props.loading);
	};

	return [value, minValue, maxValue, label, variants, isSmall, overBackground, loading];
}

class BarLoader extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
			value: 0,
			minValue: 1,
			maxValue: 2,
			label: 3,
			variants: 4,
			isSmall: 5,
			overBackground: 6,
			loading: 7
		});
	}
}

/* src/packages/Breadcrumbs/BreadcrumbsWrap.svelte generated by Svelte v3.24.1 */

function create_fragment$O(ctx) {
	let nav;
	let ul;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			nav = element("nav");
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", "spectrum-Breadcrumbs");
			toggle_class(ul, "spectrum-Breadcrumbs--multiline", /*variant*/ ctx[0] == "multiline");
			toggle_class(ul, "spectrum-Breadcrumbs--compact", /*variant*/ ctx[0] == "compact");
		},
		m(target, anchor) {
			insert(target, nav, anchor);
			append(nav, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (dirty & /*variant*/ 1) {
				toggle_class(ul, "spectrum-Breadcrumbs--multiline", /*variant*/ ctx[0] == "multiline");
			}

			if (dirty & /*variant*/ 1) {
				toggle_class(ul, "spectrum-Breadcrumbs--compact", /*variant*/ ctx[0] == "compact");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$O($$self, $$props, $$invalidate) {
	let { variant = "general" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("variant" in $$props) $$invalidate(0, variant = $$props.variant);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [variant, $$scope, $$slots];
}

class BreadcrumbsWrap extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$O, create_fragment$O, safe_not_equal, { variant: 0 });
	}
}

/* src/packages/Breadcrumbs/BreadcrumbsItem.svelte generated by Svelte v3.24.1 */

const { document: document_1$1 } = globals;

function add_css$6() {
	var style = element("style");
	style.id = "svelte-1krc9a2-style";
	style.textContent = ".is-disabled.svelte-1krc9a2{pointer-events:none}";
	append(document_1$1.head, style);
}

// (53:2) {:else}
function create_else_block$3(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let iconchevronrightsmall;
	let current;
	const if_block_creators = [create_if_block_1$w, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*nested*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	iconchevronrightsmall = new ChevronRightSmall({
			props: {
				className: "spectrum-Breadcrumbs-itemSeparator",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			if_block.c();
			t = space();
			create_component(iconchevronrightsmall.$$.fragment);
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t, anchor);
			mount_component(iconchevronrightsmall, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(t.parentNode, t);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(iconchevronrightsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(iconchevronrightsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t);
			destroy_component(iconchevronrightsmall, detaching);
		}
	};
}

// (49:2) {#if href}
function create_if_block$x(ctx) {
	let a;
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			a = element("a");
			if (default_slot) default_slot.c();
			attr(a, "class", "spectrum-Breadcrumbs-itemLink svelte-1krc9a2");
			attr(a, "role", "link");
			attr(a, "aria-current", "page");
			attr(a, "href", /*href*/ ctx[0]);
			toggle_class(a, "is-disabled", /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*href*/ 1) {
				attr(a, "href", /*href*/ ctx[0]);
			}

			if (dirty & /*disabled*/ 8) {
				toggle_class(a, "is-disabled", /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (59:4) {:else}
function create_else_block_1$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Breadcrumbs-itemLink svelte-1krc9a2");
			attr(div, "aria-disabled", /*disabled*/ ctx[3]);
			attr(div, "role", "link");
			attr(div, "tabindex", "0");
			toggle_class(div, "is-disabled", /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*disabled*/ 8) {
				attr(div, "aria-disabled", /*disabled*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 8) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (54:4) {#if nested}
function create_if_block_1$w(ctx) {
	let actionmenu;
	let current;

	actionmenu = new ActionMenu({
			props: {
				isQuiet: true,
				disabled: /*disabled*/ ctx[3],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(actionmenu.$$.fragment);
		},
		m(target, anchor) {
			mount_component(actionmenu, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const actionmenu_changes = {};
			if (dirty & /*disabled*/ 8) actionmenu_changes.disabled = /*disabled*/ ctx[3];

			if (dirty & /*$$scope, iconSize*/ 80) {
				actionmenu_changes.$$scope = { dirty, ctx };
			}

			actionmenu.$set(actionmenu_changes);
		},
		i(local) {
			if (current) return;
			transition_in(actionmenu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(actionmenu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(actionmenu, detaching);
		}
	};
}

// (56:6) <ActionMenu isQuiet {disabled}>
function create_default_slot$1(ctx) {
	let iconfolderbreadcrumb;
	let current;

	iconfolderbreadcrumb = new FolderBreadcrumb({
			props: {
				width: /*iconSize*/ ctx[4],
				height: /*iconSize*/ ctx[4],
				scale: /*iconSize*/ ctx[4] === 16 ? "M" : "L"
			}
		});

	return {
		c() {
			create_component(iconfolderbreadcrumb.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfolderbreadcrumb, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconfolderbreadcrumb_changes = {};
			if (dirty & /*iconSize*/ 16) iconfolderbreadcrumb_changes.width = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconfolderbreadcrumb_changes.height = /*iconSize*/ ctx[4];
			if (dirty & /*iconSize*/ 16) iconfolderbreadcrumb_changes.scale = /*iconSize*/ ctx[4] === 16 ? "M" : "L";
			iconfolderbreadcrumb.$set(iconfolderbreadcrumb_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconfolderbreadcrumb.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfolderbreadcrumb.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfolderbreadcrumb, detaching);
		}
	};
}

function create_fragment$P(ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$x, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			li = element("li");
			if_block.c();
			attr(li, "class", "spectrum-Breadcrumbs-item");
			toggle_class(li, "is-dragged", /*dragged*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(li, null);
			}

			if (dirty & /*dragged*/ 2) {
				toggle_class(li, "is-dragged", /*dragged*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$P($$self, $$props, $$invalidate) {
	let { href = "" } = $$props;
	let { dragged = false } = $$props;
	let { nested = false } = $$props;
	let { disabled = false } = $$props;

	onMount(() => {
		getIconScale();
	});

	let iconSize = 16;

	function getIconScale() {
		$$invalidate(4, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-200")));
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("dragged" in $$props) $$invalidate(1, dragged = $$props.dragged);
		if ("nested" in $$props) $$invalidate(2, nested = $$props.nested);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [href, dragged, nested, disabled, iconSize, $$slots, $$scope];
}

class BreadcrumbsItem extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$1.getElementById("svelte-1krc9a2-style")) add_css$6();

		init(this, options, instance$P, create_fragment$P, safe_not_equal, {
			href: 0,
			dragged: 1,
			nested: 2,
			disabled: 3
		});
	}
}

/* src/packages/Breadcrumbs/Breadcrumbs.svelte generated by Svelte v3.24.1 */

class Breadcrumbs extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, null, safe_not_equal, {});
	}
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

//Solar month of 31 days.
const SOLAR_MONTH_OF_31_DAYS = [1, 3, 5, 7, 8, 10, 12];

/**
 * The day of the week.
 * @param {Date} n
 * @returns {number}
 */
function theDayOfTheWeek(n) {
  let d = new Date(n).getDay();

  return d === 0 ? 7 : d;
}

/**
 * Format date stamp.
 * @param {Date} n
 * @param {string} f
 * @returns {string}
 */
function formatDatetamp(n, f) {
  let d = new Date(n);
  let ty = d.getFullYear();
  let tm = d.getMonth() + 1;
  let td = d.getDate();
  let th = d.getHours();
  let tmin = d.getMinutes();
  let tse = d.getSeconds();

  let r = `${ty}-${tm}-${td}`;
  switch (f) {
    case "ISO8601":
      r = `${ty}-${tm}-${td}T${th}:${tmin}:${tse}Z`;
      break;
    case "mm-yyyy" :
      r = `${tm}-${ty}`;
      break;
    case "dd/mm/yy" :
      r = `${td}/${tm}/${ty.toString().slice(-2)}`;
      break;
    case "yyyy-mm-dd" :
      r = `${ty}-${tm}-${td}`;
      break;
    case "dd.mm.yyyy" :
      r = `${td}.${tm}.${ty}`;
      break;
    case "dd/mm/yyyy" :
      r = `${td}/${tm}/${ty}`;
      break;
    case "yyyy-mm-dd" :
      r = `${ty}-${tm}-${td}`;
      break;
    case "dd-mm-yy" :
      r = `${td}-${tm}-${ty.toString().slice(-2)}`;
      break;
    case "mm-dd-yy" :
      r = `${tm}-${td}-${ty.toString().slice(-2)}`;
      break;
    default:
      r = `${ty}-${tm}-${td}`;
      break;
  }
  return r;
}

/**
 * Test solar month of 31 days.
 * @param {number} m
 * @returns {boolean}
 */
function testSolarMonthOf31Days(m) {
  return !!~SOLAR_MONTH_OF_31_DAYS.indexOf(m);
}

/**
 * Test leap year.
 * @param {number} y
 * @returns {boolean}
 */
function testLeapYear(y) {
  return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
}

/**
 * Determine the number of days in the month.
 * @param {number} y
 * @param {number} m
 * @returns {number}
 */
function testDaysInTheMouth(y, m) {
  let d = NaN;
  if (testLeapYear(y) && m === 2) {
    d = 29;
  } else if (m === 2) {
    d = 28;
  } else if (testSolarMonthOf31Days(m)) {
    d = 31;
  } else {
    d = 30;
  }
  return d;
}

/**
 * Get the year and month of the prev month.
 * @param {number} y
 * @param {number} m
 * @returns { [py:number, pm:number] }
 */
function getPrevYearAndMonth(y, m) {
  let py = NaN;
  let pm = NaN;
  if (m !== 1) {
    pm = m - 1;
    py = y;
  } else {
    pm = 12;
    py = y - 1;
  }
  return [py, pm];
}

/**
 * Get the year and month of the next month.
 * @param {number} y
 * @param {number} m
 * @returns { [ny:number, nm:number] }
 */
function getNextYearAndMonth(y, m) {
  let ny = NaN;
  let nm = NaN;
  if (m !== 12) {
    nm = m + 1;
    ny = y;
  } else {
    nm = 1;
    ny = y + 1;
  }
  return [ny, nm];
}

/**
 * Get date data for the first week of the month
 * @param {Date} n
 * @returns { Array }
 */
function getFirstWeekOfTheMonth(n) {
  let td = new Date(n);
  let ty = td.getFullYear();
  let tm = td.getMonth() + 1;
  let dotw = theDayOfTheWeek(`${ty}-${tm}-1`);
  let [py, pm] = getPrevYearAndMonth(ty, tm);
  let pmd = testDaysInTheMouth(py, pm);
  let firstWeekList = [];
  firstWeekList.length = 7;
  let i = 8 - dotw;
  let times = dotw - 2;
  for (let index = 0; index < firstWeekList.length; index++) {
    firstWeekList[index] = new Date(`${py == ty ? ty : ty - 1}-${tm == 1 ? 12 : tm - 1}-${pmd - times}`);
    times--;
  }
  for (let j = 0; j < i; j++) {
    firstWeekList[7 - i + j] = new Date(`${ty}-${tm}-${j + 1}`);
  }
  return firstWeekList;
}

/**
 * Get date data for the mid week of the month
 * @param {Date} n
 * @param {boolean} s
 * @returns { Array }
 */
function getMidWeekOfTheMonth(n, s) {
  let td = new Date(+n + 24 * 60 * 60 * 1000);
  let ty = td.getFullYear();
  let tm = td.getMonth() + 1;
  let d = td.getDate();
  let midWeekList = [];
  midWeekList.length = 7;
  if (s && tm == 12) {
    for (let index = 0; index < midWeekList.length; index++) {
      midWeekList[index] = new Date(`${ty + 1}-1-${d + index}`);
    }
  } else {
    for (let index = 0; index < midWeekList.length; index++) {
      midWeekList[index] = new Date(`${ty}-${tm}-${d + index}`);
    }
  }
  return midWeekList;
}

/**
 * Get date data for the last week of the month
 * @param {Date} n
 * @returns { Array }
 */
function getLastWeekOfTheMonth(n) {
  let td = new Date(+n + 24 * 60 * 60 * 1000);
  let ty = td.getFullYear();
  let tm = td.getMonth() + 1;
  let d = td.getDate();
  let [ny, nm] = getNextYearAndMonth(ty, tm);
  let lastWeekList = [];
  let cmd = testDaysInTheMouth(ty, tm);
  let times = cmd - d + 1;
  for (let index = 0; index < times; index++) {
    lastWeekList[index] = new Date(`${ty}-${tm}-${d + index}`);
  }
  for (let index = 0; index < 7 - times; index++) {
    lastWeekList[+times + index] = new Date(`${ny == ty ? ty : ty + 1}-${nm == 1 ? 1 : tm + 1}-${index + 1}`);
  }
  lastWeekList.length = 7;
  return lastWeekList;
}

/**
 * Get weekly data for the month of the specified date.
 * @param {Date} n
 * @returns { Array }
 */
function getThisMonthData(n) {
  let td = new Date(n);
  let ty = td.getFullYear();
  let tm = td.getMonth() + 1;
  let d = td.getDate();
  let [ny, nm] = getNextYearAndMonth(ty, tm);
  let cmd = testDaysInTheMouth(ty, tm);
  //The first week
  let theFirstWeek = getFirstWeekOfTheMonth(n);
  //The second week
  let theSecondWeek = getMidWeekOfTheMonth(theFirstWeek[6]);
  //The third week
  let theThirdWeek = getMidWeekOfTheMonth(theSecondWeek[6]);
  //The fourth week
  let theFourthWeek = getMidWeekOfTheMonth(theThirdWeek[6]);
  //The fifth week
  let fifthWeek;
  let hasSixthWeek;
  switch (true) {
    case cmd - new Date(theFourthWeek[6]).getDate() === 7:
      fifthWeek = getLastWeekOfTheMonth(theFourthWeek[6]);
      hasSixthWeek = true;
      break;
    case cmd - new Date(theFourthWeek[6]).getDate() > 7:
      fifthWeek = getMidWeekOfTheMonth(theFourthWeek[6]);
      hasSixthWeek = true;
      break;
    default:
      fifthWeek = getLastWeekOfTheMonth(theFourthWeek[6]);
      hasSixthWeek = false;
      break;
  }
  //The sixth week
  let sixthWeek = hasSixthWeek ? getLastWeekOfTheMonth(fifthWeek[6]) : getMidWeekOfTheMonth(fifthWeek[6], tm !== 11);
  return [theFirstWeek, theSecondWeek, theThirdWeek, theFourthWeek, fifthWeek, sixthWeek];
}

var noun = {
  zh: {
    weekShortAbbreviation: ["一", "二", "三", "四", "五", "六", "日"],
    weekAbbreviation: ["周一", "周二", "周三", "周四", "周五", "周六", "周日"],
    weekFullName: ["星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期日"],
    monthAbbreviation: ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"],
    monthFullName: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    today: "今天",
  },
  en: {
    weekShortAbbreviation: ["M", "T", "W", "T", "F", "S", "S"],
    weekAbbreviation: ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"],
    weekFullName: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
    monthAbbreviation: ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"],
    monthFullName: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
    today: "Today",
  },
};

/* src/packages/Calendar/CalendarHader.svelte generated by Svelte v3.24.1 */

function create_default_slot_4(ctx) {
	let t;

	return {
		c() {
			t = text(/*yearAndMonth*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*yearAndMonth*/ 1) set_data(t, /*yearAndMonth*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (97:4) <ButtonIconWrap onlyIcon>
function create_default_slot_3(ctx) {
	let iconchevronleftmedium;
	let current;

	iconchevronleftmedium = new ChevronLeftMedium({
			props: {
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconchevronleftmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronleftmedium, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconchevronleftmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronleftmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronleftmedium, detaching);
		}
	};
}

// (96:2) <Button exterior="action" isQuiet ariaLabel="Prev" class="spectrum-Calendar-prevMonth" on:click={prev}>
function create_default_slot_2(ctx) {
	let buttoniconwrap;
	let current;

	buttoniconwrap = new ButtonIconWrap({
			props: {
				onlyIcon: true,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(buttoniconwrap.$$.fragment);
		},
		m(target, anchor) {
			mount_component(buttoniconwrap, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const buttoniconwrap_changes = {};

			if (dirty & /*$$scope*/ 512) {
				buttoniconwrap_changes.$$scope = { dirty, ctx };
			}

			buttoniconwrap.$set(buttoniconwrap_changes);
		},
		i(local) {
			if (current) return;
			transition_in(buttoniconwrap.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(buttoniconwrap.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(buttoniconwrap, detaching);
		}
	};
}

// (102:4) <ButtonIconWrap onlyIcon>
function create_default_slot_1$1(ctx) {
	let iconchevronrightmedium;
	let current;

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconchevronrightmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronrightmedium, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronrightmedium, detaching);
		}
	};
}

// (101:2) <Button exterior="action" isQuiet ariaLabel="Next" class="spectrum-Calendar-nextMonth" on:click={next}>
function create_default_slot$2(ctx) {
	let buttoniconwrap;
	let current;

	buttoniconwrap = new ButtonIconWrap({
			props: {
				onlyIcon: true,
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(buttoniconwrap.$$.fragment);
		},
		m(target, anchor) {
			mount_component(buttoniconwrap, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const buttoniconwrap_changes = {};

			if (dirty & /*$$scope*/ 512) {
				buttoniconwrap_changes.$$scope = { dirty, ctx };
			}

			buttoniconwrap.$set(buttoniconwrap_changes);
		},
		i(local) {
			if (current) return;
			transition_in(buttoniconwrap.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(buttoniconwrap.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(buttoniconwrap, detaching);
		}
	};
}

function create_fragment$Q(ctx) {
	let div;
	let button0;
	let t0;
	let button1;
	let t1;
	let button2;
	let current;

	button0 = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				class: "spectrum-Calendar-title",
				role: "heading",
				"aria-live": "assertive",
				"aria-atomic": "true",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*switchView*/ ctx[4]);

	button1 = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				ariaLabel: "Prev",
				class: "spectrum-Calendar-prevMonth",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*prev*/ ctx[2]);

	button2 = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				ariaLabel: "Next",
				class: "spectrum-Calendar-nextMonth",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	button2.$on("click", /*next*/ ctx[3]);

	return {
		c() {
			div = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			create_component(button2.$$.fragment);
			attr(div, "class", "spectrum-Calendar-header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button0, div, null);
			append(div, t0);
			mount_component(button1, div, null);
			append(div, t1);
			mount_component(button2, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope, yearAndMonth*/ 513) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 512) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};

			if (dirty & /*$$scope*/ 512) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(button2);
		}
	};
}

function instance$Q($$self, $$props, $$invalidate) {
	let $rubusCalendar;
	let m;
	let y;
	let rubusCalendar = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendar, value => $$invalidate(7, $rubusCalendar = value));

	onMount(() => {
		m = new Date().getMonth() + 1;
		y = new Date().getFullYear();
	});

	function formatMonthName(n) {
		let nd = new Date(n);
		let ty = nd.getFullYear();
		let tm = nd.getMonth();
		let monthName = noun[$rubusCalendar.lang][$rubusCalendar.monthName][tm];
		let calendarTitle;

		switch ($rubusCalendar.view) {
			case "month":
				calendarTitle = `${monthName} - ${ty}`;
				break;
			case "year":
				calendarTitle = `${ty}`;
				break;
		}

		return calendarTitle;
	}

	function prev() {
		let nd = new Date($rubusCalendar.viewDate);
		let ty = nd.getFullYear();
		let tm = nd.getMonth() + 1;
		let td = nd.getDate();
		let [py, pm] = getPrevYearAndMonth(ty, tm);

		switch ($rubusCalendar.view) {
			case "month":
				set_store_value(rubusCalendar, $rubusCalendar.viewDate = `${py}-${pm}-${td}`, $rubusCalendar);
				break;
			case "year":
				set_store_value(rubusCalendar, $rubusCalendar.viewDate = `${ty - 1}-${tm}-${td}`, $rubusCalendar);
				break;
		}

		set_store_value(rubusCalendar, $rubusCalendar.action = "prev", $rubusCalendar);
		set_store_value(rubusCalendar, $rubusCalendar.flag = !$rubusCalendar.flag, $rubusCalendar);
	}

	function next() {
		let nd = new Date($rubusCalendar.viewDate);
		let ty = nd.getFullYear();
		let tm = nd.getMonth() + 1;
		let td = nd.getDate();
		let [ny, nm] = getNextYearAndMonth(ty, tm);

		switch ($rubusCalendar.view) {
			case "month":
				set_store_value(rubusCalendar, $rubusCalendar.viewDate = `${ny}-${nm}-${td}`, $rubusCalendar);
				break;
			case "year":
				set_store_value(rubusCalendar, $rubusCalendar.viewDate = `${ty + 1}-${tm}-${td}`, $rubusCalendar);
				break;
		}

		set_store_value(rubusCalendar, $rubusCalendar.action = "next", $rubusCalendar);
		set_store_value(rubusCalendar, $rubusCalendar.flag = !$rubusCalendar.flag, $rubusCalendar);
	}

	function switchView() {
		switch ($rubusCalendar.view) {
			case "month":
				set_store_value(rubusCalendar, $rubusCalendar.view = "year", $rubusCalendar);
				break;
			case "year":
				set_store_value(rubusCalendar, $rubusCalendar.view = "month", $rubusCalendar);
				break;
		}
	}

	let yearAndMonth;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$rubusCalendar*/ 128) {
			 $$invalidate(0, yearAndMonth = formatMonthName($rubusCalendar.viewDate));
		}
	};

	return [yearAndMonth, rubusCalendar, prev, next, switchView];
}

class CalendarHader extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});
	}
}

/* src/packages/Calendar/body/CalendarBodyHead.svelte generated by Svelte v3.24.1 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (11:4) {#each weekNames as item}
function create_each_block(ctx) {
	let th;
	let abbr;
	let t0_value = /*item*/ ctx[3] + "";
	let t0;
	let t1;

	return {
		c() {
			th = element("th");
			abbr = element("abbr");
			t0 = text(t0_value);
			t1 = space();
			attr(abbr, "class", "spectrum-Calendar-dayOfWeek");
			attr(abbr, "title", "Sunday");
			attr(th, "role", "columnheader");
			attr(th, "scope", "col");
			attr(th, "class", "spectrum-Calendar-tableCell");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, abbr);
			append(abbr, t0);
			append(th, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*weekNames*/ 1 && t0_value !== (t0_value = /*item*/ ctx[3] + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(th);
		}
	};
}

function create_fragment$R(ctx) {
	let thead;
	let tr;
	let each_value = /*weekNames*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			thead = element("thead");
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(tr, "role", "row");
			attr(thead, "role", "presentation");
		},
		m(target, anchor) {
			insert(target, thead, anchor);
			append(thead, tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*weekNames*/ 1) {
				each_value = /*weekNames*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(thead);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$R($$self, $$props, $$invalidate) {
	let $rubusCalendar;
	let rubusCalendar = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendar, value => $$invalidate(2, $rubusCalendar = value));
	let weekNames;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$rubusCalendar*/ 4) {
			 $$invalidate(0, weekNames = noun[$rubusCalendar.lang][$rubusCalendar.weekName]);
		}
	};

	return [weekNames, rubusCalendar];
}

class CalendarBodyHead extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});
	}
}

/* src/packages/Calendar/body/CalendarBodyDay.svelte generated by Svelte v3.24.1 */

function add_css$7() {
	var style = element("style");
	style.id = "svelte-h7v6p6-style";
	style.textContent = ".rubus-calendar-weekend.svelte-h7v6p6{background-color:var(--spectrum-alias-border-color-light)}.rubus-calendar-outsideMonth.svelte-h7v6p6{color:var(--spectrum-alias-placeholder-text-color)}.rubus-calendar-outsideMonth-disabled.svelte-h7v6p6{color:var(--spectrum-global-color-gray-300)}";
	append(document.head, style);
}

function create_fragment$S(ctx) {
	let td;
	let span;
	let t;
	let td_aria_disabled_value;
	let td_aria_selected_value;
	let td_title_value;
	let mounted;
	let dispose;

	return {
		c() {
			td = element("td");
			span = element("span");
			t = text(/*dayLabel*/ ctx[10]);
			attr(span, "role", "presentation");
			attr(span, "class", "spectrum-Calendar-date svelte-h7v6p6");
			toggle_class(span, "is-today", /*isToday*/ ctx[14]);
			toggle_class(span, "is-selected", /*isSelected*/ ctx[0] || /*$rubusCalendar*/ ctx[13].result === +/*day*/ ctx[1]);
			toggle_class(span, "is-focused", /*isFocused*/ ctx[2]);
			toggle_class(span, "is-disabled", /*disabled*/ ctx[4] || /*invalid*/ ctx[3]);
			toggle_class(span, "is-range-selection", /*isRangeSelection*/ ctx[5]);
			toggle_class(span, "is-selection-start", /*isSelectionStart*/ ctx[6]);
			toggle_class(span, "is-selection-end", /*isSelectionEnd*/ ctx[7]);
			toggle_class(span, "is-range-start", /*isRangeStart*/ ctx[8]);
			toggle_class(span, "is-range-end", /*isRangeEnd*/ ctx[9]);
			toggle_class(span, "rubus-calendar-outsideMonth", /*isOutsideMonth*/ ctx[12]);
			toggle_class(span, "rubus-calendar-outsideMonth-disabled", /*isOutsideMonth*/ ctx[12] && (/*disabled*/ ctx[4] || /*invalid*/ ctx[3]));
			toggle_class(span, "is-outsideMonth", /*isOutsideMonth*/ ctx[12] && !/*$rubusCalendar*/ ctx[13].showOutsideMonth);
			attr(td, "role", "gridcell");
			attr(td, "class", "spectrum-Calendar-tableCell svelte-h7v6p6");
			attr(td, "aria-disabled", td_aria_disabled_value = /*disabled*/ ctx[4] || /*invalid*/ ctx[3]);
			attr(td, "aria-selected", td_aria_selected_value = /*isSelected*/ ctx[0] || /*$rubusCalendar*/ ctx[13].result === +/*day*/ ctx[1]);
			attr(td, "aria-invalid", /*invalid*/ ctx[3]);
			attr(td, "title", td_title_value = /*formarWeekName*/ ctx[16](/*day*/ ctx[1]) + " , " + formatDatetamp(/*day*/ ctx[1], "yyyy-mm-dd"));
			toggle_class(td, "rubus-calendar-weekend", /*isWeekend*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, span);
			append(span, t);

			if (!mounted) {
				dispose = listen(span, "click", /*pick*/ ctx[17]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*dayLabel*/ 1024) set_data(t, /*dayLabel*/ ctx[10]);

			if (dirty & /*isToday*/ 16384) {
				toggle_class(span, "is-today", /*isToday*/ ctx[14]);
			}

			if (dirty & /*isSelected, $rubusCalendar, day*/ 8195) {
				toggle_class(span, "is-selected", /*isSelected*/ ctx[0] || /*$rubusCalendar*/ ctx[13].result === +/*day*/ ctx[1]);
			}

			if (dirty & /*isFocused*/ 4) {
				toggle_class(span, "is-focused", /*isFocused*/ ctx[2]);
			}

			if (dirty & /*disabled, invalid*/ 24) {
				toggle_class(span, "is-disabled", /*disabled*/ ctx[4] || /*invalid*/ ctx[3]);
			}

			if (dirty & /*isRangeSelection*/ 32) {
				toggle_class(span, "is-range-selection", /*isRangeSelection*/ ctx[5]);
			}

			if (dirty & /*isSelectionStart*/ 64) {
				toggle_class(span, "is-selection-start", /*isSelectionStart*/ ctx[6]);
			}

			if (dirty & /*isSelectionEnd*/ 128) {
				toggle_class(span, "is-selection-end", /*isSelectionEnd*/ ctx[7]);
			}

			if (dirty & /*isRangeStart*/ 256) {
				toggle_class(span, "is-range-start", /*isRangeStart*/ ctx[8]);
			}

			if (dirty & /*isRangeEnd*/ 512) {
				toggle_class(span, "is-range-end", /*isRangeEnd*/ ctx[9]);
			}

			if (dirty & /*isOutsideMonth*/ 4096) {
				toggle_class(span, "rubus-calendar-outsideMonth", /*isOutsideMonth*/ ctx[12]);
			}

			if (dirty & /*isOutsideMonth, disabled, invalid*/ 4120) {
				toggle_class(span, "rubus-calendar-outsideMonth-disabled", /*isOutsideMonth*/ ctx[12] && (/*disabled*/ ctx[4] || /*invalid*/ ctx[3]));
			}

			if (dirty & /*isOutsideMonth, $rubusCalendar*/ 12288) {
				toggle_class(span, "is-outsideMonth", /*isOutsideMonth*/ ctx[12] && !/*$rubusCalendar*/ ctx[13].showOutsideMonth);
			}

			if (dirty & /*disabled, invalid*/ 24 && td_aria_disabled_value !== (td_aria_disabled_value = /*disabled*/ ctx[4] || /*invalid*/ ctx[3])) {
				attr(td, "aria-disabled", td_aria_disabled_value);
			}

			if (dirty & /*isSelected, $rubusCalendar, day*/ 8195 && td_aria_selected_value !== (td_aria_selected_value = /*isSelected*/ ctx[0] || /*$rubusCalendar*/ ctx[13].result === +/*day*/ ctx[1])) {
				attr(td, "aria-selected", td_aria_selected_value);
			}

			if (dirty & /*invalid*/ 8) {
				attr(td, "aria-invalid", /*invalid*/ ctx[3]);
			}

			if (dirty & /*day*/ 2 && td_title_value !== (td_title_value = /*formarWeekName*/ ctx[16](/*day*/ ctx[1]) + " , " + formatDatetamp(/*day*/ ctx[1], "yyyy-mm-dd"))) {
				attr(td, "title", td_title_value);
			}

			if (dirty & /*isWeekend*/ 2048) {
				toggle_class(td, "rubus-calendar-weekend", /*isWeekend*/ ctx[11]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(td);
			mounted = false;
			dispose();
		}
	};
}

function instance$S($$self, $$props, $$invalidate) {
	let $rubusCalendar;
	let { day = 1 } = $$props;
	let { isSelected = false } = $$props;
	let { isFocused = false } = $$props;
	let { invalid = false } = $$props;
	let { disabled = false } = $$props;
	let isRangeSelection = false;
	let isSelectionStart = false;
	let isSelectionEnd = false;
	let isRangeStart = false;
	let isRangeEnd = false;
	let rubusCalendar = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendar, value => $$invalidate(13, $rubusCalendar = value));

	beforeUpdate(() => {
		if ($rubusCalendar.pickerMode == "single") {
			$$invalidate(0, isSelected = new Date(day).getTime() == new Date($rubusCalendar.selected).getTime());
		}

		if ($rubusCalendar.pickerMode == "range") {
			$$invalidate(5, [isRangeSelection, isSelectionStart, isSelectionEnd] = testSelectedRange(day), isRangeSelection, $$invalidate(6, isSelectionStart), $$invalidate(7, isSelectionEnd));
			$$invalidate(8, isRangeStart = theDayOfTheWeek(day) == 1);
			$$invalidate(9, isRangeEnd = theDayOfTheWeek(day) == 7);
			$$invalidate(0, isSelected = isRangeSelection);
		}
	});

	function formarWeekName(n) {
		let dotw = theDayOfTheWeek(n);
		return noun[$rubusCalendar.lang][`weekFullName`][dotw - 1];
	}

	function pick() {
		if ($rubusCalendar.pickerMode == "single") {
			set_store_value(rubusCalendar, $rubusCalendar.selected = new Date(day).getTime(), $rubusCalendar);
		}

		if ($rubusCalendar.pickerMode == "range") {
			set_store_value(rubusCalendar, $rubusCalendar.selected = rangePicker($rubusCalendar.selected), $rubusCalendar);
		}
	}

	function testSelectedRange(n) {
		let i = new Date(n).getTime();
		let startDate = new Date($rubusCalendar.selected[0]).getTime();
		let endDate = new Date($rubusCalendar.selected[1]).getTime();
		return [i >= startDate && i <= endDate, i == startDate, i == endDate];
	}

	function rangePicker(arr) {
		let thisDate = new Date(day).getTime();
		let startDate = new Date(arr[0]).getTime();
		let endDate = new Date(arr[1]).getTime();

		if (!endDate || !startDate || startDate == thisDate) {
			startDate = thisDate;
			endDate = thisDate;
		} else {
			if (thisDate > endDate) {
				endDate = thisDate;
			} else if (thisDate < startDate || thisDate > startDate) {
				startDate = thisDate;
			} else if (thisDate == endDate) {
				startDate = thisDate;
			}
		}

		return [startDate, endDate];
	}

	$$self.$$set = $$props => {
		if ("day" in $$props) $$invalidate(1, day = $$props.day);
		if ("isSelected" in $$props) $$invalidate(0, isSelected = $$props.isSelected);
		if ("isFocused" in $$props) $$invalidate(2, isFocused = $$props.isFocused);
		if ("invalid" in $$props) $$invalidate(3, invalid = $$props.invalid);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
	};

	let dayLabel;
	let isWeekend;
	let isOutsideMonth;
	let isToday;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*day*/ 2) {
			 $$invalidate(10, dayLabel = new Date(day).getDate());
		}

		if ($$self.$$.dirty & /*day*/ 2) {
			 $$invalidate(11, isWeekend = theDayOfTheWeek(day) === 6 || theDayOfTheWeek(day) === 7);
		}

		if ($$self.$$.dirty & /*$rubusCalendar, day*/ 8194) {
			 $$invalidate(12, isOutsideMonth = new Date($rubusCalendar.viewDate).getMonth() != new Date(day).getMonth());
		}

		if ($$self.$$.dirty & /*$rubusCalendar, day*/ 8194) {
			 $$invalidate(14, isToday = new Date($rubusCalendar.nowDate).getDate() == new Date(day).getDate() && new Date($rubusCalendar.nowDate).getMonth() == new Date(day).getMonth() && new Date($rubusCalendar.nowDate).getFullYear() == new Date(day).getFullYear());
		}
	};

	return [
		isSelected,
		day,
		isFocused,
		invalid,
		disabled,
		isRangeSelection,
		isSelectionStart,
		isSelectionEnd,
		isRangeStart,
		isRangeEnd,
		dayLabel,
		isWeekend,
		isOutsideMonth,
		$rubusCalendar,
		isToday,
		rubusCalendar,
		formarWeekName,
		pick
	];
}

class CalendarBodyDay extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-h7v6p6-style")) add_css$7();

		init(this, options, instance$S, create_fragment$S, safe_not_equal, {
			day: 1,
			isSelected: 0,
			isFocused: 2,
			invalid: 3,
			disabled: 4
		});
	}
}

/* src/packages/Calendar/body/CalendarBodyWeek.svelte generated by Svelte v3.24.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (37:2) {#each week as item}
function create_each_block$1(ctx) {
	let calendarbodyday;
	let current;

	calendarbodyday = new CalendarBodyDay({
			props: {
				day: /*item*/ ctx[4],
				isFocused: filter(/*$rubusCalendar*/ ctx[1].focused, /*item*/ ctx[4]),
				disabled: filter(/*$rubusCalendar*/ ctx[1].disabled, /*item*/ ctx[4]),
				invalid: filter(/*$rubusCalendar*/ ctx[1].validRange, /*item*/ ctx[4])
			}
		});

	return {
		c() {
			create_component(calendarbodyday.$$.fragment);
		},
		m(target, anchor) {
			mount_component(calendarbodyday, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const calendarbodyday_changes = {};
			if (dirty & /*week*/ 1) calendarbodyday_changes.day = /*item*/ ctx[4];
			if (dirty & /*$rubusCalendar, week*/ 3) calendarbodyday_changes.isFocused = filter(/*$rubusCalendar*/ ctx[1].focused, /*item*/ ctx[4]);
			if (dirty & /*$rubusCalendar, week*/ 3) calendarbodyday_changes.disabled = filter(/*$rubusCalendar*/ ctx[1].disabled, /*item*/ ctx[4]);
			if (dirty & /*$rubusCalendar, week*/ 3) calendarbodyday_changes.invalid = filter(/*$rubusCalendar*/ ctx[1].validRange, /*item*/ ctx[4]);
			calendarbodyday.$set(calendarbodyday_changes);
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyday.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(calendarbodyday.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(calendarbodyday, detaching);
		}
	};
}

function create_fragment$T(ctx) {
	let tr;
	let current;
	let each_value = /*week*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(tr, "role", "row");
		},
		m(target, anchor) {
			insert(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*week, filter, $rubusCalendar*/ 3) {
				each_value = /*week*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tr, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			destroy_each(each_blocks, detaching);
		}
	};
}

function filter(arr, day) {
	let thisDate = new Date(day).getTime();

	if (arr.length === 2 && new Date(arr[0]).getTime() < new Date(arr[1]).getTime()) {
		if (thisDate >= new Date(arr[0]).getTime() && thisDate <= new Date(arr[1]).getTime()) {
			return true;
		}
	}

	for (let index = 0; index < arr.length; index++) {
		if (new Date(arr[index]).getTime() == thisDate) {
			return true;
		}
	}
}

function instance$T($$self, $$props, $$invalidate) {
	let $rubusCalendar;
	let { week = [] } = $$props;
	let rubusCalendar = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendar, value => $$invalidate(1, $rubusCalendar = value));

	$$self.$$set = $$props => {
		if ("week" in $$props) $$invalidate(0, week = $$props.week);
	};

	return [week, $rubusCalendar, rubusCalendar];
}

class CalendarBodyWeek extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$T, create_fragment$T, safe_not_equal, { week: 0 });
	}
}

/* src/packages/Calendar/body/CalendarBodyYear.svelte generated by Svelte v3.24.1 */

function add_css$8() {
	var style = element("style");
	style.id = "svelte-mxrq3u-style";
	style.textContent = ".spectrum--medium{--rubus-Calendar-month-width:280px}.spectrum--large{--rubus-Calendar-month-width:336px}.rubus-Calendar-month.svelte-mxrq3u{height:calc(var(--rubus-Calendar-month-width) / 4.4);width:calc(var(--rubus-Calendar-month-width) / 3.2);margin:var(--spectrum-calendar-day-padding, 4px);border-radius:4px;line-height:calc(\n      var(--rubus-Calendar-month-width) / 4.4 - var(--spectrum-calendar-day-border-size-key-focus, 2px) * 2\n    )}.spectrum-Calendar-date.svelte-mxrq3u:before{content:\"\";position:absolute;top:0;left:0;box-sizing:border-box;height:calc(var(--rubus-Calendar-month-width) / 4.4);width:calc(var(--rubus-Calendar-month-width) / 3);border-radius:4px;border:var(--spectrum-calendar-day-border-size-key-focus, 2px) solid transparent}.spectrum-Calendar-tableCell.svelte-mxrq3u{text-align:center;padding:0;position:relative;box-sizing:content-box;height:calc(var(--rubus-Calendar-month-width) / 4.4);width:calc(var(--rubus-Calendar-month-width) / 3);padding:var(--spectrum-calendar-day-padding, 4px)}.current-month.svelte-mxrq3u{color:var(--spectrum-calendar-day-today-text-color, var(--spectrum-global-color-gray-800));border-color:var(--spectrum-calendar-day-today-border-color, var(--spectrum-global-color-gray-800))}";
	append(document.head, style);
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

// (64:4) {#if i < 3}
function create_if_block_3$4(ctx) {
	let td;
	let span;
	let t0_value = /*item*/ ctx[11] + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[6](/*i*/ ctx[13], ...args);
	}

	return {
		c() {
			td = element("td");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			attr(span, "role", "presentation");
			attr(span, "class", "spectrum-Calendar-date rubus-Calendar-month svelte-mxrq3u");
			toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			attr(td, "role", "gridcell");
			attr(td, "class", "spectrum-Calendar-tableCell svelte-mxrq3u");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, span);
			append(span, t0);
			append(td, t1);

			if (!mounted) {
				dispose = listen(td, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*monthList*/ 1 && t0_value !== (t0_value = /*item*/ ctx[11] + "")) set_data(t0, t0_value);

			if (dirty & /*currentMonth, currentYear*/ 6) {
				toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(td);
			mounted = false;
			dispose();
		}
	};
}

// (63:2) {#each monthList as item, i}
function create_each_block_3(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[13] < 3 && create_if_block_3$4(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*i*/ ctx[13] < 3) if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (77:4) {#if i >= 3 && i < 6}
function create_if_block_2$5(ctx) {
	let td;
	let span;
	let t0_value = /*item*/ ctx[11] + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[7](/*i*/ ctx[13], ...args);
	}

	return {
		c() {
			td = element("td");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			attr(span, "role", "presentation");
			attr(span, "class", "spectrum-Calendar-date rubus-Calendar-month svelte-mxrq3u");
			toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			attr(td, "role", "gridcell");
			attr(td, "class", "spectrum-Calendar-tableCell svelte-mxrq3u");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, span);
			append(span, t0);
			append(td, t1);

			if (!mounted) {
				dispose = listen(td, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*monthList*/ 1 && t0_value !== (t0_value = /*item*/ ctx[11] + "")) set_data(t0, t0_value);

			if (dirty & /*currentMonth, currentYear*/ 6) {
				toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(td);
			mounted = false;
			dispose();
		}
	};
}

// (76:2) {#each monthList as item, i}
function create_each_block_2(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[13] >= 3 && /*i*/ ctx[13] < 6 && create_if_block_2$5(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*i*/ ctx[13] >= 3 && /*i*/ ctx[13] < 6) if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (89:4) {#if i >= 6 && i < 9}
function create_if_block_1$x(ctx) {
	let td;
	let span;
	let t0_value = /*item*/ ctx[11] + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[8](/*i*/ ctx[13], ...args);
	}

	return {
		c() {
			td = element("td");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			attr(span, "role", "presentation");
			attr(span, "class", "spectrum-Calendar-date rubus-Calendar-month svelte-mxrq3u");
			toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			attr(td, "role", "gridcell");
			attr(td, "class", "spectrum-Calendar-tableCell svelte-mxrq3u");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, span);
			append(span, t0);
			append(td, t1);

			if (!mounted) {
				dispose = listen(td, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*monthList*/ 1 && t0_value !== (t0_value = /*item*/ ctx[11] + "")) set_data(t0, t0_value);

			if (dirty & /*currentMonth, currentYear*/ 6) {
				toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(td);
			mounted = false;
			dispose();
		}
	};
}

// (88:2) {#each monthList as item, i}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[13] >= 6 && /*i*/ ctx[13] < 9 && create_if_block_1$x(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*i*/ ctx[13] >= 6 && /*i*/ ctx[13] < 9) if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (101:4) {#if i >= 9 && i < 12}
function create_if_block$y(ctx) {
	let td;
	let span;
	let t0_value = /*item*/ ctx[11] + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[9](/*i*/ ctx[13], ...args);
	}

	return {
		c() {
			td = element("td");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			attr(span, "role", "presentation");
			attr(span, "class", "spectrum-Calendar-date rubus-Calendar-month svelte-mxrq3u");
			toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			attr(td, "role", "gridcell");
			attr(td, "class", "spectrum-Calendar-tableCell svelte-mxrq3u");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, span);
			append(span, t0);
			append(td, t1);

			if (!mounted) {
				dispose = listen(td, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*monthList*/ 1 && t0_value !== (t0_value = /*item*/ ctx[11] + "")) set_data(t0, t0_value);

			if (dirty & /*currentMonth, currentYear*/ 6) {
				toggle_class(span, "current-month", /*currentMonth*/ ctx[2] == /*i*/ ctx[13] && /*currentYear*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(td);
			mounted = false;
			dispose();
		}
	};
}

// (100:2) {#each monthList as item, i}
function create_each_block$2(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[13] >= 9 && /*i*/ ctx[13] < 12 && create_if_block$y(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*i*/ ctx[13] >= 9 && /*i*/ ctx[13] < 12) if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$U(ctx) {
	let tr0;
	let t0;
	let tr1;
	let t1;
	let tr2;
	let t2;
	let tr3;
	let each_value_3 = /*monthList*/ ctx[0];
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let each_value_2 = /*monthList*/ ctx[0];
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = /*monthList*/ ctx[0];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*monthList*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			tr0 = element("tr");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t0 = space();
			tr1 = element("tr");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t1 = space();
			tr2 = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t2 = space();
			tr3 = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(tr0, "role", "row");
			attr(tr1, "role", "row");
			attr(tr2, "role", "row");
			attr(tr3, "role", "row");
		},
		m(target, anchor) {
			insert(target, tr0, anchor);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(tr0, null);
			}

			insert(target, t0, anchor);
			insert(target, tr1, anchor);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(tr1, null);
			}

			insert(target, t1, anchor);
			insert(target, tr2, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr2, null);
			}

			insert(target, t2, anchor);
			insert(target, tr3, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr3, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*pickMonth, currentMonth, currentYear, monthList*/ 23) {
				each_value_3 = /*monthList*/ ctx[0];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
					} else {
						each_blocks_3[i] = create_each_block_3(child_ctx);
						each_blocks_3[i].c();
						each_blocks_3[i].m(tr0, null);
					}
				}

				for (; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d(1);
				}

				each_blocks_3.length = each_value_3.length;
			}

			if (dirty & /*pickMonth, currentMonth, currentYear, monthList*/ 23) {
				each_value_2 = /*monthList*/ ctx[0];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_2(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(tr1, null);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_2.length;
			}

			if (dirty & /*pickMonth, currentMonth, currentYear, monthList*/ 23) {
				each_value_1 = /*monthList*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr2, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*pickMonth, currentMonth, currentYear, monthList*/ 23) {
				each_value = /*monthList*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(tr0);
			destroy_each(each_blocks_3, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(tr1);
			destroy_each(each_blocks_2, detaching);
			if (detaching) detach(t1);
			if (detaching) detach(tr2);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(tr3);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$U($$self, $$props, $$invalidate) {
	let $rubusCalendar;
	let { dateDate = [] } = $$props;
	let rubusCalendar = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendar, value => $$invalidate(10, $rubusCalendar = value));

	function pickMonth(i) {
		let d = new Date($rubusCalendar.viewDate);
		let ty = d.getFullYear();
		let td = d.getDate();
		set_store_value(rubusCalendar, $rubusCalendar.viewDate = `${ty}-${i + 1}-${td}`, $rubusCalendar);
		set_store_value(rubusCalendar, $rubusCalendar.view = "month", $rubusCalendar);
	}

	const click_handler = i => pickMonth(i);
	const click_handler_1 = i => pickMonth(i);
	const click_handler_2 = i => pickMonth(i);
	const click_handler_3 = i => pickMonth(i);

	$$self.$$set = $$props => {
		if ("dateDate" in $$props) $$invalidate(5, dateDate = $$props.dateDate);
	};

	let monthList;
	let currentYear;
	let currentMonth;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$rubusCalendar*/ 1024) {
			 $$invalidate(0, monthList = noun[$rubusCalendar.lang][$rubusCalendar.monthName]);
		}

		if ($$self.$$.dirty & /*dateDate, $rubusCalendar*/ 1056) {
			 $$invalidate(1, currentYear = new Date(dateDate).getFullYear() == new Date($rubusCalendar.nowDate).getFullYear());
		}

		if ($$self.$$.dirty & /*dateDate*/ 32) {
			 $$invalidate(2, currentMonth = new Date(dateDate).getMonth());
		}
	};

	return [
		monthList,
		currentYear,
		currentMonth,
		rubusCalendar,
		pickMonth,
		dateDate,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3
	];
}

class CalendarBodyYear extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-mxrq3u-style")) add_css$8();
		init(this, options, instance$U, create_fragment$U, safe_not_equal, { dateDate: 5 });
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

/* src/packages/Calendar/body/CalendarBody.svelte generated by Svelte v3.24.1 */

function add_css$9() {
	var style = element("style");
	style.id = "svelte-smch71-style";
	style.textContent = ".spectrum--medium .spectrum-Calendar-body{width:280px;height:280px}.spectrum--large .spectrum-Calendar-body{width:336px;height:336px}.spectrum-Calendar-body.svelte-smch71{position:relative;overflow:hidden}.rubus-calendar-body.svelte-smch71{position:absolute;bottom:0;left:0}";
	append(document.head, style);
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

// (60:46) 
function create_if_block_2$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3$5, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*$rubusCalendarData*/ ctx[1].flag) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (34:2) {#if $rubusCalendarData.view == 'month'}
function create_if_block$z(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$y, create_else_block$4];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$rubusCalendarData*/ ctx[1].flag) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (70:4) {:else}
function create_else_block_1$2(ctx) {
	let table;
	let tbody;
	let calendarbodyyear;
	let table_intro;
	let current;

	calendarbodyyear = new CalendarBodyYear({
			props: {
				dateDate: /*$rubusCalendarData*/ ctx[1].viewDate
			}
		});

	return {
		c() {
			table = element("table");
			tbody = element("tbody");
			create_component(calendarbodyyear.$$.fragment);
			attr(tbody, "role", "presentation");
			attr(table, "role", "presentation");
			attr(table, "class", "spectrum-Calendar-table rubus-calendar-body svelte-smch71");
		},
		m(target, anchor) {
			insert(target, table, anchor);
			append(table, tbody);
			mount_component(calendarbodyyear, tbody, null);
			current = true;
		},
		p(ctx, dirty) {
			const calendarbodyyear_changes = {};
			if (dirty & /*$rubusCalendarData*/ 2) calendarbodyyear_changes.dateDate = /*$rubusCalendarData*/ ctx[1].viewDate;
			calendarbodyyear.$set(calendarbodyyear_changes);
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyyear.$$.fragment, local);

			if (!table_intro) {
				add_render_callback(() => {
					table_intro = create_in_transition(table, fly, {
						y: `${/*$rubusCalendarData*/ ctx[1].action == "next"
						? 200
						: -200}`,
						duration: 300
					});

					table_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(calendarbodyyear.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);
			destroy_component(calendarbodyyear);
		}
	};
}

// (61:4) {#if $rubusCalendarData.flag}
function create_if_block_3$5(ctx) {
	let table;
	let tbody;
	let calendarbodyyear;
	let table_intro;
	let current;

	calendarbodyyear = new CalendarBodyYear({
			props: {
				dateDate: /*$rubusCalendarData*/ ctx[1].viewDate
			}
		});

	return {
		c() {
			table = element("table");
			tbody = element("tbody");
			create_component(calendarbodyyear.$$.fragment);
			attr(tbody, "role", "presentation");
			attr(table, "role", "presentation");
			attr(table, "class", "spectrum-Calendar-table rubus-calendar-body svelte-smch71");
		},
		m(target, anchor) {
			insert(target, table, anchor);
			append(table, tbody);
			mount_component(calendarbodyyear, tbody, null);
			current = true;
		},
		p(ctx, dirty) {
			const calendarbodyyear_changes = {};
			if (dirty & /*$rubusCalendarData*/ 2) calendarbodyyear_changes.dateDate = /*$rubusCalendarData*/ ctx[1].viewDate;
			calendarbodyyear.$set(calendarbodyyear_changes);
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyyear.$$.fragment, local);

			if (!table_intro) {
				add_render_callback(() => {
					table_intro = create_in_transition(table, fly, {
						y: `${/*$rubusCalendarData*/ ctx[1].action == "prev"
						? -200
						: 200}`,
						duration: 300
					});

					table_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(calendarbodyyear.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);
			destroy_component(calendarbodyyear);
		}
	};
}

// (47:4) {:else}
function create_else_block$4(ctx) {
	let table;
	let calendarbodyhead;
	let t;
	let tbody;
	let table_intro;
	let current;
	calendarbodyhead = new CalendarBodyHead({});
	let each_value_1 = /*monthData*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			table = element("table");
			create_component(calendarbodyhead.$$.fragment);
			t = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(tbody, "role", "presentation");
			attr(table, "role", "presentation");
			attr(table, "class", "spectrum-Calendar-table rubus-calendar-body svelte-smch71");
		},
		m(target, anchor) {
			insert(target, table, anchor);
			mount_component(calendarbodyhead, table, null);
			append(table, t);
			append(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*monthData*/ 1) {
				each_value_1 = /*monthData*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tbody, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyhead.$$.fragment, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			if (local) {
				if (!table_intro) {
					add_render_callback(() => {
						table_intro = create_in_transition(table, fly, {
							x: `${/*$rubusCalendarData*/ ctx[1].action == "next"
							? 200
							: -200}`,
							duration: 300
						});

						table_intro.start();
					});
				}
			}

			current = true;
		},
		o(local) {
			transition_out(calendarbodyhead.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);
			destroy_component(calendarbodyhead);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (35:4) {#if $rubusCalendarData.flag}
function create_if_block_1$y(ctx) {
	let table;
	let calendarbodyhead;
	let t;
	let tbody;
	let table_intro;
	let current;
	calendarbodyhead = new CalendarBodyHead({});
	let each_value = /*monthData*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			table = element("table");
			create_component(calendarbodyhead.$$.fragment);
			t = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(tbody, "role", "presentation");
			attr(table, "role", "presentation");
			attr(table, "class", "spectrum-Calendar-table rubus-calendar-body svelte-smch71");
		},
		m(target, anchor) {
			insert(target, table, anchor);
			mount_component(calendarbodyhead, table, null);
			append(table, t);
			append(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*monthData*/ 1) {
				each_value = /*monthData*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tbody, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyhead.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			if (local) {
				if (!table_intro) {
					add_render_callback(() => {
						table_intro = create_in_transition(table, fly, {
							x: `${/*$rubusCalendarData*/ ctx[1].action == "prev"
							? -200
							: 200}`,
							duration: 300
						});

						table_intro.start();
					});
				}
			}

			current = true;
		},
		o(local) {
			transition_out(calendarbodyhead.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);
			destroy_component(calendarbodyhead);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (54:10) {#each monthData as item, i}
function create_each_block_1$1(ctx) {
	let calendarbodyweek;
	let current;
	calendarbodyweek = new CalendarBodyWeek({ props: { week: /*item*/ ctx[3] } });

	return {
		c() {
			create_component(calendarbodyweek.$$.fragment);
		},
		m(target, anchor) {
			mount_component(calendarbodyweek, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const calendarbodyweek_changes = {};
			if (dirty & /*monthData*/ 1) calendarbodyweek_changes.week = /*item*/ ctx[3];
			calendarbodyweek.$set(calendarbodyweek_changes);
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyweek.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(calendarbodyweek.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(calendarbodyweek, detaching);
		}
	};
}

// (42:10) {#each monthData as item, i}
function create_each_block$3(ctx) {
	let calendarbodyweek;
	let current;
	calendarbodyweek = new CalendarBodyWeek({ props: { week: /*item*/ ctx[3] } });

	return {
		c() {
			create_component(calendarbodyweek.$$.fragment);
		},
		m(target, anchor) {
			mount_component(calendarbodyweek, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const calendarbodyweek_changes = {};
			if (dirty & /*monthData*/ 1) calendarbodyweek_changes.week = /*item*/ ctx[3];
			calendarbodyweek.$set(calendarbodyweek_changes);
		},
		i(local) {
			if (current) return;
			transition_in(calendarbodyweek.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(calendarbodyweek.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(calendarbodyweek, detaching);
		}
	};
}

function create_fragment$V(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$z, create_if_block_2$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$rubusCalendarData*/ ctx[1].view == "month") return 0;
		if (/*$rubusCalendarData*/ ctx[1].view == "year") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "spectrum-Calendar-body svelte-smch71");
			attr(div, "role", "grid");
			attr(div, "tabindex", "0");
			attr(div, "aria-readonly", "true");
			attr(div, "aria-disabled", "false");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

function instance$V($$self, $$props, $$invalidate) {
	let $rubusCalendarData;
	let rubusCalendarData = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendarData, value => $$invalidate(1, $rubusCalendarData = value));
	let monthData;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$rubusCalendarData*/ 2) {
			 $$invalidate(0, monthData = getThisMonthData($rubusCalendarData.viewDate));
		}
	};

	return [monthData, $rubusCalendarData, rubusCalendarData];
}

class CalendarBody extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-smch71-style")) add_css$9();
		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});
	}
}

//Safari Date function polyfill
!(function (_Date) {
  function standardizeArgs(args) {
    if (args.length === 1 && typeof args[0] === "string" && isNaN(_Date.parse(args[0]))) {
      args[0] = args[0].replace(/-/g, "/");
    }
    return Array.prototype.slice.call(args);
  }

  function $Date() {
    if (this instanceof $Date) {
      return new (Function.prototype.bind.apply(_Date, [null].concat(standardizeArgs(arguments))))();
    }
    return _Date();
  }
  $Date.prototype = _Date.prototype;

  $Date.now = _Date.now;
  $Date.UTC = _Date.UTC;
  $Date.parse = function () {
    return _Date.parse.apply(_Date, standardizeArgs(arguments));
  };

  Date = $Date;
})(Date);

/* src/packages/Calendar/Calendar.svelte generated by Svelte v3.24.1 */

function create_fragment$W(ctx) {
	let div;
	let calendarhader;
	let t;
	let calendarbody;
	let current;
	calendarhader = new CalendarHader({});
	calendarbody = new CalendarBody({});

	return {
		c() {
			div = element("div");
			create_component(calendarhader.$$.fragment);
			t = space();
			create_component(calendarbody.$$.fragment);
			attr(div, "class", "spectrum-Calendar");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(calendarhader, div, null);
			append(div, t);
			mount_component(calendarbody, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(calendarhader.$$.fragment, local);
			transition_in(calendarbody.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(calendarhader.$$.fragment, local);
			transition_out(calendarbody.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(calendarhader);
			destroy_component(calendarbody);
		}
	};
}

function instance$W($$self, $$props, $$invalidate) {
	let $rubusCalendarConfig;
	let { nowDate = new Date() } = $$props;
	let { lang = "en" } = $$props;
	let { viewDate = nowDate } = $$props;
	let { showOutsideMonth = true } = $$props;
	let { pickerMode = "single" } = $$props;
	let { disabled = [] } = $$props;
	let { selected = [] } = $$props;
	let { focused = [] } = $$props;
	let { validRange = "any" } = $$props;
	let { weekNameMode = "weekShortAbbreviation" } = $$props;
	let { monthNameMode = "monthFullName" } = $$props;

	const RubusCalendarData = writable({
		nowDate: [],
		viewDate,
		action: "next",
		flag: false,
		view: "month",
		monthName: monthNameMode,
		weekName: weekNameMode,
		lang,
		showOutsideMonth,
		pickerMode,
		disabled,
		selected,
		focused,
		validRange
	});

	setContext("RubusCalendarData", RubusCalendarData);
	let rubusCalendarConfig = getContext("RubusCalendarData");
	component_subscribe($$self, rubusCalendarConfig, value => $$invalidate(12, $rubusCalendarConfig = value));

	beforeUpdate(() => {
		set_store_value(rubusCalendarConfig, $rubusCalendarConfig.nowDate = nowDate, $rubusCalendarConfig);
		$$invalidate(1, selected = $rubusCalendarConfig.selected);
	});

	$$self.$$set = $$props => {
		if ("nowDate" in $$props) $$invalidate(2, nowDate = $$props.nowDate);
		if ("lang" in $$props) $$invalidate(3, lang = $$props.lang);
		if ("viewDate" in $$props) $$invalidate(4, viewDate = $$props.viewDate);
		if ("showOutsideMonth" in $$props) $$invalidate(5, showOutsideMonth = $$props.showOutsideMonth);
		if ("pickerMode" in $$props) $$invalidate(6, pickerMode = $$props.pickerMode);
		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
		if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
		if ("focused" in $$props) $$invalidate(8, focused = $$props.focused);
		if ("validRange" in $$props) $$invalidate(9, validRange = $$props.validRange);
		if ("weekNameMode" in $$props) $$invalidate(10, weekNameMode = $$props.weekNameMode);
		if ("monthNameMode" in $$props) $$invalidate(11, monthNameMode = $$props.monthNameMode);
	};

	return [
		rubusCalendarConfig,
		selected,
		nowDate,
		lang,
		viewDate,
		showOutsideMonth,
		pickerMode,
		disabled,
		focused,
		validRange,
		weekNameMode,
		monthNameMode
	];
}

class Calendar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
			nowDate: 2,
			lang: 3,
			viewDate: 4,
			showOutsideMonth: 5,
			pickerMode: 6,
			disabled: 7,
			selected: 1,
			focused: 8,
			validRange: 9,
			weekNameMode: 10,
			monthNameMode: 11
		});
	}
}

/* src/packages/Asset/Image.svelte generated by Svelte v3.24.1 */

function create_if_block_1$z(ctx) {
	let img;
	let img_class_value;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", img_class_value = /*$$restProps*/ ctx[3].class);
			attr(img, "alt", /*imgAlt*/ ctx[1]);
			if (img.src !== (img_src_value = /*imgUrl*/ ctx[0])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$$restProps*/ 8 && img_class_value !== (img_class_value = /*$$restProps*/ ctx[3].class)) {
				attr(img, "class", img_class_value);
			}

			if (dirty & /*imgAlt*/ 2) {
				attr(img, "alt", /*imgAlt*/ ctx[1]);
			}

			if (dirty & /*imgUrl*/ 1 && img.src !== (img_src_value = /*imgUrl*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (20:0) {#if variants == 'background'}
function create_if_block$A(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$$restProps*/ ctx[3].class);
			set_style(div, "background-image", "url(" + /*imgUrl*/ ctx[0] + ")");
			attr(div, "aria-label", /*imgAlt*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$$restProps*/ 8 && div_class_value !== (div_class_value = /*$$restProps*/ ctx[3].class)) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*imgUrl*/ 1) {
				set_style(div, "background-image", "url(" + /*imgUrl*/ ctx[0] + ")");
			}

			if (dirty & /*imgAlt*/ 2) {
				attr(div, "aria-label", /*imgAlt*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$X(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[2] == "background") return create_if_block$A;
		if (/*variants*/ ctx[2] == "foreground") return create_if_block_1$z;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$X($$self, $$props, $$invalidate) {
	const omit_props_names = ["imgUrl","imgAlt","variants"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { imgUrl = "" } = $$props;
	let { imgAlt = "Image" } = $$props;
	let { variants = "foreground" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("imgUrl" in $$new_props) $$invalidate(0, imgUrl = $$new_props.imgUrl);
		if ("imgAlt" in $$new_props) $$invalidate(1, imgAlt = $$new_props.imgAlt);
		if ("variants" in $$new_props) $$invalidate(2, variants = $$new_props.variants);
	};

	return [imgUrl, imgAlt, variants, $$restProps];
}

class Image extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$X, create_fragment$X, safe_not_equal, { imgUrl: 0, imgAlt: 1, variants: 2 });
	}
}

/* src/packages/Card/Card.svelte generated by Svelte v3.24.1 */

function add_css$a() {
	var style = element("style");
	style.id = "svelte-ub9nhp-style";
	style.textContent = ".spectrum-Card-quickActions{display:flex;justify-content:center;align-items:center}.spectrum-Card:hover .spectrum-Card-quickActions,.spectrum-Card-actions{transition:background-color var(--spectrum-global-animation-duration-100, 130ms);border-radius:var(--spectrum-quickactions-border-radius, var(--spectrum-alias-border-radius-regular));background-color:var(\n      --spectrum-quickactions-background-color,\n      var(--spectrum-alias-background-color-quickactions)\n    )}.is-focused .spectrum-Card-quickActions{transition:background-color var(--spectrum-global-animation-duration-100, 130ms);border-radius:var(--spectrum-quickactions-border-radius, var(--spectrum-alias-border-radius-regular));background-color:var(\n      --spectrum-quickactions-background-color,\n      var(--spectrum-alias-background-color-quickactions)\n    )}.rubus-Checkbox{display:flex;flex-wrap:wrap;align-items:center;justify-content:center;width:var(--spectrum-global-dimension-size-175)}.spectrum-Card-actions{display:flex;flex-wrap:wrap;align-items:center;justify-content:center;width:var(--spectrum-quickactions-height, var(--spectrum-global-dimension-size-500))}";
	append(document.head, style);
}

const get_card_action_slot_changes_1 = dirty => ({});
const get_card_action_slot_context_1 = ctx => ({});
const get_card_action_slot_changes = dirty => ({});
const get_card_action_slot_context = ctx => ({});
const get_card_preview_slot_changes = dirty => ({});
const get_card_preview_slot_context = ctx => ({});

// (148:4) {:else}
function create_else_block$5(ctx) {
	let current;
	const card_preview_slot_template = /*$$slots*/ ctx[16]["card-preview"];
	const card_preview_slot = create_slot(card_preview_slot_template, ctx, /*$$scope*/ ctx[15], get_card_preview_slot_context);

	return {
		c() {
			if (card_preview_slot) card_preview_slot.c();
		},
		m(target, anchor) {
			if (card_preview_slot) {
				card_preview_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (card_preview_slot) {
				if (card_preview_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(card_preview_slot, card_preview_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_card_preview_slot_changes, get_card_preview_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(card_preview_slot, local);
			current = true;
		},
		o(local) {
			transition_out(card_preview_slot, local);
			current = false;
		},
		d(detaching) {
			if (card_preview_slot) card_preview_slot.d(detaching);
		}
	};
}

// (146:4) {#if coverPhotoUrl}
function create_if_block_5$1(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				class: "spectrum-Card-coverPhoto",
				variants: "background",
				imgAlt: /*coverPhotoAlt*/ ctx[1],
				imgUrl: /*coverPhotoUrl*/ ctx[2]
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*coverPhotoAlt*/ 2) image_changes.imgAlt = /*coverPhotoAlt*/ ctx[1];
			if (dirty & /*coverPhotoUrl*/ 4) image_changes.imgUrl = /*coverPhotoUrl*/ ctx[2];
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (154:8) {#if !isQuiet || !isSmall}
function create_if_block_4$3(ctx) {
	let div;
	let current;
	const card_action_slot_template = /*$$slots*/ ctx[16]["card-action"];
	const card_action_slot = create_slot(card_action_slot_template, ctx, /*$$scope*/ ctx[15], get_card_action_slot_context);

	return {
		c() {
			div = element("div");
			if (card_action_slot) card_action_slot.c();
			attr(div, "class", "spectrum-Card-actionButton");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (card_action_slot) {
				card_action_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (card_action_slot) {
				if (card_action_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(card_action_slot, card_action_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_card_action_slot_changes, get_card_action_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(card_action_slot, local);
			current = true;
		},
		o(local) {
			transition_out(card_action_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (card_action_slot) card_action_slot.d(detaching);
		}
	};
}

// (162:8) {#if description}
function create_if_block_3$6(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*description*/ ctx[10]);
			attr(div, "class", "spectrum-Card-description");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*description*/ 1024) set_data(t, /*description*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (167:4) {#if !isQuiet}
function create_if_block_2$7(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Card-footer");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (172:4) {#if orientation == 'vertical'}
function create_if_block$B(ctx) {
	let t;
	let div1;
	let div0;
	let checkbox;
	let updating_checked;
	let current;
	let if_block = /*isQuiet*/ ctx[6] && /*isSmall*/ ctx[7] && create_if_block_1$A(ctx);

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[17].call(null, value);
	}

	let checkbox_props = { disabled: /*disabled*/ ctx[4] };

	if (/*isSelected*/ ctx[0] !== void 0) {
		checkbox_props.checked = /*isSelected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div1 = element("div");
			div0 = element("div");
			create_component(checkbox.$$.fragment);
			attr(div0, "class", "spectrum-Checkbox rubus-Checkbox");
			attr(div1, "class", "spectrum-QuickActions spectrum-Card-quickActions");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(checkbox, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*isQuiet*/ ctx[6] && /*isSmall*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isQuiet, isSmall*/ 192) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$A(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const checkbox_changes = {};
			if (dirty & /*disabled*/ 16) checkbox_changes.disabled = /*disabled*/ ctx[4];

			if (!updating_checked && dirty & /*isSelected*/ 1) {
				updating_checked = true;
				checkbox_changes.checked = /*isSelected*/ ctx[0];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			destroy_component(checkbox);
		}
	};
}

// (173:6) {#if isQuiet && isSmall}
function create_if_block_1$A(ctx) {
	let div;
	let current;
	const card_action_slot_template = /*$$slots*/ ctx[16]["card-action"];
	const card_action_slot = create_slot(card_action_slot_template, ctx, /*$$scope*/ ctx[15], get_card_action_slot_context_1);

	return {
		c() {
			div = element("div");
			if (card_action_slot) card_action_slot.c();
			attr(div, "class", "spectrum-QuickActions spectrum-Card-actions");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (card_action_slot) {
				card_action_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (card_action_slot) {
				if (card_action_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(card_action_slot, card_action_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_card_action_slot_changes_1, get_card_action_slot_context_1);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(card_action_slot, local);
			current = true;
		},
		o(local) {
			transition_out(card_action_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (card_action_slot) card_action_slot.d(detaching);
		}
	};
}

function create_fragment$Y(ctx) {
	let div6;
	let div5;
	let current_block_type_index;
	let if_block0;
	let t0;
	let div4;
	let div1;
	let div0;
	let t1;
	let t2;
	let t3;
	let div3;
	let div2;
	let t4;
	let t5;
	let t6;
	let t7;
	let current;
	const if_block_creators = [create_if_block_5$1, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*coverPhotoUrl*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = (!/*isQuiet*/ ctx[6] || !/*isSmall*/ ctx[7]) && create_if_block_4$3(ctx);
	let if_block2 = /*description*/ ctx[10] && create_if_block_3$6(ctx);
	let if_block3 = !/*isQuiet*/ ctx[6] && create_if_block_2$7(ctx);
	let if_block4 = /*orientation*/ ctx[3] == "vertical" && create_if_block$B(ctx);

	return {
		c() {
			div6 = element("div");
			div5 = element("div");
			if_block0.c();
			t0 = space();
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			t1 = text(/*title*/ ctx[8]);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div3 = element("div");
			div2 = element("div");
			t4 = text(/*subtitle*/ ctx[9]);
			t5 = space();
			if (if_block2) if_block2.c();
			t6 = space();
			if (if_block3) if_block3.c();
			t7 = space();
			if (if_block4) if_block4.c();
			attr(div0, "class", "spectrum-Card-title");
			attr(div1, "class", "spectrum-Card-header");
			attr(div2, "class", "spectrum-Card-subtitle");
			attr(div3, "class", "spectrum-Card-content");
			attr(div4, "class", "spectrum-Card-body");
			attr(div5, "style", /*styleCss*/ ctx[12]);
			attr(div5, "class", "spectrum-Card");
			attr(div5, "tabindex", "0");
			attr(div5, "role", "figure");
			toggle_class(div5, "spectrum-Card--quiet", /*isQuiet*/ ctx[6]);
			toggle_class(div5, "spectrum-Card--small", /*isSmall*/ ctx[7]);
			toggle_class(div5, "spectrum-Card--horizontal", /*orientation*/ ctx[3] == "horizontal");
			toggle_class(div5, "is-focused", /*isFocused*/ ctx[5]);
			attr(div6, "style", /*styleCss*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, div6, anchor);
			append(div6, div5);
			if_blocks[current_block_type_index].m(div5, null);
			append(div5, t0);
			append(div5, div4);
			append(div4, div1);
			append(div1, div0);
			append(div0, t1);
			append(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append(div4, t3);
			append(div4, div3);
			append(div3, div2);
			append(div2, t4);
			append(div3, t5);
			if (if_block2) if_block2.m(div3, null);
			append(div5, t6);
			if (if_block3) if_block3.m(div5, null);
			append(div5, t7);
			if (if_block4) if_block4.m(div5, null);
			/*div5_binding*/ ctx[18](div5);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(div5, t0);
			}

			if (!current || dirty & /*title*/ 256) set_data(t1, /*title*/ ctx[8]);

			if (!/*isQuiet*/ ctx[6] || !/*isSmall*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*isQuiet, isSmall*/ 192) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*subtitle*/ 512) set_data(t4, /*subtitle*/ ctx[9]);

			if (/*description*/ ctx[10]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_3$6(ctx);
					if_block2.c();
					if_block2.m(div3, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!/*isQuiet*/ ctx[6]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*isQuiet*/ 64) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_2$7(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div5, t7);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*orientation*/ ctx[3] == "vertical") {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty & /*orientation*/ 8) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block$B(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div5, null);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*styleCss*/ 4096) {
				attr(div5, "style", /*styleCss*/ ctx[12]);
			}

			if (dirty & /*isQuiet*/ 64) {
				toggle_class(div5, "spectrum-Card--quiet", /*isQuiet*/ ctx[6]);
			}

			if (dirty & /*isSmall*/ 128) {
				toggle_class(div5, "spectrum-Card--small", /*isSmall*/ ctx[7]);
			}

			if (dirty & /*orientation*/ 8) {
				toggle_class(div5, "spectrum-Card--horizontal", /*orientation*/ ctx[3] == "horizontal");
			}

			if (dirty & /*isFocused*/ 32) {
				toggle_class(div5, "is-focused", /*isFocused*/ ctx[5]);
			}

			if (!current || dirty & /*styleCss*/ 4096) {
				attr(div6, "style", /*styleCss*/ ctx[12]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block3);
			transition_in(if_block4);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block3);
			transition_out(if_block4);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div6);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			/*div5_binding*/ ctx[18](null);
		}
	};
}

function instance$Y($$self, $$props, $$invalidate) {
	let { coverPhotoAlt = "Cover photo" } = $$props;
	let { coverPhotoUrl = "" } = $$props;
	let { orientation = "vertical" } = $$props;
	let { isSelected = false } = $$props;
	let { disabled = false } = $$props;
	let { isFocused = false } = $$props;
	let { isQuiet = false } = $$props;
	let { isSmall = false } = $$props;
	let { title = "" } = $$props;
	let { subtitle = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { description = "" } = $$props;
	let card;

	onMount(() => {
		card && advanceAddClassName(card, "card-preview", "spectrum-Card-preview");
	});

	let { $$slots = {}, $$scope } = $$props;

	function checkbox_checked_binding(value) {
		isSelected = value;
		$$invalidate(0, isSelected);
	}

	function div5_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			card = $$value;
			$$invalidate(11, card);
		});
	}

	$$self.$$set = $$props => {
		if ("coverPhotoAlt" in $$props) $$invalidate(1, coverPhotoAlt = $$props.coverPhotoAlt);
		if ("coverPhotoUrl" in $$props) $$invalidate(2, coverPhotoUrl = $$props.coverPhotoUrl);
		if ("orientation" in $$props) $$invalidate(3, orientation = $$props.orientation);
		if ("isSelected" in $$props) $$invalidate(0, isSelected = $$props.isSelected);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ("isFocused" in $$props) $$invalidate(5, isFocused = $$props.isFocused);
		if ("isQuiet" in $$props) $$invalidate(6, isQuiet = $$props.isQuiet);
		if ("isSmall" in $$props) $$invalidate(7, isSmall = $$props.isSmall);
		if ("title" in $$props) $$invalidate(8, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(9, subtitle = $$props.subtitle);
		if ("width" in $$props) $$invalidate(13, width = $$props.width);
		if ("height" in $$props) $$invalidate(14, height = $$props.height);
		if ("description" in $$props) $$invalidate(10, description = $$props.description);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	let styleCss;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*width, height*/ 24576) {
			 $$invalidate(12, styleCss = [
				width && `width:var(--spectrum-global-dimension-${width});`,
				height && `height:var(--spectrum-global-dimension-${height});`
			].filter(Boolean).join(" "));
		}
	};

	return [
		isSelected,
		coverPhotoAlt,
		coverPhotoUrl,
		orientation,
		disabled,
		isFocused,
		isQuiet,
		isSmall,
		title,
		subtitle,
		description,
		card,
		styleCss,
		width,
		height,
		$$scope,
		$$slots,
		checkbox_checked_binding,
		div5_binding
	];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-ub9nhp-style")) add_css$a();

		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
			coverPhotoAlt: 1,
			coverPhotoUrl: 2,
			orientation: 3,
			isSelected: 0,
			disabled: 4,
			isFocused: 5,
			isQuiet: 6,
			isSmall: 7,
			title: 8,
			subtitle: 9,
			width: 13,
			height: 14,
			description: 10
		});
	}
}

/* src/packages/CircleLoader/Circleloader.svelte generated by Svelte v3.24.1 */

function create_fragment$Z(ctx) {
	let div8;

	return {
		c() {
			div8 = element("div");

			div8.innerHTML = `<div class="spectrum-CircleLoader-track"></div> 
  <div class="spectrum-CircleLoader-fills"><div class="spectrum-CircleLoader-fillMask1"><div class="spectrum-CircleLoader-fillSubMask1"><div class="spectrum-CircleLoader-fill"></div></div></div> 
    <div class="spectrum-CircleLoader-fillMask2"><div class="spectrum-CircleLoader-fillSubMask2"><div class="spectrum-CircleLoader-fill"></div></div></div></div>`;

			attr(div8, "class", "spectrum-CircleLoader");
			toggle_class(div8, "spectrum-CircleLoader--indeterminate", /*indeterminate*/ ctx[2]);
			toggle_class(div8, "spectrum-CircleLoader--small", /*scale*/ ctx[0] == "small");
			toggle_class(div8, "spectrum-CircleLoader--large", /*scale*/ ctx[0] == "large");
			toggle_class(div8, "spectrum-CircleLoader--overBackground", /*variants*/ ctx[1] == "overBackground");
		},
		m(target, anchor) {
			insert(target, div8, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*indeterminate*/ 4) {
				toggle_class(div8, "spectrum-CircleLoader--indeterminate", /*indeterminate*/ ctx[2]);
			}

			if (dirty & /*scale*/ 1) {
				toggle_class(div8, "spectrum-CircleLoader--small", /*scale*/ ctx[0] == "small");
			}

			if (dirty & /*scale*/ 1) {
				toggle_class(div8, "spectrum-CircleLoader--large", /*scale*/ ctx[0] == "large");
			}

			if (dirty & /*variants*/ 2) {
				toggle_class(div8, "spectrum-CircleLoader--overBackground", /*variants*/ ctx[1] == "overBackground");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div8);
		}
	};
}

function animateCircleLoaders() {
	var value = 0;

	setInterval(
		function () {
			var loaders = document.querySelectorAll(".spectrum-CircleLoader:not(spectrum-CircleLoader--indeterminate)");

			if (loaders.length) {
				changeLoaders(loaders, value++);

				if (value >= 100) {
					value = 0;
				}
			}
		},
		500
	);
}

function changeLoaders(nodeList, value) {
	Array.prototype.slice.call(nodeList).forEach(function (loader) {
		changeLoader(loader, value);
	});
}

function changeLoader(loader, value, submask1, submask2) {
	submask1 = submask1 || loader.querySelector(".spectrum-CircleLoader-fillSubMask1");
	submask2 = submask2 || loader.querySelector(".spectrum-CircleLoader-fillSubMask2");
	var angle;

	if (value > 0 && value <= 50) {
		angle = -180 + value / 50 * 180;
		submask1.style.transform = "rotate(" + angle + "deg)";
		submask2.style.transform = "rotate(-180deg)";
	} else if (value > 50) {
		angle = -180 + (value - 50) / 50 * 180;
		submask1.style.transform = "rotate(0deg)";
		submask2.style.transform = "rotate(" + angle + "deg)";
	}
}

function instance$Z($$self, $$props, $$invalidate) {
	let { scale = "medium" } = $$props;
	let { variants = "general" } = $$props;
	let { indeterminate = false } = $$props;

	onMount(() => {
		animateCircleLoaders();
	});

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("indeterminate" in $$props) $$invalidate(2, indeterminate = $$props.indeterminate);
	};

	return [scale, variants, indeterminate];
}

class Circleloader extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { scale: 0, variants: 1, indeterminate: 2 });
	}
}

function integrateProps(a) {
  let keys = Object.getOwnPropertyNames(a);
  let arr = [];
  for (let index = 0; index < keys.length; index++) {
    arr[index] = keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() + ":" + a[keys[index]] + ";";
  }
  return arr.filter(Boolean).join("");
}
function integrateDimensionProps(a) {
  let keys = Object.getOwnPropertyNames(a);
  let arr = [];
  for (let index = 0; index < keys.length; index++) {
    arr[index] =
      keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() +
      `:var(--spectrum-global-dimension-${a[keys[index]]}, var(--spectrum-alias-${a[keys[index]]}));`;
  }
  return arr.filter(Boolean).join("");
}

function integrateAutoProps(a) {
  let keys = Object.getOwnPropertyNames(a);
  let arr = [];
  for (let index = 0; index < keys.length; index++) {
    if (typeof a[keys[index]] == "string" && a[keys[index]].search("size") > -1) {
      if (a[keys[index]].search("-size") > -1) {
        arr[index] =
          keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() +
          `:calc(-1 * var(--spectrum-global-dimension-${a[keys[index]]}, var(--spectrum-alias-${a[keys[index]]})));`;
      } else {
        arr[index] =
          keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() +
          `:var(--spectrum-global-dimension-${a[keys[index]]}, var(--spectrum-alias-${a[keys[index]]}));`;
      }
    } else if (typeof a[keys[index]] == "string" && determineMode(a[keys[index]])) {
      arr[index] =
        keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() + `:var(--spectrum-global-color-${a[keys[index]]});`;
    } else {
      arr[index] = keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() + ":" + a[keys[index]] + ";";
    }
  }
  return arr.filter(Boolean).join("");
}

function determineMode(t) {
  let colorKey = [
    "celery",
    "chartreuse",
    "yellow",
    "magenta",
    "fuchsia",
    "purple",
    "indigo",
    "seafoam",
    "red",
    "orange",
    "green",
    "blue",
    "gray",
  ];
  for (let index = 0; index < colorKey.length; index++) {
    if (t.search(colorKey[index]) != -1) {
      return true;
    }
  }
  return false;
}

/* src/packages/CoachMark/CoachMark.svelte generated by Svelte v3.24.1 */

function add_css$b() {
	var style = element("style");
	style.id = "svelte-18mrz44-style";
	style.textContent = ".spectrum-CoachMarkIndicator{position:absolute;margin:0;padding:0;z-index:100}.rubus-CoachMarkPopover{position:relative}.spectrum-CoachMarkPopover{position:absolute;z-index:100}[dir=\"ltr\"] .rubus-CoachMarkPopover-leftTop{left:var(--spectrum-global-dimension-size-700)}[dir=\"rtl\"] .rubus-CoachMarkPopover-leftTop{right:var(--spectrum-global-dimension-size-700)}[dir=\"ltr\"] .rubus-CoachMarkPopover-rightTop{right:var(--spectrum-global-dimension-size-700)}[dir=\"rtl\"] .rubus-CoachMarkPopover-rightTop{left:var(--spectrum-global-dimension-size-700)}[dir=\"ltr\"] .rubus-CoachMarkPopover-leftBottom{left:var(--spectrum-global-dimension-size-700);bottom:calc(-1 * var(--spectrum-global-dimension-size-500))}[dir=\"rtl\"] .rubus-CoachMarkPopover-leftBottom{right:var(--spectrum-global-dimension-size-700);bottom:calc(-1 * var(--spectrum-global-dimension-size-500))}[dir=\"ltr\"] .rubus-CoachMarkPopover-rightBottom{right:var(--spectrum-global-dimension-size-700);bottom:calc(-1 * var(--spectrum-global-dimension-size-500))}[dir=\"rtl\"] .rubus-CoachMarkPopover-rightBottom{left:var(--spectrum-global-dimension-size-700);bottom:calc(-1 * var(--spectrum-global-dimension-size-500))}[dir=\"ltr\"] .rubus-CoachMarkPopover-quiet-leftTop{left:var(--spectrum-global-dimension-size-500)}[dir=\"rtl\"] .rubus-CoachMarkPopover-quiet-leftTop{right:var(--spectrum-global-dimension-size-500)}[dir=\"ltr\"] .rubus-CoachMarkPopover-quiet-rightTop{right:var(--spectrum-global-dimension-size-500)}[dir=\"rtl\"] .rubus-CoachMarkPopover-quiet-rightTop{left:var(--spectrum-global-dimension-size-500)}[dir=\"ltr\"] .rubus-CoachMarkPopover-quiet-leftBottom{left:var(--spectrum-global-dimension-size-500);bottom:calc(-1 * var(--spectrum-global-dimension-size-250))}[dir=\"rtl\"] .rubus-CoachMarkPopover-quiet-leftBottom{right:var(--spectrum-global-dimension-size-500);bottom:calc(-1 * var(--spectrum-global-dimension-size-250))}[dir=\"ltr\"] .rubus-CoachMarkPopover-quiet-rightBottom{right:var(--spectrum-global-dimension-size-500);bottom:calc(-1 * var(--spectrum-global-dimension-size-250))}[dir=\"rtl\"] .rubus-CoachMarkPopover-quiet-rightBottom{left:var(--spectrum-global-dimension-size-500);bottom:calc(-1 * var(--spectrum-global-dimension-size-250))}";
	append(document.head, style);
}

const get_coachmark_popover_footer_slot_changes = dirty => ({});
const get_coachmark_popover_footer_slot_context = ctx => ({});

// (156:6) {#if coverPhotoUrl}
function create_if_block_1$B(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				imgUrl: /*coverPhotoUrl*/ ctx[3],
				imgAlt: /*coverPhotoAlt*/ ctx[2],
				class: "spectrum-CoachMarkPopover-image"
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*coverPhotoUrl*/ 8) image_changes.imgUrl = /*coverPhotoUrl*/ ctx[3];
			if (dirty & /*coverPhotoAlt*/ 4) image_changes.imgAlt = /*coverPhotoAlt*/ ctx[2];
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (161:8) {#if totalStep}
function create_if_block$C(ctx) {
	let div;
	let bdo;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			div = element("div");
			bdo = element("bdo");
			t0 = text(/*presentStep*/ ctx[6]);
			t1 = text(" of ");
			t2 = text(/*totalStep*/ ctx[5]);
			attr(bdo, "dir", "ltr");
			attr(div, "class", "spectrum-CoachMarkPopover-step");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, bdo);
			append(bdo, t0);
			append(bdo, t1);
			append(bdo, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*presentStep*/ 64) set_data(t0, /*presentStep*/ ctx[6]);
			if (dirty & /*totalStep*/ 32) set_data(t2, /*totalStep*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$_(ctx) {
	let div8;
	let div4;
	let div3;
	let t0;
	let div1;
	let div0;
	let t1;
	let t2;
	let t3;
	let div2;
	let t4;
	let div3_class_value;
	let t5;
	let div5;
	let t6;
	let div6;
	let t7;
	let div7;
	let current;
	let if_block0 = /*coverPhotoUrl*/ ctx[3] && create_if_block_1$B(ctx);
	let if_block1 = /*totalStep*/ ctx[5] && create_if_block$C(ctx);
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	const coachmark_popover_footer_slot_template = /*$$slots*/ ctx[13]["coachmark-popover-footer"];
	const coachmark_popover_footer_slot = create_slot(coachmark_popover_footer_slot_template, ctx, /*$$scope*/ ctx[12], get_coachmark_popover_footer_slot_context);

	return {
		c() {
			div8 = element("div");
			div4 = element("div");
			div3 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			t1 = text(/*title*/ ctx[4]);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			t4 = space();
			if (coachmark_popover_footer_slot) coachmark_popover_footer_slot.c();
			t5 = space();
			div5 = element("div");
			t6 = space();
			div6 = element("div");
			t7 = space();
			div7 = element("div");
			attr(div0, "class", "spectrum-CoachMarkPopover-title");
			attr(div1, "class", "spectrum-CoachMarkPopover-header");
			attr(div2, "class", "spectrum-CoachMarkPopover-content");

			attr(div3, "class", div3_class_value = "spectrum-CoachMarkPopover " + (/*isQuiet*/ ctx[0]
			? `rubus-CoachMarkPopover-quiet-${/*coachMarkPopoverPosition*/ ctx[7]}`
			: `rubus-CoachMarkPopover-${/*coachMarkPopoverPosition*/ ctx[7]}`));

			attr(div4, "class", "rubus-CoachMarkPopover");
			attr(div5, "class", "spectrum-CoachMarkIndicator-ring");
			attr(div6, "class", "spectrum-CoachMarkIndicator-ring");
			attr(div7, "class", "spectrum-CoachMarkIndicator-ring");
			attr(div8, "class", "spectrum-CoachMarkIndicator");
			attr(div8, "style", /*positioningCssText*/ ctx[10]);
			toggle_class(div8, "spectrum-CoachMarkIndicator--quiet", /*isQuiet*/ ctx[0]);
			toggle_class(div8, "spectrum-CoachMarkIndicator--dark", /*variants*/ ctx[1] == "dark");
			toggle_class(div8, "spectrum-CoachMarkIndicator--light", /*variants*/ ctx[1] == "light");
		},
		m(target, anchor) {
			insert(target, div8, anchor);
			append(div8, div4);
			append(div4, div3);
			if (if_block0) if_block0.m(div3, null);
			append(div3, t0);
			append(div3, div1);
			append(div1, div0);
			append(div0, t1);
			append(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append(div3, t3);
			append(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			append(div3, t4);

			if (coachmark_popover_footer_slot) {
				coachmark_popover_footer_slot.m(div3, null);
			}

			/*div3_binding*/ ctx[14](div3);
			append(div8, t5);
			append(div8, div5);
			append(div8, t6);
			append(div8, div6);
			append(div8, t7);
			append(div8, div7);
			/*div8_binding*/ ctx[15](div8);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*coverPhotoUrl*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*coverPhotoUrl*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$B(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div3, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*title*/ 16) set_data(t1, /*title*/ ctx[4]);

			if (/*totalStep*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$C(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}

			if (coachmark_popover_footer_slot) {
				if (coachmark_popover_footer_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(coachmark_popover_footer_slot, coachmark_popover_footer_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_coachmark_popover_footer_slot_changes, get_coachmark_popover_footer_slot_context);
				}
			}

			if (!current || dirty & /*isQuiet, coachMarkPopoverPosition*/ 129 && div3_class_value !== (div3_class_value = "spectrum-CoachMarkPopover " + (/*isQuiet*/ ctx[0]
			? `rubus-CoachMarkPopover-quiet-${/*coachMarkPopoverPosition*/ ctx[7]}`
			: `rubus-CoachMarkPopover-${/*coachMarkPopoverPosition*/ ctx[7]}`))) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*positioningCssText*/ 1024) {
				attr(div8, "style", /*positioningCssText*/ ctx[10]);
			}

			if (dirty & /*isQuiet*/ 1) {
				toggle_class(div8, "spectrum-CoachMarkIndicator--quiet", /*isQuiet*/ ctx[0]);
			}

			if (dirty & /*variants*/ 2) {
				toggle_class(div8, "spectrum-CoachMarkIndicator--dark", /*variants*/ ctx[1] == "dark");
			}

			if (dirty & /*variants*/ 2) {
				toggle_class(div8, "spectrum-CoachMarkIndicator--light", /*variants*/ ctx[1] == "light");
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(coachmark_popover_footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(coachmark_popover_footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div8);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (coachmark_popover_footer_slot) coachmark_popover_footer_slot.d(detaching);
			/*div3_binding*/ ctx[14](null);
			/*div8_binding*/ ctx[15](null);
		}
	};
}

function instance$_($$self, $$props, $$invalidate) {
	let { isQuiet = false } = $$props;
	let { variants = "general" } = $$props;
	let { coverPhotoAlt = "Cover photo" } = $$props;
	let { coverPhotoUrl = "" } = $$props;
	let { title = "" } = $$props;
	let { totalStep = 0 } = $$props;
	let { presentStep = 1 } = $$props;
	let { coachMarkPopoverPosition = "leftTop" } = $$props;
	let { positioning = {} } = $$props;
	let coachMarkIndicator;
	let coachMarkPopover;
	let positioningCssText = "";

	onMount(() => {
		coachMarkPopover && advanceAddClassName(coachMarkPopover, "coachmark-popover-footer", "spectrum-CoachMarkPopover-footer");
		coachMarkIndicator && setPositionedAccording(coachMarkIndicator);
	});

	afterUpdate(() => {
		$$invalidate(10, positioningCssText = integrateAutoProps(positioning));
	});

	let { $$slots = {}, $$scope } = $$props;

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			coachMarkPopover = $$value;
			$$invalidate(9, coachMarkPopover);
		});
	}

	function div8_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			coachMarkIndicator = $$value;
			$$invalidate(8, coachMarkIndicator);
		});
	}

	$$self.$$set = $$props => {
		if ("isQuiet" in $$props) $$invalidate(0, isQuiet = $$props.isQuiet);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("coverPhotoAlt" in $$props) $$invalidate(2, coverPhotoAlt = $$props.coverPhotoAlt);
		if ("coverPhotoUrl" in $$props) $$invalidate(3, coverPhotoUrl = $$props.coverPhotoUrl);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
		if ("totalStep" in $$props) $$invalidate(5, totalStep = $$props.totalStep);
		if ("presentStep" in $$props) $$invalidate(6, presentStep = $$props.presentStep);
		if ("coachMarkPopoverPosition" in $$props) $$invalidate(7, coachMarkPopoverPosition = $$props.coachMarkPopoverPosition);
		if ("positioning" in $$props) $$invalidate(11, positioning = $$props.positioning);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	return [
		isQuiet,
		variants,
		coverPhotoAlt,
		coverPhotoUrl,
		title,
		totalStep,
		presentStep,
		coachMarkPopoverPosition,
		coachMarkIndicator,
		coachMarkPopover,
		positioningCssText,
		positioning,
		$$scope,
		$$slots,
		div3_binding,
		div8_binding
	];
}

class CoachMark extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-18mrz44-style")) add_css$b();

		init(this, options, instance$_, create_fragment$_, safe_not_equal, {
			isQuiet: 0,
			variants: 1,
			coverPhotoAlt: 2,
			coverPhotoUrl: 3,
			title: 4,
			totalStep: 5,
			presentStep: 6,
			coachMarkPopoverPosition: 7,
			positioning: 11
		});
	}
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle = createCommonjsModule(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

var colorString = createCommonjsModule(function (module) {
/* MIT license */



var reverseNames = {};

// create a list of reverse color names
for (var name in colorName) {
	if (colorName.hasOwnProperty(name)) {
		reverseNames[colorName[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorName[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var conversions = createCommonjsModule(function (module) {
/* MIT license */


// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in colorName$1) {
	if (colorName$1.hasOwnProperty(key)) {
		reverseKeywords[colorName$1[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in colorName$1) {
		if (colorName$1.hasOwnProperty(keyword)) {
			var value = colorName$1[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return colorName$1[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};
});

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert;

var _slice = [].slice;

var skippedModels = [
  // to be honest, I don't really feel like keyword belongs in color convert, but eh.
  "keyword",

  // gray conflicts with some method names, and has its own method defined.
  "gray",

  // shouldn't really be in color-convert either...
  "hex",
];

var hashedModelKeys = {};
Object.keys(colorConvert).forEach(function (model) {
  hashedModelKeys[_slice.call(colorConvert[model].labels).sort().join("")] = model;
});

var limiters = {};

function Color(obj, model) {
  if (!(this instanceof Color)) {
    return new Color(obj, model);
  }

  if (model && model in skippedModels) {
    model = null;
  }

  if (model && !(model in colorConvert)) {
    throw new Error("Unknown model: " + model);
  }

  var i;
  var channels;

  if (obj == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    this.model = "rgb";
    this.color = [0, 0, 0];
    this.valpha = 1;
  } else if (obj instanceof Color) {
    this.model = obj.model;
    this.color = obj.color.slice();
    this.valpha = obj.valpha;
  } else if (typeof obj === "string") {
    var result = colorString.get(obj);
    if (result === null) {
      throw new Error("Unable to parse color from string: " + obj);
    }

    this.model = result.model;
    channels = colorConvert[this.model].channels;
    this.color = result.value.slice(0, channels);
    this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
  } else if (obj.length) {
    this.model = model || "rgb";
    channels = colorConvert[this.model].channels;
    var newArr = _slice.call(obj, 0, channels);
    this.color = zeroArray(newArr, channels);
    this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
  } else if (typeof obj === "number") {
    // this is always RGB - can be converted later on.
    obj &= 0xffffff;
    this.model = "rgb";
    this.color = [(obj >> 16) & 0xff, (obj >> 8) & 0xff, obj & 0xff];
    this.valpha = 1;
  } else {
    this.valpha = 1;

    var keys = Object.keys(obj);
    if ("alpha" in obj) {
      keys.splice(keys.indexOf("alpha"), 1);
      this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
    }

    var hashedKeys = keys.sort().join("");
    if (!(hashedKeys in hashedModelKeys)) {
      throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
    }

    this.model = hashedModelKeys[hashedKeys];

    var labels = colorConvert[this.model].labels;
    var color = [];
    for (i = 0; i < labels.length; i++) {
      color.push(obj[labels[i]]);
    }

    this.color = zeroArray(color);
  }

  // perform limitations (clamping, etc.)
  if (limiters[this.model]) {
    channels = colorConvert[this.model].channels;
    for (i = 0; i < channels; i++) {
      var limit = limiters[this.model][i];
      if (limit) {
        this.color[i] = limit(this.color[i]);
      }
    }
  }

  this.valpha = Math.max(0, Math.min(1, this.valpha));

  if (Object.freeze) {
    Object.freeze(this);
  }
}

Color.prototype = {
  toString: function () {
    return this.string();
  },

  toJSON: function () {
    return this[this.model]();
  },

  string: function (places) {
    var self = this.model in colorString.to ? this : this.rgb();
    self = self.round(typeof places === "number" ? places : 1);
    var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    return colorString.to[self.model](args);
  },

  percentString: function (places) {
    var self = this.rgb().round(typeof places === "number" ? places : 1);
    var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    return colorString.to.rgb.percent(args);
  },

  array: function () {
    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
  },

  object: function () {
    var result = {};
    var channels = colorConvert[this.model].channels;
    var labels = colorConvert[this.model].labels;

    for (var i = 0; i < channels; i++) {
      result[labels[i]] = this.color[i];
    }

    if (this.valpha !== 1) {
      result.alpha = this.valpha;
    }

    return result;
  },

  unitArray: function () {
    var rgb = this.rgb().color;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;

    if (this.valpha !== 1) {
      rgb.push(this.valpha);
    }

    return rgb;
  },

  unitObject: function () {
    var rgb = this.rgb().object();
    rgb.r /= 255;
    rgb.g /= 255;
    rgb.b /= 255;

    if (this.valpha !== 1) {
      rgb.alpha = this.valpha;
    }

    return rgb;
  },

  round: function (places) {
    places = Math.max(places || 0, 0);
    return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
  },

  alpha: function (val) {
    if (arguments.length) {
      return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
    }

    return this.valpha;
  },

  // rgb
  red: getset("rgb", 0, maxfn(255)),
  green: getset("rgb", 1, maxfn(255)),
  blue: getset("rgb", 2, maxfn(255)),

  hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function (val) {
    return ((val % 360) + 360) % 360;
  }), // eslint-disable-line brace-style

  saturationl: getset("hsl", 1, maxfn(100)),
  lightness: getset("hsl", 2, maxfn(100)),

  saturationv: getset("hsv", 1, maxfn(100)),
  value: getset("hsv", 2, maxfn(100)),

  chroma: getset("hcg", 1, maxfn(100)),
  gray: getset("hcg", 2, maxfn(100)),

  white: getset("hwb", 1, maxfn(100)),
  wblack: getset("hwb", 2, maxfn(100)),

  cyan: getset("cmyk", 0, maxfn(100)),
  magenta: getset("cmyk", 1, maxfn(100)),
  yellow: getset("cmyk", 2, maxfn(100)),
  black: getset("cmyk", 3, maxfn(100)),

  x: getset("xyz", 0, maxfn(100)),
  y: getset("xyz", 1, maxfn(100)),
  z: getset("xyz", 2, maxfn(100)),

  l: getset("lab", 0, maxfn(100)),
  a: getset("lab", 1),
  b: getset("lab", 2),

  keyword: function (val) {
    if (arguments.length) {
      return new Color(val);
    }

    return colorConvert[this.model].keyword(this.color);
  },

  hex: function (val) {
    if (arguments.length) {
      return new Color(val);
    }

    return colorString.to.hex(this.rgb().round().color);
  },

  rgbNumber: function () {
    var rgb = this.rgb().color;
    return ((rgb[0] & 0xff) << 16) | ((rgb[1] & 0xff) << 8) | (rgb[2] & 0xff);
  },

  luminosity: function () {
    // http://www.w3.org/TR/WCAG20/#relativeluminancedef
    var rgb = this.rgb().color;

    var lum = [];
    for (var i = 0; i < rgb.length; i++) {
      var chan = rgb[i] / 255;
      lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
    }

    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  },

  contrast: function (color2) {
    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
    var lum1 = this.luminosity();
    var lum2 = color2.luminosity();

    if (lum1 > lum2) {
      return (lum1 + 0.05) / (lum2 + 0.05);
    }

    return (lum2 + 0.05) / (lum1 + 0.05);
  },

  level: function (color2) {
    var contrastRatio = this.contrast(color2);
    if (contrastRatio >= 7.1) {
      return "AAA";
    }

    return contrastRatio >= 4.5 ? "AA" : "";
  },

  isDark: function () {
    // YIQ equation from http://24ways.org/2010/calculating-color-contrast
    var rgb = this.rgb().color;
    var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
    return yiq < 128;
  },

  isLight: function () {
    return !this.isDark();
  },

  negate: function () {
    var rgb = this.rgb();
    for (var i = 0; i < 3; i++) {
      rgb.color[i] = 255 - rgb.color[i];
    }
    return rgb;
  },

  lighten: function (ratio) {
    var hsl = this.hsl();
    hsl.color[2] += hsl.color[2] * ratio;
    return hsl;
  },

  darken: function (ratio) {
    var hsl = this.hsl();
    hsl.color[2] -= hsl.color[2] * ratio;
    return hsl;
  },

  saturate: function (ratio) {
    var hsl = this.hsl();
    hsl.color[1] += hsl.color[1] * ratio;
    return hsl;
  },

  desaturate: function (ratio) {
    var hsl = this.hsl();
    hsl.color[1] -= hsl.color[1] * ratio;
    return hsl;
  },

  whiten: function (ratio) {
    var hwb = this.hwb();
    hwb.color[1] += hwb.color[1] * ratio;
    return hwb;
  },

  blacken: function (ratio) {
    var hwb = this.hwb();
    hwb.color[2] += hwb.color[2] * ratio;
    return hwb;
  },

  grayscale: function () {
    // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
    var rgb = this.rgb().color;
    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    return Color.rgb(val, val, val);
  },

  fade: function (ratio) {
    return this.alpha(this.valpha - this.valpha * ratio);
  },

  opaquer: function (ratio) {
    return this.alpha(this.valpha + this.valpha * ratio);
  },

  rotate: function (degrees) {
    var hsl = this.hsl();
    var hue = hsl.color[0];
    hue = (hue + degrees) % 360;
    hue = hue < 0 ? 360 + hue : hue;
    hsl.color[0] = hue;
    return hsl;
  },

  mix: function (mixinColor, weight) {
    // ported from sass implementation in C
    // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
    if (!mixinColor || !mixinColor.rgb) {
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    }
    var color1 = mixinColor.rgb();
    var color2 = this.rgb();
    var p = weight === undefined ? 0.5 : weight;

    var w = 2 * p - 1;
    var a = color1.alpha() - color2.alpha();

    var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
    var w2 = 1 - w1;

    return Color.rgb(
      w1 * color1.red() + w2 * color2.red(),
      w1 * color1.green() + w2 * color2.green(),
      w1 * color1.blue() + w2 * color2.blue(),
      color1.alpha() * p + color2.alpha() * (1 - p)
    );
  },
};

// model conversion methods and static constructors
Object.keys(colorConvert).forEach(function (model) {
  if (skippedModels.indexOf(model) !== -1) {
    return;
  }

  var channels = colorConvert[model].channels;

  // conversion methods
  Color.prototype[model] = function () {
    if (this.model === model) {
      return new Color(this);
    }

    if (arguments.length) {
      return new Color(arguments, model);
    }

    var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
    return new Color(assertArray(colorConvert[this.model][model].raw(this.color)).concat(newAlpha), model);
  };

  // 'static' construction methods
  Color[model] = function (color) {
    if (typeof color === "number") {
      color = zeroArray(_slice.call(arguments), channels);
    }
    return new Color(color, model);
  };
});

function roundTo(num, places) {
  return Number(num.toFixed(places));
}

function roundToPlace(places) {
  return function (num) {
    return roundTo(num, places);
  };
}

function getset(model, channel, modifier) {
  model = Array.isArray(model) ? model : [model];

  model.forEach(function (m) {
    (limiters[m] || (limiters[m] = []))[channel] = modifier;
  });

  model = model[0];

  return function (val) {
    var result;

    if (arguments.length) {
      if (modifier) {
        val = modifier(val);
      }

      result = this[model]();
      result.color[channel] = val;
      return result;
    }

    result = this[model]().color[channel];
    if (modifier) {
      result = modifier(result);
    }

    return result;
  };
}

function maxfn(max) {
  return function (v) {
    return Math.max(0, Math.min(max, v));
  };
}

function assertArray(val) {
  return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
  for (var i = 0; i < length; i++) {
    if (typeof arr[i] !== "number") {
      arr[i] = 0;
    }
  }

  return arr;
}

var color = Color;

/* src/packages/ColorLoupe/ColorLoupe.svelte generated by Svelte v3.24.1 */

function add_css$c() {
	var style = element("style");
	style.id = "svelte-yqx9jt-style";
	style.textContent = ".spectrum-ColorLoupe{bottom:calc(20% + var(--spectrum-global-dimension-static-size-200, 16px))}.spectrum-ColorLoupe--vertical{left:-15px;right:0;bottom:calc(var(--spectrum-global-dimension-static-size-200) / 4);transform:rotate(90deg)}.spectrum-ColorLoupe--vertical.is-open{left:-10px;right:-20px;bottom:calc(var(--spectrum-global-dimension-static-size-200) / 4);transform:rotate(90deg)}";
	append(document.head, style);
}

function create_fragment$$(ctx) {
	let svg;
	let g;
	let path0;
	let path0_fill_value;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "class", "spectrum-ColorLoupe-inner");
			attr(path0, "d", "M24,0A24,24,0,0,1,48,24c0,16.255-24,40-24,40S0,40.255,0,24A24,24,0,0,1,24,0Z");
			attr(path0, "fill", path0_fill_value = "rgba(" + /*thisBackgroundColor*/ ctx[3].r + "," + /*thisBackgroundColor*/ ctx[3].g + "," + /*thisBackgroundColor*/ ctx[3].b + "," + /*alpha*/ ctx[2] + ")");
			attr(path1, "class", "spectrum-ColorLoupe-outer");
			attr(path1, "d", "M24,2A21.98,21.98,0,0,0,2,24c0,6.2,4,14.794,11.568,24.853A144.233,144.233,0,0,0,24,61.132,144.085,144.085,0,0,0,34.4,48.893C41.99,38.816,46,30.209,46,24A21.98,21.98,0,0,0,24,2m0-2A24,24,0,0,1,48,24c0,16.255-24,40-24,40S0,40.255,0,24A24,24,0,0,1,24,0Z");
			attr(g, "transform", "translate(1 1)");
			attr(svg, "class", "spectrum-ColorLoupe");
			toggle_class(svg, "spectrum-ColorLoupe--vertical", /*orientation*/ ctx[1] === "vertical");
			toggle_class(svg, "is-open", /*isOpen*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*thisBackgroundColor, alpha*/ 12 && path0_fill_value !== (path0_fill_value = "rgba(" + /*thisBackgroundColor*/ ctx[3].r + "," + /*thisBackgroundColor*/ ctx[3].g + "," + /*thisBackgroundColor*/ ctx[3].b + "," + /*alpha*/ ctx[2] + ")")) {
				attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*orientation*/ 2) {
				toggle_class(svg, "spectrum-ColorLoupe--vertical", /*orientation*/ ctx[1] === "vertical");
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(svg, "is-open", /*isOpen*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$$($$self, $$props, $$invalidate) {
	let { isOpen = false } = $$props;
	let { color: color$1 = "#000" } = $$props;
	let { orientation = "horizontal" } = $$props;
	let { alpha = 1 } = $$props;

	$$self.$$set = $$props => {
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("color" in $$props) $$invalidate(4, color$1 = $$props.color);
		if ("orientation" in $$props) $$invalidate(1, orientation = $$props.orientation);
		if ("alpha" in $$props) $$invalidate(2, alpha = $$props.alpha);
	};

	let thisBackgroundColor;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color*/ 16) {
			 $$invalidate(3, thisBackgroundColor = color(color$1).rgb().object());
		}
	};

	return [isOpen, orientation, alpha, thisBackgroundColor, color$1];
}

class ColorLoupe extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-yqx9jt-style")) add_css$c();

		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
			isOpen: 0,
			color: 4,
			orientation: 1,
			alpha: 2
		});
	}
}

/* src/packages/ColorHandle/ColorHandle.svelte generated by Svelte v3.24.1 */

function create_fragment$10(ctx) {
	let div1;
	let div0;
	let t;
	let colorloupe;
	let div1_class_value;
	let current;

	colorloupe = new ColorLoupe({
			props: {
				color: /*color*/ ctx[2],
				isOpen: /*isOpen*/ ctx[6],
				orientation: /*orientation*/ ctx[4],
				alpha: /*alpha*/ ctx[5]
			}
		});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			create_component(colorloupe.$$.fragment);
			attr(div0, "class", "spectrum-ColorHandle-color");
			set_style(div0, "background-color", "rgba(" + /*thisBackgroundColor*/ ctx[8].r + "," + /*thisBackgroundColor*/ ctx[8].g + "," + /*thisBackgroundColor*/ ctx[8].b + "," + /*alpha*/ ctx[5] + ")");
			attr(div1, "class", div1_class_value = "spectrum-ColorHandle " + /*$$restProps*/ ctx[9].class);
			set_style(div1, "position", "absolute");
			set_style(div1, "top", /*py*/ ctx[1] + "%");
			set_style(div1, "left", /*px*/ ctx[0] + "%");
			toggle_class(div1, "is-disabled", /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div1, t);
			mount_component(colorloupe, div1, null);
			/*div1_binding*/ ctx[10](div1);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*thisBackgroundColor, alpha*/ 288) {
				set_style(div0, "background-color", "rgba(" + /*thisBackgroundColor*/ ctx[8].r + "," + /*thisBackgroundColor*/ ctx[8].g + "," + /*thisBackgroundColor*/ ctx[8].b + "," + /*alpha*/ ctx[5] + ")");
			}

			const colorloupe_changes = {};
			if (dirty & /*color*/ 4) colorloupe_changes.color = /*color*/ ctx[2];
			if (dirty & /*isOpen*/ 64) colorloupe_changes.isOpen = /*isOpen*/ ctx[6];
			if (dirty & /*orientation*/ 16) colorloupe_changes.orientation = /*orientation*/ ctx[4];
			if (dirty & /*alpha*/ 32) colorloupe_changes.alpha = /*alpha*/ ctx[5];
			colorloupe.$set(colorloupe_changes);

			if (!current || dirty & /*$$restProps*/ 512 && div1_class_value !== (div1_class_value = "spectrum-ColorHandle " + /*$$restProps*/ ctx[9].class)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*py*/ 2) {
				set_style(div1, "top", /*py*/ ctx[1] + "%");
			}

			if (!current || dirty & /*px*/ 1) {
				set_style(div1, "left", /*px*/ ctx[0] + "%");
			}

			if (dirty & /*$$restProps, disabled*/ 520) {
				toggle_class(div1, "is-disabled", /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(colorloupe.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorloupe.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(colorloupe);
			/*div1_binding*/ ctx[10](null);
		}
	};
}

function instance$10($$self, $$props, $$invalidate) {
	const omit_props_names = ["px","py","color","disabled","orientation","alpha"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { px = 0 } = $$props;
	let { py = 0 } = $$props;
	let { color: color$1 = "#000" } = $$props;
	let { disabled = false } = $$props;
	let { orientation = "horizontal" } = $$props;
	let { alpha = 1 } = $$props;
	let isOpen = false;
	let colorHandle;

	onMount(() => {
		if (!disabled) {
			colorHandle && colorHandle.parentElement && colorHandle.parentElement.addEventListener("mouseup", function (e) {
				$$invalidate(6, isOpen = false);
			});

			colorHandle && colorHandle.parentElement && colorHandle.parentElement.addEventListener("mousedown", function (e) {
				$$invalidate(6, isOpen = true);
			});

			window && window.addEventListener("click", listenForOtherClicks);
			window && window.addEventListener("keyup", listenForOtherClicks);
		}
	});

	function listenForOtherClicks(e) {
		if (colorHandle && colorHandle.parentElement && !colorHandle.parentElement.contains(e.target)) {
			$$invalidate(6, isOpen = false);
		}
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			colorHandle = $$value;
			$$invalidate(7, colorHandle);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("px" in $$new_props) $$invalidate(0, px = $$new_props.px);
		if ("py" in $$new_props) $$invalidate(1, py = $$new_props.py);
		if ("color" in $$new_props) $$invalidate(2, color$1 = $$new_props.color);
		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("orientation" in $$new_props) $$invalidate(4, orientation = $$new_props.orientation);
		if ("alpha" in $$new_props) $$invalidate(5, alpha = $$new_props.alpha);
	};

	let thisBackgroundColor;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color*/ 4) {
			 $$invalidate(8, thisBackgroundColor = color(color$1).rgb().object());
		}
	};

	return [
		px,
		py,
		color$1,
		disabled,
		orientation,
		alpha,
		isOpen,
		colorHandle,
		thisBackgroundColor,
		$$restProps,
		div1_binding
	];
}

class ColorHandle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
			px: 0,
			py: 1,
			color: 2,
			disabled: 3,
			orientation: 4,
			alpha: 5
		});
	}
}

/* src/packages/ColorArea/ColorArea.svelte generated by Svelte v3.24.1 */

function add_css$d() {
	var style = element("style");
	style.id = "svelte-80zovz-style";
	style.textContent = ".spectrum-ColorArea:before{display:none}";
	append(document.head, style);
}

function create_fragment$11(ctx) {
	let div;
	let canvas_1;
	let t0;
	let colorhandle;
	let t1;
	let input0;
	let input0_step_value;
	let t2;
	let input1;
	let input1_step_value;
	let current;

	colorhandle = new ColorHandle({
			props: {
				class: "spectrum-ColorArea-handle",
				px: /*px*/ ctx[4],
				py: /*py*/ ctx[5],
				color: /*currentColor*/ ctx[0],
				disabled: /*disabled*/ ctx[3]
			}
		});

	return {
		c() {
			div = element("div");
			canvas_1 = element("canvas");
			t0 = space();
			create_component(colorhandle.$$.fragment);
			t1 = space();
			input0 = element("input");
			t2 = space();
			input1 = element("input");
			attr(canvas_1, "class", "spectrum-ColorArea-gradient");
			attr(input0, "type", "range");
			attr(input0, "class", "spectrum-ColorArea-slider");
			attr(input0, "name", "x");
			attr(input0, "aria-label", "saturation and value");
			attr(input0, "aria-disabled", /*disabled*/ ctx[3]);
			attr(input0, "min", "0");
			attr(input0, "max", "1");
			attr(input0, "step", input0_step_value = /*px*/ ctx[4] / 100);
			input0.disabled = /*disabled*/ ctx[3];
			attr(input1, "type", "range");
			attr(input1, "class", "spectrum-ColorArea-slider");
			attr(input1, "name", "y");
			attr(input1, "aria-label", "saturation and value");
			attr(input1, "aria-disabled", /*disabled*/ ctx[3]);
			attr(input1, "min", "0");
			attr(input1, "max", "1");
			attr(input1, "step", input1_step_value = /*py*/ ctx[5] / 100);
			input1.disabled = /*disabled*/ ctx[3];
			attr(div, "class", "spectrum-ColorArea");
			set_style(div, "width", /*width*/ ctx[1] + "px");
			set_style(div, "height", /*height*/ ctx[2] + "px");
			toggle_class(div, "is-disabled", /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, canvas_1);
			/*canvas_1_binding*/ ctx[7](canvas_1);
			append(div, t0);
			mount_component(colorhandle, div, null);
			append(div, t1);
			append(div, input0);
			append(div, t2);
			append(div, input1);
			current = true;
		},
		p(ctx, [dirty]) {
			const colorhandle_changes = {};
			if (dirty & /*px*/ 16) colorhandle_changes.px = /*px*/ ctx[4];
			if (dirty & /*py*/ 32) colorhandle_changes.py = /*py*/ ctx[5];
			if (dirty & /*currentColor*/ 1) colorhandle_changes.color = /*currentColor*/ ctx[0];
			if (dirty & /*disabled*/ 8) colorhandle_changes.disabled = /*disabled*/ ctx[3];
			colorhandle.$set(colorhandle_changes);

			if (!current || dirty & /*disabled*/ 8) {
				attr(input0, "aria-disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*px*/ 16 && input0_step_value !== (input0_step_value = /*px*/ ctx[4] / 100)) {
				attr(input0, "step", input0_step_value);
			}

			if (!current || dirty & /*disabled*/ 8) {
				input0.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*disabled*/ 8) {
				attr(input1, "aria-disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*py*/ 32 && input1_step_value !== (input1_step_value = /*py*/ ctx[5] / 100)) {
				attr(input1, "step", input1_step_value);
			}

			if (!current || dirty & /*disabled*/ 8) {
				input1.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*width*/ 2) {
				set_style(div, "width", /*width*/ ctx[1] + "px");
			}

			if (!current || dirty & /*height*/ 4) {
				set_style(div, "height", /*height*/ ctx[2] + "px");
			}

			if (dirty & /*disabled*/ 8) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(colorhandle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorhandle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*canvas_1_binding*/ ctx[7](null);
			destroy_component(colorhandle);
		}
	};
}

function instance$11($$self, $$props, $$invalidate) {
	let { width = 192 } = $$props;
	let { height = width } = $$props;
	let { disabled = false } = $$props;
	let { currentColor = "rgb(255,0,0)" } = $$props;
	let px = 0;
	let py = 0;
	let canvas;
	let baseColor = "rgb(255,0,0)";

	function createColorArea(color) {
		let context = canvas.getContext("2d");
		context.rect(0, 0, canvas.width, canvas.height);
		let gradB = context.createLinearGradient(0, 0, 0, canvas.height);
		gradB.addColorStop(0, "white");
		gradB.addColorStop(1, "black");
		let gradC = context.createLinearGradient(0, 0, canvas.width, 0);
		gradC.addColorStop(0, "rgb(255,255,255)");
		gradC.addColorStop(1, color);
		context.fillStyle = gradB;
		context.fillRect(0, 0, canvas.width, canvas.height);
		context.fillStyle = gradC;
		context.globalCompositeOperation = "multiply";
		context.fillRect(0, 0, canvas.width, canvas.height);
		context.globalCompositeOperation = "source-over";
	}

	function colorToPos(color$1) {
		const thisRect = canvas.getBoundingClientRect();
		let _color = color(color$1);
		let hsl = _color.hsl().object();
		let hsv = _color.hsv().object();
		let x = thisRect.width * hsv.s;
		let y = thisRect.height * hsv.v;
		$$invalidate(4, px = x / 100 / thisRect.width * 100);
		$$invalidate(5, py = 100 - y / 100 / thisRect.height * 100);
	}

	function startGetAreaColor(e) {
		getAreaColor(e);
		window.addEventListener("mousemove", getAreaColor);
		window.addEventListener("mouseup", endGetAreaColor);
	}

	function getAreaColor(e) {
		e.preventDefault();
		const thisRect = canvas.getBoundingClientRect();
		let x = e.pageX - thisRect.left;
		let y = e.pageY - thisRect.top;

		if (x > thisRect.width) {
			x = thisRect.width;
		}

		if (x < 0) {
			x = 0;
		}

		if (y > thisRect.height) {
			y = thisRect.height;
		}

		if (y < 0) {
			y = 0.1;
		}

		let lightness = 0.5;
		let saturation = 1;
		let xRatio = x / thisRect.width * 100;
		let yRatio = y / thisRect.height * 100;
		let hsvValue = 1 - yRatio / 100;
		let hsvSaturation = xRatio / 100;
		lightness = hsvValue / 2 * (2 - hsvSaturation);
		saturation = hsvValue * hsvSaturation / (1 - Math.abs(2 * lightness - 1));

		const colorStr = `hsl(${hue},${isNaN(parseInt(saturation * 100))
		? 0
		: parseInt(saturation * 100)}%,${isNaN(parseInt(lightness * 100))
		? 0
		: parseInt(lightness * 100)}%)`;

		const color$1 = color.hsl(colorStr);
		$$invalidate(4, px = xRatio);
		$$invalidate(5, py = yRatio);
		$$invalidate(0, currentColor = color$1.rgb().string());
	}

	function endGetAreaColor() {
		window.removeEventListener("mousemove", getAreaColor);
	}

	onMount(() => {
		$$invalidate(6, canvas.width = canvas.offsetWidth, canvas);
		$$invalidate(6, canvas.height = canvas.offsetHeight, canvas);

		canvas.addEventListener("mousedown", function (e) {
			startGetAreaColor(e);
		});

		baseColor = currentColor;
	});

	afterUpdate(() => {
		let staticColor = color(baseColor);
		let staticHsl = staticColor.hsl().object();
		let varColor = color(currentColor);
		let varHsl = varColor.hsl().object();
		let finalColor = color.hsl(`hsl(${varHsl.h}, ${staticHsl.s}%, 50%)`);
		canvas && throttle$1(500, createColorArea(finalColor.hex()));

		//Prevent automatic positioning when the current color is '#000000'
		if (varHsl.l != 0) {
			canvas && throttle$1(500, colorToPos(currentColor));
		}
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			canvas = $$value;
			$$invalidate(6, canvas);
		});
	}

	$$self.$$set = $$props => {
		if ("width" in $$props) $$invalidate(1, width = $$props.width);
		if ("height" in $$props) $$invalidate(2, height = $$props.height);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("currentColor" in $$props) $$invalidate(0, currentColor = $$props.currentColor);
	};

	let initColor;
	let hue;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*currentColor*/ 1) {
			 $$invalidate(9, initColor = color(currentColor));
		}

		if ($$self.$$.dirty & /*initColor*/ 512) {
			 hue = initColor.hue();
		}
	};

	return [currentColor, width, height, disabled, px, py, canvas, canvas_1_binding];
}

class ColorArea extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-80zovz-style")) add_css$d();

		init(this, options, instance$11, create_fragment$11, safe_not_equal, {
			width: 1,
			height: 2,
			disabled: 3,
			currentColor: 0
		});
	}
}

/* src/packages/ColorSlider/ColorSlider.svelte generated by Svelte v3.24.1 */

function add_css$e() {
	var style = element("style");
	style.id = "svelte-1umbmv5-style";
	style.textContent = ".spectrum-ColorSlider-checkerboard:before{display:none}";
	append(document.head, style);
}

function create_fragment$12(ctx) {
	let div1;
	let div0;
	let canvas;
	let t0;
	let colorhandle;
	let t1;
	let input;
	let input_step_value;
	let current;

	colorhandle = new ColorHandle({
			props: {
				class: "spectrum-ColorSlider-handle",
				px: /*px*/ ctx[4],
				py: /*py*/ ctx[5],
				color: /*currentColor*/ ctx[0],
				disabled: /*disabled*/ ctx[2],
				orientation: /*orientation*/ ctx[3],
				alpha: /*alpha*/ ctx[1]
			}
		});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			canvas = element("canvas");
			t0 = space();
			create_component(colorhandle.$$.fragment);
			t1 = space();
			input = element("input");
			attr(canvas, "class", "spectrum-ColorSlider-gradient");
			attr(canvas, "role", "presentation");
			attr(div0, "class", "spectrum-ColorSlider-checkerboard");
			attr(div0, "role", "presentation");
			attr(input, "type", "range");
			attr(input, "class", "spectrum-ColorSlider-slider");
			attr(input, "min", "0");
			attr(input, "max", "100");

			attr(input, "step", input_step_value = /*orientation*/ ctx[3] === "horizontal"
			? /*px*/ ctx[4]
			: /*py*/ ctx[5]);

			attr(div1, "class", "spectrum-ColorSlider");
			toggle_class(div1, "spectrum-ColorSlider--vertical", /*orientation*/ ctx[3] === "vertical");
			toggle_class(div1, "is-disabled", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, canvas);
			/*canvas_binding*/ ctx[10](canvas);
			append(div1, t0);
			mount_component(colorhandle, div1, null);
			append(div1, t1);
			append(div1, input);
			current = true;
		},
		p(ctx, [dirty]) {
			const colorhandle_changes = {};
			if (dirty & /*px*/ 16) colorhandle_changes.px = /*px*/ ctx[4];
			if (dirty & /*py*/ 32) colorhandle_changes.py = /*py*/ ctx[5];
			if (dirty & /*currentColor*/ 1) colorhandle_changes.color = /*currentColor*/ ctx[0];
			if (dirty & /*disabled*/ 4) colorhandle_changes.disabled = /*disabled*/ ctx[2];
			if (dirty & /*orientation*/ 8) colorhandle_changes.orientation = /*orientation*/ ctx[3];
			if (dirty & /*alpha*/ 2) colorhandle_changes.alpha = /*alpha*/ ctx[1];
			colorhandle.$set(colorhandle_changes);

			if (!current || dirty & /*orientation, px, py*/ 56 && input_step_value !== (input_step_value = /*orientation*/ ctx[3] === "horizontal"
			? /*px*/ ctx[4]
			: /*py*/ ctx[5])) {
				attr(input, "step", input_step_value);
			}

			if (dirty & /*orientation*/ 8) {
				toggle_class(div1, "spectrum-ColorSlider--vertical", /*orientation*/ ctx[3] === "vertical");
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(div1, "is-disabled", /*disabled*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(colorhandle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorhandle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			/*canvas_binding*/ ctx[10](null);
			destroy_component(colorhandle);
		}
	};
}

function createColorSliderHue(el) {
	const context = el.getContext("2d");
	context.rect(0, 0, el.width, el.height);
	let gradient = context.createLinearGradient(0, 0, el.width, el.height);
	gradient.addColorStop(0, "hsl(360,100%,50%)");
	gradient.addColorStop(0.17, "hsl(61.2,100%,50%)");
	gradient.addColorStop(0.33, "hsl(118.8, 100%, 50%)");
	gradient.addColorStop(0.5, "hsl(180, 100%, 50%)");
	gradient.addColorStop(0.67, "hsl(241.2, 100%, 50%)");
	gradient.addColorStop(0.83, "hsl(298.8, 100%, 50%)");
	gradient.addColorStop(1, "hsl(0,100%,50%)");
	context.fillStyle = gradient;
	context.fill();
	context.fillRect(0, 0, el.width, el.height);
}

function interpolateColor(c1, c2, factor) {
	if (arguments.length < 3) {
		factor = 0.5;
	}

	var result = c1.slice();

	for (var i = 0; i < 3; i++) {
		result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]));
	}

	return result;
}

function interpolateColors(c1, c2, steps) {
	var stepFactor = 1 / (steps - 1), interpolatedColorArray = [];

	if (c1) {
		c1 = c1.match(/\d+/g);
		c1 = c1.map(Number);
	}

	if (c2) {
		c2 = c2.match(/\d+/g);
		c2 = c2.map(Number);
	}

	for (var i = 0; i < steps; i++) {
		interpolatedColorArray.push(interpolateColor(c1, c2, stepFactor * i));
	}

	return interpolatedColorArray;
}

function getColorStep(colorRangeGroup2, colorRgb) {
	for (let index = 0; index < colorRangeGroup2.length; index++) {
		if (colorRangeGroup2[index][0] == colorRgb.r && colorRangeGroup2[index][1] == colorRgb.g && colorRangeGroup2[index][2] == colorRgb.b) {
			return index;
		}
	}
}

function instance$12($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;
	let { currentColor = "" } = $$props;
	let { variants = "hue" } = $$props;
	let { orientation = "horizontal" } = $$props;
	let { startColor = "rgb(0,0,0)" } = $$props;
	let { endColor = "rgb(255,255,255)" } = $$props;
	let { alpha = 1 } = $$props;
	let px = 0;
	let py = 0;
	let colorSliderCanvas;

	function createColorSliderAlpha(el) {
		const context = el.getContext("2d");
		context.rect(0, 0, el.width, el.height);
		let gradient = context.createLinearGradient(0, 0, el.width, el.height);
		gradient.addColorStop(0, `rgba(${startColor.r},${startColor.g},${startColor.b},1.0)`);
		gradient.addColorStop(1, `rgba(${startColor.r},${startColor.g},${startColor.b},0.0)`);
		context.fillStyle = gradient;
		context.fill();
		context.fillRect(0, 0, el.width, el.height);
		const thisRect = el.getBoundingClientRect();

		orientation === "horizontal"
		? $$invalidate(5, py = thisRect.height * 2)
		: $$invalidate(4, px = thisRect.width * 2);
	}

	function createColorSliderRange(el) {
		const context = el.getContext("2d");
		context.rect(0, 0, el.width, el.height);
		let gradient = context.createLinearGradient(0, 0, el.width, el.height);
		let _color = color(startColor);
		let _color2 = color(endColor);
		$$invalidate(7, startColor = _color.object());
		$$invalidate(8, endColor = _color2.object());
		gradient.addColorStop(0, `rgb(${startColor.r},${startColor.g},${startColor.b})`);
		gradient.addColorStop(1, `rgb(${endColor.r},${endColor.g},${endColor.b})`);
		context.fillStyle = gradient;
		context.fill();
		context.fillRect(0, 0, el.width, el.height);
		const thisRect = el.getBoundingClientRect();

		orientation === "horizontal"
		? $$invalidate(5, py = thisRect.height * 2)
		: $$invalidate(4, px = thisRect.width * 2);
	}

	function startGetSliderColor(e) {
		getSliderColor(e);
		window.addEventListener("mousemove", getSliderColor);
		window.addEventListener("mouseup", endGetHueColor);
	}

	let colorRangeGroup;

	function getSliderColor(e) {
		e.preventDefault();
		const thisRect = colorSliderCanvas.getBoundingClientRect();
		let _pageP = orientation === "horizontal" ? e.pageX : e.pageY;

		let _orientation = orientation === "horizontal"
		? thisRect.left
		: thisRect.top;

		let _crisscross = orientation === "horizontal"
		? thisRect.width
		: thisRect.height;

		let _p = _pageP - _orientation;

		if (_p > _crisscross) {
			_p = _crisscross;
		}

		if (_p < 0) {
			_p = 0;
		}

		let percent = _p / _crisscross;
		hue = 360 + 360 * percent;
		let colorStr;
		let color$1;

		switch (variants) {
			case "hue":
				colorStr = `hsl(${hue},100%,50%)`;
				color$1 = color.hsl(colorStr);
				$$invalidate(0, currentColor = color$1.rgb().string());
				break;
			case "alpha":
				$$invalidate(0, currentColor = `rgb(${startColor.r},${startColor.g},${startColor.b})`);
				$$invalidate(1, alpha = (1 - _p / _crisscross).toFixed(2));
				break;
			case "range":
				colorRangeGroup = interpolateColors(`rgb(${startColor.r},${startColor.g},${startColor.b})`, `rgb(${endColor.r},${endColor.g},${endColor.b})`, _crisscross);
				if (_p == 0) {
					$$invalidate(0, currentColor = `rgb(${startColor.r},${startColor.g},${startColor.b})`);
				} else if (_p == _crisscross) {
					$$invalidate(0, currentColor = `rgb(${endColor.r},${endColor.g},${endColor.b})`);
				} else {
					$$invalidate(0, currentColor = `rgb(${colorRangeGroup[_p][0] || endColor.r},${colorRangeGroup[_p][1] || endColor.g},${colorRangeGroup[_p][2] || endColor.b})`);
				}
				break;
		}

		orientation === "horizontal"
		? $$invalidate(4, px = _p / _crisscross * 100)
		: $$invalidate(5, py = _p / _crisscross * 100);
	}

	function endGetHueColor(e) {
		window.removeEventListener("mousemove", getSliderColor);
	}

	function colorToPos(color$1) {
		const thisRect = colorSliderCanvas.getBoundingClientRect();

		switch (variants) {
			case "hue":
				let _color = color(color$1);
				let hsl = _color.hsl().object();
				let hsv = _color.hsv().object();
				let obsNum = hue;
				let referNum = hue;
				hue = hsl.h;
				obsNum = hue;
				if (orientation === "horizontal") {
					if (referNum > obsNum) {
						$$invalidate(4, px = hue === 0 ? 100 : hue / 360 * 100);
					} else {
						$$invalidate(4, px = hue === 0 ? 0 : hue / 360 * 100);
					}
				} else {
					if (referNum > obsNum) {
						$$invalidate(5, py = hue === 0 ? 100 : hue / 360 * 100);
					} else {
						$$invalidate(5, py = hue === 0 ? 0 : hue / 360 * 100);
					}
				}
				break;
			case "alpha":
				if (+alpha >= 1) {
					$$invalidate(1, alpha = 1);
				}
				if (+alpha <= 0) {
					$$invalidate(1, alpha = 0);
				}
				if (orientation === "horizontal") {
					$$invalidate(4, px = (1 - +alpha) * 100);
				} else {
					$$invalidate(5, py = (1 - +alpha) * 100);
				}
				break;
			case "range":
				const thisRect = colorSliderCanvas.getBoundingClientRect();
				let _crisscross = orientation === "horizontal"
				? thisRect.width
				: thisRect.height;
				let _color2 = color(color$1);
				let colorRgb = _color2.object();
				let _step = 0;
				let colorRangeGroup2 = interpolateColors(`rgb(${startColor.r},${startColor.g},${startColor.b})`, `rgb(${endColor.r},${endColor.g},${endColor.b})`, _crisscross);
				_step = getColorStep(colorRangeGroup2, colorRgb);
				if (orientation === "horizontal" && _step) {
					$$invalidate(4, px = (_crisscross - (_crisscross - _step)) / _crisscross * 100);
					$$invalidate(4, px = px > 99.479 ? 100 : px);
				} else if (_step) {
					$$invalidate(5, py = (_crisscross - (_crisscross - _step)) / _crisscross * 100);
					$$invalidate(5, py = py > 99.479 ? 100 : py);
				}
				break;
		}

		orientation === "horizontal"
		? $$invalidate(5, py = thisRect.height * 2)
		: $$invalidate(4, px = thisRect.width * 2);
	}

	beforeUpdate(() => {
		if (variants === "hue" && !currentColor) {
			$$invalidate(0, currentColor = "rgb(255,0,0)");
		}

		if (variants === "alpha" && !currentColor) {
			$$invalidate(0, currentColor = "rgb(0,0,0)");
		}

		if (variants === "range" && !currentColor) {
			$$invalidate(0, currentColor = "rgb(0,0,0)");
		}
	});

	onMount(() => {
		$$invalidate(6, colorSliderCanvas.width = colorSliderCanvas.offsetWidth, colorSliderCanvas);
		$$invalidate(6, colorSliderCanvas.height = colorSliderCanvas.offsetHeight, colorSliderCanvas);

		colorSliderCanvas.addEventListener("mousedown", function (e) {
			startGetSliderColor(e);
		});

		if (variants === "alpha") {
			let _color = currentColor ? color(currentColor) : color("rgb(0,0,0)");
			$$invalidate(7, startColor = _color.object());
			throttle$1(500, createColorSliderAlpha(colorSliderCanvas));
		}
	});

	afterUpdate(() => {
		if (colorSliderCanvas) {
			variants === "hue" && throttle$1(500, createColorSliderHue(colorSliderCanvas));
			variants === "range" && throttle$1(500, createColorSliderRange(colorSliderCanvas));
		}

		throttle$1(500, colorToPos(currentColor));
	});

	function canvas_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			colorSliderCanvas = $$value;
			$$invalidate(6, colorSliderCanvas);
		});
	}

	$$self.$$set = $$props => {
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("currentColor" in $$props) $$invalidate(0, currentColor = $$props.currentColor);
		if ("variants" in $$props) $$invalidate(9, variants = $$props.variants);
		if ("orientation" in $$props) $$invalidate(3, orientation = $$props.orientation);
		if ("startColor" in $$props) $$invalidate(7, startColor = $$props.startColor);
		if ("endColor" in $$props) $$invalidate(8, endColor = $$props.endColor);
		if ("alpha" in $$props) $$invalidate(1, alpha = $$props.alpha);
	};

	let initColor;
	let hue;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*currentColor*/ 1) {
			 $$invalidate(12, initColor = currentColor ? color(currentColor) : color("rgb(0,0,0)"));
		}

		if ($$self.$$.dirty & /*initColor*/ 4096) {
			 hue = initColor.hue();
		}
	};

	return [
		currentColor,
		alpha,
		disabled,
		orientation,
		px,
		py,
		colorSliderCanvas,
		startColor,
		endColor,
		variants,
		canvas_binding
	];
}

class ColorSlider extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1umbmv5-style")) add_css$e();

		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
			disabled: 2,
			currentColor: 0,
			variants: 9,
			orientation: 3,
			startColor: 7,
			endColor: 8,
			alpha: 1
		});
	}
}

/* src/packages/Cornerstone/Cornerstone.svelte generated by Svelte v3.24.1 */

const { document: document_1$2 } = globals;

function create_fragment$13(ctx) {
	let meta;
	let meta_content_value;
	let t;
	let current;
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			meta = element("meta");
			t = space();
			if (default_slot) default_slot.c();
			attr(meta, "name", "theme-color");
			attr(meta, "content", meta_content_value = /*themeColor*/ ctx[0] || /*themeBgColor*/ ctx[1]);
		},
		m(target, anchor) {
			append(document_1$2.head, meta);
			insert(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*themeColor, themeBgColor*/ 3 && meta_content_value !== (meta_content_value = /*themeColor*/ ctx[0] || /*themeBgColor*/ ctx[1])) {
				attr(meta, "content", meta_content_value);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			detach(meta);
			if (detaching) detach(t);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function resetCssVariables(array) {
	if (!array) {
		return;
	}

	let cssVariablesName;

	for (let index = 0; index < array.length; index++) {
		cssVariablesName = Object.getOwnPropertyNames(array[index]);
		document.documentElement.style.setProperty(cssVariablesName, array[index][cssVariablesName]);
	}
}

function resetCssContent(contentText) {
	if (!contentText) {
		return;
	}

	var sheet = document.createElement("style");
	sheet.innerHTML = contentText;
	document.head.appendChild(sheet);
}

function instance$13($$self, $$props, $$invalidate) {
	let { spectrumScale = "medium" } = $$props;
	let { spectrumTheme = "dark" } = $$props;
	let { resetCss = [] } = $$props;
	let { resetCssText = "" } = $$props;
	let { themeColor = undefined } = $$props;
	let { language = "en" } = $$props;
	let { languageReadingOrder = "ltr" } = $$props;
	let themeBgColor = "#cccccc";

	onMount(() => {
		setDocumentElementProperty();
		resetCssContent(resetCssText);
	});

	afterUpdate(() => {
		Promise.resolve().then(function () { return index$2; });
	});

	beforeUpdate(() => {
		setDocumentElementProperty();
		resetCssVariables(resetCss);
		getThemeBgColor();
	});

	function setDocumentElementProperty() {
		document.documentElement.className = `spectrum spectrum--${spectrumScale} spectrum--${spectrumTheme}`;
		document.documentElement.lang = language;
		document.documentElement.dir = languageReadingOrder;
	}

	function getThemeBgColor() {
		$$invalidate(1, themeBgColor = getComputedStyle(document.documentElement).getPropertyValue("--spectrum-alias-background-color-default"));
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("spectrumScale" in $$props) $$invalidate(2, spectrumScale = $$props.spectrumScale);
		if ("spectrumTheme" in $$props) $$invalidate(3, spectrumTheme = $$props.spectrumTheme);
		if ("resetCss" in $$props) $$invalidate(4, resetCss = $$props.resetCss);
		if ("resetCssText" in $$props) $$invalidate(5, resetCssText = $$props.resetCssText);
		if ("themeColor" in $$props) $$invalidate(0, themeColor = $$props.themeColor);
		if ("language" in $$props) $$invalidate(6, language = $$props.language);
		if ("languageReadingOrder" in $$props) $$invalidate(7, languageReadingOrder = $$props.languageReadingOrder);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		themeColor,
		themeBgColor,
		spectrumScale,
		spectrumTheme,
		resetCss,
		resetCssText,
		language,
		languageReadingOrder,
		$$scope,
		$$slots
	];
}

class Cornerstone extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$13, create_fragment$13, safe_not_equal, {
			spectrumScale: 2,
			spectrumTheme: 3,
			resetCss: 4,
			resetCssText: 5,
			themeColor: 0,
			language: 6,
			languageReadingOrder: 7
		});
	}
}

/* src/packages/CycleButton/CycleButton.svelte generated by Svelte v3.24.1 */

function create_fragment$14(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			button = element("button");
			if (default_slot) default_slot.c();
			attr(button, "class", "spectrum-ActionButton spectrum-ActionButton--quiet spectrum-CycleButton");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			/*button_binding*/ ctx[9](button);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "click", switchStatus$1),
					listen(button, "click", /*click_handler*/ ctx[4]),
					listen(button, "keydown", /*keydown_handler*/ ctx[5]),
					listen(button, "keyup", /*keyup_handler*/ ctx[6]),
					listen(button, "keypress", /*keypress_handler*/ ctx[7]),
					listen(button, "dblclick", /*dblclick_handler*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (default_slot) default_slot.d(detaching);
			/*button_binding*/ ctx[9](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function switchStatus$1(event) {
	var button = event.target.closest(".spectrum-CycleButton");

	if (button) {
		var icons = button.querySelectorAll(".spectrum-Icon");
		var currentIcon = button.querySelector(".spectrum-Icon.is-selected");
		var currentIconIndex = Array.prototype.slice.call(icons).indexOf(currentIcon);

		if (currentIcon) {
			currentIcon.classList.remove("is-selected");

			var newIndex = currentIconIndex + 1 < icons.length
			? currentIconIndex + 1
			: 0;

			icons[newIndex].classList.add("is-selected");
		}
	}
}

function instance$14($$self, $$props, $$invalidate) {
	let { isSelected = false } = $$props;
	let cycleButton;

	onMount(() => {
		if (cycleButton.children.length) {
			if (cycleButton.children[0]) {
				cycleButton.children[0].classList.add("sspectrum-Icon--sizeS");
				cycleButton.children[0].classList.add("spectrum-CycleButton-item");
				!isSelected && cycleButton.children[0].classList.add("is-selected");
			}

			if (cycleButton.children[1]) {
				cycleButton.children[1].classList.add("sspectrum-Icon--sizeS");
				cycleButton.children[1].classList.add("spectrum-CycleButton-item");
				isSelected && cycleButton.children[1].classList.add("is-selected");
			}
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function keypress_handler(event) {
		bubble($$self, event);
	}

	function dblclick_handler(event) {
		bubble($$self, event);
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			cycleButton = $$value;
			$$invalidate(0, cycleButton);
		});
	}

	$$self.$$set = $$props => {
		if ("isSelected" in $$props) $$invalidate(1, isSelected = $$props.isSelected);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [
		cycleButton,
		isSelected,
		$$scope,
		$$slots,
		click_handler,
		keydown_handler,
		keyup_handler,
		keypress_handler,
		dblclick_handler,
		button_binding
	];
}

class CycleButton extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$14, create_fragment$14, safe_not_equal, { isSelected: 1 });
	}
}

/* src/packages/Dial/Dial.svelte generated by Svelte v3.24.1 */

function create_fragment$15(ctx) {
	let div2;
	let div1;
	let div0;
	let input;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			input = element("input");
			attr(input, "type", "range");
			attr(input, "class", "spectrum-Dial-input");
			attr(input, "min", "0");
			attr(input, "max", "100");
			input.value = /*value*/ ctx[0];
			attr(div0, "class", "spectrum-Dial-handle");
			attr(div0, "tabindex", "0");
			set_style(div0, "transform", "rotate(" + /*deg*/ ctx[4] + "deg)");
			attr(div1, "class", "spectrum-Dial-controls");
			attr(div2, "class", "spectrum-Dial");
			toggle_class(div2, "is-disabled", /*disabled*/ ctx[1]);
			toggle_class(div2, "spectrum-Dial--small", /*isSmall*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, input);
			/*div2_binding*/ ctx[6](div2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*value*/ 1) {
				input.value = /*value*/ ctx[0];
			}

			if (dirty & /*deg*/ 16) {
				set_style(div0, "transform", "rotate(" + /*deg*/ ctx[4] + "deg)");
			}

			if (dirty & /*disabled*/ 2) {
				toggle_class(div2, "is-disabled", /*disabled*/ ctx[1]);
			}

			if (dirty & /*isSmall*/ 4) {
				toggle_class(div2, "spectrum-Dial--small", /*isSmall*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			/*div2_binding*/ ctx[6](null);
		}
	};
}

function instance$15($$self, $$props, $$invalidate) {
	let { value = 0 } = $$props;
	let { damping = 0.8 } = $$props;
	let { disabled = false } = $$props;
	let { isSmall = false } = $$props;
	let dial;
	let i = 0;

	onMount(() => {
		i = +value;

		!disabled && dial.addEventListener("mousedown", function (e) {
			startGetDialValue(e);
		});
	});

	function startGetDialValue(e) {
		getDialValue(e);
		window.addEventListener("mousemove", getDialValue);
		window.addEventListener("mouseup", endGetDialValue);
	}

	function getDialValue(e) {
		e.preventDefault();
		const thisRect = dial.getBoundingClientRect();
		let x = e.pageX - thisRect.left;
		let y = e.pageY - thisRect.top;
		x > 0 && y > 0 ? i = i + damping : i = i - damping;

		if (i > 100) {
			$$invalidate(0, value = 100);
			i = value;
		} else if (i < 0) {
			$$invalidate(0, value = 0);
			i = value;
		} else {
			$$invalidate(0, value = +i.toFixed(2));
			i = value;
		}
	}

	function endGetDialValue(e) {
		window.removeEventListener("mousemove", getDialValue);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			dial = $$value;
			$$invalidate(3, dial);
		});
	}

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("damping" in $$props) $$invalidate(5, damping = $$props.damping);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ("isSmall" in $$props) $$invalidate(2, isSmall = $$props.isSmall);
	};

	let deg;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			 $$invalidate(4, deg = (value * 2.7 - 45).toFixed(2));
		}
	};

	return [value, disabled, isSmall, dial, deg, damping, div2_binding];
}

class Dial extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$15, create_fragment$15, safe_not_equal, {
			value: 0,
			damping: 5,
			disabled: 1,
			isSmall: 2
		});
	}
}

/* src/packages/Dialog/Dialog.svelte generated by Svelte v3.24.1 */

const { document: document_1$3 } = globals;

function add_css$f() {
	var style = element("style");
	style.id = "svelte-1cumdv1-style";
	style.textContent = ".spectrum-Underlay{background:var(--spectrum-dialog-underlay-background-color, var(--spectrum-alias-background-color-modal-overlay))}.spectrum-Underlay{position:fixed;top:0;right:0;bottom:0;left:0;overflow:hidden;transition:opacity\n        var(--spectrum-dialog-background-exit-animation-duration, var(--spectrum-global-animation-duration-300))\n        cubic-bezier(0.5, 0, 1, 1)\n        var(--spectrum-dialog-background-exit-animation-delay, var(--spectrum-global-animation-duration-200)),\n      visibility 0ms linear\n        calc(\n          var(--spectrum-dialog-background-exit-animation-delay, var(--spectrum-global-animation-duration-200)) +\n            var(--spectrum-dialog-background-exit-animation-duration, var(--spectrum-global-animation-duration-300))\n        )}.spectrum-Underlay{visibility:hidden;opacity:0;transition:transform var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      opacity var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      visibility 0ms linear var(--spectrum-global-animation-duration-100, 130ms);pointer-events:none}.spectrum-Underlay.is-open{transition:opacity\n      var(--spectrum-dialog-background-entry-animation-duration, var(--spectrum-global-animation-duration-600))\n      cubic-bezier(0, 0, 0.4, 1) 0ms}.spectrum-Underlay.is-open{visibility:visible;opacity:1;transition-delay:0ms;pointer-events:auto}[dir=\"ltr\"].spectrum--large .spectrum-Dialog-closeButton{right:0}[dir=\"rtl\"].spectrum--large .spectrum-Dialog-closeButton{left:0}.spectrum--large .spectrum-Dialog-closeButton{position:absolute;top:calc(-1 * var(--spectrum-global-dimension-size-75))}";
	append(document_1$3.head, style);
}

const get_dialog_footer_slot_changes = dirty => ({});
const get_dialog_footer_slot_context = ctx => ({});
const get_dialog_header_slot_changes = dirty => ({});
const get_dialog_header_slot_context = ctx => ({});

// (159:4) {#if heroImgUrl}
function create_if_block_1$C(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				imgUrl: /*heroImgUrl*/ ctx[4],
				imgAlt: /*heroImgAlt*/ ctx[5],
				class: "spectrum-Dialog-hero"
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*heroImgUrl*/ 16) image_changes.imgUrl = /*heroImgUrl*/ ctx[4];
			if (dirty & /*heroImgAlt*/ 32) image_changes.imgAlt = /*heroImgAlt*/ ctx[5];
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (165:6) {#if isError && variants == 'alert'}
function create_if_block$D(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: { className: "spectrum-Dialog-typeIcon" }
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (169:8) <div slot="button-icon">
function create_button_icon_slot(ctx) {
	let div;
	let iconcrosslarge;
	let current;

	iconcrosslarge = new CrossLarge({
			props: {
				scale: /*large*/ ctx[11] ? "L" : "M",
				width: /*iconSize*/ ctx[12],
				height: /*iconSize*/ ctx[12]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(iconcrosslarge.$$.fragment);
			attr(div, "slot", "button-icon");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(iconcrosslarge, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const iconcrosslarge_changes = {};
			if (dirty & /*large*/ 2048) iconcrosslarge_changes.scale = /*large*/ ctx[11] ? "L" : "M";
			if (dirty & /*iconSize*/ 4096) iconcrosslarge_changes.width = /*iconSize*/ ctx[12];
			if (dirty & /*iconSize*/ 4096) iconcrosslarge_changes.height = /*iconSize*/ ctx[12];
			iconcrosslarge.$set(iconcrosslarge_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconcrosslarge.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcrosslarge.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(iconcrosslarge);
		}
	};
}

function create_fragment$16(ctx) {
	let div0;
	let t0;
	let div4;
	let div3;
	let t1;
	let div1;
	let h2;
	let t2;
	let t3;
	let t4;
	let t5;
	let button;
	let t6;
	let div2;
	let t7;
	let div3_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*heroImgUrl*/ ctx[4] && create_if_block_1$C(ctx);
	const dialog_header_slot_template = /*$$slots*/ ctx[14]["dialog-header"];
	const dialog_header_slot = create_slot(dialog_header_slot_template, ctx, /*$$scope*/ ctx[16], get_dialog_header_slot_context);
	let if_block1 = /*isError*/ ctx[7] && /*variants*/ ctx[1] == "alert" && create_if_block$D();

	button = new Button({
			props: {
				class: "spectrum-Dialog-closeButton",
				exterior: "action",
				isQuiet: true,
				$$slots: { "button-icon": [create_button_icon_slot] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*cancelDialog*/ ctx[13]);
	const default_slot_template = /*$$slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	const dialog_footer_slot_template = /*$$slots*/ ctx[14]["dialog-footer"];
	const dialog_footer_slot = create_slot(dialog_footer_slot_template, ctx, /*$$scope*/ ctx[16], get_dialog_footer_slot_context);

	return {
		c() {
			div0 = element("div");
			t0 = space();
			div4 = element("div");
			div3 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			h2 = element("h2");
			t2 = text(/*title*/ ctx[3]);
			t3 = space();
			if (dialog_header_slot) dialog_header_slot.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			create_component(button.$$.fragment);
			t6 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			t7 = space();
			if (dialog_footer_slot) dialog_footer_slot.c();
			attr(div0, "class", "spectrum-Underlay");
			set_style(div0, "z-index", /*zIndex*/ ctx[2]);
			toggle_class(div0, "is-open", /*isOpen*/ ctx[0]);
			attr(h2, "class", "spectrum-Dialog-title");
			attr(div1, "class", "spectrum-Dialog-header");
			attr(div2, "class", "spectrum-Dialog-content");

			attr(div3, "class", div3_class_value = "spectrum-Dialog " + (/*variants*/ ctx[1]
			? `spectrum-Dialog--${/*variants*/ ctx[1]}`
			: ""));

			toggle_class(div3, "spectrum-Dialog--dismissible", /*dismissible*/ ctx[6]);
			toggle_class(div3, "spectrum-Dialog--error", /*isError*/ ctx[7] && /*variants*/ ctx[1] == "alert");
			toggle_class(div3, "spectrum-Dialog--noDivider", /*noDivider*/ ctx[8]);
			toggle_class(div3, "is-open", /*isOpen*/ ctx[0]);
			attr(div4, "class", "spectrum-Dialog-wrapper");
			set_style(div4, "z-index", +/*zIndex*/ ctx[2] + 1);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t0, anchor);
			insert(target, div4, anchor);
			append(div4, div3);
			if (if_block0) if_block0.m(div3, null);
			append(div3, t1);
			append(div3, div1);
			append(div1, h2);
			append(h2, t2);
			append(div1, t3);

			if (dialog_header_slot) {
				dialog_header_slot.m(div1, null);
			}

			append(div1, t4);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t5);
			mount_component(button, div1, null);
			append(div3, t6);
			append(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			append(div3, t7);

			if (dialog_footer_slot) {
				dialog_footer_slot.m(div3, null);
			}

			/*div3_binding*/ ctx[15](div3);
			current = true;

			if (!mounted) {
				dispose = listen(div0, "click", function () {
					if (is_function(/*puncture*/ ctx[9] && /*cancelDialog*/ ctx[13])) (/*puncture*/ ctx[9] && /*cancelDialog*/ ctx[13]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (!current || dirty & /*zIndex*/ 4) {
				set_style(div0, "z-index", /*zIndex*/ ctx[2]);
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(div0, "is-open", /*isOpen*/ ctx[0]);
			}

			if (/*heroImgUrl*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*heroImgUrl*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$C(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div3, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*title*/ 8) set_data(t2, /*title*/ ctx[3]);

			if (dialog_header_slot) {
				if (dialog_header_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(dialog_header_slot, dialog_header_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_dialog_header_slot_changes, get_dialog_header_slot_context);
				}
			}

			if (/*isError*/ ctx[7] && /*variants*/ ctx[1] == "alert") {
				if (if_block1) {
					if (dirty & /*isError, variants*/ 130) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$D();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t5);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const button_changes = {};

			if (dirty & /*$$scope, large, iconSize*/ 71680) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (dialog_footer_slot) {
				if (dialog_footer_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(dialog_footer_slot, dialog_footer_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_dialog_footer_slot_changes, get_dialog_footer_slot_context);
				}
			}

			if (!current || dirty & /*variants*/ 2 && div3_class_value !== (div3_class_value = "spectrum-Dialog " + (/*variants*/ ctx[1]
			? `spectrum-Dialog--${/*variants*/ ctx[1]}`
			: ""))) {
				attr(div3, "class", div3_class_value);
			}

			if (dirty & /*variants, dismissible*/ 66) {
				toggle_class(div3, "spectrum-Dialog--dismissible", /*dismissible*/ ctx[6]);
			}

			if (dirty & /*variants, isError, variants*/ 130) {
				toggle_class(div3, "spectrum-Dialog--error", /*isError*/ ctx[7] && /*variants*/ ctx[1] == "alert");
			}

			if (dirty & /*variants, noDivider*/ 258) {
				toggle_class(div3, "spectrum-Dialog--noDivider", /*noDivider*/ ctx[8]);
			}

			if (dirty & /*variants, isOpen*/ 3) {
				toggle_class(div3, "is-open", /*isOpen*/ ctx[0]);
			}

			if (!current || dirty & /*zIndex*/ 4) {
				set_style(div4, "z-index", +/*zIndex*/ ctx[2] + 1);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(dialog_header_slot, local);
			transition_in(if_block1);
			transition_in(button.$$.fragment, local);
			transition_in(default_slot, local);
			transition_in(dialog_footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(dialog_header_slot, local);
			transition_out(if_block1);
			transition_out(button.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(dialog_footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t0);
			if (detaching) detach(div4);
			if (if_block0) if_block0.d();
			if (dialog_header_slot) dialog_header_slot.d(detaching);
			if (if_block1) if_block1.d();
			destroy_component(button);
			if (default_slot) default_slot.d(detaching);
			if (dialog_footer_slot) dialog_footer_slot.d(detaching);
			/*div3_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$16($$self, $$props, $$invalidate) {
	let { variants = "" } = $$props;
	let { zIndex = 100 } = $$props;
	let { title = "" } = $$props;
	let { heroImgUrl = "" } = $$props;
	let { heroImgAlt = "Hero image" } = $$props;
	let { dismissible = false } = $$props;
	let { isError = false } = $$props;
	let { noDivider = false } = $$props;
	let { isOpen = false } = $$props;
	let { puncture = false } = $$props;
	let dialogEl;
	let large = false;
	let iconSize = 12;

	function getIconScale() {
		$$invalidate(12, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-150")));

		if (iconSize == 12) {
			$$invalidate(11, large = false);
		} else {
			$$invalidate(11, large = true);
		}
	}

	onMount(() => {
		advanceAddClassName(dialogEl, "dialog-footer", "spectrum-Dialog-footer");
	});

	afterUpdate(() => {
		getIconScale();
	});

	function cancelDialog() {
		$$invalidate(0, isOpen = false);
	}

	let { $$slots = {}, $$scope } = $$props;

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			dialogEl = $$value;
			$$invalidate(10, dialogEl);
		});
	}

	$$self.$$set = $$props => {
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("zIndex" in $$props) $$invalidate(2, zIndex = $$props.zIndex);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
		if ("heroImgUrl" in $$props) $$invalidate(4, heroImgUrl = $$props.heroImgUrl);
		if ("heroImgAlt" in $$props) $$invalidate(5, heroImgAlt = $$props.heroImgAlt);
		if ("dismissible" in $$props) $$invalidate(6, dismissible = $$props.dismissible);
		if ("isError" in $$props) $$invalidate(7, isError = $$props.isError);
		if ("noDivider" in $$props) $$invalidate(8, noDivider = $$props.noDivider);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("puncture" in $$props) $$invalidate(9, puncture = $$props.puncture);
		if ("$$scope" in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	return [
		isOpen,
		variants,
		zIndex,
		title,
		heroImgUrl,
		heroImgAlt,
		dismissible,
		isError,
		noDivider,
		puncture,
		dialogEl,
		large,
		iconSize,
		cancelDialog,
		$$slots,
		div3_binding,
		$$scope
	];
}

class Dialog extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1$3.getElementById("svelte-1cumdv1-style")) add_css$f();

		init(this, options, instance$16, create_fragment$16, safe_not_equal, {
			variants: 1,
			zIndex: 2,
			title: 3,
			heroImgUrl: 4,
			heroImgAlt: 5,
			dismissible: 6,
			isError: 7,
			noDivider: 8,
			isOpen: 0,
			puncture: 9
		});
	}
}

/* src/packages/DropIndicator/DropIndicator.svelte generated by Svelte v3.24.1 */

function create_fragment$17(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = "spectrum-DropIndicator spectrum-DropIndicator--" + /*orientation*/ ctx[0]);
			attr(div, "style", /*styleCssText*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*orientation*/ 1 && div_class_value !== (div_class_value = "spectrum-DropIndicator spectrum-DropIndicator--" + /*orientation*/ ctx[0])) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*styleCssText*/ 2) {
				attr(div, "style", /*styleCssText*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$17($$self, $$props, $$invalidate) {
	let { orientation = "horizontal" } = $$props;
	let { spacing = {} } = $$props;
	let { dimension = "size-600" } = $$props;
	let spacingCssText = "";

	onMount(() => {
		$$invalidate(4, spacingCssText = integrateAutoProps(spacing));
	});

	$$self.$$set = $$props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$props.orientation);
		if ("spacing" in $$props) $$invalidate(2, spacing = $$props.spacing);
		if ("dimension" in $$props) $$invalidate(3, dimension = $$props.dimension);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*orientation, dimension, spacingCssText*/ 25) {
			 $$invalidate(1, styleCssText = [
				orientation == "horizontal" && dimension.indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${dimension});`
				: `width:${dimension};`,
				orientation == "vertical" && dimension.indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${dimension});`
				: `height:${dimension};`,
				spacingCssText
			].filter(Boolean).join(""));
		}
	};

	return [orientation, styleCssText, spacing, dimension];
}

class DropIndicator extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$17, create_fragment$17, safe_not_equal, { orientation: 0, spacing: 2, dimension: 3 });
	}
}

/* src/packages/Menu/Menu.svelte generated by Svelte v3.24.1 */

function add_css$g() {
	var style = element("style");
	style.id = "svelte-wo9yzt-style";
	style.textContent = ".spectrum-Menu-itemLabel{white-space:nowrap;width:auto;display:inline-block;*display:inline}.spectrum-Menu{overflow-x:hidden}.spectrum-Menu-nested{position:absolute}";
	append(document.head, style);
}

function create_fragment$18(ctx) {
	let ul;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", "spectrum-Menu");
			attr(ul, "role", /*role*/ ctx[0]);
			attr(ul, "style", /*styleCssText*/ ctx[4]);
			attr(ul, "aria-labelledby", /*ariaLabelledby*/ ctx[1]);
			toggle_class(ul, "spectrum-Menu-nested", /*nested*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			/*ul_binding*/ ctx[9](ul);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			if (!current || dirty & /*role*/ 1) {
				attr(ul, "role", /*role*/ ctx[0]);
			}

			if (!current || dirty & /*styleCssText*/ 16) {
				attr(ul, "style", /*styleCssText*/ ctx[4]);
			}

			if (!current || dirty & /*ariaLabelledby*/ 2) {
				attr(ul, "aria-labelledby", /*ariaLabelledby*/ ctx[1]);
			}

			if (dirty & /*nested*/ 4) {
				toggle_class(ul, "spectrum-Menu-nested", /*nested*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (default_slot) default_slot.d(detaching);
			/*ul_binding*/ ctx[9](null);
		}
	};
}

function instance$18($$self, $$props, $$invalidate) {
	let { role = "menu" } = $$props;
	let { maxWidth = 0 } = $$props;
	let { minWidth = 0 } = $$props;
	let { ariaLabelledby = "" } = $$props;
	let { nested = false } = $$props;
	let menuEl;
	let menuWidth;

	afterUpdate(() => {
		if (menuEl) {
			nested && resetPosition();
			$$invalidate(10, menuWidth = setWidth().width);
		}
	});

	onMount(() => {
		nested && window.addEventListener("click", listenForChildClicks);
	});

	function listenForChildClicks(e) {
		let prevNode = menuEl.previousElementSibling;

		if (prevNode && prevNode.contains(e.target)) {
			menuEl.previousElementSibling && resetPosition();
		}
	}

	let getInTheBoxPositionTop = 0;
	let getInTheBoxPositionLeft = 0;

	function resetPosition() {
		let prevNode = menuEl.previousElementSibling;

		if (prevNode) {
			let openItem = prevNode.querySelector(".spectrum-Menu-item.is-open");
			$$invalidate(12, getInTheBoxPositionLeft = getRect(prevNode).width);
			$$invalidate(11, [,getInTheBoxPositionTop] = getInTheBoxPosition(prevNode, openItem), getInTheBoxPositionTop);
		}
	}

	function setWidth() {
		let thisMenu = menuEl.parentElement.parentElement.querySelector("#rubus-ActionSource");

		if (thisMenu) {
			return getRect(thisMenu);
		} else {
			return { width: 0 };
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			menuEl = $$value;
			$$invalidate(3, menuEl);
		});
	}

	$$self.$$set = $$props => {
		if ("role" in $$props) $$invalidate(0, role = $$props.role);
		if ("maxWidth" in $$props) $$invalidate(5, maxWidth = $$props.maxWidth);
		if ("minWidth" in $$props) $$invalidate(6, minWidth = $$props.minWidth);
		if ("ariaLabelledby" in $$props) $$invalidate(1, ariaLabelledby = $$props.ariaLabelledby);
		if ("nested" in $$props) $$invalidate(2, nested = $$props.nested);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*maxWidth, menuWidth, minWidth, nested, getInTheBoxPositionTop, getInTheBoxPositionLeft*/ 7268) {
			 $$invalidate(4, styleCssText = [
				maxWidth
				? `max-width:${maxWidth}px;`
				: `max-width:${menuWidth}px;`,
				minWidth
				? `min-width:${minWidth}px;`
				: `min-width:${menuWidth}px;`,
				nested && `top:${getInTheBoxPositionTop}px;`,
				nested && `left:${getInTheBoxPositionLeft}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		role,
		ariaLabelledby,
		nested,
		menuEl,
		styleCssText,
		maxWidth,
		minWidth,
		$$scope,
		$$slots,
		ul_binding
	];
}

class Menu extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-wo9yzt-style")) add_css$g();

		init(this, options, instance$18, create_fragment$18, safe_not_equal, {
			role: 0,
			maxWidth: 5,
			minWidth: 6,
			ariaLabelledby: 1,
			nested: 2
		});
	}
}

/* src/packages/Menu/MenuItem.svelte generated by Svelte v3.24.1 */

function add_css$h() {
	var style = element("style");
	style.id = "svelte-o6smev-style";
	style.textContent = ".spectrum-Menu-item{width:100%}.spectrum-Menu-itemIcon{text-align:center;right:0}.spectrum-Menu-item.is-disabled{pointer-events:none}";
	append(document.head, style);
}

// (87:0) {:else}
function create_else_block$6(ctx) {
	let li;
	let t;
	let current_block_type_index;
	let if_block;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);
	const if_block_creators = [create_if_block_1$D, create_if_block_2$8];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*nested*/ ctx[9] && (/*isSelected*/ ctx[2] || /*resultIndex*/ ctx[0] === /*thisIndex*/ ctx[5])) return 0;
		if (/*showCheckmark*/ ctx[8]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			li = element("li");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			if (if_block) if_block.c();
			attr(li, "class", "spectrum-Menu-item");
			attr(li, "role", /*role*/ ctx[7]);
			attr(li, "tabindex", /*tabindex*/ ctx[6]);
			toggle_class(li, "is-selected", !/*nested*/ ctx[9] && (/*isSelected*/ ctx[2] || /*resultIndex*/ ctx[0] === /*thisIndex*/ ctx[5]));
			toggle_class(li, "is-disabled", /*disabled*/ ctx[3]);
			toggle_class(li, "is-open", /*nested*/ ctx[9] && (/*isSelected*/ ctx[2] || /*resultIndex*/ ctx[0] === /*thisIndex*/ ctx[5]));
		},
		m(target, anchor) {
			insert(target, li, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(li, null);
			}

			append(li, t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(li, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "click", function () {
						if (is_function(!/*disabled*/ ctx[3] && /*dropdownPick*/ ctx[11])) (!/*disabled*/ ctx[3] && /*dropdownPick*/ ctx[11]).apply(this, arguments);
					}),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[10].call(null, li))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(li, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty & /*role*/ 128) {
				attr(li, "role", /*role*/ ctx[7]);
			}

			if (!current || dirty & /*tabindex*/ 64) {
				attr(li, "tabindex", /*tabindex*/ ctx[6]);
			}

			if (dirty & /*nested, isSelected, resultIndex, thisIndex*/ 549) {
				toggle_class(li, "is-selected", !/*nested*/ ctx[9] && (/*isSelected*/ ctx[2] || /*resultIndex*/ ctx[0] === /*thisIndex*/ ctx[5]));
			}

			if (dirty & /*disabled*/ 8) {
				toggle_class(li, "is-disabled", /*disabled*/ ctx[3]);
			}

			if (dirty & /*nested, isSelected, resultIndex, thisIndex*/ 549) {
				toggle_class(li, "is-open", /*nested*/ ctx[9] && (/*isSelected*/ ctx[2] || /*resultIndex*/ ctx[0] === /*thisIndex*/ ctx[5]));
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (85:0) {#if isDivider}
function create_if_block$E(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			attr(li, "class", "spectrum-Menu-divider");
			attr(li, "role", "separator");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (97:10) <span class="spectrum-Menu-itemLabel">
function fallback_block$3(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*label*/ ctx[1]);
			attr(span, "class", "spectrum-Menu-itemLabel");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data(t, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (106:28) 
function create_if_block_2$8(ctx) {
	let iconcheckmarkmedium;
	let current;

	iconcheckmarkmedium = new CheckmarkMedium({
			props: {
				className: "spectrum-Menu-checkmark spectrum-Menu-itemIcon",
				focusable: "false",
				width: "12",
				height: "12",
				"aria-hidden": /*isSelected*/ ctx[2]
			}
		});

	return {
		c() {
			create_component(iconcheckmarkmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcheckmarkmedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconcheckmarkmedium_changes = {};
			if (dirty & /*isSelected*/ 4) iconcheckmarkmedium_changes["aria-hidden"] = /*isSelected*/ ctx[2];
			iconcheckmarkmedium.$set(iconcheckmarkmedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconcheckmarkmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcheckmarkmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcheckmarkmedium, detaching);
		}
	};
}

// (98:4) {#if nested && (isSelected || resultIndex === thisIndex)}
function create_if_block_1$D(ctx) {
	let iconchevronrightmedium;
	let current;

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				className: "spectrum-UIIcon-ChevronRightMedium spectrum-Menu-chevron spectrum-Menu-itemIcon",
				focusable: "false",
				width: "6",
				height: "10",
				"aria-hidden": /*isSelected*/ ctx[2],
				"aria-label": "Next"
			}
		});

	return {
		c() {
			create_component(iconchevronrightmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronrightmedium, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const iconchevronrightmedium_changes = {};
			if (dirty & /*isSelected*/ 4) iconchevronrightmedium_changes["aria-hidden"] = /*isSelected*/ ctx[2];
			iconchevronrightmedium.$set(iconchevronrightmedium_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronrightmedium, detaching);
		}
	};
}

function create_fragment$19(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$E, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isDivider*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$19($$self, $$props, $$invalidate) {
	let { label = "" } = $$props;
	let { isSelected = false } = $$props;
	let { disabled = false } = $$props;
	let { isDivider = false } = $$props;
	let { resultIndex = 0 } = $$props;
	let { thisIndex = 0 } = $$props;
	let { tabindex = 0 } = $$props;
	let { role = "menuitem" } = $$props;
	let { showCheckmark = true } = $$props;
	let { nested = false } = $$props;
	const eventsListen = getEventsAction(current_component);

	function dropdownPick() {
		$$invalidate(0, resultIndex = thisIndex);
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("isSelected" in $$props) $$invalidate(2, isSelected = $$props.isSelected);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isDivider" in $$props) $$invalidate(4, isDivider = $$props.isDivider);
		if ("resultIndex" in $$props) $$invalidate(0, resultIndex = $$props.resultIndex);
		if ("thisIndex" in $$props) $$invalidate(5, thisIndex = $$props.thisIndex);
		if ("tabindex" in $$props) $$invalidate(6, tabindex = $$props.tabindex);
		if ("role" in $$props) $$invalidate(7, role = $$props.role);
		if ("showCheckmark" in $$props) $$invalidate(8, showCheckmark = $$props.showCheckmark);
		if ("nested" in $$props) $$invalidate(9, nested = $$props.nested);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	return [
		resultIndex,
		label,
		isSelected,
		disabled,
		isDivider,
		thisIndex,
		tabindex,
		role,
		showCheckmark,
		nested,
		eventsListen,
		dropdownPick,
		$$scope,
		$$slots
	];
}

class MenuItem extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-o6smev-style")) add_css$h();

		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
			label: 1,
			isSelected: 2,
			disabled: 3,
			isDivider: 4,
			resultIndex: 0,
			thisIndex: 5,
			tabindex: 6,
			role: 7,
			showCheckmark: 8,
			nested: 9
		});
	}
}

/* src/packages/Menu/MenuGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$1a(ctx) {
	let li;
	let span;
	let t0;
	let t1;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			li = element("li");
			span = element("span");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			if (default_slot) default_slot.c();
			attr(span, "class", "spectrum-Menu-sectionHeading");
			attr(span, "id", /*id*/ ctx[1]);
			attr(span, "aria-hidden", "true");
			attr(li, "role", "presentation");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, span);
			append(span, t0);
			append(li, t1);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);

			if (!current || dirty & /*id*/ 2) {
				attr(span, "id", /*id*/ ctx[1]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1a($$self, $$props, $$invalidate) {
	let { title = "" } = $$props;
	let { id = "" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [title, id, $$scope, $$slots];
}

class MenuGroup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { title: 0, id: 1 });
	}
}

/* src/packages/Dropdown/Dropdown.svelte generated by Svelte v3.24.1 */

function add_css$i() {
	var style = element("style");
	style.id = "svelte-1bhv1ic-style";
	style.textContent = ".spectrum-FieldButton{display:flex}.spectrum-Dropdown-trigger>.spectrum-Dropdown-icon{transition:transform var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      opacity var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      visibility 0ms linear var(--spectrum-global-animation-duration-100, 130ms)}.spectrum-Dropdown-trigger.is-selected>.spectrum-Dropdown-icon{transform:rotate(180deg)}";
	append(document.head, style);
}

const get_dropdown_label_slot_changes = dirty => ({});
const get_dropdown_label_slot_context = ctx => ({});

// (155:4) {:else}
function create_else_block$7(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_anchor = empty();
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(/*triggerNode*/ ctx[8], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*triggerNode*/ 256) html_tag.p(/*triggerNode*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (151:4) {#if !triggerNode}
function create_if_block_1$E(ctx) {
	let span;
	let current;
	const dropdown_label_slot_template = /*$$slots*/ ctx[13]["dropdown-label"];
	const dropdown_label_slot = create_slot(dropdown_label_slot_template, ctx, /*$$scope*/ ctx[15], get_dropdown_label_slot_context);
	const dropdown_label_slot_or_fallback = dropdown_label_slot || fallback_block$4(ctx);

	return {
		c() {
			span = element("span");
			if (dropdown_label_slot_or_fallback) dropdown_label_slot_or_fallback.c();
			attr(span, "class", "spectrum-Dropdown-label");
			toggle_class(span, "is-placeholder", !/*isActive*/ ctx[6] && /*placeholder*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (dropdown_label_slot_or_fallback) {
				dropdown_label_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dropdown_label_slot) {
				if (dropdown_label_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(dropdown_label_slot, dropdown_label_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_dropdown_label_slot_changes, get_dropdown_label_slot_context);
				}
			} else {
				if (dropdown_label_slot_or_fallback && dropdown_label_slot_or_fallback.p && dirty & /*placeholder*/ 2) {
					dropdown_label_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (dirty & /*isActive, placeholder*/ 66) {
				toggle_class(span, "is-placeholder", !/*isActive*/ ctx[6] && /*placeholder*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(dropdown_label_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(dropdown_label_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (dropdown_label_slot_or_fallback) dropdown_label_slot_or_fallback.d(detaching);
		}
	};
}

// (153:36) {placeholder}
function fallback_block$4(ctx) {
	let t;

	return {
		c() {
			t = text(/*placeholder*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*placeholder*/ 2) set_data(t, /*placeholder*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (158:4) {#if isInvalid}
function create_if_block$F(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				focusable: "false",
				"aria-hidden": "true",
				"aria-label": "Folder"
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (165:4) <Menu role="listbox" {minWidth}>
function create_default_slot_1$2(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (164:2) <Popover class="spectrum-Dropdown-popover" {isOpen}>
function create_default_slot$3(ctx) {
	let menu;
	let current;

	menu = new Menu({
			props: {
				role: "listbox",
				minWidth: /*minWidth*/ ctx[5],
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(menu.$$.fragment);
		},
		m(target, anchor) {
			mount_component(menu, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const menu_changes = {};
			if (dirty & /*minWidth*/ 32) menu_changes.minWidth = /*minWidth*/ ctx[5];

			if (dirty & /*$$scope*/ 32768) {
				menu_changes.$$scope = { dirty, ctx };
			}

			menu.$set(menu_changes);
		},
		i(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(menu, detaching);
		}
	};
}

function create_fragment$1b(ctx) {
	let div1;
	let button;
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let iconchevrondownmedium;
	let t2;
	let popover;
	let t3;
	let div0;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$E, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*triggerNode*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*isInvalid*/ ctx[3] && create_if_block$F();

	iconchevrondownmedium = new ChevronDownMedium({
			props: {
				className: "spectrum-Dropdown-icon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	popover = new Popover({
			props: {
				class: "spectrum-Dropdown-popover",
				isOpen: /*isOpen*/ ctx[0],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			button = element("button");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			create_component(iconchevrondownmedium.$$.fragment);
			t2 = space();
			create_component(popover.$$.fragment);
			t3 = space();
			div0 = element("div");
			attr(button, "class", "spectrum-FieldButton spectrum-Dropdown-trigger");
			attr(button, "aria-haspopup", "listbox");
			attr(button, "id", "rubus-ActionSource");
			set_style(button, "min-width", /*minWidth*/ ctx[5] + "px");
			toggle_class(button, "is-selected", /*isOpen*/ ctx[0]);
			toggle_class(button, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(button, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(button, "spectrum-FieldButton--quiet", /*isQuiet*/ ctx[4]);
			attr(div1, "class", "spectrum-Dropdown");
			toggle_class(div1, "is-open", /*isOpen*/ ctx[0]);
			toggle_class(div1, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(div1, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(div1, "spectrum-Dropdown--quiet", /*isQuiet*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, button);
			if_blocks[current_block_type_index].m(button, null);
			append(button, t0);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			mount_component(iconchevrondownmedium, button, null);
			append(div1, t2);
			mount_component(popover, div1, null);
			append(div1, t3);
			append(div1, div0);
			/*div1_binding*/ ctx[14](div1);
			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", function () {
					if (is_function(!/*disabled*/ ctx[2] && /*dropdownStatusCutover*/ ctx[9])) (!/*disabled*/ ctx[2] && /*dropdownStatusCutover*/ ctx[9]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(button, t0);
			}

			if (/*isInvalid*/ ctx[3]) {
				if (if_block1) {
					if (dirty & /*isInvalid*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$F();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*minWidth*/ 32) {
				set_style(button, "min-width", /*minWidth*/ ctx[5] + "px");
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(button, "is-selected", /*isOpen*/ ctx[0]);
			}

			if (dirty & /*isInvalid*/ 8) {
				toggle_class(button, "is-invalid", /*isInvalid*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(button, "is-disabled", /*disabled*/ ctx[2]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(button, "spectrum-FieldButton--quiet", /*isQuiet*/ ctx[4]);
			}

			const popover_changes = {};
			if (dirty & /*isOpen*/ 1) popover_changes.isOpen = /*isOpen*/ ctx[0];

			if (dirty & /*$$scope, minWidth*/ 32800) {
				popover_changes.$$scope = { dirty, ctx };
			}

			popover.$set(popover_changes);

			if (dirty & /*isOpen*/ 1) {
				toggle_class(div1, "is-open", /*isOpen*/ ctx[0]);
			}

			if (dirty & /*isInvalid*/ 8) {
				toggle_class(div1, "is-invalid", /*isInvalid*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(div1, "is-disabled", /*disabled*/ ctx[2]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(div1, "spectrum-Dropdown--quiet", /*isQuiet*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(iconchevrondownmedium.$$.fragment, local);
			transition_in(popover.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(iconchevrondownmedium.$$.fragment, local);
			transition_out(popover.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			destroy_component(iconchevrondownmedium);
			destroy_component(popover);
			/*div1_binding*/ ctx[14](null);
			mounted = false;
			dispose();
		}
	};
}

function testHasClassName(el, verifyString) {
	if (!el) {
		return false;
	}

	for (let index = 0; index < el.length; index++) {
		return el[index] === verifyString;
	}
}

function getNodeHTML(el) {
	if (!el.length) {
		return "";
	}

	let nodeHTML = "";

	for (let index = 0; index < el.length; index++) {
		if (!testHasClassName(el[index].classList, `spectrum-Menu-checkmark`)) {
			el[index].outerHTML
			? nodeHTML = nodeHTML + el[index].outerHTML
			: nodeHTML;
		}
	}

	return nodeHTML.replace(/spectrum-Menu-itemLabel/g, "spectrum-Dropdown-label");
}

function instance$1b($$self, $$props, $$invalidate) {
	let { placeholder = "" } = $$props;
	let { disabled = false } = $$props;
	let { isOpen = false } = $$props;
	let { resultIndex = 0 } = $$props;
	let { thisIndex = 0 } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { minWidth = 200 } = $$props;
	let { autoFold = true } = $$props;
	let isActive = false;

	function dropdownStatusCutover() {
		$$invalidate(6, isActive = true);
		$$invalidate(10, resultIndex = thisIndex);
		$$invalidate(0, isOpen = !isOpen);
	}

	onMount(() => {
		dropmenuEl && dropmenuEl.addEventListener("click", listenForChildClicks);
		dropmenuEl && dropmenuEl.addEventListener("keyup", listenForChildClicks);
		window && window.addEventListener("click", listenForOtherClicks);
		window && window.addEventListener("keyup", listenForOtherClicks);
	});

	let dropmenuEl;
	let triggerNode = "";

	function listenForChildClicks(e) {
		if (dropmenuEl && dropmenuEl.contains(e.target)) {
			if (e.target.classList.length) {
				if (testHasClassName(e.target.classList, `spectrum-Menu-item`)) {
					$$invalidate(8, triggerNode = getNodeHTML(e.target.childNodes));
				} else if (testHasClassName(e.target.classList, `spectrum-Menu-itemLabel`)) {
					$$invalidate(8, triggerNode = getNodeHTML(e.target.parentNode.childNodes));
				} else if (testHasClassName(e.target.parentNode.classList, `spectrum-Menu-item`)) {
					$$invalidate(8, triggerNode = getNodeHTML(e.target.parentNode.childNodes));
				}
			}
		}
	}

	function listenForOtherClicks(e) {
		if (!autoFold) {
			return;
		}

		if (dropmenuEl && !dropmenuEl.contains(e.target)) {
			$$invalidate(0, isOpen = false);
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			dropmenuEl = $$value;
			$$invalidate(7, dropmenuEl);
		});
	}

	$$self.$$set = $$props => {
		if ("placeholder" in $$props) $$invalidate(1, placeholder = $$props.placeholder);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("resultIndex" in $$props) $$invalidate(10, resultIndex = $$props.resultIndex);
		if ("thisIndex" in $$props) $$invalidate(11, thisIndex = $$props.thisIndex);
		if ("isInvalid" in $$props) $$invalidate(3, isInvalid = $$props.isInvalid);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("minWidth" in $$props) $$invalidate(5, minWidth = $$props.minWidth);
		if ("autoFold" in $$props) $$invalidate(12, autoFold = $$props.autoFold);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	return [
		isOpen,
		placeholder,
		disabled,
		isInvalid,
		isQuiet,
		minWidth,
		isActive,
		dropmenuEl,
		triggerNode,
		dropdownStatusCutover,
		resultIndex,
		thisIndex,
		autoFold,
		$$slots,
		div1_binding,
		$$scope
	];
}

class Dropdown extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1bhv1ic-style")) add_css$i();

		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
			placeholder: 1,
			disabled: 2,
			isOpen: 0,
			resultIndex: 10,
			thisIndex: 11,
			isInvalid: 3,
			isQuiet: 4,
			minWidth: 5,
			autoFold: 12
		});
	}
}

/* src/packages/IllustratedMessage/IllustratedError.svelte generated by Svelte v3.24.1 */

function create_fragment$1c(ctx) {
	let svg;
	let g;
	let path0;
	let circle0;
	let circle1;
	let circle2;
	let path1;
	let circle3;
	let svg_class_value;

	let svg_levels = [
		{ width: "146.569" },
		{ height: "94" },
		/*$$restProps*/ ctx[0],
		{
			class: svg_class_value = /*$$restProps*/ ctx[0].class
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			path1 = svg_element("path");
			circle3 = svg_element("circle");
			attr(path0, "d", "M415.8 2988v-18a2.006 2.006 0 012-2h118a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-110M428.8 3000h107a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-92M443.8 3032h92a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-118a2.006 2.006 0 01-2-2v-20M526.8 3028v3M526.8 2996v3");
			attr(path0, "fill", "none");
			attr(path0, "strokelinecap", "round");
			attr(path0, "strokelinejoin", "round");
			attr(path0, "strokemiterlimit", "10");
			attr(path0, "strokewidth", "3");
			attr(circle0, "cx", "4");
			attr(circle0, "cy", "4");
			attr(circle0, "r", "4");
			attr(circle0, "transform", "translate(522.8 2977.5)");
			attr(circle0, "strokewidth", "2");
			attr(circle0, "strokelinecap", "round");
			attr(circle0, "strokelinejoin", "round");
			attr(circle0, "strokemiterlimit", "10");
			attr(circle0, "fill", "none");
			attr(circle1, "cx", "4");
			attr(circle1, "cy", "4");
			attr(circle1, "r", "4");
			attr(circle1, "transform", "translate(522.8 3010)");
			attr(circle1, "strokewidth", "2");
			attr(circle1, "strokelinecap", "round");
			attr(circle1, "strokelinejoin", "round");
			attr(circle1, "strokemiterlimit", "10");
			attr(circle1, "fill", "none");
			attr(circle2, "cx", "4");
			attr(circle2, "cy", "4");
			attr(circle2, "r", "4");
			attr(circle2, "transform", "translate(522.8 3041.5)");
			attr(circle2, "strokewidth", "2");
			attr(circle2, "strokelinecap", "round");
			attr(circle2, "strokelinejoin", "round");
			attr(circle2, "strokemiterlimit", "10");
			attr(circle2, "fill", "none");
			attr(path1, "d", "M413.1 2995.5l-18.4 31.1a2.916 2.916 0 002.6 4.4h36.9a2.933 2.933 0 002.6-4.4l-18.4-31.1a3.091 3.091 0 00-5.3 0zM415.8 3016.2v-6.9");
			attr(path1, "fill", "none");
			attr(path1, "strokelinecap", "round");
			attr(path1, "strokelinejoin", "round");
			attr(path1, "strokemiterlimit", "10");
			attr(path1, "strokewidth", "3");
			attr(circle3, "cx", "1.9");
			attr(circle3, "cy", "1.9");
			attr(circle3, "r", "1.9");
			attr(circle3, "transform", "translate(413.9 3020.3)");
			attr(circle3, "stroke", "none");
			attr(g, "transform", "translate(-392.731 -2966.5)");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, circle0);
			append(g, circle1);
			append(g, circle2);
			append(g, path1);
			append(g, circle3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ width: "146.569" },
				{ height: "94" },
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				dirty & /*$$restProps*/ 1 && svg_class_value !== (svg_class_value = /*$$restProps*/ ctx[0].class) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1c($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class IllustratedError extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});
	}
}

/* src/packages/IllustratedMessage/IllustratedNotFound.svelte generated by Svelte v3.24.1 */

function create_fragment$1d(ctx) {
	let svg;
	let g;
	let path0;
	let path1;
	let path2;
	let svg_class_value;

	let svg_levels = [
		{ width: "135.321" },
		{ height: "87" },
		/*$$restProps*/ ctx[0],
		{
			class: svg_class_value = /*$$restProps*/ ctx[0].class
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M11.821 60.5v23a2.006 2.006 0 002 2h118a2.006 2.006 0 002-2v-80a2.006 2.006 0 00-2-2h-118a2.006 2.006 0 00-2 2v27");
			attr(path0, "strokewidth", "3");
			attr(path1, "strokewidth", "2");
			attr(path1, "d", "M133.721 14h-122M29.721 8h-10");
			attr(path2, "strokewidth", "3");
			attr(path2, "d", "M2.121 55.1l19.3-19.2M21.421 55.1l-19.3-19.2");
			attr(g, "fill", "none");
			attr(g, "strokelinecap", "round");
			attr(g, "strokelinejoin", "round");
			attr(g, "strokemiterlimit", "10");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(g, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ width: "135.321" },
				{ height: "87" },
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				dirty & /*$$restProps*/ 1 && svg_class_value !== (svg_class_value = /*$$restProps*/ ctx[0].class) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1d($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class IllustratedNotFound extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});
	}
}

/* src/packages/IllustratedMessage/IllustratedTimeout.svelte generated by Svelte v3.24.1 */

function create_fragment$1e(ctx) {
	let svg;
	let g;
	let path0;
	let circle0;
	let circle1;
	let circle2;
	let path1;
	let path2;
	let svg_class_value;

	let svg_levels = [
		{ width: "137" },
		{ height: "94" },
		/*$$restProps*/ ctx[0],
		{
			class: svg_class_value = /*$$restProps*/ ctx[0].class
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M417.8 3803v-19a2.006 2.006 0 012-2h118a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-102M435.8 3814h102a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-102M435.8 3846h102a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-118a2.006 2.006 0 01-2-2v-17M527.8 3842v3M527.8 3810v3");
			attr(path0, "strokewidth", "3");
			attr(circle0, "cx", "4");
			attr(circle0, "cy", "4");
			attr(circle0, "r", "4");
			attr(circle0, "transform", "translate(523.8 3791.5)");
			attr(circle0, "strokewidth", "2");
			attr(circle1, "cx", "4");
			attr(circle1, "cy", "4");
			attr(circle1, "r", "4");
			attr(circle1, "transform", "translate(523.8 3824)");
			attr(circle1, "strokewidth", "2");
			attr(circle2, "cx", "4");
			attr(circle2, "cy", "4");
			attr(circle2, "r", "4");
			attr(circle2, "transform", "translate(523.8 3855.5)");
			attr(circle2, "strokewidth", "2");
			attr(path1, "d", "M429.8 3844.4v3.6h-24v-3.6c0-9.1 9-10.9 9-15.4v-.9c0-4.5-9-6.3-9-15.4v-3.6h24v3.6c0 9.1-9 10.9-9 15.4v.9c0 4.5 9 6.3 9 15.4z");
			attr(path1, "strokewidth", "3");
			attr(path2, "d", "M428.6 3846.8l-8.4-8.4a3.441 3.441 0 00-4.8 0l-8.4 8.4");
			attr(path2, "strokewidth", "2");
			attr(g, "transform", "translate(-404.3 -3780.5)");
			attr(g, "fill", "none");
			attr(g, "strokelinecap", "round");
			attr(g, "strokelinejoin", "round");
			attr(g, "strokemiterlimit", "10");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, circle0);
			append(g, circle1);
			append(g, circle2);
			append(g, path1);
			append(g, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ width: "137" },
				{ height: "94" },
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				dirty & /*$$restProps*/ 1 && svg_class_value !== (svg_class_value = /*$$restProps*/ ctx[0].class) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1e($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class IllustratedTimeout extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});
	}
}

/* src/packages/IllustratedMessage/IllustratedUnauthorized.svelte generated by Svelte v3.24.1 */

function create_fragment$1f(ctx) {
	let svg;
	let g;
	let path0;
	let path1;
	let path2;
	let svg_class_value;

	let svg_levels = [
		{ width: "125" },
		{ height: "87" },
		/*$$restProps*/ ctx[0],
		{
			class: svg_class_value = /*$$restProps*/ ctx[0].class
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M1.5 83.5a2.006 2.006 0 002 2h118a2.006 2.006 0 002-2v-80a2.006 2.006 0 00-2-2H3.5a2.006 2.006 0 00-2 2z");
			attr(path0, "strokewidth", "3");
			attr(path1, "strokewidth", "2");
			attr(path1, "d", "M123.4 14H1.4M19.4 8h-10");
			attr(path2, "d", "M46.5 69.5h30a2.006 2.006 0 002-2v-22a2.006 2.006 0 00-2-2h-30a2.006 2.006 0 00-2 2v22a2.006 2.006 0 002 2zM71.5 43.5v-7.2A10.238 10.238 0 0063 26.1 10.014 10.014 0 0051.5 36v6.5");
			attr(path2, "strokewidth", "3");
			attr(g, "fill", "none");
			attr(g, "strokelinecap", "round");
			attr(g, "strokelinejoin", "round");
			attr(g, "strokemiterlimit", "10");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(g, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ width: "125" },
				{ height: "87" },
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				dirty & /*$$restProps*/ 1 && svg_class_value !== (svg_class_value = /*$$restProps*/ ctx[0].class) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1f($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class IllustratedUnauthorized extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});
	}
}

/* src/packages/IllustratedMessage/IllustratedUnavailable.svelte generated by Svelte v3.24.1 */

function create_fragment$1g(ctx) {
	let svg;
	let g;
	let circle0;
	let path;
	let circle1;
	let circle2;
	let circle3;
	let svg_class_value;

	let svg_levels = [
		{ width: "143.1" },
		{ height: "94" },
		/*$$restProps*/ ctx[0],
		{
			class: svg_class_value = /*$$restProps*/ ctx[0].class
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			circle0 = svg_element("circle");
			path = svg_element("path");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			attr(circle0, "cx", "18.1");
			attr(circle0, "cy", "18.1");
			attr(circle0, "r", "18.1");
			attr(circle0, "transform", "translate(417.7 3396.9)");
			attr(circle0, "strokewidth", "3");
			attr(path, "strokewidth", "3");
			attr(path, "d", "M423.4 3402.2l24.5 24.4M435.8 3390v-19a2.006 2.006 0 012-2h118a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-104M457.8 3401h98a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-97M452.8 3433h103a2.006 2.006 0 012 2v23a2.006 2.006 0 01-2 2h-118a2.006 2.006 0 01-2-2v-18M546.8 3429v3M546.8 3397v3");
			attr(circle1, "cx", "4");
			attr(circle1, "cy", "4");
			attr(circle1, "r", "4");
			attr(circle1, "transform", "translate(542.8 3378.5)");
			attr(circle1, "strokewidth", "2");
			attr(circle2, "cx", "4");
			attr(circle2, "cy", "4");
			attr(circle2, "r", "4");
			attr(circle2, "transform", "translate(542.8 3411)");
			attr(circle2, "strokewidth", "2");
			attr(circle3, "cx", "4");
			attr(circle3, "cy", "4");
			attr(circle3, "r", "4");
			attr(circle3, "transform", "translate(542.8 3442.5)");
			attr(circle3, "strokewidth", "2");
			attr(g, "transform", "translate(-416.2 -3367.5)");
			attr(g, "strokelinecap", "round");
			attr(g, "strokelinejoin", "round");
			attr(g, "strokemiterlimit", "10");
			attr(g, "fill", "none");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, circle0);
			append(g, path);
			append(g, circle1);
			append(g, circle2);
			append(g, circle3);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ width: "143.1" },
				{ height: "94" },
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				dirty & /*$$restProps*/ 1 && svg_class_value !== (svg_class_value = /*$$restProps*/ ctx[0].class) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1g($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class IllustratedUnavailable extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});
	}
}

/* src/packages/IllustratedMessage/IllustratedUpload.svelte generated by Svelte v3.24.1 */

function create_fragment$1h(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let svg_class_value;

	let svg_levels = [
		{ width: "191.2" },
		{ height: "97.9" },
		/*$$restProps*/ ctx[0],
		{
			class: svg_class_value = /*$$restProps*/ ctx[0].class
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M51.5 33h-48A3.543 3.543 0 000 36.5v35A3.543 3.543 0 003.5 75h48a3.543 3.543 0 003.5-3.5v-35a3.543 3.543 0 00-3.5-3.5zm-48 3h48a.472.472 0 01.5.5v30.6L40.5 55.4a2.94 2.94 0 00-2.2-.9 3.1 3.1 0 00-2.2.9l-4.7 5-11.8-12a2.94 2.94 0 00-2.2-.9 3.1 3.1 0 00-2.2.9L3 60.8V36.5a.472.472 0 01.5-.5zM3 71.5v-7.8l13.7-13.8a1.08 1.08 0 01.7-.3.908.908 0 01.7.3L40.2 72H3.5a.472.472 0 01-.5-.5zm48.5.5h-8.6c0-.1-.1-.1-.1-.2l-9.9-10 4.7-5a.908.908 0 01.7-.3.779.779 0 01.7.3L52 70v1.5a.472.472 0 01-.5.5z");
			attr(path0, "stroke", "none");
			attr(path1, "d", "M41.8 51.3a5.664 5.664 0 004.1-1.7 5.835 5.835 0 001.7-4.1 5.957 5.957 0 00-5.8-5.9 5.85 5.85 0 000 11.7zm-2.7-8.5a3.864 3.864 0 012.7-1.1 3.8 3.8 0 013.8 3.8 3.756 3.756 0 01-3.8 3.8 3.8 3.8 0 01-3.8-3.8 3.864 3.864 0 011.1-2.7zM187.3 35h-27.2l-7.5-6.8a4.713 4.713 0 00-3-1.2h-15.3a3.159 3.159 0 00-3.2 3.2v40.1a3.691 3.691 0 003.7 3.7h52.7a3.691 3.691 0 003.7-3.7V38.7a3.933 3.933 0 00-3.9-3.7zm-53.1-5h15.3a1.284 1.284 0 011 .4l5.1 4.6H134v-4.8a.215.215 0 01.2-.2zM188 70.3a.684.684 0 01-.7.7h-52.7a.684.684 0 01-.7-.7V38h53.3a.684.684 0 01.7.7v31.6zM100.4 86L93 93.4V55.7a1.5 1.5 0 00-3 0v37.7L82.6 86a1.449 1.449 0 00-2.1 0 1.541 1.541 0 000 2.1l8.9 8.9a2.878 2.878 0 002.1.9 2.723 2.723 0 002.1-.9l8.9-8.9a1.485 1.485 0 00-2.1-2.1z");
			attr(path1, "stroke", "none");
			attr(path2, "d", "M119.5 26a1.538 1.538 0 00-1.5 1.5v43.7a.86.86 0 01-.8.8H97.5a1.5 1.5 0 000 3h19.7a3.8 3.8 0 003.8-3.8V27.5a1.538 1.538 0 00-1.5-1.5zM121 21.4a.749.749 0 00-.1-.5c-.1-.2-.2-.3-.3-.5l-21-20a2.186 2.186 0 00-.5-.3 1.486 1.486 0 00-.6-.1H67.8A3.8 3.8 0 0064 3.8v67.4a3.8 3.8 0 003.8 3.8h17.7a1.5 1.5 0 000-3H67.8a.86.86 0 01-.8-.8V3.8a.86.86 0 01.8-.8H97v16.2a3.8 3.8 0 003.8 3.8h19c.1 0 .2 0 .2-.1h.1c.1 0 .2-.1.3-.1l.1-.1c.1 0 .1-.1.2-.1a2.186 2.186 0 00.3-.5v-.7zm-21-2.2V5l15.7 15h-15a.858.858 0 01-.7-.8z");
			attr(path2, "stroke", "none");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ width: "191.2" },
				{ height: "97.9" },
				dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0],
				dirty & /*$$restProps*/ 1 && svg_class_value !== (svg_class_value = /*$$restProps*/ ctx[0].class) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$1h($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class IllustratedUpload extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});
	}
}

/* src/packages/IllustratedMessage/IllustratedMessage.svelte generated by Svelte v3.24.1 */

function create_if_block_5$2(ctx) {
	let illustratedupload;
	let current;

	illustratedupload = new IllustratedUpload({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	return {
		c() {
			create_component(illustratedupload.$$.fragment);
		},
		m(target, anchor) {
			mount_component(illustratedupload, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(illustratedupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(illustratedupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(illustratedupload, detaching);
		}
	};
}

// (36:39) 
function create_if_block_4$4(ctx) {
	let illustratedunavailable;
	let current;

	illustratedunavailable = new IllustratedUnavailable({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	return {
		c() {
			create_component(illustratedunavailable.$$.fragment);
		},
		m(target, anchor) {
			mount_component(illustratedunavailable, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(illustratedunavailable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(illustratedunavailable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(illustratedunavailable, detaching);
		}
	};
}

// (34:40) 
function create_if_block_3$7(ctx) {
	let illustratedunauthorized;
	let current;

	illustratedunauthorized = new IllustratedUnauthorized({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	return {
		c() {
			create_component(illustratedunauthorized.$$.fragment);
		},
		m(target, anchor) {
			mount_component(illustratedunauthorized, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(illustratedunauthorized.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(illustratedunauthorized.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(illustratedunauthorized, detaching);
		}
	};
}

// (32:35) 
function create_if_block_2$9(ctx) {
	let illustratedtimeout;
	let current;

	illustratedtimeout = new IllustratedTimeout({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	return {
		c() {
			create_component(illustratedtimeout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(illustratedtimeout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(illustratedtimeout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(illustratedtimeout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(illustratedtimeout, detaching);
		}
	};
}

// (30:36) 
function create_if_block_1$F(ctx) {
	let illustratednotfound;
	let current;

	illustratednotfound = new IllustratedNotFound({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	return {
		c() {
			create_component(illustratednotfound.$$.fragment);
		},
		m(target, anchor) {
			mount_component(illustratednotfound, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(illustratednotfound.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(illustratednotfound.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(illustratednotfound, detaching);
		}
	};
}

// (28:2) {#if variants === 'error'}
function create_if_block$G(ctx) {
	let illustratederror;
	let current;

	illustratederror = new IllustratedError({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	return {
		c() {
			create_component(illustratederror.$$.fragment);
		},
		m(target, anchor) {
			mount_component(illustratederror, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(illustratederror.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(illustratederror.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(illustratederror, detaching);
		}
	};
}

function create_fragment$1i(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t0;
	let h2;
	let t1;
	let t2;
	let p;
	let current;

	const if_block_creators = [
		create_if_block$G,
		create_if_block_1$F,
		create_if_block_2$9,
		create_if_block_3$7,
		create_if_block_4$4,
		create_if_block_5$2
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[0] === "error") return 0;
		if (/*variants*/ ctx[0] === "notFound") return 1;
		if (/*variants*/ ctx[0] === "timeout") return 2;
		if (/*variants*/ ctx[0] === "unauthorized") return 3;
		if (/*variants*/ ctx[0] === "unavailable") return 4;
		if (/*variants*/ ctx[0] === "upload") return 5;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			h2 = element("h2");
			t1 = text(/*title*/ ctx[1]);
			t2 = space();
			p = element("p");
			if (default_slot) default_slot.c();
			attr(h2, "class", "spectrum-Heading--pageTitle spectrum-IllustratedMessage-heading");
			attr(p, "class", "spectrum-Body--secondary spectrum-IllustratedMessage-description");
			attr(div, "class", "spectrum-IllustratedMessage");
			toggle_class(div, "spectrum-IllustratedMessage--cta", /*isCta*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			append(div, t0);
			append(div, h2);
			append(h2, t1);
			append(div, t2);
			append(div, p);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div, t0);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty & /*title*/ 2) set_data(t1, /*title*/ ctx[1]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (dirty & /*isCta*/ 4) {
				toggle_class(div, "spectrum-IllustratedMessage--cta", /*isCta*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1i($$self, $$props, $$invalidate) {
	let { variants = "error" } = $$props;
	let { title = "" } = $$props;
	let { isCta = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("variants" in $$props) $$invalidate(0, variants = $$props.variants);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("isCta" in $$props) $$invalidate(2, isCta = $$props.isCta);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [variants, title, isCta, $$scope, $$slots];
}

class IllustratedMessage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, { variants: 0, title: 1, isCta: 2 });
	}
}

/* src/packages/Dropzone/Dropzone.svelte generated by Svelte v3.24.1 */

function create_fragment$1j(ctx) {
	let div1;
	let div0;
	let illustratedupload;
	let t0;
	let h2;
	let t1;
	let t2;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;

	illustratedupload = new IllustratedUpload({
			props: {
				class: "spectrum-IllustratedMessage-illustration"
			}
		});

	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(illustratedupload.$$.fragment);
			t0 = space();
			h2 = element("h2");
			t1 = text(/*title*/ ctx[1]);
			t2 = space();
			if (default_slot) default_slot.c();
			attr(h2, "class", "spectrum-Heading--pageTitle spectrum-IllustratedMessage-heading");
			attr(div0, "class", "spectrum-IllustratedMessage spectrum-IllustratedMessage--cta");
			attr(div1, "class", "spectrum-Dropzone");
			attr(div1, "role", "region");
			attr(div1, "tabindex", "0");
			attr(div1, "style", /*styleCssText*/ ctx[2]);
			toggle_class(div1, "is-dragged", /*isDragged*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(illustratedupload, div0, null);
			append(div0, t0);
			append(div0, h2);
			append(h2, t1);
			append(div0, t2);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[3].call(null, div1));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 2) set_data(t1, /*title*/ ctx[1]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*styleCssText*/ 4) {
				attr(div1, "style", /*styleCssText*/ ctx[2]);
			}

			if (dirty & /*isDragged*/ 1) {
				toggle_class(div1, "is-dragged", /*isDragged*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(illustratedupload.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(illustratedupload.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(illustratedupload);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1j($$self, $$props, $$invalidate) {
	let { isDragged = false } = $$props;
	let { title = "" } = $$props;
	let { width = 600 } = $$props;
	let { height = 250 } = $$props;
	const eventsListen = getEventsAction(current_component);
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("isDragged" in $$props) $$invalidate(0, isDragged = $$props.isDragged);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("width" in $$props) $$invalidate(4, width = $$props.width);
		if ("height" in $$props) $$invalidate(5, height = $$props.height);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*width, height*/ 48) {
			 $$invalidate(2, styleCssText = [
				(width + "").indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: `width:${width}px;`,
				(height + "").indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: `height:${height}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [isDragged, title, styleCssText, eventsListen, width, height, $$scope, $$slots];
}

class Dropzone extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {
			isDragged: 0,
			title: 1,
			width: 4,
			height: 5
		});
	}
}

/* src/packages/FieldGroup/FieldGroup.svelte generated by Svelte v3.24.1 */

function create_fragment$1k(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-FieldGroup");
			toggle_class(div, "spectrum-FieldGroup--vertical", /*orientation*/ ctx[0] === "vertical");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[5](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (dirty & /*orientation*/ 1) {
				toggle_class(div, "spectrum-FieldGroup--vertical", /*orientation*/ ctx[0] === "vertical");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[5](null);
		}
	};
}

function addChildClassName(el) {
	if (!el) {
		return false;
	}

	for (let index = 0; index < el.length; index++) {
		if (testHasClassName$1(el[index].classList, `spectrum-Radio`)) {
			el[index].classList += " spectrum-Radio--labelBelow";
		}

		if (testHasClassName$1(el[index].classList, `spectrum-Checkbox`)) {
			el[index].classList += " spectrum-Checkbox--labelBelow";
		}
	}
}

function testHasClassName$1(el, verifyString) {
	if (!el) {
		return false;
	}

	for (let index = 0; index < el.length; index++) {
		return el[index] === verifyString;
	}
}

function instance$1k($$self, $$props, $$invalidate) {
	let { orientation = "horizontal" } = $$props;
	let { labelBelow = false } = $$props;
	let fieldGroupEl;

	onMount(() => {
		if (labelBelow && fieldGroupEl && fieldGroupEl.childElementCount && fieldGroupEl.childNodes) {
			addChildClassName(fieldGroupEl.childNodes);
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			fieldGroupEl = $$value;
			$$invalidate(1, fieldGroupEl);
		});
	}

	$$self.$$set = $$props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$props.orientation);
		if ("labelBelow" in $$props) $$invalidate(2, labelBelow = $$props.labelBelow);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [orientation, fieldGroupEl, labelBelow, $$scope, $$slots, div_binding];
}

class FieldGroup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { orientation: 0, labelBelow: 2 });
	}
}

/* src/packages/FieldLabel/FieldLabel.svelte generated by Svelte v3.24.1 */

function fallback_block$5(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data(t, /*label*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (66:2) {#if required}
function create_if_block$H(ctx) {
	let iconasterisk;
	let current;

	iconasterisk = new Asterisk({
			props: {
				className: "spectrum-FieldLabel-requiredIcon"
			}
		});

	return {
		c() {
			create_component(iconasterisk.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconasterisk, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconasterisk.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconasterisk.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconasterisk, detaching);
		}
	};
}

function create_fragment$1l(ctx) {
	let label_1;
	let t;
	let label_1_for_value;
	let label_1_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	const default_slot_or_fallback = default_slot || fallback_block$5(ctx);
	let if_block = /*required*/ ctx[1] && create_if_block$H();

	return {
		c() {
			label_1 = element("label");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			if (if_block) if_block.c();
			attr(label_1, "for", label_1_for_value = /*forTargetId*/ ctx[3] || /*relatedID*/ ctx[5]);
			attr(label_1, "class", label_1_class_value = "spectrum-FieldLabel " + (/*alignSide*/ ctx[0] !== "above" && `spectrum-FieldLabel--${/*alignSide*/ ctx[0]}`) + " " + /*$$restProps*/ ctx[7].class);
			attr(label_1, "style", /*styleCssText*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(label_1, null);
			}

			append(label_1, t);
			if (if_block) if_block.m(label_1, null);
			/*label_1_binding*/ ctx[12](label_1);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (/*required*/ ctx[1]) {
				if (if_block) {
					if (dirty & /*required*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$H();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(label_1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*forTargetId, relatedID*/ 40 && label_1_for_value !== (label_1_for_value = /*forTargetId*/ ctx[3] || /*relatedID*/ ctx[5])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (!current || dirty & /*alignSide, $$restProps*/ 129 && label_1_class_value !== (label_1_class_value = "spectrum-FieldLabel " + (/*alignSide*/ ctx[0] !== "above" && `spectrum-FieldLabel--${/*alignSide*/ ctx[0]}`) + " " + /*$$restProps*/ ctx[7].class)) {
				attr(label_1, "class", label_1_class_value);
			}

			if (!current || dirty & /*styleCssText*/ 64) {
				attr(label_1, "style", /*styleCssText*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (if_block) if_block.d();
			/*label_1_binding*/ ctx[12](null);
		}
	};
}

function instance$1l($$self, $$props, $$invalidate) {
	const omit_props_names = ["alignSide","required","label","forTargetId","width","height"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { alignSide = "above" } = $$props;
	let { required = false } = $$props;
	let { label = "Label Text" } = $$props;
	let { forTargetId = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let fieldLabelEl;
	let relatedID = "";

	onMount(() => {
		let nextNode = fieldLabelEl.nextElementSibling;

		if (nextNode) {
			let relatedEl = nextNode.querySelectorAll("input");

			if (relatedEl.length && relatedEl[0].id) {
				$$invalidate(5, relatedID = relatedEl[0].id);
			}
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function label_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			fieldLabelEl = $$value;
			$$invalidate(4, fieldLabelEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("alignSide" in $$new_props) $$invalidate(0, alignSide = $$new_props.alignSide);
		if ("required" in $$new_props) $$invalidate(1, required = $$new_props.required);
		if ("label" in $$new_props) $$invalidate(2, label = $$new_props.label);
		if ("forTargetId" in $$new_props) $$invalidate(3, forTargetId = $$new_props.forTargetId);
		if ("width" in $$new_props) $$invalidate(8, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(9, height = $$new_props.height);
		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*width, height*/ 768) {
			 $$invalidate(6, styleCssText = [
				(width + "").indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: `width:${width}px;`,
				(height + "").indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: `height:${height}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		alignSide,
		required,
		label,
		forTargetId,
		fieldLabelEl,
		relatedID,
		styleCssText,
		$$restProps,
		width,
		height,
		$$scope,
		$$slots,
		label_1_binding
	];
}

class FieldLabel extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
			alignSide: 0,
			required: 1,
			label: 2,
			forTargetId: 3,
			width: 8,
			height: 9
		});
	}
}

/* src/packages/Form/Form.svelte generated by Svelte v3.24.1 */

function create_fragment$1m(ctx) {
	let form;
	let form_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let form_levels = [
		{
			class: form_class_value = "spectrum-Form " + (/*alignSide*/ ctx[0] === "above" && "spectrum-Form--labelsAbove")
		},
		/*$$restProps*/ ctx[3]
	];

	let form_data = {};

	for (let i = 0; i < form_levels.length; i += 1) {
		form_data = assign(form_data, form_levels[i]);
	}

	return {
		c() {
			form = element("form");
			if (default_slot) default_slot.c();
			set_attributes(form, form_data);
		},
		m(target, anchor) {
			insert(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			/*form_binding*/ ctx[6](form);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[2].call(null, form));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(form, form_data = get_spread_update(form_levels, [
				(!current || dirty & /*alignSide*/ 1 && form_class_value !== (form_class_value = "spectrum-Form " + (/*alignSide*/ ctx[0] === "above" && "spectrum-Form--labelsAbove"))) && { class: form_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			if (default_slot) default_slot.d(detaching);
			/*form_binding*/ ctx[6](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$1m($$self, $$props, $$invalidate) {
	const omit_props_names = ["alignSide"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { alignSide = "above" } = $$props;
	let formEl;
	const eventsListen = getEventsAction(current_component);

	onMount(() => {
		formEl && addClassName();
	});

	function addClassName() {
		let fieldLabelList = formEl.getElementsByClassName("spectrum-FieldLabel");

		if (fieldLabelList.length) {
			for (let index = 0; index < fieldLabelList.length; index++) {
				fieldLabelList[index].classList.toggle(`spectrum-Form-itemLabel`);
				alignSide !== "above" && fieldLabelList[index].classList.toggle(`spectrum-FieldLabel--${alignSide}`);
			}
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function form_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			formEl = $$value;
			$$invalidate(1, formEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("alignSide" in $$new_props) $$invalidate(0, alignSide = $$new_props.alignSide);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	return [alignSide, formEl, eventsListen, $$restProps, $$scope, $$slots, form_binding];
}

class Form extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { alignSide: 0 });
	}
}

/* src/packages/Form/FormItem.svelte generated by Svelte v3.24.1 */
const get_from_item_field_slot_changes = dirty => ({});
const get_from_item_field_slot_context = ctx => ({});

function create_fragment$1n(ctx) {
	let div;
	let t;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
	const from_item_field_slot_template = /*$$slots*/ ctx[2]["from-item-field"];
	const from_item_field_slot = create_slot(from_item_field_slot_template, ctx, /*$$scope*/ ctx[1], get_from_item_field_slot_context);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (from_item_field_slot) from_item_field_slot.c();
			attr(div, "class", "spectrum-Form-item");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(div, t);

			if (from_item_field_slot) {
				from_item_field_slot.m(div, null);
			}

			/*div_binding*/ ctx[3](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (from_item_field_slot) {
				if (from_item_field_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(from_item_field_slot, from_item_field_slot_template, ctx, /*$$scope*/ ctx[1], dirty, get_from_item_field_slot_changes, get_from_item_field_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(from_item_field_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(from_item_field_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (from_item_field_slot) from_item_field_slot.d(detaching);
			/*div_binding*/ ctx[3](null);
		}
	};
}

function instance$1n($$self, $$props, $$invalidate) {
	let itemFieldEl;

	onMount(() => {
		itemFieldEl && advanceAddClassName(itemFieldEl, "from-item-field", "spectrum-Form-itemField");
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			itemFieldEl = $$value;
			$$invalidate(0, itemFieldEl);
		});
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [itemFieldEl, $$scope, $$slots, div_binding];
}

class FormItem extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {});
	}
}

/* src/packages/Layout/Flex.svelte generated by Svelte v3.24.1 */

function create_fragment$1o(ctx) {
	let div;
	let div_style_value;
	let div_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "style", div_style_value = /*layoutCssText*/ ctx[1] + /*spacingCssText*/ ctx[2] + /*sizingCssText*/ ctx[3] + /*positioningCssText*/ ctx[4] + /*componentStyle*/ ctx[5]);
			attr(div, "class", div_class_value = /*$$restProps*/ ctx[6].class);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*layoutCssText, spacingCssText, sizingCssText, positioningCssText, componentStyle*/ 62 && div_style_value !== (div_style_value = /*layoutCssText*/ ctx[1] + /*spacingCssText*/ ctx[2] + /*sizingCssText*/ ctx[3] + /*positioningCssText*/ ctx[4] + /*componentStyle*/ ctx[5])) {
				attr(div, "style", div_style_value);
			}

			if (!current || dirty & /*$$restProps*/ 64 && div_class_value !== (div_class_value = /*$$restProps*/ ctx[6].class)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1o($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"id","display","direction","wrap","justifyContent","alignContent","alignItems","gap","columnGap","rowGap","layout","spacing","sizing","positioning"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { id = "" } = $$props;
	let { display = "flex" } = $$props;
	let { direction = "row" } = $$props;
	let { wrap = "" } = $$props;
	let { justifyContent = "" } = $$props;
	let { alignContent = "" } = $$props;
	let { alignItems = "" } = $$props;
	let { gap = "" } = $$props;
	let { columnGap = "" } = $$props;
	let { rowGap = "" } = $$props;
	let { layout = {} } = $$props;
	let { spacing = {} } = $$props;
	let { sizing = {} } = $$props;
	let { positioning = {} } = $$props;
	let layoutCssText = "";
	let spacingCssText = "";
	let sizingCssText = "";
	let positioningCssText = "";

	afterUpdate(() => {
		$$invalidate(1, layoutCssText = integrateProps(layout));
		$$invalidate(2, spacingCssText = integrateDimensionProps(spacing));
		$$invalidate(3, sizingCssText = integrateAutoProps(sizing));
		$$invalidate(4, positioningCssText = integrateAutoProps(positioning));
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("display" in $$new_props) $$invalidate(7, display = $$new_props.display);
		if ("direction" in $$new_props) $$invalidate(8, direction = $$new_props.direction);
		if ("wrap" in $$new_props) $$invalidate(9, wrap = $$new_props.wrap);
		if ("justifyContent" in $$new_props) $$invalidate(10, justifyContent = $$new_props.justifyContent);
		if ("alignContent" in $$new_props) $$invalidate(11, alignContent = $$new_props.alignContent);
		if ("alignItems" in $$new_props) $$invalidate(12, alignItems = $$new_props.alignItems);
		if ("gap" in $$new_props) $$invalidate(13, gap = $$new_props.gap);
		if ("columnGap" in $$new_props) $$invalidate(14, columnGap = $$new_props.columnGap);
		if ("rowGap" in $$new_props) $$invalidate(15, rowGap = $$new_props.rowGap);
		if ("layout" in $$new_props) $$invalidate(16, layout = $$new_props.layout);
		if ("spacing" in $$new_props) $$invalidate(17, spacing = $$new_props.spacing);
		if ("sizing" in $$new_props) $$invalidate(18, sizing = $$new_props.sizing);
		if ("positioning" in $$new_props) $$invalidate(19, positioning = $$new_props.positioning);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	let componentStyle;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*display, direction, wrap, justifyContent, alignContent, alignItems, gap, columnGap, rowGap*/ 65408) {
			 $$invalidate(5, componentStyle = [
				`display:${display};`,
				direction && `flex-direction:${direction};`,
				wrap && `flex-wrap:${wrap};`,
				justifyContent && `justify-content:${justifyContent};`,
				alignContent && `align-content:${alignContent}`,
				alignItems && `align-items:${alignItems}`,
				gap && `gap:var(--spectrum-global-dimension-${gap}, var(--spectrum-alias-${gap}));"`,
				columnGap && `column-gap:var(--spectrum-global-dimension-${columnGap}, var(--spectrum-alias-${columnGap}));"`,
				rowGap && `row-gap:var(--spectrum-global-dimension-${rowGap}, var(--spectrum-alias-${rowGap}));"`
			].filter(Boolean).join(""));
		}
	};

	return [
		id,
		layoutCssText,
		spacingCssText,
		sizingCssText,
		positioningCssText,
		componentStyle,
		$$restProps,
		display,
		direction,
		wrap,
		justifyContent,
		alignContent,
		alignItems,
		gap,
		columnGap,
		rowGap,
		layout,
		spacing,
		sizing,
		positioning,
		$$scope,
		$$slots
	];
}

class Flex extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {
			id: 0,
			display: 7,
			direction: 8,
			wrap: 9,
			justifyContent: 10,
			alignContent: 11,
			alignItems: 12,
			gap: 13,
			columnGap: 14,
			rowGap: 15,
			layout: 16,
			spacing: 17,
			sizing: 18,
			positioning: 19
		});
	}
}

/* src/packages/Layout/View.svelte generated by Svelte v3.24.1 */

function create_fragment$1p(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "style", /*styleCss*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*styleCss*/ 1) {
				attr(div, "style", /*styleCss*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$1p($$self, $$props, $$invalidate) {
	let { style = {} } = $$props;
	let styleCss = "";

	afterUpdate(() => {
		$$invalidate(0, styleCss = integrateAutoProps(style));
	});

	$$self.$$set = $$props => {
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
	};

	return [styleCss, style];
}

class View extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, { style: 1 });
	}
}

/* src/packages/Label/Label.svelte generated by Svelte v3.24.1 */

function fallback_block$6(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data(t, /*label*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1q(ctx) {
	let span;
	let span_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);

	return {
		c() {
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(span, "class", span_class_value = "spectrum-Label spectrum-Label--" + /*variants*/ ctx[1] + " spectrum-Label--" + /*scale*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*variants, scale*/ 3 && span_class_value !== (span_class_value = "spectrum-Label spectrum-Label--" + /*variants*/ ctx[1] + " spectrum-Label--" + /*scale*/ ctx[0])) {
				attr(span, "class", span_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

function instance$1q($$self, $$props, $$invalidate) {
	let { scale = "medium" } = $$props;
	let { variants = "active" } = $$props;
	let { label = "" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [scale, variants, label, $$scope, $$slots];
}

class Label extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, { scale: 0, variants: 1, label: 2 });
	}
}

/* src/packages/Link/Link.svelte generated by Svelte v3.24.1 */

function add_css$j() {
	var style = element("style");
	style.id = "svelte-dj2iyd-style";
	style.textContent = ".spectrum-Link--disabled{pointer-events:none;color:var(--spectrum-alias-text-color-disabled)}.spectrum-Link--overBackground.spectrum-Link--disabled{color:rgba(255, 255, 255, 0.6)}";
	append(document.head, style);
}

function create_fragment$1r(ctx) {
	let a;
	let a_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let a_levels = [
		{ href: /*href*/ ctx[0] },
		{ target: /*target*/ ctx[1] },
		/*linkProps*/ ctx[5],
		{
			class: a_class_value = "spectrum-Link spectrum-Link--" + /*variants*/ ctx[2]
		}
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			toggle_class(a, "spectrum-Link--quiet", /*isQuiet*/ ctx[3]);
			toggle_class(a, "spectrum-Link--disabled", /*disabled*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[6].call(null, a));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
				(!current || dirty & /*target*/ 2) && { target: /*target*/ ctx[1] },
				dirty & /*linkProps*/ 32 && /*linkProps*/ ctx[5],
				(!current || dirty & /*variants*/ 4 && a_class_value !== (a_class_value = "spectrum-Link spectrum-Link--" + /*variants*/ ctx[2])) && { class: a_class_value }
			]));

			toggle_class(a, "spectrum-Link--quiet", /*isQuiet*/ ctx[3]);
			toggle_class(a, "spectrum-Link--disabled", /*disabled*/ ctx[4]);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1r($$self, $$props, $$invalidate) {
	const omit_props_names = ["href","target","variants","rel","id","isQuiet","disabled"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { href = "#" } = $$props;
	let { target = "" } = $$props;
	let { variants = "primary" } = $$props;
	let { rel = "" } = $$props;
	let { id = "" } = $$props;
	let { isQuiet = false } = $$props;
	let { disabled = false } = $$props;
	const eventsListen = getEventsAction(current_component);
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(1, target = $$new_props.target);
		if ("variants" in $$new_props) $$invalidate(2, variants = $$new_props.variants);
		if ("rel" in $$new_props) $$invalidate(7, rel = $$new_props.rel);
		if ("id" in $$new_props) $$invalidate(8, id = $$new_props.id);
		if ("isQuiet" in $$new_props) $$invalidate(3, isQuiet = $$new_props.isQuiet);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	let linkProps;

	$$self.$$.update = () => {
		 $$invalidate(5, linkProps = { id, rel, disabled, ...$$restProps });
	};

	return [
		href,
		target,
		variants,
		isQuiet,
		disabled,
		linkProps,
		eventsListen,
		rel,
		id,
		$$scope,
		$$slots
	];
}

class Link extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-dj2iyd-style")) add_css$j();

		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {
			href: 0,
			target: 1,
			variants: 2,
			rel: 7,
			id: 8,
			isQuiet: 3,
			disabled: 4
		});
	}
}

/* src/packages/Meter/Meter.svelte generated by Svelte v3.24.1 */

function fallback_block$7(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data(t, /*label*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1s(ctx) {
	let div4;
	let div0;
	let t0;
	let div1;
	let t1;
	let t2;
	let t3;
	let div3;
	let div2;
	let div2_style_value;
	let div4_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$7(ctx);

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t0 = space();
			div1 = element("div");
			t1 = text(/*finalValue*/ ctx[4]);
			t2 = text("%");
			t3 = space();
			div3 = element("div");
			div2 = element("div");
			attr(div0, "class", "spectrum-ProgressBar-label");
			attr(div1, "class", "spectrum-ProgressBar-percentage");
			attr(div2, "class", "spectrum-ProgressBar-fill");
			attr(div2, "style", div2_style_value = `width: ${/*finalValue*/ ctx[4]}%;`);
			attr(div3, "class", "spectrum-ProgressBar-track");
			attr(div4, "class", div4_class_value = "spectrum-ProgressBar is-" + /*variants*/ ctx[3]);
			attr(div4, "finalvalue", /*finalValue*/ ctx[4]);
			attr(div4, "role", "progressbar");
			attr(div4, "aria-valuenow", /*finalValue*/ ctx[4]);
			attr(div4, "aria-valuemin", /*minValue*/ ctx[0]);
			attr(div4, "aria-valuemax", /*maxValue*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div0, null);
			}

			append(div4, t0);
			append(div4, div1);
			append(div1, t1);
			append(div1, t2);
			append(div4, t3);
			append(div4, div3);
			append(div3, div2);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*finalValue*/ 16) set_data(t1, /*finalValue*/ ctx[4]);

			if (!current || dirty & /*finalValue*/ 16 && div2_style_value !== (div2_style_value = `width: ${/*finalValue*/ ctx[4]}%;`)) {
				attr(div2, "style", div2_style_value);
			}

			if (!current || dirty & /*variants*/ 8 && div4_class_value !== (div4_class_value = "spectrum-ProgressBar is-" + /*variants*/ ctx[3])) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty & /*finalValue*/ 16) {
				attr(div4, "finalvalue", /*finalValue*/ ctx[4]);
			}

			if (!current || dirty & /*finalValue*/ 16) {
				attr(div4, "aria-valuenow", /*finalValue*/ ctx[4]);
			}

			if (!current || dirty & /*minValue*/ 1) {
				attr(div4, "aria-valuemin", /*minValue*/ ctx[0]);
			}

			if (!current || dirty & /*maxValue*/ 2) {
				attr(div4, "aria-valuemax", /*maxValue*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

function regulateValue(v) {
	if (+v < 0) {
		return 0;
	}

	if (+v > 100) {
		return 100;
	}

	return isNaN(parseInt(v)) ? 0 : parseInt(v);
}

function instance$1s($$self, $$props, $$invalidate) {
	let { value = 50 } = $$props;
	let { minValue = 0 } = $$props;
	let { maxValue = 100 } = $$props;
	let { label = "Storage Space" } = $$props;
	let { variants = "" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(5, value = $$props.value);
		if ("minValue" in $$props) $$invalidate(0, minValue = $$props.minValue);
		if ("maxValue" in $$props) $$invalidate(1, maxValue = $$props.maxValue);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("variants" in $$props) $$invalidate(3, variants = $$props.variants);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let finalValue;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 32) {
			 $$invalidate(4, finalValue = regulateValue(value));
		}
	};

	return [minValue, maxValue, label, variants, finalValue, value, $$scope, $$slots];
}

class Meter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {
			value: 5,
			minValue: 0,
			maxValue: 1,
			label: 2,
			variants: 3
		});
	}
}

/* src/packages/MillerColumns/MillerColumns.svelte generated by Svelte v3.24.1 */

function create_fragment$1t(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-MillerColumns");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1t($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, $$slots];
}

class MillerColumns extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {});
	}
}

/* src/packages/MillerColumns/MillerColumnsItem.svelte generated by Svelte v3.24.1 */

function create_fragment$1u(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-MillerColumns-item");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1u($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, $$slots];
}

class MillerColumnsItem extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {});
	}
}

/* src/packages/Modal/Modal.svelte generated by Svelte v3.24.1 */

function create_fragment$1v(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let div0_style_value;
	let div1_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = "spectrum-Modal " + /*$$restProps*/ ctx[2].innerClass);
			attr(div0, "style", div0_style_value = /*$$restProps*/ ctx[2].innerStyle);
			toggle_class(div0, "is-open", /*isOpen*/ ctx[0]);
			attr(div1, "class", div1_class_value = "spectrum-Modal-wrapper " + /*$$restProps*/ ctx[2].class);
			set_style(div1, "z-index", +/*zIndex*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*$$restProps*/ 4 && div0_class_value !== (div0_class_value = "spectrum-Modal " + /*$$restProps*/ ctx[2].innerClass)) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*$$restProps*/ 4 && div0_style_value !== (div0_style_value = /*$$restProps*/ ctx[2].innerStyle)) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty & /*$$restProps, isOpen*/ 5) {
				toggle_class(div0, "is-open", /*isOpen*/ ctx[0]);
			}

			if (!current || dirty & /*$$restProps*/ 4 && div1_class_value !== (div1_class_value = "spectrum-Modal-wrapper " + /*$$restProps*/ ctx[2].class)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*zIndex*/ 2) {
				set_style(div1, "z-index", +/*zIndex*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1v($$self, $$props, $$invalidate) {
	const omit_props_names = ["isOpen","zIndex"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { isOpen = false } = $$props;
	let { zIndex = 100 } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("zIndex" in $$new_props) $$invalidate(1, zIndex = $$new_props.zIndex);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	return [isOpen, zIndex, $$restProps, $$scope, $$slots];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, { isOpen: 0, zIndex: 1 });
	}
}

/* src/packages/Page/Page.svelte generated by Svelte v3.24.1 */

function create_fragment$1w(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "spectrum--" + /*scale*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale*/ 1 && div_class_value !== (div_class_value = "spectrum--" + /*scale*/ ctx[0])) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1w($$self, $$props, $$invalidate) {
	let { scale = "medium" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [scale, $$scope, $$slots];
}

class Page extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, { scale: 0 });
	}
}

/* src/packages/Pagination/PaginationButtonStyle.svelte generated by Svelte v3.24.1 */

function create_fragment$1x(ctx) {
	let nav;
	let nav_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			nav = element("nav");
			if (default_slot) default_slot.c();
			attr(nav, "class", nav_class_value = "spectrum-SplitButton spectrum-SplitButton--" + /*side*/ ctx[0] + " spectrum-SplitButton--" + /*variants*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, nav, anchor);

			if (default_slot) {
				default_slot.m(nav, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*side, variants*/ 3 && nav_class_value !== (nav_class_value = "spectrum-SplitButton spectrum-SplitButton--" + /*side*/ ctx[0] + " spectrum-SplitButton--" + /*variants*/ ctx[1])) {
				attr(nav, "class", nav_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1x($$self, $$props, $$invalidate) {
	let { side = "left" } = $$props;
	let { variants = "cta" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("side" in $$props) $$invalidate(0, side = $$props.side);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [side, variants, $$scope, $$slots];
}

class PaginationButtonStyle extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, { side: 0, variants: 1 });
	}
}

/* src/packages/Pagination/PaginationButtonStyleNext.svelte generated by Svelte v3.24.1 */

function create_if_block_1$G(ctx) {
	let iconchevronleftmedium;
	let current;

	iconchevronleftmedium = new ChevronLeftMedium({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-ChevronLeftMedium",
				focusable: "false",
				"aria-hidden": "true",
				"aria-label": "ChevronLeft"
			}
		});

	return {
		c() {
			create_component(iconchevronleftmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronleftmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconchevronleftmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronleftmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronleftmedium, detaching);
		}
	};
}

// (63:44) {label}
function fallback_block$8(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data(t, /*label*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (64:2) {#if isLeft}
function create_if_block$I(ctx) {
	let iconchevronrightmedium;
	let current;

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-ChevronRightMedium",
				focusable: "false",
				"aria-hidden": "true",
				"aria-label": "ChevronRight"
			}
		});

	return {
		c() {
			create_component(iconchevronrightmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronrightmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronrightmedium, detaching);
		}
	};
}

function create_fragment$1y(ctx) {
	let a;
	let t0;
	let span;
	let t1;
	let a_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = !/*isLeft*/ ctx[4] && create_if_block_1$G();
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const default_slot_or_fallback = default_slot || fallback_block$8(ctx);
	let if_block1 = /*isLeft*/ ctx[4] && create_if_block$I();

	return {
		c() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(span, "class", "spectrum-Button-label");
			attr(a, "href", /*href*/ ctx[0]);
			attr(a, "type", /*type*/ ctx[1]);
			attr(a, "class", a_class_value = "spectrum-Button spectrum-Button--" + /*variants*/ ctx[6] + " spectrum-SplitButton-action spectrum-Pagination-nextButton");
			toggle_class(a, "is-disabled", /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append(a, t0);
			append(a, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			append(a, t1);
			if (if_block1) if_block1.m(a, null);
			/*a_binding*/ ctx[10](a);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[7].call(null, a));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!/*isLeft*/ ctx[4]) {
				if (if_block0) {
					if (dirty & /*isLeft*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$G();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (/*isLeft*/ ctx[4]) {
				if (if_block1) {
					if (dirty & /*isLeft*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$I();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*href*/ 1) {
				attr(a, "href", /*href*/ ctx[0]);
			}

			if (!current || dirty & /*type*/ 2) {
				attr(a, "type", /*type*/ ctx[1]);
			}

			if (!current || dirty & /*variants*/ 64 && a_class_value !== (a_class_value = "spectrum-Button spectrum-Button--" + /*variants*/ ctx[6] + " spectrum-SplitButton-action spectrum-Pagination-nextButton")) {
				attr(a, "class", a_class_value);
			}

			if (dirty & /*variants, disabled*/ 72) {
				toggle_class(a, "is-disabled", /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot_or_fallback, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot_or_fallback, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block0) if_block0.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (if_block1) if_block1.d();
			/*a_binding*/ ctx[10](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$1y($$self, $$props, $$invalidate) {
	let { href = "#" } = $$props;
	let { type = "button" } = $$props;
	let { label = "Next" } = $$props;
	let { disabled = false } = $$props;
	let isLeft = true;
	let paginationNextButton;
	let variants = "cta";
	const eventsListen = getEventsAction(current_component);

	onMount(() => {
		$$invalidate(4, isLeft = paginationNextButton.parentNode.classList.contains("spectrum-SplitButton--left"));

		if (paginationNextButton.parentNode.classList.contains("spectrum-SplitButton--cta")) {
			$$invalidate(6, variants = "cta");
		}

		if (paginationNextButton.parentNode.classList.contains("spectrum-SplitButton--primary")) {
			$$invalidate(6, variants = "primary");
		}

		if (paginationNextButton.parentNode.classList.contains("spectrum-SplitButton--secondary")) {
			$$invalidate(6, variants = "secondary");
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			paginationNextButton = $$value;
			$$invalidate(5, paginationNextButton);
		});
	}

	$$self.$$set = $$props => {
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		href,
		type,
		label,
		disabled,
		isLeft,
		paginationNextButton,
		variants,
		eventsListen,
		$$scope,
		$$slots,
		a_binding
	];
}

class PaginationButtonStyleNext extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, { href: 0, type: 1, label: 2, disabled: 3 });
	}
}

/* src/packages/Pagination/PaginationButtonStylePrev.svelte generated by Svelte v3.24.1 */

function create_else_block$8(ctx) {
	let iconchevronrightmedium;
	let current;

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-ChevronRightMedium",
				focusable: "false",
				"aria-hidden": "true",
				"aria-label": "ChevronRight"
			}
		});

	return {
		c() {
			create_component(iconchevronrightmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronrightmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronrightmedium, detaching);
		}
	};
}

// (50:2) {#if isLeft}
function create_if_block$J(ctx) {
	let iconchevronleftmedium;
	let current;

	iconchevronleftmedium = new ChevronLeftMedium({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-ChevronLeftMedium",
				focusable: "false",
				"aria-hidden": "true",
				"aria-label": "ChevronLeft"
			}
		});

	return {
		c() {
			create_component(iconchevronleftmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronleftmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconchevronleftmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronleftmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronleftmedium, detaching);
		}
	};
}

function create_fragment$1z(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let a_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$J, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLeft*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			a = element("a");
			if_block.c();
			attr(a, "href", /*href*/ ctx[0]);
			attr(a, "type", /*type*/ ctx[2]);
			attr(a, "class", a_class_value = "spectrum-Button spectrum-Button--" + /*variants*/ ctx[5] + " spectrum-SplitButton-trigger spectrum-Pagination-prevButton");
			toggle_class(a, "is-disabled", /*disabled*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			/*a_binding*/ ctx[7](a);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[6].call(null, a));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(a, null);
			}

			if (!current || dirty & /*href*/ 1) {
				attr(a, "href", /*href*/ ctx[0]);
			}

			if (!current || dirty & /*type*/ 4) {
				attr(a, "type", /*type*/ ctx[2]);
			}

			if (!current || dirty & /*variants*/ 32 && a_class_value !== (a_class_value = "spectrum-Button spectrum-Button--" + /*variants*/ ctx[5] + " spectrum-SplitButton-trigger spectrum-Pagination-prevButton")) {
				attr(a, "class", a_class_value);
			}

			if (dirty & /*variants, disabled*/ 34) {
				toggle_class(a, "is-disabled", /*disabled*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if_blocks[current_block_type_index].d();
			/*a_binding*/ ctx[7](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$1z($$self, $$props, $$invalidate) {
	let { href = "#" } = $$props;
	let { disabled = false } = $$props;
	let { type = "button" } = $$props;
	let paginationPrevButton;
	let isLeft = true;
	let variants = "cta";
	const eventsListen = getEventsAction(current_component);

	onMount(() => {
		$$invalidate(4, isLeft = paginationPrevButton.parentNode.classList.contains("spectrum-SplitButton--left"));

		if (paginationPrevButton.parentNode.classList.contains("spectrum-SplitButton--cta")) {
			$$invalidate(5, variants = "cta");
		}

		if (paginationPrevButton.parentNode.classList.contains("spectrum-SplitButton--primary")) {
			$$invalidate(5, variants = "primary");
		}

		if (paginationPrevButton.parentNode.classList.contains("spectrum-SplitButton--secondary")) {
			$$invalidate(5, variants = "secondary");
		}
	});

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			paginationPrevButton = $$value;
			$$invalidate(3, paginationPrevButton);
		});
	}

	$$self.$$set = $$props => {
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ("type" in $$props) $$invalidate(2, type = $$props.type);
	};

	return [
		href,
		disabled,
		type,
		paginationPrevButton,
		isLeft,
		variants,
		eventsListen,
		a_binding
	];
}

class PaginationButtonStylePrev extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, { href: 0, disabled: 1, type: 2 });
	}
}

/* src/packages/TextField/Textfield.svelte generated by Svelte v3.24.1 */

function create_if_block_1$H(ctx) {
	let iconcheckmarkmedium;
	let current;

	iconcheckmarkmedium = new CheckmarkMedium({
			props: {
				className: "spectrum-Textfield-validationIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcheckmarkmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcheckmarkmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconcheckmarkmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcheckmarkmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcheckmarkmedium, detaching);
		}
	};
}

// (141:2) {#if isInvalid}
function create_if_block$K(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Textfield-validationIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

function create_fragment$1A(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let input;
	let input_class_value;
	let input_autocomplete_value;
	let input_min_value;
	let input_max_value;
	let input_step_value;
	let eventsListen_action;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*isValid*/ ctx[7] && create_if_block_1$H();
	let if_block1 = /*isInvalid*/ ctx[8] && create_if_block$K();
	const default_slot_template = /*$$slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			input = element("input");
			attr(input, "id", /*id*/ ctx[1]);
			attr(input, "class", input_class_value = "spectrum-Textfield-input " + /*$$restProps*/ ctx[17].inputClass);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			attr(input, "name", /*name*/ ctx[3]);
			input.required = /*required*/ ctx[4];
			input.disabled = /*disabled*/ ctx[5];
			attr(input, "autocomplete", input_autocomplete_value = /*$$restProps*/ ctx[17].autocomplete);
			attr(input, "min", input_min_value = /*$$restProps*/ ctx[17].min);
			attr(input, "max", input_max_value = /*$$restProps*/ ctx[17].max);
			attr(input, "step", input_step_value = /*$$restProps*/ ctx[17].step);
			attr(input, "maxlength", /*maxLength*/ ctx[11]);
			attr(input, "minlength", /*minLength*/ ctx[12]);
			attr(div, "class", div_class_value = "spectrum-Textfield " + /*$$restProps*/ ctx[17].class);
			toggle_class(div, "spectrum-Textfield--quiet", /*isQuiet*/ ctx[6]);
			toggle_class(div, "is-valid", /*isValid*/ ctx[7]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[8]);
			toggle_class(div, "is-focused", /*isFocused*/ ctx[9]);
			toggle_class(div, "is-keyboardFocused", /*isKeyboardFocused*/ ctx[10]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(div, t2);
			append(div, input);
			/*input_binding*/ ctx[21](input);
			set_input_value(input, /*value*/ ctx[0]);
			/*div_binding*/ ctx[25](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[22]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[15].call(null, input)),
					listen(div, "focusin", /*focusin_handler*/ ctx[23]),
					listen(div, "focusout", /*focusout_handler*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isValid*/ ctx[7]) {
				if (if_block0) {
					if (dirty & /*isValid*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$H();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*isInvalid*/ ctx[8]) {
				if (if_block1) {
					if (dirty & /*isInvalid*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$K();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 2) {
				attr(input, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_class_value !== (input_class_value = "spectrum-Textfield-input " + /*$$restProps*/ ctx[17].inputClass)) {
				attr(input, "class", input_class_value);
			}

			if (!current || dirty & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty & /*name*/ 8) {
				attr(input, "name", /*name*/ ctx[3]);
			}

			if (!current || dirty & /*required*/ 16) {
				input.required = /*required*/ ctx[4];
			}

			if (!current || dirty & /*disabled*/ 32) {
				input.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_autocomplete_value !== (input_autocomplete_value = /*$$restProps*/ ctx[17].autocomplete)) {
				attr(input, "autocomplete", input_autocomplete_value);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_min_value !== (input_min_value = /*$$restProps*/ ctx[17].min)) {
				attr(input, "min", input_min_value);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_max_value !== (input_max_value = /*$$restProps*/ ctx[17].max)) {
				attr(input, "max", input_max_value);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_step_value !== (input_step_value = /*$$restProps*/ ctx[17].step)) {
				attr(input, "step", input_step_value);
			}

			if (!current || dirty & /*maxLength*/ 2048) {
				attr(input, "maxlength", /*maxLength*/ ctx[11]);
			}

			if (!current || dirty & /*minLength*/ 4096) {
				attr(input, "minlength", /*minLength*/ ctx[12]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && div_class_value !== (div_class_value = "spectrum-Textfield " + /*$$restProps*/ ctx[17].class)) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*$$restProps, isQuiet*/ 131136) {
				toggle_class(div, "spectrum-Textfield--quiet", /*isQuiet*/ ctx[6]);
			}

			if (dirty & /*$$restProps, isValid*/ 131200) {
				toggle_class(div, "is-valid", /*isValid*/ ctx[7]);
			}

			if (dirty & /*$$restProps, isInvalid*/ 131328) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[8]);
			}

			if (dirty & /*$$restProps, isFocused*/ 131584) {
				toggle_class(div, "is-focused", /*isFocused*/ ctx[9]);
			}

			if (dirty & /*$$restProps, isKeyboardFocused*/ 132096) {
				toggle_class(div, "is-keyboardFocused", /*isKeyboardFocused*/ ctx[10]);
			}

			if (dirty & /*$$restProps, disabled*/ 131104) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*input_binding*/ ctx[21](null);
			/*div_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1A($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"id","placeholder","name","value","required","disabled","isQuiet","isValid","isInvalid","isFocused","isKeyboardFocused","maxLength","minLength","resetType"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { id = `textfield-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { placeholder = "" } = $$props;
	let { name = "field" } = $$props;
	let { value = "" } = $$props;
	let { required = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { isValid = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isFocused = false } = $$props;
	let { isKeyboardFocused = false } = $$props;
	let { maxLength = 32 } = $$props;
	let { minLength = 0 } = $$props;
	let { resetType = "text" } = $$props;
	const eventsListen = getEventsAction(current_component);
	let textfieldEl;
	let inputEl;

	onMount(() => {
		textfieldEl && addClassName();

		if (textfieldEl && textfieldEl.lastChild.type) {
			$$invalidate(13, textfieldEl.lastChild.type = resetType, textfieldEl);
		}
	});

	function setFocus(focused) {
		var focusClass = inputEl.classList.contains("focus-ring")
		? "is-keyboardFocused"
		: "is-focused";

		if (focused) {
			textfieldEl.classList.add(focusClass);
		} else {
			textfieldEl.classList.remove("is-keyboardFocused");
			textfieldEl.classList.remove("is-focused");
		}
	}

	function addClassName() {
		let fieldIconList = textfieldEl.getElementsByClassName("spectrum-Icon");

		if (fieldIconList.length) {
			for (let index = 0; index < fieldIconList.length; index++) {
				let isUIIcon = fieldIconList[index].classList.contains("spectrum-Textfield-validationIcon");

				if (!isUIIcon) {
					fieldIconList[index].classList.toggle(`spectrum-Textfield-icon`);
				}
			}
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(14, inputEl);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const focusin_handler = () => {
		setFocus(true);
	};

	const focusout_handler = () => {
		setFocus(false);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textfieldEl = $$value;
			$$invalidate(13, textfieldEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("placeholder" in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);
		if ("name" in $$new_props) $$invalidate(3, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("required" in $$new_props) $$invalidate(4, required = $$new_props.required);
		if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("isQuiet" in $$new_props) $$invalidate(6, isQuiet = $$new_props.isQuiet);
		if ("isValid" in $$new_props) $$invalidate(7, isValid = $$new_props.isValid);
		if ("isInvalid" in $$new_props) $$invalidate(8, isInvalid = $$new_props.isInvalid);
		if ("isFocused" in $$new_props) $$invalidate(9, isFocused = $$new_props.isFocused);
		if ("isKeyboardFocused" in $$new_props) $$invalidate(10, isKeyboardFocused = $$new_props.isKeyboardFocused);
		if ("maxLength" in $$new_props) $$invalidate(11, maxLength = $$new_props.maxLength);
		if ("minLength" in $$new_props) $$invalidate(12, minLength = $$new_props.minLength);
		if ("resetType" in $$new_props) $$invalidate(18, resetType = $$new_props.resetType);
		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	return [
		value,
		id,
		placeholder,
		name,
		required,
		disabled,
		isQuiet,
		isValid,
		isInvalid,
		isFocused,
		isKeyboardFocused,
		maxLength,
		minLength,
		textfieldEl,
		inputEl,
		eventsListen,
		setFocus,
		$$restProps,
		resetType,
		$$scope,
		$$slots,
		input_binding,
		input_input_handler,
		focusin_handler,
		focusout_handler,
		div_binding
	];
}

class Textfield extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {
			id: 1,
			placeholder: 2,
			name: 3,
			value: 0,
			required: 4,
			disabled: 5,
			isQuiet: 6,
			isValid: 7,
			isInvalid: 8,
			isFocused: 9,
			isKeyboardFocused: 10,
			maxLength: 11,
			minLength: 12,
			resetType: 18
		});
	}
}

/* src/packages/Pagination/PaginationExplicit.svelte generated by Svelte v3.24.1 */

function add_css$k() {
	var style = element("style");
	style.id = "svelte-1dqmqlu-style";
	style.textContent = ".spectrum-Pagination-textfield{width:var(--spectrum-pagination-textfield-width, var(--spectrum-global-dimension-size-600)) !important;min-width:var(--spectrum-pagination-textfield-width, var(--spectrum-global-dimension-size-600)) !important}";
	append(document.head, style);
}

const get_pagination_next_slot_changes = dirty => ({});
const get_pagination_next_slot_context = ctx => ({});
const get_pagination_prev_slot_changes = dirty => ({});
const get_pagination_prev_slot_context = ctx => ({});

// (44:75) of 
function fallback_block$9(ctx) {
	let t0;
	let t1;
	let t2;

	return {
		c() {
			t0 = text("of ");
			t1 = text(/*totalPageNumber*/ ctx[1]);
			t2 = text(" pages");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*totalPageNumber*/ 2) set_data(t1, /*totalPageNumber*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

function create_fragment$1B(ctx) {
	let nav;
	let t0;
	let textfield;
	let updating_value;
	let t1;
	let span;
	let t2;
	let current;
	const pagination_prev_slot_template = /*$$slots*/ ctx[4]["pagination-prev"];
	const pagination_prev_slot = create_slot(pagination_prev_slot_template, ctx, /*$$scope*/ ctx[3], get_pagination_prev_slot_context);

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[5].call(null, value);
	}

	let textfield_props = {
		resetType: "number",
		class: "spectrum-Pagination-textfield",
		name: "field",
		pattern: "[1-9]\\d+",
		min: "1"
	};

	if (/*currentPageNumber*/ ctx[0] !== void 0) {
		textfield_props.value = /*currentPageNumber*/ ctx[0];
	}

	textfield = new Textfield({ props: textfield_props });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
	textfield.$on("change", /*testValue*/ ctx[2]);
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const default_slot_or_fallback = default_slot || fallback_block$9(ctx);
	const pagination_next_slot_template = /*$$slots*/ ctx[4]["pagination-next"];
	const pagination_next_slot = create_slot(pagination_next_slot_template, ctx, /*$$scope*/ ctx[3], get_pagination_next_slot_context);

	return {
		c() {
			nav = element("nav");
			if (pagination_prev_slot) pagination_prev_slot.c();
			t0 = space();
			create_component(textfield.$$.fragment);
			t1 = space();
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t2 = space();
			if (pagination_next_slot) pagination_next_slot.c();
			attr(span, "class", "spectrum-Body--secondary spectrum-Pagination-counter");
			attr(nav, "class", "spectrum-Pagination spectrum-Pagination--explicit");
		},
		m(target, anchor) {
			insert(target, nav, anchor);

			if (pagination_prev_slot) {
				pagination_prev_slot.m(nav, null);
			}

			append(nav, t0);
			mount_component(textfield, nav, null);
			append(nav, t1);
			append(nav, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			append(nav, t2);

			if (pagination_next_slot) {
				pagination_next_slot.m(nav, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (pagination_prev_slot) {
				if (pagination_prev_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(pagination_prev_slot, pagination_prev_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_pagination_prev_slot_changes, get_pagination_prev_slot_context);
				}
			}

			const textfield_changes = {};

			if (!updating_value && dirty & /*currentPageNumber*/ 1) {
				updating_value = true;
				textfield_changes.value = /*currentPageNumber*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*totalPageNumber*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (pagination_next_slot) {
				if (pagination_next_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(pagination_next_slot, pagination_next_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_pagination_next_slot_changes, get_pagination_next_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(pagination_prev_slot, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(default_slot_or_fallback, local);
			transition_in(pagination_next_slot, local);
			current = true;
		},
		o(local) {
			transition_out(pagination_prev_slot, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(default_slot_or_fallback, local);
			transition_out(pagination_next_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			if (pagination_prev_slot) pagination_prev_slot.d(detaching);
			destroy_component(textfield);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (pagination_next_slot) pagination_next_slot.d(detaching);
		}
	};
}

function instance$1B($$self, $$props, $$invalidate) {
	let { currentPageNumber = 1 } = $$props;
	let { totalPageNumber = 3 } = $$props;

	function testValue() {
		$$invalidate(0, currentPageNumber = Math.abs(parseInt(+currentPageNumber)));
	}

	let { $$slots = {}, $$scope } = $$props;

	function textfield_value_binding(value) {
		currentPageNumber = value;
		($$invalidate(0, currentPageNumber), $$invalidate(1, totalPageNumber));
	}

	$$self.$$set = $$props => {
		if ("currentPageNumber" in $$props) $$invalidate(0, currentPageNumber = $$props.currentPageNumber);
		if ("totalPageNumber" in $$props) $$invalidate(1, totalPageNumber = $$props.totalPageNumber);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*currentPageNumber*/ 1) {
			 if (currentPageNumber === 0) {
				$$invalidate(0, currentPageNumber = 1);
			}
		}

		if ($$self.$$.dirty & /*currentPageNumber, totalPageNumber*/ 3) {
			 if (currentPageNumber > totalPageNumber) {
				$$invalidate(0, currentPageNumber = totalPageNumber);
			}
		}
	};

	return [
		currentPageNumber,
		totalPageNumber,
		testValue,
		$$scope,
		$$slots,
		textfield_value_binding
	];
}

class PaginationExplicit extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1dqmqlu-style")) add_css$k();
		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, { currentPageNumber: 0, totalPageNumber: 1 });
	}
}

/* src/packages/Pagination/PaginationPage.svelte generated by Svelte v3.24.1 */
const get_pagination_next_slot_changes$1 = dirty => ({});
const get_pagination_next_slot_context$1 = ctx => ({});

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

const get_pagination_prev_slot_changes$1 = dirty => ({});
const get_pagination_prev_slot_context$1 = ctx => ({});

// (92:4) {:else}
function create_else_block$9(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				isSelected: /*item*/ ctx[11] === /*currentPageNumber*/ ctx[0],
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*paginationArr, currentPageNumber*/ 3) button_changes.isSelected = /*item*/ ctx[11] === /*currentPageNumber*/ ctx[0];

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (82:4) {#if item}
function create_if_block$L(ctx) {
	let button;
	let current;

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[7](/*item*/ ctx[11], ...args);
	}

	button = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				isSelected: /*item*/ ctx[11] === /*currentPageNumber*/ ctx[0],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	button.$on("click", click_handler_1);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*paginationArr, currentPageNumber*/ 3) button_changes.isSelected = /*item*/ ctx[11] === /*currentPageNumber*/ ctx[0];

			if (dirty & /*$$scope, paginationArr*/ 258) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (93:6) <Button exterior="action" isQuiet isSelected={item === currentPageNumber}>
function create_default_slot_1$3(ctx) {
	let t;

	return {
		c() {
			t = text("...");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (83:6) <Button         exterior="action"         isQuiet         isSelected={item === currentPageNumber}         on:click={() => {           currentPageNumber = item;         }}>
function create_default_slot$4(ctx) {
	let t_value = /*item*/ ctx[11] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*paginationArr*/ 2 && t_value !== (t_value = /*item*/ ctx[11] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (81:2) {#each paginationArr as item}
function create_each_block$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$L, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[11]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$1C(ctx) {
	let nav;
	let t0;
	let t1;
	let t2;
	let current;
	let mounted;
	let dispose;
	const pagination_prev_slot_template = /*$$slots*/ ctx[4]["pagination-prev"];
	const pagination_prev_slot = create_slot(pagination_prev_slot_template, ctx, /*$$scope*/ ctx[8], get_pagination_prev_slot_context$1);
	let each_value = /*paginationArr*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const pagination_next_slot_template = /*$$slots*/ ctx[4]["pagination-next"];
	const pagination_next_slot = create_slot(pagination_next_slot_template, ctx, /*$$scope*/ ctx[8], get_pagination_next_slot_context$1);
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			nav = element("nav");
			if (pagination_prev_slot) pagination_prev_slot.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (pagination_next_slot) pagination_next_slot.c();
			t2 = space();
			if (default_slot) default_slot.c();
			attr(nav, "class", "spectrum-Pagination spectrum-Pagination--listing");
		},
		m(target, anchor) {
			insert(target, nav, anchor);

			if (pagination_prev_slot) {
				pagination_prev_slot.m(nav, null);
			}

			append(nav, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(nav, null);
			}

			append(nav, t1);

			if (pagination_next_slot) {
				pagination_next_slot.m(nav, null);
			}

			insert(target, t2, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(nav, "click", /*click_handler*/ ctx[5]),
					listen(nav, "keydown", /*keydown_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (pagination_prev_slot) {
				if (pagination_prev_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(pagination_prev_slot, pagination_prev_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_pagination_prev_slot_changes$1, get_pagination_prev_slot_context$1);
				}
			}

			if (dirty & /*paginationArr, currentPageNumber*/ 3) {
				each_value = /*paginationArr*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(nav, t1);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (pagination_next_slot) {
				if (pagination_next_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(pagination_next_slot, pagination_next_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_pagination_next_slot_changes$1, get_pagination_next_slot_context$1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(pagination_prev_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(pagination_next_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(pagination_prev_slot, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(pagination_next_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			if (pagination_prev_slot) pagination_prev_slot.d(detaching);
			destroy_each(each_blocks, detaching);
			if (pagination_next_slot) pagination_next_slot.d(detaching);
			if (detaching) detach(t2);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1C($$self, $$props, $$invalidate) {
	let { currentPageNumber = 1 } = $$props;
	let { totalPageNumber = 3 } = $$props;
	let { showPaginationNumber = 8 } = $$props;
	let showPaginationStart = 1;
	let paginationArr = [];

	afterUpdate(() => {
		getCurrentPagination();
	});

	function getCurrentPagination() {
		if (totalPageNumber <= showPaginationNumber) {
			$$invalidate(1, paginationArr.length = totalPageNumber, paginationArr);

			for (let index = 0; index < paginationArr.length; index++) {
				$$invalidate(1, paginationArr[index] = index + 1, paginationArr);
			}
		} else {
			$$invalidate(1, paginationArr.length = showPaginationNumber, paginationArr);

			if (currentPageNumber !== 1 && currentPageNumber - showPaginationStart >= showPaginationNumber - 3) {
				showPaginationStart = currentPageNumber - 1;
			}

			if (currentPageNumber - showPaginationStart === showPaginationNumber - 2) {
				showPaginationStart = currentPageNumber - 1;
			}

			if (currentPageNumber - showPaginationStart < 0 && currentPageNumber != 2) {
				showPaginationStart = showPaginationStart - showPaginationNumber + 2;
			}

			if (showPaginationStart < 1) {
				showPaginationStart = 1;
			}

			if (currentPageNumber + (showPaginationNumber - 3) >= totalPageNumber) {
				showPaginationStart = totalPageNumber - showPaginationNumber;
			}

			if (currentPageNumber + (showPaginationNumber - 3) < totalPageNumber) {
				for (let index = 0; index < paginationArr.length; index++) {
					if (index + 1 == showPaginationNumber) {
						$$invalidate(1, paginationArr[index] = totalPageNumber, paginationArr);
					} else if (index + 1 == showPaginationNumber - 1) {
						$$invalidate(1, paginationArr[index] = 0, paginationArr);
					} else {
						$$invalidate(1, paginationArr[index] = showPaginationStart + index, paginationArr);
					}
				}
			} else {
				for (let index = 0; index < paginationArr.length; index++) {
					if (index === 0) {
						$$invalidate(1, paginationArr[index] = 1, paginationArr);
					} else if (index == 1) {
						$$invalidate(1, paginationArr[index] = 0, paginationArr);
					} else {
						$$invalidate(1, paginationArr[index] = showPaginationStart + index + 1, paginationArr);
					}
				}
			}
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	const click_handler_1 = item => {
		$$invalidate(0, currentPageNumber = item);
	};

	$$self.$$set = $$props => {
		if ("currentPageNumber" in $$props) $$invalidate(0, currentPageNumber = $$props.currentPageNumber);
		if ("totalPageNumber" in $$props) $$invalidate(2, totalPageNumber = $$props.totalPageNumber);
		if ("showPaginationNumber" in $$props) $$invalidate(3, showPaginationNumber = $$props.showPaginationNumber);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		currentPageNumber,
		paginationArr,
		totalPageNumber,
		showPaginationNumber,
		$$slots,
		click_handler,
		keydown_handler,
		click_handler_1,
		$$scope
	];
}

class PaginationPage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {
			currentPageNumber: 0,
			totalPageNumber: 2,
			showPaginationNumber: 3
		});
	}
}

/* src/packages/Pagination/PaginationPageNext.svelte generated by Svelte v3.24.1 */

function create_default_slot$5(ctx) {
	let t;

	return {
		c() {
			t = text("Next");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1D(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				variant: "primary",
				isQuiet: true,
				class: "spectrum-Pagination-nextButton",
				disabled: /*disabled*/ ctx[0],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[1]);
	button.$on("keydown", /*keydown_handler*/ ctx[2]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

function instance$1D($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
	};

	return [disabled, click_handler, keydown_handler];
}

class PaginationPageNext extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, { disabled: 0 });
	}
}

/* src/packages/Pagination/PaginationPagePrev.svelte generated by Svelte v3.24.1 */

function create_default_slot$6(ctx) {
	let t;

	return {
		c() {
			t = text("Prev");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1E(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				variant: "primary",
				isQuiet: true,
				class: "spectrum-Pagination-prevButton",
				disabled: /*disabled*/ ctx[0],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[1]);
	button.$on("keydown", /*keydown_handler*/ ctx[2]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

function instance$1E($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
	};

	return [disabled, click_handler, keydown_handler];
}

class PaginationPagePrev extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, { disabled: 0 });
	}
}

/* src/packages/Pagination/PaginationExplicitNext.svelte generated by Svelte v3.24.1 */

function create_default_slot$7(ctx) {
	let iconchevronrightmedium;
	let current;

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-ChevronRightMedium",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconchevronrightmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronrightmedium, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronrightmedium, detaching);
		}
	};
}

function create_fragment$1F(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				class: "spectrum-Pagination-nextButton",
				disabled: /*disabled*/ ctx[0],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[1]);
	button.$on("keydown", /*keydown_handler*/ ctx[2]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

function instance$1F($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
	};

	return [disabled, click_handler, keydown_handler];
}

class PaginationExplicitNext extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, { disabled: 0 });
	}
}

/* src/packages/Pagination/PaginationExplicitPrev.svelte generated by Svelte v3.24.1 */

function create_default_slot$8(ctx) {
	let iconchevronleftmedium;
	let current;

	iconchevronleftmedium = new ChevronLeftMedium({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-ChevronLeftMedium",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconchevronleftmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronleftmedium, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconchevronleftmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronleftmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronleftmedium, detaching);
		}
	};
}

function create_fragment$1G(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				class: "spectrum-Pagination-prevButton",
				disabled: /*disabled*/ ctx[0],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[1]);
	button.$on("keydown", /*keydown_handler*/ ctx[2]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

function instance$1G($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
	};

	return [disabled, click_handler, keydown_handler];
}

class PaginationExplicitPrev extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, { disabled: 0 });
	}
}

/* src/packages/Picker/Picker.svelte generated by Svelte v3.24.1 */

function add_css$l() {
	var style = element("style");
	style.id = "svelte-k4x60k-style";
	style.textContent = ".spectrum-FieldButton{display:flex}.spectrum-Picker-trigger>.spectrum-Picker-icon{transition:transform var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      opacity var(--spectrum-global-animation-duration-100, 130ms) ease-in-out,\n      visibility 0ms linear var(--spectrum-global-animation-duration-100, 130ms)}.spectrum-Picker-trigger.is-selected>.spectrum-Picker-icon{transform:rotate(180deg)}";
	append(document.head, style);
}

const get_Picker_label_slot_changes = dirty => ({});
const get_Picker_label_slot_context = ctx => ({});

// (160:4) {:else}
function create_else_block$a(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_anchor = empty();
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(/*triggerNode*/ ctx[8], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*triggerNode*/ 256) html_tag.p(/*triggerNode*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (156:4) {#if !triggerNode}
function create_if_block_1$I(ctx) {
	let span;
	let current;
	const Picker_label_slot_template = /*$$slots*/ ctx[14]["Picker-label"];
	const Picker_label_slot = create_slot(Picker_label_slot_template, ctx, /*$$scope*/ ctx[16], get_Picker_label_slot_context);
	const Picker_label_slot_or_fallback = Picker_label_slot || fallback_block$a(ctx);

	return {
		c() {
			span = element("span");
			if (Picker_label_slot_or_fallback) Picker_label_slot_or_fallback.c();
			attr(span, "class", "spectrum-Picker-label");
			toggle_class(span, "is-placeholder", !/*isActive*/ ctx[6] && /*placeholder*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (Picker_label_slot_or_fallback) {
				Picker_label_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (Picker_label_slot) {
				if (Picker_label_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(Picker_label_slot, Picker_label_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_Picker_label_slot_changes, get_Picker_label_slot_context);
				}
			} else {
				if (Picker_label_slot_or_fallback && Picker_label_slot_or_fallback.p && dirty & /*placeholder*/ 2) {
					Picker_label_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (dirty & /*isActive, placeholder*/ 66) {
				toggle_class(span, "is-placeholder", !/*isActive*/ ctx[6] && /*placeholder*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(Picker_label_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(Picker_label_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (Picker_label_slot_or_fallback) Picker_label_slot_or_fallback.d(detaching);
		}
	};
}

// (158:34) {placeholder}
function fallback_block$a(ctx) {
	let t;

	return {
		c() {
			t = text(/*placeholder*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*placeholder*/ 2) set_data(t, /*placeholder*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (163:4) {#if isInvalid}
function create_if_block$M(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				focusable: "false",
				"aria-hidden": "true",
				"aria-label": "Folder"
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (170:4) <Menu role="listbox" {minWidth}>
function create_default_slot_1$4(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (169:2) <Popover class="spectrum-Picker-popover" {isOpen}>
function create_default_slot$9(ctx) {
	let menu;
	let current;

	menu = new Menu({
			props: {
				role: "listbox",
				minWidth: /*minWidth*/ ctx[5],
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(menu.$$.fragment);
		},
		m(target, anchor) {
			mount_component(menu, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const menu_changes = {};
			if (dirty & /*minWidth*/ 32) menu_changes.minWidth = /*minWidth*/ ctx[5];

			if (dirty & /*$$scope*/ 65536) {
				menu_changes.$$scope = { dirty, ctx };
			}

			menu.$set(menu_changes);
		},
		i(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(menu, detaching);
		}
	};
}

function create_fragment$1H(ctx) {
	let div1;
	let button;
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let iconchevrondownmedium;
	let t2;
	let popover;
	let t3;
	let div0;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$I, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*triggerNode*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*isInvalid*/ ctx[3] && create_if_block$M();

	iconchevrondownmedium = new ChevronDownMedium({
			props: {
				className: "spectrum-Picker-icon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	popover = new Popover({
			props: {
				class: "spectrum-Picker-popover",
				isOpen: /*isOpen*/ ctx[0],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			button = element("button");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			create_component(iconchevrondownmedium.$$.fragment);
			t2 = space();
			create_component(popover.$$.fragment);
			t3 = space();
			div0 = element("div");
			attr(button, "class", "spectrum-FieldButton spectrum-Picker-trigger");
			attr(button, "aria-haspopup", "listbox");
			attr(button, "id", "rubus-ActionSource");
			set_style(button, "min-width", /*minWidth*/ ctx[5] + "px");
			attr(button, "type", "button");
			toggle_class(button, "is-selected", /*isOpen*/ ctx[0]);
			toggle_class(button, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(button, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(button, "spectrum-FieldButton--quiet", /*isQuiet*/ ctx[4]);
			attr(div1, "title", /*placeholder*/ ctx[1]);
			attr(div1, "class", div1_class_value = "spectrum-Picker " + /*$$restProps*/ ctx[10].class);
			toggle_class(div1, "is-open", /*isOpen*/ ctx[0]);
			toggle_class(div1, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(div1, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(div1, "spectrum-Picker--quiet", /*isQuiet*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, button);
			if_blocks[current_block_type_index].m(button, null);
			append(button, t0);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			mount_component(iconchevrondownmedium, button, null);
			append(div1, t2);
			mount_component(popover, div1, null);
			append(div1, t3);
			append(div1, div0);
			/*div1_binding*/ ctx[15](div1);
			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", function () {
					if (is_function(!/*disabled*/ ctx[2] && /*PickerStatusCutover*/ ctx[9])) (!/*disabled*/ ctx[2] && /*PickerStatusCutover*/ ctx[9]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(button, t0);
			}

			if (/*isInvalid*/ ctx[3]) {
				if (if_block1) {
					if (dirty & /*isInvalid*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$M();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*minWidth*/ 32) {
				set_style(button, "min-width", /*minWidth*/ ctx[5] + "px");
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(button, "is-selected", /*isOpen*/ ctx[0]);
			}

			if (dirty & /*isInvalid*/ 8) {
				toggle_class(button, "is-invalid", /*isInvalid*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(button, "is-disabled", /*disabled*/ ctx[2]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(button, "spectrum-FieldButton--quiet", /*isQuiet*/ ctx[4]);
			}

			const popover_changes = {};
			if (dirty & /*isOpen*/ 1) popover_changes.isOpen = /*isOpen*/ ctx[0];

			if (dirty & /*$$scope, minWidth*/ 65568) {
				popover_changes.$$scope = { dirty, ctx };
			}

			popover.$set(popover_changes);

			if (!current || dirty & /*placeholder*/ 2) {
				attr(div1, "title", /*placeholder*/ ctx[1]);
			}

			if (!current || dirty & /*$$restProps*/ 1024 && div1_class_value !== (div1_class_value = "spectrum-Picker " + /*$$restProps*/ ctx[10].class)) {
				attr(div1, "class", div1_class_value);
			}

			if (dirty & /*$$restProps, isOpen*/ 1025) {
				toggle_class(div1, "is-open", /*isOpen*/ ctx[0]);
			}

			if (dirty & /*$$restProps, isInvalid*/ 1032) {
				toggle_class(div1, "is-invalid", /*isInvalid*/ ctx[3]);
			}

			if (dirty & /*$$restProps, disabled*/ 1028) {
				toggle_class(div1, "is-disabled", /*disabled*/ ctx[2]);
			}

			if (dirty & /*$$restProps, isQuiet*/ 1040) {
				toggle_class(div1, "spectrum-Picker--quiet", /*isQuiet*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(iconchevrondownmedium.$$.fragment, local);
			transition_in(popover.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(iconchevrondownmedium.$$.fragment, local);
			transition_out(popover.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			destroy_component(iconchevrondownmedium);
			destroy_component(popover);
			/*div1_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};
}

function testHasClassName$2(el, verifyString) {
	if (!el) {
		return false;
	}

	for (let index = 0; index < el.length; index++) {
		return el[index] === verifyString;
	}
}

function getNodeHTML$1(el) {
	if (!el.length) {
		return "";
	}

	let nodeHTML = "";

	for (let index = 0; index < el.length; index++) {
		if (!testHasClassName$2(el[index].classList, `spectrum-Menu-checkmark`)) {
			el[index].outerHTML
			? nodeHTML = nodeHTML + el[index].outerHTML
			: nodeHTML;
		}
	}

	return nodeHTML.replace(/spectrum-Menu-itemLabel/g, "spectrum-Picker-label");
}

function instance$1H($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"placeholder","disabled","isOpen","resultIndex","thisIndex","isInvalid","isQuiet","minWidth","autoFold"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { placeholder = "" } = $$props;
	let { disabled = false } = $$props;
	let { isOpen = false } = $$props;
	let { resultIndex = 0 } = $$props;
	let { thisIndex = 0 } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { minWidth = 125 } = $$props;
	let { autoFold = true } = $$props;
	let isActive = false;

	function PickerStatusCutover() {
		$$invalidate(6, isActive = true);
		$$invalidate(11, resultIndex = thisIndex);
		$$invalidate(0, isOpen = !isOpen);
	}

	onMount(() => {
		if (resultIndex) {
			$$invalidate(6, isActive = true);
		}

		pickerEl && pickerEl.addEventListener("click", listenForChildClicks);
		pickerEl && pickerEl.addEventListener("keyup", listenForChildClicks);
		window && window.addEventListener("click", listenForOtherClicks);
		window && window.addEventListener("keyup", listenForOtherClicks);
	});

	let pickerEl;
	let triggerNode = "";

	function listenForChildClicks(e) {
		if (pickerEl && pickerEl.contains(e.target)) {
			if (e.target.classList.length) {
				if (testHasClassName$2(e.target.classList, `spectrum-Menu-item`)) {
					$$invalidate(8, triggerNode = getNodeHTML$1(e.target.childNodes));
				} else if (testHasClassName$2(e.target.classList, `spectrum-Menu-itemLabel`)) {
					$$invalidate(8, triggerNode = getNodeHTML$1(e.target.parentNode.childNodes));
				} else if (testHasClassName$2(e.target.parentNode.classList, `spectrum-Menu-item`)) {
					$$invalidate(8, triggerNode = getNodeHTML$1(e.target.parentNode.childNodes));
				}
			}
		}
	}

	function listenForOtherClicks(e) {
		if (!autoFold) {
			return;
		}

		if (pickerEl && !pickerEl.contains(e.target)) {
			$$invalidate(0, isOpen = false);
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			pickerEl = $$value;
			$$invalidate(7, pickerEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("placeholder" in $$new_props) $$invalidate(1, placeholder = $$new_props.placeholder);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("resultIndex" in $$new_props) $$invalidate(11, resultIndex = $$new_props.resultIndex);
		if ("thisIndex" in $$new_props) $$invalidate(12, thisIndex = $$new_props.thisIndex);
		if ("isInvalid" in $$new_props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$new_props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("minWidth" in $$new_props) $$invalidate(5, minWidth = $$new_props.minWidth);
		if ("autoFold" in $$new_props) $$invalidate(13, autoFold = $$new_props.autoFold);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	return [
		isOpen,
		placeholder,
		disabled,
		isInvalid,
		isQuiet,
		minWidth,
		isActive,
		pickerEl,
		triggerNode,
		PickerStatusCutover,
		$$restProps,
		resultIndex,
		thisIndex,
		autoFold,
		$$slots,
		div1_binding,
		$$scope
	];
}

class Picker extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-k4x60k-style")) add_css$l();

		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {
			placeholder: 1,
			disabled: 2,
			isOpen: 0,
			resultIndex: 11,
			thisIndex: 12,
			isInvalid: 3,
			isQuiet: 4,
			minWidth: 5,
			autoFold: 13
		});
	}
}

/* src/packages/QuickActions/QuickActions.svelte generated by Svelte v3.24.1 */

function create_fragment$1I(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-QuickActions");
			toggle_class(div, "spectrum-QuickActions--textOnly", /*textOnly*/ ctx[1]);
			toggle_class(div, "is-open", /*isOpen*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (dirty & /*textOnly*/ 2) {
				toggle_class(div, "spectrum-QuickActions--textOnly", /*textOnly*/ ctx[1]);
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(div, "is-open", /*isOpen*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1I($$self, $$props, $$invalidate) {
	let { isOpen = false } = $$props;
	let { textOnly = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("textOnly" in $$props) $$invalidate(1, textOnly = $$props.textOnly);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [isOpen, textOnly, $$scope, $$slots];
}

class QuickActions extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, { isOpen: 0, textOnly: 1 });
	}
}

/* src/packages/Rating/Rating.svelte generated by Svelte v3.24.1 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (103:2) {#each startNum as item}
function create_each_block$5(ctx) {
	let span;
	let iconstar;
	let t0;
	let iconstaroutline;
	let t1;
	let current;
	let mounted;
	let dispose;

	iconstar = new Star({
			props: {
				className: "spectrum-UIIcon-StarOutline spectrum-Rating-starActive",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	iconstaroutline = new StarOutline({
			props: {
				className: "spectrum-UIIcon-StarOutline spectrum-Rating-starInactive",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	function click_handler(...args) {
		return /*click_handler*/ ctx[12](/*item*/ ctx[16], ...args);
	}

	return {
		c() {
			span = element("span");
			create_component(iconstar.$$.fragment);
			t0 = space();
			create_component(iconstaroutline.$$.fragment);
			t1 = space();
			attr(span, "class", "spectrum-Rating-icon");
			toggle_class(span, "is-selected", /*item*/ ctx[16] <= /*value*/ ctx[0]);
			toggle_class(span, "is-currentValue", /*item*/ ctx[16] === /*value*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(iconstar, span, null);
			append(span, t0);
			mount_component(iconstaroutline, span, null);
			append(span, t1);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*startNum, value*/ 65) {
				toggle_class(span, "is-selected", /*item*/ ctx[16] <= /*value*/ ctx[0]);
			}

			if (dirty & /*startNum, value*/ 65) {
				toggle_class(span, "is-currentValue", /*item*/ ctx[16] === /*value*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(iconstar.$$.fragment, local);
			transition_in(iconstaroutline.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconstar.$$.fragment, local);
			transition_out(iconstaroutline.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(iconstar);
			destroy_component(iconstaroutline);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$1J(ctx) {
	let div;
	let input;
	let t;
	let current;
	let mounted;
	let dispose;
	let each_value = /*startNum*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(input, "class", "spectrum-Rating-input");
			attr(input, "aria-label", "Rating");
			attr(input, "type", "range");
			attr(input, "min", /*minValue*/ ctx[5]);
			attr(input, "max", /*maxValue*/ ctx[4]);
			input.value = /*value*/ ctx[0];
			input.readOnly = /*readonly*/ ctx[1];
			attr(div, "class", "spectrum-Rating");
			toggle_class(div, "spectrum-Rating--emphasized", /*emphasized*/ ctx[2]);
			toggle_class(div, "is-readOnly", /*readonly*/ ctx[1]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			/*input_binding*/ ctx[11](input);
			append(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[13](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "keydown", /*handleKeydown*/ ctx[10]),
					listen(div, "focusin", /*focusin_handler*/ ctx[14]),
					listen(div, "focusout", /*focusout_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*minValue*/ 32) {
				attr(input, "min", /*minValue*/ ctx[5]);
			}

			if (!current || dirty & /*maxValue*/ 16) {
				attr(input, "max", /*maxValue*/ ctx[4]);
			}

			if (!current || dirty & /*value*/ 1) {
				input.value = /*value*/ ctx[0];
			}

			if (!current || dirty & /*readonly*/ 2) {
				input.readOnly = /*readonly*/ ctx[1];
			}

			if (dirty & /*startNum, value, readonly*/ 67) {
				each_value = /*startNum*/ ctx[6];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*emphasized*/ 4) {
				toggle_class(div, "spectrum-Rating--emphasized", /*emphasized*/ ctx[2]);
			}

			if (dirty & /*readonly*/ 2) {
				toggle_class(div, "is-readOnly", /*readonly*/ ctx[1]);
			}

			if (dirty & /*disabled*/ 8) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*input_binding*/ ctx[11](null);
			destroy_each(each_blocks, detaching);
			/*div_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1J($$self, $$props, $$invalidate) {
	let { readonly = false } = $$props;
	let { emphasized = false } = $$props;
	let { disabled = false } = $$props;
	let { value = 0 } = $$props;
	let { maxValue = 5 } = $$props;
	let { minValue = 0 } = $$props;
	let startNum = [];
	let ratingEl;
	let ratingInputEl;

	beforeUpdate(() => {
		$$invalidate(6, startNum.length = maxValue, startNum);

		for (let index = 0; index < startNum.length; index++) {
			$$invalidate(6, startNum[index] = index + 1, startNum);
		}
	});

	function setFocus(focused) {
		if (disabled) {
			return;
		}

		ratingEl.classList[focused ? "add" : "remove"]("is-focused");
	}

	function handleKeydown(event) {
		if (event.preventDefaulted || readonly || disabled) {
			return;
		}

		switch (event.which) {
			case 38:
				$$invalidate(0, value = value < maxValue ? value + 1 : maxValue);
				break;
			case 39:
				$$invalidate(0, value = value < maxValue ? value + 1 : maxValue);
				break;
			case 40:
				$$invalidate(0, value = value <= minValue + 1 ? minValue : value - 1);
				break;
			case 37:
				$$invalidate(0, value = value <= minValue + 1 ? minValue : value - 1);
				break;
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ratingInputEl = $$value;
			$$invalidate(8, ratingInputEl);
		});
	}

	const click_handler = item => {
		if (readonly) {
			return;
		}

		$$invalidate(0, value = item);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ratingEl = $$value;
			$$invalidate(7, ratingEl);
		});
	}

	const focusin_handler = () => {
		setFocus(true);
	};

	const focusout_handler = () => {
		setFocus(false);
	};

	$$self.$$set = $$props => {
		if ("readonly" in $$props) $$invalidate(1, readonly = $$props.readonly);
		if ("emphasized" in $$props) $$invalidate(2, emphasized = $$props.emphasized);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("maxValue" in $$props) $$invalidate(4, maxValue = $$props.maxValue);
		if ("minValue" in $$props) $$invalidate(5, minValue = $$props.minValue);
	};

	return [
		value,
		readonly,
		emphasized,
		disabled,
		maxValue,
		minValue,
		startNum,
		ratingEl,
		ratingInputEl,
		setFocus,
		handleKeydown,
		input_binding,
		click_handler,
		div_binding,
		focusin_handler,
		focusout_handler
	];
}

class Rating extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, {
			readonly: 1,
			emphasized: 2,
			disabled: 3,
			value: 0,
			maxValue: 4,
			minValue: 5
		});
	}
}

/* src/packages/Radio/Radio.svelte generated by Svelte v3.24.1 */

function add_css$m() {
	var style = element("style");
	style.id = "svelte-ec5zll-style";
	style.textContent = ".spectrum-Radio.is-readonly{pointer-events:none}";
	append(document.head, style);
}

// (63:53) {value}
function fallback_block$b(ctx) {
	let t;

	return {
		c() {
			t = text(/*value*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 64) set_data(t, /*value*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1K(ctx) {
	let div;
	let input;
	let t0;
	let span;
	let t1;
	let label;
	let current;
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const default_slot_or_fallback = default_slot || fallback_block$b(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			label = element("label");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(input, "type", "radio");
			attr(input, "name", /*name*/ ctx[5]);
			attr(input, "class", "spectrum-Radio-input");
			attr(input, "id", /*id*/ ctx[0]);
			input.checked = /*checked*/ ctx[1];
			input.disabled = /*disabled*/ ctx[3];
			input.value = /*value*/ ctx[6];
			input.readOnly = /*readonly*/ ctx[7];
			attr(span, "class", "spectrum-Radio-button");
			attr(label, "class", "spectrum-Radio-label");
			attr(label, "for", /*id*/ ctx[0]);
			attr(div, "class", "spectrum-Radio");
			toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			append(div, t0);
			append(div, span);
			append(div, t1);
			append(div, label);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(label, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 32) {
				attr(input, "name", /*name*/ ctx[5]);
			}

			if (!current || dirty & /*id*/ 1) {
				attr(input, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*checked*/ 2) {
				input.checked = /*checked*/ ctx[1];
			}

			if (!current || dirty & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*value*/ 64) {
				input.value = /*value*/ ctx[6];
			}

			if (!current || dirty & /*readonly*/ 128) {
				input.readOnly = /*readonly*/ ctx[7];
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*value*/ 64) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			}

			if (dirty & /*isInvalid*/ 4) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			}

			if (dirty & /*readonly*/ 128) {
				toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

function instance$1K($$self, $$props, $$invalidate) {
	let { id = `radio-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { checked = false } = $$props;
	let { isInvalid = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { name = "radio" } = $$props;
	let { value = "" } = $$props;
	let { readonly = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly,
		$$scope,
		$$slots
	];
}

class Radio extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-ec5zll-style")) add_css$m();

		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {
			id: 0,
			checked: 1,
			isInvalid: 2,
			disabled: 3,
			isQuiet: 4,
			name: 5,
			value: 6,
			readonly: 7
		});
	}
}

/* src/packages/Search/Search.svelte generated by Svelte v3.24.1 */

function create_default_slot_1$5(ctx) {
	let iconmagnifier;
	let current;

	iconmagnifier = new Magnifier({
			props: {
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconmagnifier.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconmagnifier, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconmagnifier.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconmagnifier.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconmagnifier, detaching);
		}
	};
}

// (77:2) {#if showClearButton}
function create_if_block$N(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				type: "reset",
				exterior: "clear",
				class: "spectrum-Search-clearButton",
				disabled: /*disabled*/ ctx[4],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*disabled*/ 16) button_changes.disabled = /*disabled*/ ctx[4];

			if (dirty & /*$$scope*/ 262144) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (78:4) <Button type="reset" exterior="clear" class="spectrum-Search-clearButton" {disabled}>
function create_default_slot$a(ctx) {
	let iconcrosssmall;
	let current;

	iconcrosssmall = new CrossSmall({
			props: {
				className: "spectrum-Icon spectrum-UIIcon-CrossSmall",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcrosssmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcrosssmall, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconcrosssmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcrosssmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcrosssmall, detaching);
		}
	};
}

function create_fragment$1L(ctx) {
	let form;
	let textfield;
	let updating_value;
	let t;
	let current;

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[9].call(null, value);
	}

	let textfield_props = {
		resetType: "search",
		placeholder: /*placeholder*/ ctx[2],
		name: /*name*/ ctx[3],
		disabled: /*disabled*/ ctx[4],
		isQuiet: /*isQuiet*/ ctx[5],
		autocomplete: /*autocomplete*/ ctx[6],
		inputClass: "spectrum-Search-input",
		$$slots: { default: [create_default_slot_1$5] },
		$$scope: { ctx }
	};

	if (/*value*/ ctx[0] !== void 0) {
		textfield_props.value = /*value*/ ctx[0];
	}

	textfield = new Textfield({ props: textfield_props });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
	textfield.$on("focusin", /*focusin_handler_1*/ ctx[10]);
	textfield.$on("focusout", /*focusout_handler_1*/ ctx[11]);
	textfield.$on("focusin", /*focusin_handler*/ ctx[12]);
	textfield.$on("focusout", /*focusout_handler*/ ctx[13]);
	textfield.$on("input", /*input_handler*/ ctx[14]);
	textfield.$on("change", /*change_handler*/ ctx[15]);
	textfield.$on("keyup", /*keyup_handler*/ ctx[16]);
	textfield.$on("keydown", /*keydown_handler*/ ctx[17]);
	let if_block = /*showClearButton*/ ctx[8] && create_if_block$N(ctx);

	return {
		c() {
			form = element("form");
			create_component(textfield.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(form, "class", "spectrum-Search");
			attr(form, "id", /*id*/ ctx[1]);
			toggle_class(form, "spectrum-Search--quiet", /*isQuiet*/ ctx[5]);
			toggle_class(form, "is-disabled", /*disabled*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, form, anchor);
			mount_component(textfield, form, null);
			append(form, t);
			if (if_block) if_block.m(form, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const textfield_changes = {};
			if (dirty & /*placeholder*/ 4) textfield_changes.placeholder = /*placeholder*/ ctx[2];
			if (dirty & /*name*/ 8) textfield_changes.name = /*name*/ ctx[3];
			if (dirty & /*disabled*/ 16) textfield_changes.disabled = /*disabled*/ ctx[4];
			if (dirty & /*isQuiet*/ 32) textfield_changes.isQuiet = /*isQuiet*/ ctx[5];
			if (dirty & /*autocomplete*/ 64) textfield_changes.autocomplete = /*autocomplete*/ ctx[6];

			if (dirty & /*$$scope*/ 262144) {
				textfield_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty & /*value*/ 1) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (/*showClearButton*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showClearButton*/ 256) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$N(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(form, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*id*/ 2) {
				attr(form, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*isQuiet*/ 32) {
				toggle_class(form, "spectrum-Search--quiet", /*isQuiet*/ ctx[5]);
			}

			if (dirty & /*disabled*/ 16) {
				toggle_class(form, "is-disabled", /*disabled*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(textfield.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			destroy_component(textfield);
			if (if_block) if_block.d();
		}
	};
}

function instance$1L($$self, $$props, $$invalidate) {
	let { id = `search-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { placeholder = "Search" } = $$props;
	let { name = "search" } = $$props;
	let { value = "" } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { autocomplete = "off" } = $$props;
	let focused = false;

	function textfield_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	const focusin_handler_1 = () => {
		$$invalidate(7, focused = true);
	};

	const focusout_handler_1 = () => {
		$$invalidate(7, focused = false);
	};

	function focusin_handler(event) {
		bubble($$self, event);
	}

	function focusout_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(5, isQuiet = $$props.isQuiet);
		if ("autocomplete" in $$props) $$invalidate(6, autocomplete = $$props.autocomplete);
	};

	let showClearButton;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*focused, value*/ 129) {
			 $$invalidate(8, showClearButton = focused && value || value);
		}
	};

	return [
		value,
		id,
		placeholder,
		name,
		disabled,
		isQuiet,
		autocomplete,
		focused,
		showClearButton,
		textfield_value_binding,
		focusin_handler_1,
		focusout_handler_1,
		focusin_handler,
		focusout_handler,
		input_handler,
		change_handler,
		keyup_handler,
		keydown_handler
	];
}

class Search extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {
			id: 1,
			placeholder: 2,
			name: 3,
			value: 0,
			disabled: 4,
			isQuiet: 5,
			autocomplete: 6
		});
	}
}

/* src/packages/SearchWithin/SearchWithin.svelte generated by Svelte v3.24.1 */

function add_css$n() {
	var style = element("style");
	style.id = "svelte-1kjfhrt-style";
	style.textContent = ".spectrum-SearchWithin-input::-webkit-search-cancel-button,.spectrum-SearchWithin-input::-webkit-search-decoration{-webkit-appearance:none}";
	append(document.head, style);
}

// (75:2) {#if showClearButton}
function create_if_block$O(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				type: "reset",
				exterior: "clear",
				class: "spectrum-SearchWithin-clearButton",
				disabled: /*disabled*/ ctx[4],
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*disabled*/ 16) button_changes.disabled = /*disabled*/ ctx[4];

			if (dirty & /*$$scope*/ 262144) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (76:4) <Button type="reset" exterior="clear" class="spectrum-SearchWithin-clearButton" {disabled}>
function create_default_slot$b(ctx) {
	let iconcrosssmall;
	let current;

	iconcrosssmall = new CrossSmall({
			props: {
				className: "spectrum-UIIcon-CrossSmall",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcrosssmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcrosssmall, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconcrosssmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcrosssmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcrosssmall, detaching);
		}
	};
}

function create_fragment$1M(ctx) {
	let form;
	let t0;
	let textfield;
	let updating_value;
	let t1;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[9].call(null, value);
	}

	let textfield_props = {
		resetType: "search",
		placeholder: /*placeholder*/ ctx[2],
		name: /*name*/ ctx[3],
		disabled: /*disabled*/ ctx[4],
		autocomplete: /*autocomplete*/ ctx[5],
		inputClass: "spectrum-SearchWithin-input"
	};

	if (/*value*/ ctx[0] !== void 0) {
		textfield_props.value = /*value*/ ctx[0];
	}

	textfield = new Textfield({ props: textfield_props });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
	textfield.$on("focusin", /*focusin_handler_1*/ ctx[10]);
	textfield.$on("focusout", /*focusout_handler_1*/ ctx[11]);
	textfield.$on("focusin", /*focusin_handler*/ ctx[12]);
	textfield.$on("focusout", /*focusout_handler*/ ctx[13]);
	textfield.$on("input", /*input_handler*/ ctx[14]);
	textfield.$on("change", /*change_handler*/ ctx[15]);
	textfield.$on("keyup", /*keyup_handler*/ ctx[16]);
	textfield.$on("keydown", /*keydown_handler*/ ctx[17]);
	let if_block = /*showClearButton*/ ctx[7] && create_if_block$O(ctx);

	return {
		c() {
			form = element("form");
			if (default_slot) default_slot.c();
			t0 = space();
			create_component(textfield.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			attr(form, "class", "spectrum-SearchWithin");
			attr(form, "id", /*id*/ ctx[1]);
			toggle_class(form, "is-disabled", /*disabled*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			append(form, t0);
			mount_component(textfield, form, null);
			append(form, t1);
			if (if_block) if_block.m(form, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, null, null);
				}
			}

			const textfield_changes = {};
			if (dirty & /*placeholder*/ 4) textfield_changes.placeholder = /*placeholder*/ ctx[2];
			if (dirty & /*name*/ 8) textfield_changes.name = /*name*/ ctx[3];
			if (dirty & /*disabled*/ 16) textfield_changes.disabled = /*disabled*/ ctx[4];
			if (dirty & /*autocomplete*/ 32) textfield_changes.autocomplete = /*autocomplete*/ ctx[5];

			if (!updating_value && dirty & /*value*/ 1) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (/*showClearButton*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showClearButton*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$O(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(form, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*id*/ 2) {
				attr(form, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*disabled*/ 16) {
				toggle_class(form, "is-disabled", /*disabled*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			if (default_slot) default_slot.d(detaching);
			destroy_component(textfield);
			if (if_block) if_block.d();
		}
	};
}

function instance$1M($$self, $$props, $$invalidate) {
	let { id = `searchwithin-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { placeholder = "Search" } = $$props;
	let { name = "search" } = $$props;
	let { value = "" } = $$props;
	let { disabled = false } = $$props;
	let { autocomplete = "off" } = $$props;
	let focused = false;
	let { $$slots = {}, $$scope } = $$props;

	function textfield_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	const focusin_handler_1 = () => {
		$$invalidate(6, focused = true);
	};

	const focusout_handler_1 = () => {
		$$invalidate(6, focused = false);
	};

	function focusin_handler(event) {
		bubble($$self, event);
	}

	function focusout_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ("autocomplete" in $$props) $$invalidate(5, autocomplete = $$props.autocomplete);
		if ("$$scope" in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	};

	let showClearButton;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*focused, value*/ 65) {
			 $$invalidate(7, showClearButton = focused && value || value);
		}
	};

	return [
		value,
		id,
		placeholder,
		name,
		disabled,
		autocomplete,
		focused,
		showClearButton,
		$$slots,
		textfield_value_binding,
		focusin_handler_1,
		focusout_handler_1,
		focusin_handler,
		focusout_handler,
		input_handler,
		change_handler,
		keyup_handler,
		keydown_handler,
		$$scope
	];
}

class SearchWithin extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1kjfhrt-style")) add_css$n();

		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {
			id: 1,
			placeholder: 2,
			name: 3,
			value: 0,
			disabled: 4,
			autocomplete: 5
		});
	}
}

/* src/packages/SideNav/SideNav.svelte generated by Svelte v3.24.1 */

function create_fragment$1N(ctx) {
	let nav;
	let current;
	const default_slot_template = /*$$slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			nav = element("nav");
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			insert(target, nav, anchor);

			if (default_slot) {
				default_slot.m(nav, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1N($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, $$slots];
}

class SideNav extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, {});
	}
}

/* src/packages/SideNav/SideNavItem.svelte generated by Svelte v3.24.1 */
const get_sidenav_child_slot_changes = dirty => ({});
const get_sidenav_child_slot_context = ctx => ({});

// (46:88) {label}
function fallback_block$c(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data(t, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1O(ctx) {
	let li;
	let a;
	let a_aria_current_value;
	let t;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$c(ctx);
	const sidenav_child_slot_template = /*$$slots*/ ctx[7]["sidenav-child"];
	const sidenav_child_slot = create_slot(sidenav_child_slot_template, ctx, /*$$scope*/ ctx[6], get_sidenav_child_slot_context);

	return {
		c() {
			li = element("li");
			a = element("a");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			if (sidenav_child_slot) sidenav_child_slot.c();
			attr(a, "href", /*href*/ ctx[3]);
			attr(a, "class", "spectrum-SideNav-itemLink");
			attr(a, "aria-current", a_aria_current_value = /*isSelected*/ ctx[1] && "page");
			attr(li, "class", "spectrum-SideNav-item");
			toggle_class(li, "is-selected", /*isSelected*/ ctx[1]);
			toggle_class(li, "is-disabled", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(a, null);
			}

			append(li, t);

			if (sidenav_child_slot) {
				sidenav_child_slot.m(li, null);
			}

			/*li_binding*/ ctx[8](li);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[5].call(null, li));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 1) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*href*/ 8) {
				attr(a, "href", /*href*/ ctx[3]);
			}

			if (!current || dirty & /*isSelected*/ 2 && a_aria_current_value !== (a_aria_current_value = /*isSelected*/ ctx[1] && "page")) {
				attr(a, "aria-current", a_aria_current_value);
			}

			if (sidenav_child_slot) {
				if (sidenav_child_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(sidenav_child_slot, sidenav_child_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_sidenav_child_slot_changes, get_sidenav_child_slot_context);
				}
			}

			if (dirty & /*isSelected*/ 2) {
				toggle_class(li, "is-selected", /*isSelected*/ ctx[1]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(li, "is-disabled", /*disabled*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			transition_in(sidenav_child_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			transition_out(sidenav_child_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (sidenav_child_slot) sidenav_child_slot.d(detaching);
			/*li_binding*/ ctx[8](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$1O($$self, $$props, $$invalidate) {
	let { label = "" } = $$props;
	let { isSelected = false } = $$props;
	let { disabled = false } = $$props;
	let { href = "#" } = $$props;
	let sideNavItemEl;
	const eventsListen = getEventsAction(current_component);

	afterUpdate(() => {
		if (sideNavItemEl && sideNavItemEl.getElementsByTagName("svg").length) {
			let sideNavItemIcon = sideNavItemEl && sideNavItemEl.getElementsByTagName("svg")[0];
			sideNavItemIcon.classList.toggle("spectrum-SideNav-itemIcon");
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			sideNavItemEl = $$value;
			$$invalidate(4, sideNavItemEl);
		});
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("isSelected" in $$props) $$invalidate(1, isSelected = $$props.isSelected);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("href" in $$props) $$invalidate(3, href = $$props.href);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		label,
		isSelected,
		disabled,
		href,
		sideNavItemEl,
		eventsListen,
		$$scope,
		$$slots,
		li_binding
	];
}

class SideNavItem extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {
			label: 0,
			isSelected: 1,
			disabled: 2,
			href: 3
		});
	}
}

/* src/packages/SideNav/SideNavGroup.svelte generated by Svelte v3.24.1 */

function create_if_block$P(ctx) {
	let h2;
	let t;

	return {
		c() {
			h2 = element("h2");
			t = text(/*title*/ ctx[1]);
			attr(h2, "class", "spectrum-SideNav-heading");
			attr(h2, "id", /*id*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t, /*title*/ ctx[1]);

			if (dirty & /*id*/ 4) {
				attr(h2, "id", /*id*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

function create_fragment$1P(ctx) {
	let t;
	let ul;
	let ul_aria_labelledby_value;
	let current;
	let if_block = /*title*/ ctx[1] && create_if_block$P(ctx);
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", "spectrum-SideNav");
			attr(ul, "aria-labelledby", ul_aria_labelledby_value = /*title*/ ctx[1] && /*id*/ ctx[2]);
			toggle_class(ul, "spectrum-SideNav--multiLevel", /*multiLevel*/ ctx[0]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*title*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$P(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*title, id*/ 6 && ul_aria_labelledby_value !== (ul_aria_labelledby_value = /*title*/ ctx[1] && /*id*/ ctx[2])) {
				attr(ul, "aria-labelledby", ul_aria_labelledby_value);
			}

			if (dirty & /*multiLevel*/ 1) {
				toggle_class(ul, "spectrum-SideNav--multiLevel", /*multiLevel*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1P($$self, $$props, $$invalidate) {
	let { multiLevel = false } = $$props;
	let { title = "" } = $$props;
	let { id = `nav-heading-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("multiLevel" in $$props) $$invalidate(0, multiLevel = $$props.multiLevel);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [multiLevel, title, id, $$scope, $$slots];
}

class SideNavGroup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, { multiLevel: 0, title: 1, id: 2 });
	}
}

/* src/packages/Slider/Slider.svelte generated by Svelte v3.24.1 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	return child_ctx;
}

// (294:2) {#if label}
function create_if_block_5$3(ctx) {
	let div1;
	let label_1;
	let t0;
	let label_1_id_value;
	let label_1_for_value;
	let t1;
	let div0;

	let t2_value = (/*variants*/ ctx[6] === "range"
	? /*rangeValue*/ ctx[1][0] + "-" + /*rangeValue*/ ctx[1][1]
	: /*value*/ ctx[0]) + "";

	let t2;
	let div0_aria_labelledby_value;

	return {
		c() {
			div1 = element("div");
			label_1 = element("label");
			t0 = text(/*label*/ ctx[4]);
			t1 = space();
			div0 = element("div");
			t2 = text(t2_value);
			attr(label_1, "class", "spectrum-Slider-label");
			attr(label_1, "id", label_1_id_value = "spectrum-Slider-label-" + /*id*/ ctx[3]);
			attr(label_1, "for", label_1_for_value = "spectrum-Slider-input-" + /*id*/ ctx[3]);
			attr(div0, "class", "spectrum-Slider-value");
			attr(div0, "role", "textbox");
			attr(div0, "aria-readonly", "true");
			attr(div0, "aria-labelledby", div0_aria_labelledby_value = "spectrum-Slider-label-" + /*id*/ ctx[3]);
			attr(div1, "class", "spectrum-Slider-labelContainer");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, label_1);
			append(label_1, t0);
			append(div1, t1);
			append(div1, div0);
			append(div0, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 16) set_data(t0, /*label*/ ctx[4]);

			if (dirty[0] & /*id*/ 8 && label_1_id_value !== (label_1_id_value = "spectrum-Slider-label-" + /*id*/ ctx[3])) {
				attr(label_1, "id", label_1_id_value);
			}

			if (dirty[0] & /*id*/ 8 && label_1_for_value !== (label_1_for_value = "spectrum-Slider-input-" + /*id*/ ctx[3])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (dirty[0] & /*variants, rangeValue, value*/ 67 && t2_value !== (t2_value = (/*variants*/ ctx[6] === "range"
			? /*rangeValue*/ ctx[1][0] + "-" + /*rangeValue*/ ctx[1][1]
			: /*value*/ ctx[0]) + "")) set_data(t2, t2_value);

			if (dirty[0] & /*id*/ 8 && div0_aria_labelledby_value !== (div0_aria_labelledby_value = "spectrum-Slider-label-" + /*id*/ ctx[3])) {
				attr(div0, "aria-labelledby", div0_aria_labelledby_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (311:4) {#if variants === 'tick' || variants === 'tick-with-label'}
function create_if_block_3$8(ctx) {
	let div;
	let each_value = /*ticks*/ ctx[17];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "spectrum-Slider-ticks");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*ticks, variants*/ 131136) {
				each_value = /*ticks*/ ctx[17];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (315:12) {#if variants === 'tick-with-label'}
function create_if_block_4$5(ctx) {
	let div;
	let t_value = /*tickItem*/ ctx[31] + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "spectrum-Slider-tickLabel");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*ticks*/ 131072 && t_value !== (t_value = /*tickItem*/ ctx[31] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (313:8) {#each ticks as tickItem}
function create_each_block$6(ctx) {
	let div;
	let t;
	let if_block = /*variants*/ ctx[6] === "tick-with-label" && create_if_block_4$5(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			attr(div, "class", "spectrum-Slider-tick");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);
		},
		p(ctx, dirty) {
			if (/*variants*/ ctx[6] === "tick-with-label") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$5(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

// (322:4) {#if variants === 'ramp'}
function create_if_block_2$a(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<svg viewBox="0 0 240 16" preserveAspectRatio="none" aria-hidden="true" focusable="false"><path d="M240,4v8c0,2.3-1.9,4.1-4.2,4L1,9C0.4,9,0,8.5,0,8c0-0.5,0.4-1,1-1l234.8-7C238.1-0.1,240,1.7,240,4z"></path></svg>`;
			attr(div, "class", "spectrum-Slider-ramp");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (345:4) {#if variants === 'range'}
function create_if_block_1$J(ctx) {
	let div0;
	let div0_style_value;
	let t;
	let div1;
	let input;
	let input_value_value;
	let input_aria_labelledby_value;

	return {
		c() {
			div0 = element("div");
			t = space();
			div1 = element("div");
			input = element("input");
			attr(div0, "class", "spectrum-Slider-track 01");
			attr(div0, "style", div0_style_value = `left:${/*sliderHandleAmount*/ ctx[8]}%;width:${/*expendAmountAnother*/ ctx[12]}%;`);
			attr(input, "type", "range");
			attr(input, "class", "spectrum-Slider-input");
			input.value = input_value_value = /*rangeValue*/ ctx[1][1];
			attr(input, "step", "2");
			attr(input, "min", /*minValue*/ ctx[7]);
			attr(input, "max", /*maxValue*/ ctx[2]);
			attr(input, "id", "spectrum-Slider-input-8-1");
			attr(input, "aria-labelledby", input_aria_labelledby_value = "spectrum-Slider-label-" + /*id*/ ctx[3] + " spectrum-Slider-input-" + /*id*/ ctx[3] + "-1");
			attr(div1, "class", "spectrum-Slider-handle spectrum-Slider-handle-another");
			attr(div1, "role", "presentation");
			set_style(div1, "left", /*sliderHandleAmountAnother*/ ctx[13] + "%");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			append(div1, input);
			/*div1_binding_1*/ ctx[21](div1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*sliderHandleAmount, expendAmountAnother*/ 4352 && div0_style_value !== (div0_style_value = `left:${/*sliderHandleAmount*/ ctx[8]}%;width:${/*expendAmountAnother*/ ctx[12]}%;`)) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty[0] & /*rangeValue*/ 2 && input_value_value !== (input_value_value = /*rangeValue*/ ctx[1][1])) {
				input.value = input_value_value;
			}

			if (dirty[0] & /*minValue*/ 128) {
				attr(input, "min", /*minValue*/ ctx[7]);
			}

			if (dirty[0] & /*maxValue*/ 4) {
				attr(input, "max", /*maxValue*/ ctx[2]);
			}

			if (dirty[0] & /*id*/ 8 && input_aria_labelledby_value !== (input_aria_labelledby_value = "spectrum-Slider-label-" + /*id*/ ctx[3] + " spectrum-Slider-input-" + /*id*/ ctx[3] + "-1")) {
				attr(input, "aria-labelledby", input_aria_labelledby_value);
			}

			if (dirty[0] & /*sliderHandleAmountAnother*/ 8192) {
				set_style(div1, "left", /*sliderHandleAmountAnother*/ ctx[13] + "%");
			}
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			/*div1_binding_1*/ ctx[21](null);
		}
	};
}

// (364:4) {#if variants === 'filled-offset'}
function create_if_block$Q(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "spectrum-Slider-fill");

			attr(div, "style", div_style_value = "" + ((/*value*/ ctx[0] < 0
			? `left: ${/*maxValue*/ ctx[2] / 2 - /*sliderFillWidth*/ ctx[11]}%;`
			: `left: 50%;`) + " width: " + /*sliderFillWidth*/ ctx[11] + "%"));

			toggle_class(div, "spectrum-Slider-fill--right", /*value*/ ctx[0] > 0);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value, maxValue, sliderFillWidth*/ 2053 && div_style_value !== (div_style_value = "" + ((/*value*/ ctx[0] < 0
			? `left: ${/*maxValue*/ ctx[2] / 2 - /*sliderFillWidth*/ ctx[11]}%;`
			: `left: 50%;`) + " width: " + /*sliderFillWidth*/ ctx[11] + "%"))) {
				attr(div, "style", div_style_value);
			}

			if (dirty[0] & /*value*/ 1) {
				toggle_class(div, "spectrum-Slider-fill--right", /*value*/ ctx[0] > 0);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$1Q(ctx) {
	let div4;
	let t0;
	let div3;
	let div0;
	let t1;
	let t2;
	let t3;
	let div1;
	let input;
	let input_value_value;
	let input_id_value;
	let input_aria_labelledby_value;
	let t4;
	let t5;
	let div2;
	let t6;
	let div4_aria_labelledby_value;
	let if_block0 = /*label*/ ctx[4] && create_if_block_5$3(ctx);
	let if_block1 = (/*variants*/ ctx[6] === "tick" || /*variants*/ ctx[6] === "tick-with-label") && create_if_block_3$8(ctx);
	let if_block2 = /*variants*/ ctx[6] === "ramp" && create_if_block_2$a();
	let if_block3 = /*variants*/ ctx[6] === "range" && create_if_block_1$J(ctx);
	let if_block4 = /*variants*/ ctx[6] === "filled-offset" && create_if_block$Q(ctx);

	return {
		c() {
			div4 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div3 = element("div");
			div0 = element("div");
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			div1 = element("div");
			input = element("input");
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			div2 = element("div");
			t6 = space();
			if (if_block4) if_block4.c();
			attr(div0, "class", "spectrum-Slider-track");
			set_style(div0, "width", /*expendAmount*/ ctx[9] + "%");
			attr(input, "type", "range");
			attr(input, "class", "spectrum-Slider-input");

			input.value = input_value_value = /*variants*/ ctx[6] === "range"
			? /*rangeValue*/ ctx[1][0]
			: /*value*/ ctx[0];

			attr(input, "step", "2");
			attr(input, "min", /*minValue*/ ctx[7]);
			attr(input, "max", /*maxValue*/ ctx[2]);
			attr(input, "id", input_id_value = "spectrum-Slider-input-" + /*id*/ ctx[3]);
			attr(input, "aria-labelledby", input_aria_labelledby_value = "spectrum-Slider-label-8 spectrum-Slider-input-" + /*id*/ ctx[3]);
			attr(div1, "class", "spectrum-Slider-handle spectrum-Slider-handle-main");
			attr(div1, "role", "presentation");
			set_style(div1, "left", /*sliderHandleAmount*/ ctx[8] + "%");
			attr(div2, "class", "spectrum-Slider-track");
			set_style(div2, "width", /*remainderAmount*/ ctx[10] + "%");
			attr(div3, "class", "spectrum-Slider-controls");
			attr(div3, "role", "presentation");
			attr(div4, "class", "spectrum-Slider");
			attr(div4, "aria-labelledby", div4_aria_labelledby_value = "spectrum-Slider-label-" + /*id*/ ctx[3]);
			attr(div4, "role", "group");
			set_style(div4, "width", "400px");
			toggle_class(div4, "spectrum-Slider--filled", /*variants*/ ctx[6] === "filled");
			toggle_class(div4, "spectrum-Slider--range", /*variants*/ ctx[6] === "range");
			toggle_class(div4, "spectrum-Slider--tick", /*variants*/ ctx[6] === "tick");
			toggle_class(div4, "spectrum-Slider--ramp", /*variants*/ ctx[6] === "ramp");
			toggle_class(div4, "is-disabled", /*disabled*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			if (if_block0) if_block0.m(div4, null);
			append(div4, t0);
			append(div4, div3);
			append(div3, div0);
			append(div3, t1);
			if (if_block1) if_block1.m(div3, null);
			append(div3, t2);
			if (if_block2) if_block2.m(div3, null);
			append(div3, t3);
			append(div3, div1);
			append(div1, input);
			/*div1_binding*/ ctx[20](div1);
			append(div3, t4);
			if (if_block3) if_block3.m(div3, null);
			append(div3, t5);
			append(div3, div2);
			append(div3, t6);
			if (if_block4) if_block4.m(div3, null);
			/*div4_binding*/ ctx[22](div4);
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5$3(ctx);
					if_block0.c();
					if_block0.m(div4, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*expendAmount*/ 512) {
				set_style(div0, "width", /*expendAmount*/ ctx[9] + "%");
			}

			if (/*variants*/ ctx[6] === "tick" || /*variants*/ ctx[6] === "tick-with-label") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$8(ctx);
					if_block1.c();
					if_block1.m(div3, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*variants*/ ctx[6] === "ramp") {
				if (if_block2) ; else {
					if_block2 = create_if_block_2$a();
					if_block2.c();
					if_block2.m(div3, t3);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*variants, rangeValue, value*/ 67 && input_value_value !== (input_value_value = /*variants*/ ctx[6] === "range"
			? /*rangeValue*/ ctx[1][0]
			: /*value*/ ctx[0])) {
				input.value = input_value_value;
			}

			if (dirty[0] & /*minValue*/ 128) {
				attr(input, "min", /*minValue*/ ctx[7]);
			}

			if (dirty[0] & /*maxValue*/ 4) {
				attr(input, "max", /*maxValue*/ ctx[2]);
			}

			if (dirty[0] & /*id*/ 8 && input_id_value !== (input_id_value = "spectrum-Slider-input-" + /*id*/ ctx[3])) {
				attr(input, "id", input_id_value);
			}

			if (dirty[0] & /*id*/ 8 && input_aria_labelledby_value !== (input_aria_labelledby_value = "spectrum-Slider-label-8 spectrum-Slider-input-" + /*id*/ ctx[3])) {
				attr(input, "aria-labelledby", input_aria_labelledby_value);
			}

			if (dirty[0] & /*sliderHandleAmount*/ 256) {
				set_style(div1, "left", /*sliderHandleAmount*/ ctx[8] + "%");
			}

			if (/*variants*/ ctx[6] === "range") {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1$J(ctx);
					if_block3.c();
					if_block3.m(div3, t5);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*remainderAmount*/ 1024) {
				set_style(div2, "width", /*remainderAmount*/ ctx[10] + "%");
			}

			if (/*variants*/ ctx[6] === "filled-offset") {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block$Q(ctx);
					if_block4.c();
					if_block4.m(div3, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (dirty[0] & /*id*/ 8 && div4_aria_labelledby_value !== (div4_aria_labelledby_value = "spectrum-Slider-label-" + /*id*/ ctx[3])) {
				attr(div4, "aria-labelledby", div4_aria_labelledby_value);
			}

			if (dirty[0] & /*variants*/ 64) {
				toggle_class(div4, "spectrum-Slider--filled", /*variants*/ ctx[6] === "filled");
			}

			if (dirty[0] & /*variants*/ 64) {
				toggle_class(div4, "spectrum-Slider--range", /*variants*/ ctx[6] === "range");
			}

			if (dirty[0] & /*variants*/ 64) {
				toggle_class(div4, "spectrum-Slider--tick", /*variants*/ ctx[6] === "tick");
			}

			if (dirty[0] & /*variants*/ 64) {
				toggle_class(div4, "spectrum-Slider--ramp", /*variants*/ ctx[6] === "ramp");
			}

			if (dirty[0] & /*disabled*/ 32) {
				toggle_class(div4, "is-disabled", /*disabled*/ ctx[5]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div4);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*div1_binding*/ ctx[20](null);
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			/*div4_binding*/ ctx[22](null);
		}
	};
}

function instance$1Q($$self, $$props, $$invalidate) {
	let { id = Math.round(Math.random() * (99 - 0)) + 0 } = $$props;
	let { label = "" } = $$props;
	let { value = 0 } = $$props;
	let { rangeValue = [] } = $$props;
	let { disabled = false } = $$props;
	let { variants = "basic" } = $$props;
	let { tickTotal = 5 } = $$props;
	let { tickRestrict = false } = $$props;
	let { maxValue = 100 } = $$props;
	let { minValue = 0 } = $$props;
	let sliderHandleAmount = 50;
	let isMain = false;
	let isAnother = false;

	function handleSliderAction(e) {
		if (disabled) {
			return;
		}

		isMain = e.target.classList.contains("spectrum-Slider-handle-main");
		isAnother = e.target.classList.contains("spectrum-Slider-handle-another");
		getSliderPosition(e);
		window.addEventListener("mousemove", getSliderPosition);
		window.addEventListener("mouseup", removeGetSliderPositionEvent);
	}

	let expendAmount = 50;
	let remainderAmount = 50;
	let sliderFillWidth = 0;
	let expendAmountAnother = 100;
	let sliderHandleAmountAnother = 100;
	let posValue = 50;
	let posAnotherValue = 50;

	function getSliderPosition(e) {
		e.preventDefault();
		document.body.classList.add("u-isGrabbing");
		const thisRect = sliderEl.getBoundingClientRect();
		let _pageP =  e.pageX ;

		let _orientation =  thisRect.left
		;

		let _crisscross =  thisRect.width
		;

		let _p = _pageP - _orientation;

		if (_p > _crisscross) {
			_p = _crisscross;
		}

		if (_p < 0) {
			_p = 0;
		}

		if (variants === "basic" || variants === "filled" || variants === "tick" || variants === "tick-with-label" || variants === "ramp") {
			 $$invalidate(8, sliderHandleAmount = _p / _crisscross * maxValue) && (posValue = _p / _crisscross * maxValue)
			;

			$$invalidate(0, value = parseInt(posValue, 10));
		}

		if (variants === "filled-offset") {
			 $$invalidate(8, sliderHandleAmount = _p / _crisscross * maxValue) && (posValue = _p / _crisscross * maxValue)
			;

			if (posValue < maxValue / 2) {
				if (posValue === minValue) {
					$$invalidate(0, value = -1 * (maxValue / 2));
				} else {
					$$invalidate(0, value = -1 * (maxValue / 2) + posValue);
				}
			}

			if (posValue > maxValue / 2) {
				if (posValue >= maxValue) {
					$$invalidate(0, value = posValue - maxValue / 2 - 1);
				} else {
					$$invalidate(0, value = posValue - maxValue / 2);
				}
			}

			$$invalidate(0, value = parseInt(value, 10));
		}

		if (variants === "range") {
			let stintValue = _p / _crisscross * maxValue;

			{
				if (isMain) {
					$$invalidate(8, sliderHandleAmount = _p / _crisscross * maxValue);
					posValue = _p / _crisscross * maxValue;
					$$invalidate(1, rangeValue[0] = parseInt(posValue, 10), rangeValue);

					if (rangeValue[0] >= rangeValue[1]) {
						$$invalidate(1, rangeValue[0] = rangeValue[1] - 1, rangeValue);
					}
				} else if (isAnother) {
					$$invalidate(13, sliderHandleAmountAnother = _p / _crisscross * maxValue);
					posAnotherValue = _p / _crisscross * maxValue;
					$$invalidate(1, rangeValue[1] = parseInt(posAnotherValue, 10), rangeValue);

					if (rangeValue[1] <= rangeValue[0]) {
						$$invalidate(1, rangeValue[1] = rangeValue[0] + 1, rangeValue);
					}
				} else {
					if (stintValue < posValue) {
						$$invalidate(8, sliderHandleAmount = _p / _crisscross * maxValue);
						posValue = _p / _crisscross * maxValue;
						$$invalidate(1, rangeValue[0] = parseInt(posValue, 10), rangeValue);

						if (rangeValue[0] >= rangeValue[1]) {
							$$invalidate(1, rangeValue[0] = rangeValue[1] - 1, rangeValue);
						}
					} else if (stintValue !== posValue) {
						$$invalidate(13, sliderHandleAmountAnother = _p / _crisscross * maxValue);
						posAnotherValue = _p / _crisscross * maxValue;
						$$invalidate(1, rangeValue[1] = parseInt(posAnotherValue, 10), rangeValue);

						if (rangeValue[1] <= rangeValue[0]) {
							$$invalidate(1, rangeValue[1] = rangeValue[0] + 1, rangeValue);
						}
					}
				}
			}
		}
	}

	function removeGetSliderPositionEvent(e) {
		document.body.classList.remove("u-isGrabbing");
		window.removeEventListener("mousemove", getSliderPosition);
		isMain = false;
		isAnother = false;

		if ((variants === "tick" || variants === "tick-with-label") && tickRestrict) {
			let fl = value;
			let times = 0;
			let times2 = 0;
			let thisTickIndex = 0;

			for (let index = 0; index < ticks[1]; index++) {
				if (ticks.indexOf(fl + index) !== -1) {
					times = index;
					thisTickIndex = ticks.indexOf(fl + index);
				}
			}

			for (let index = 0; index < ticks[1]; index++) {
				if (ticks.indexOf(fl - index) !== -1) {
					times2 = index;
				}
			}

			if (times > times2) {
				$$invalidate(0, value = ticks[thisTickIndex - 1]);
			} else {
				$$invalidate(0, value = ticks[thisTickIndex]);
			}

			$$invalidate(1, rangeValue = [ticks[thisTickIndex - 1], ticks[thisTickIndex]]);
		}
	}

	function getTrackRect() {
		if (variants === "basic" || variants === "filled" || variants === "tick" || variants === "tick-with-label" || variants === "ramp") {
			$$invalidate(9, expendAmount = value);
			$$invalidate(8, sliderHandleAmount = value);
			$$invalidate(10, remainderAmount = maxValue - expendAmount);
		}

		if (variants === "basic" || variants === "filled" || variants === "ramp") {
			$$invalidate(1, rangeValue = [minValue, maxValue]);
		}

		if (variants === "filled-offset") {
			if (value < 0) {
				posValue = maxValue / 2 - Math.abs(value);
			}

			if (value > 0) {
				posValue = maxValue / 2 + value;
			}

			$$invalidate(9, expendAmount = posValue);
			$$invalidate(8, sliderHandleAmount = posValue);
			$$invalidate(10, remainderAmount = maxValue - expendAmount);
			$$invalidate(11, sliderFillWidth = Math.abs(posValue - maxValue / 2));
			$$invalidate(1, rangeValue = [expendAmount, remainderAmount]);
		}

		if (variants === "range") {
			$$invalidate(9, expendAmount = rangeValue[0]);
			$$invalidate(8, sliderHandleAmount = rangeValue[0]);
			$$invalidate(12, expendAmountAnother = Math.abs(100 - rangeValue[1] - (100 - expendAmount)));
			$$invalidate(13, sliderHandleAmountAnother = rangeValue[1]);
			$$invalidate(10, remainderAmount = 100 - sliderHandleAmountAnother);
		}
	}

	let sliderEl;
	let sliderHandleEl;
	let sliderHandleAnotherEl;
	let ticks = [];

	onMount(() => {
		sliderEl.addEventListener("mousedown", function (e) {
			handleSliderAction(e);
		});

		if (variants === "filled-offset") {
			$$invalidate(2, maxValue += (maxValue - minValue) * 0.02);
		}

		if (variants === "range") {
			if (!rangeValue.length) {
				$$invalidate(1, rangeValue = [minValue, maxValue]);
			}
		}

		if (variants === "tick" || variants === "tick-with-label") {
			$$invalidate(17, ticks.length = tickTotal, ticks);

			for (let index = 0; index < tickTotal + 1; index++) {
				$$invalidate(17, ticks[index] = parseInt((maxValue - minValue) / tickTotal * index, 10), ticks);
			}

			if (!rangeValue.length) {
				$$invalidate(1, rangeValue = [minValue, maxValue]);
			}
		}
	});

	afterUpdate(() => {
		getTrackRect();
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			sliderHandleEl = $$value;
			$$invalidate(15, sliderHandleEl);
		});
	}

	function div1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			sliderHandleAnotherEl = $$value;
			$$invalidate(16, sliderHandleAnotherEl);
		});
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			sliderEl = $$value;
			$$invalidate(14, sliderEl);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("label" in $$props) $$invalidate(4, label = $$props.label);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("rangeValue" in $$props) $$invalidate(1, rangeValue = $$props.rangeValue);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ("variants" in $$props) $$invalidate(6, variants = $$props.variants);
		if ("tickTotal" in $$props) $$invalidate(18, tickTotal = $$props.tickTotal);
		if ("tickRestrict" in $$props) $$invalidate(19, tickRestrict = $$props.tickRestrict);
		if ("maxValue" in $$props) $$invalidate(2, maxValue = $$props.maxValue);
		if ("minValue" in $$props) $$invalidate(7, minValue = $$props.minValue);
	};

	return [
		value,
		rangeValue,
		maxValue,
		id,
		label,
		disabled,
		variants,
		minValue,
		sliderHandleAmount,
		expendAmount,
		remainderAmount,
		sliderFillWidth,
		expendAmountAnother,
		sliderHandleAmountAnother,
		sliderEl,
		sliderHandleEl,
		sliderHandleAnotherEl,
		ticks,
		tickTotal,
		tickRestrict,
		div1_binding,
		div1_binding_1,
		div4_binding
	];
}

class Slider extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$1Q,
			create_fragment$1Q,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				value: 0,
				rangeValue: 1,
				disabled: 5,
				variants: 6,
				tickTotal: 18,
				tickRestrict: 19,
				maxValue: 2,
				minValue: 7
			},
			[-1, -1]
		);
	}
}

/* src/packages/SplitButton/SplitButton.svelte generated by Svelte v3.24.1 */
const get_splitbutton_trigger_slot_changes_1 = dirty => ({});
const get_splitbutton_trigger_slot_context_1 = ctx => ({});
const get_splitbutton_trigger_slot_changes = dirty => ({});
const get_splitbutton_trigger_slot_context = ctx => ({});

// (87:2) {:else}
function create_else_block$b(ctx) {
	let t;
	let button;
	let current;
	const splitbutton_trigger_slot_template = /*$$slots*/ ctx[5]["splitbutton-trigger"];
	const splitbutton_trigger_slot = create_slot(splitbutton_trigger_slot_template, ctx, /*$$scope*/ ctx[11], get_splitbutton_trigger_slot_context_1);

	button = new Button({
			props: {
				variant: /*variants*/ ctx[2],
				class: "spectrum-SplitButton-action",
				disabled: /*disabled*/ ctx[3],
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler_1*/ ctx[8]);
	button.$on("keydown", /*keydown_handler_1*/ ctx[9]);

	return {
		c() {
			if (splitbutton_trigger_slot) splitbutton_trigger_slot.c();
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			if (splitbutton_trigger_slot) {
				splitbutton_trigger_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (splitbutton_trigger_slot) {
				if (splitbutton_trigger_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(splitbutton_trigger_slot, splitbutton_trigger_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_splitbutton_trigger_slot_changes_1, get_splitbutton_trigger_slot_context_1);
				}
			}

			const button_changes = {};
			if (dirty & /*variants*/ 4) button_changes.variant = /*variants*/ ctx[2];
			if (dirty & /*disabled*/ 8) button_changes.disabled = /*disabled*/ ctx[3];

			if (dirty & /*$$scope, label*/ 2050) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(splitbutton_trigger_slot, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(splitbutton_trigger_slot, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (splitbutton_trigger_slot) splitbutton_trigger_slot.d(detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (81:2) {#if side === 'right'}
function create_if_block$R(ctx) {
	let button;
	let t;
	let current;

	button = new Button({
			props: {
				variant: /*variants*/ ctx[2],
				class: "spectrum-SplitButton-action",
				disabled: /*disabled*/ ctx[3],
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[6]);
	button.$on("keydown", /*keydown_handler*/ ctx[7]);
	const splitbutton_trigger_slot_template = /*$$slots*/ ctx[5]["splitbutton-trigger"];
	const splitbutton_trigger_slot = create_slot(splitbutton_trigger_slot_template, ctx, /*$$scope*/ ctx[11], get_splitbutton_trigger_slot_context);

	return {
		c() {
			create_component(button.$$.fragment);
			t = space();
			if (splitbutton_trigger_slot) splitbutton_trigger_slot.c();
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			insert(target, t, anchor);

			if (splitbutton_trigger_slot) {
				splitbutton_trigger_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*variants*/ 4) button_changes.variant = /*variants*/ ctx[2];
			if (dirty & /*disabled*/ 8) button_changes.disabled = /*disabled*/ ctx[3];

			if (dirty & /*$$scope, label*/ 2050) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (splitbutton_trigger_slot) {
				if (splitbutton_trigger_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(splitbutton_trigger_slot, splitbutton_trigger_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_splitbutton_trigger_slot_changes, get_splitbutton_trigger_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(splitbutton_trigger_slot, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			transition_out(splitbutton_trigger_slot, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
			if (detaching) detach(t);
			if (splitbutton_trigger_slot) splitbutton_trigger_slot.d(detaching);
		}
	};
}

// (90:12) {label}
function fallback_block_1$1(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data(t, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (89:4) <Button variant={variants} class="spectrum-SplitButton-action" {disabled} on:click on:keydown>
function create_default_slot_1$6(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	const default_slot_or_fallback = default_slot || fallback_block_1$1(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (83:12) {label}
function fallback_block$d(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data(t, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (82:4) <Button variant={variants} class="spectrum-SplitButton-action" {disabled} on:click on:keydown>
function create_default_slot$c(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	const default_slot_or_fallback = default_slot || fallback_block$d(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

function create_fragment$1R(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$R, create_else_block$b];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*side*/ ctx[0] === "right") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "spectrum-SplitButton");
			toggle_class(div, "spectrum-SplitButton--left", /*side*/ ctx[0] === "left");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if (dirty & /*side*/ 1) {
				toggle_class(div, "spectrum-SplitButton--left", /*side*/ ctx[0] === "left");
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			/*div_binding*/ ctx[10](null);
		}
	};
}

function advanceAddClassName$1(el, slotName, className, isClassName, hasClassName) {
	let targetChild = el.children;

	if (targetChild) {
		for (let index = 0; index < targetChild.length; index++) {
			if (slotName && targetChild[index].slot && targetChild[index].slot == slotName) {
				if (isClassName) {
					let thisEl = targetChild[index].querySelectorAll(isClassName)[0];

					if (hasClassName && thisEl.classList.contains(hasClassName)) {
						thisEl.classList.remove(hasClassName);
					}

					thisEl.classList.add(className);
				} else {
					targetChild[index].classList.add(className);
				}
			}
		}
	}
}

function instance$1R($$self, $$props, $$invalidate) {
	let { side = "right" } = $$props;
	let { label = "Split Button" } = $$props;
	let { variants = "cta" } = $$props;
	let { disabled = false } = $$props;
	let splitButtonEl;

	onMount(() => {
		advanceAddClassName$1(splitButtonEl, "splitbutton-trigger", "spectrum-SplitButton-icon", ".spectrum-Icon");

		switch (variants) {
			case "cta":
				advanceAddClassName$1(splitButtonEl, "splitbutton-trigger", "spectrum-SplitButton-trigger", ".spectrum-Button");
				break;
			case "primary":
				advanceAddClassName$1(splitButtonEl, "splitbutton-trigger", "spectrum-SplitButton-trigger", ".spectrum-Button", "spectrum-Button--cta");
				advanceAddClassName$1(splitButtonEl, "splitbutton-trigger", "spectrum-Button--primary", ".spectrum-Button");
				break;
			case "secondary":
				advanceAddClassName$1(splitButtonEl, "splitbutton-trigger", "spectrum-SplitButton-trigger", ".spectrum-Button", "spectrum-Button--cta");
				advanceAddClassName$1(splitButtonEl, "splitbutton-trigger", "spectrum-Button--secondary", ".spectrum-Button");
				break;
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	function keydown_handler_1(event) {
		bubble($$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			splitButtonEl = $$value;
			$$invalidate(4, splitButtonEl);
		});
	}

	$$self.$$set = $$props => {
		if ("side" in $$props) $$invalidate(0, side = $$props.side);
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	return [
		side,
		label,
		variants,
		disabled,
		splitButtonEl,
		$$slots,
		click_handler,
		keydown_handler,
		click_handler_1,
		keydown_handler_1,
		div_binding,
		$$scope
	];
}

class SplitButton extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, {
			side: 0,
			label: 1,
			variants: 2,
			disabled: 3
		});
	}
}

/* src/packages/SplitView/SplitView.svelte generated by Svelte v3.24.1 */

function add_css$o() {
	var style = element("style");
	style.id = "svelte-1dlmidr-style";
	style.textContent = ".spectrum-SplitView-splitter.is-draggable:hover{cursor:-webkit-grab;cursor:grab}.spectrum-SplitView--horizontal>.spectrum-SplitView-splitter.is-draggable:active{cursor:ew-resize}.spectrum-SplitView--vertical>.spectrum-SplitView-splitter.is-draggable:active{cursor:ns-resize}";
	append(document.head, style);
}

const get_splitview_pane_another_slot_changes = dirty => ({});
const get_splitview_pane_another_slot_context = ctx => ({});

// (121:4) {#if isDraggable}
function create_if_block$S(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "spectrum-SplitView-gripper");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$1S(ctx) {
	let div3;
	let div0;
	let div0_style_value;
	let t0;
	let div1;
	let t1;
	let div2;
	let div2_style_value;
	let div3_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let if_block = /*isDraggable*/ ctx[2] && create_if_block$S();
	const splitview_pane_another_slot_template = /*$$slots*/ ctx[10]["splitview-pane-another"];
	const splitview_pane_another_slot = create_slot(splitview_pane_another_slot_template, ctx, /*$$scope*/ ctx[9], get_splitview_pane_another_slot_context);

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			div1 = element("div");
			if (if_block) if_block.c();
			t1 = space();
			div2 = element("div");
			if (splitview_pane_another_slot) splitview_pane_another_slot.c();
			attr(div0, "class", "spectrum-SplitView-pane");

			attr(div0, "style", div0_style_value = /*orientation*/ ctx[3] === "horizontal"
			? `width: ${/*paneDimension*/ ctx[0]}%;`
			: `height: ${/*paneDimension*/ ctx[0]}%;`);

			attr(div1, "class", "spectrum-SplitView-splitter ");
			toggle_class(div1, "is-draggable", /*isDraggable*/ ctx[2]);
			toggle_class(div1, "is-collapsed-start", /*paneDimension*/ ctx[0] === 0);
			toggle_class(div1, "is-collapsed-end", /*paneAnotherDimension*/ ctx[1] <= 0);
			attr(div2, "class", "spectrum-SplitView-pane");

			attr(div2, "style", div2_style_value = /*orientation*/ ctx[3] === "horizontal"
			? `width: ${/*paneAnotherDimension*/ ctx[1]}%;`
			: `height: ${/*paneAnotherDimension*/ ctx[1]}%;`);

			attr(div3, "class", div3_class_value = "spectrum-SplitView spectrum-SplitView--" + /*orientation*/ ctx[3]);
			attr(div3, "style", /*styleCssText*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append(div3, t0);
			append(div3, div1);
			if (if_block) if_block.m(div1, null);
			/*div1_binding*/ ctx[11](div1);
			append(div3, t1);
			append(div3, div2);

			if (splitview_pane_another_slot) {
				splitview_pane_another_slot.m(div2, null);
			}

			/*div3_binding*/ ctx[12](div3);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*orientation, paneDimension*/ 9 && div0_style_value !== (div0_style_value = /*orientation*/ ctx[3] === "horizontal"
			? `width: ${/*paneDimension*/ ctx[0]}%;`
			: `height: ${/*paneDimension*/ ctx[0]}%;`)) {
				attr(div0, "style", div0_style_value);
			}

			if (/*isDraggable*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block$S();
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*isDraggable*/ 4) {
				toggle_class(div1, "is-draggable", /*isDraggable*/ ctx[2]);
			}

			if (dirty & /*paneDimension*/ 1) {
				toggle_class(div1, "is-collapsed-start", /*paneDimension*/ ctx[0] === 0);
			}

			if (dirty & /*paneAnotherDimension*/ 2) {
				toggle_class(div1, "is-collapsed-end", /*paneAnotherDimension*/ ctx[1] <= 0);
			}

			if (splitview_pane_another_slot) {
				if (splitview_pane_another_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(splitview_pane_another_slot, splitview_pane_another_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_splitview_pane_another_slot_changes, get_splitview_pane_another_slot_context);
				}
			}

			if (!current || dirty & /*orientation, paneAnotherDimension*/ 10 && div2_style_value !== (div2_style_value = /*orientation*/ ctx[3] === "horizontal"
			? `width: ${/*paneAnotherDimension*/ ctx[1]}%;`
			: `height: ${/*paneAnotherDimension*/ ctx[1]}%;`)) {
				attr(div2, "style", div2_style_value);
			}

			if (!current || dirty & /*orientation*/ 8 && div3_class_value !== (div3_class_value = "spectrum-SplitView spectrum-SplitView--" + /*orientation*/ ctx[3])) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*styleCssText*/ 64) {
				attr(div3, "style", /*styleCssText*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(splitview_pane_another_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(splitview_pane_another_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div1_binding*/ ctx[11](null);
			if (splitview_pane_another_slot) splitview_pane_another_slot.d(detaching);
			/*div3_binding*/ ctx[12](null);
		}
	};
}

function instance$1S($$self, $$props, $$invalidate) {
	let { isDraggable = false } = $$props;
	let { orientation = "horizontal" } = $$props;
	let { height = "size-3000" } = $$props;
	let { width = "size-6000" } = $$props;
	let { paneDimension = 50 } = $$props;
	let { paneAnotherDimension = 50 } = $$props;
	let splitViewEl;
	let splitterEl;

	onMount(() => {
		splitterEl.addEventListener("mousedown", function (e) {
			handleSplitViewAction(e);
		});
	});

	function handleSplitViewAction(e) {
		if (!isDraggable) {
			return;
		}

		getSplitViewPosition(e);
		window.addEventListener("mousemove", getSplitViewPosition);
		window.addEventListener("mouseup", removeGetSplitViewPositionEvent);
	}

	function getSplitViewPosition(e) {
		e.preventDefault();
		const thisRect = splitViewEl.getBoundingClientRect();
		let _pageP = orientation === "horizontal" ? e.pageX : e.pageY;

		let _orientation = orientation === "horizontal"
		? thisRect.left
		: thisRect.top;

		let _crisscross = orientation === "horizontal"
		? thisRect.width
		: thisRect.height;

		let _p = _pageP - _orientation;

		if (_p > _crisscross) {
			_p = _crisscross;
		}

		if (_p < 0) {
			_p = 0;
		}

		$$invalidate(0, paneDimension = _p / _crisscross * 100);
		$$invalidate(1, paneAnotherDimension = 100 - paneDimension);
	}

	function removeGetSplitViewPositionEvent(e) {
		window.removeEventListener("mousemove", getSplitViewPosition);
	}

	let { $$slots = {}, $$scope } = $$props;

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			splitterEl = $$value;
			$$invalidate(5, splitterEl);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			splitViewEl = $$value;
			$$invalidate(4, splitViewEl);
		});
	}

	$$self.$$set = $$props => {
		if ("isDraggable" in $$props) $$invalidate(2, isDraggable = $$props.isDraggable);
		if ("orientation" in $$props) $$invalidate(3, orientation = $$props.orientation);
		if ("height" in $$props) $$invalidate(7, height = $$props.height);
		if ("width" in $$props) $$invalidate(8, width = $$props.width);
		if ("paneDimension" in $$props) $$invalidate(0, paneDimension = $$props.paneDimension);
		if ("paneAnotherDimension" in $$props) $$invalidate(1, paneAnotherDimension = $$props.paneAnotherDimension);
		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*height, width*/ 384) {
			 $$invalidate(6, styleCssText = [
				height && height.toString().indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: height.toString().indexOf("%") !== -1
					? `height: ${height};`
					: `height: ${height}px;`,
				width && width.toString().indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: width.toString().indexOf("%") !== -1
					? `width: ${width};`
					: `width: ${width}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		paneDimension,
		paneAnotherDimension,
		isDraggable,
		orientation,
		splitViewEl,
		splitterEl,
		styleCssText,
		height,
		width,
		$$scope,
		$$slots,
		div1_binding,
		div3_binding
	];
}

class SplitView extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1dlmidr-style")) add_css$o();

		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, {
			isDraggable: 2,
			orientation: 3,
			height: 7,
			width: 8,
			paneDimension: 0,
			paneAnotherDimension: 1
		});
	}
}

/* src/packages/StatusLight/StatusLight.svelte generated by Svelte v3.24.1 */

function create_fragment$1T(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "spectrum-StatusLight spectrum-StatusLight--" + /*variants*/ ctx[0]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*variants*/ 1 && div_class_value !== (div_class_value = "spectrum-StatusLight spectrum-StatusLight--" + /*variants*/ ctx[0])) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*variants, disabled*/ 3) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1T($$self, $$props, $$invalidate) {
	let { variants = "celery" } = $$props;
	let { disabled = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("variants" in $$props) $$invalidate(0, variants = $$props.variants);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [variants, disabled, $$scope, $$slots];
}

class StatusLight extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, { variants: 0, disabled: 1 });
	}
}

/* src/packages/Steplist/Steplist.svelte generated by Svelte v3.24.1 */

function create_fragment$1U(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Steplist ");
			attr(div, "role", "list");
			toggle_class(div, "spectrum-Steplist--interactive", /*interactive*/ ctx[0]);
			toggle_class(div, "spectrum-Steplist--small", /*isSmall*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (dirty & /*interactive*/ 1) {
				toggle_class(div, "spectrum-Steplist--interactive", /*interactive*/ ctx[0]);
			}

			if (dirty & /*isSmall*/ 2) {
				toggle_class(div, "spectrum-Steplist--small", /*isSmall*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1U($$self, $$props, $$invalidate) {
	let { interactive = false } = $$props;
	let { isSmall = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("interactive" in $$props) $$invalidate(0, interactive = $$props.interactive);
		if ("isSmall" in $$props) $$invalidate(1, isSmall = $$props.isSmall);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [interactive, isSmall, $$scope, $$slots];
}

class Steplist extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, { interactive: 0, isSmall: 1 });
	}
}

/* src/packages/Steplist/StepItem.svelte generated by Svelte v3.24.1 */

function add_css$p() {
	var style = element("style");
	style.id = "svelte-1cui9oq-style";
	style.textContent = ".spectrum-Steplist-item.is-disabled{pointer-events:none}";
	append(document.head, style);
}

// (91:2) {:else}
function create_else_block$c(ctx) {
	let t;
	let span1;
	let current;
	let if_block = /*label*/ ctx[3] && create_if_block_2$b(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			span1 = element("span");
			span1.innerHTML = `<span class="spectrum-Steplist-marker"></span>`;
			attr(span1, "class", "spectrum-Steplist-markerContainer");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, span1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(span1);
		}
	};
}

// (76:2) {#if interactive}
function create_if_block$T(ctx) {
	let a;
	let t;
	let span1;
	let a_tabindex_value;
	let a_aria_current_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[3] && create_if_block_1$K(ctx);

	return {
		c() {
			a = element("a");
			if (if_block) if_block.c();
			t = space();
			span1 = element("span");
			span1.innerHTML = `<span class="spectrum-Steplist-marker"></span>`;
			attr(span1, "class", "spectrum-Steplist-markerContainer");
			attr(a, "class", "spectrum-Steplist-link");
			attr(a, "role", "link");
			attr(a, "tabindex", a_tabindex_value = /*isSelected*/ ctx[2] ? 0 : -1);
			attr(a, "aria-current", a_aria_current_value = /*isSelected*/ ctx[2] && "step");
			attr(a, "href", "#all");
			toggle_class(a, "is-complete", /*isComplete*/ ctx[6]);
			toggle_class(a, "is-selected", /*isSelected*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			if (if_block) if_block.m(a, null);
			append(a, t);
			append(a, span1);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[8].call(null, a));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$K(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*isSelected*/ 4 && a_tabindex_value !== (a_tabindex_value = /*isSelected*/ ctx[2] ? 0 : -1)) {
				attr(a, "tabindex", a_tabindex_value);
			}

			if (!current || dirty & /*isSelected*/ 4 && a_aria_current_value !== (a_aria_current_value = /*isSelected*/ ctx[2] && "step")) {
				attr(a, "aria-current", a_aria_current_value);
			}

			if (dirty & /*isComplete*/ 64) {
				toggle_class(a, "is-complete", /*isComplete*/ ctx[6]);
			}

			if (dirty & /*isSelected*/ 4) {
				toggle_class(a, "is-selected", /*isSelected*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (92:4) {#if label}
function create_if_block_2$b(ctx) {
	let span;
	let current;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	const default_slot_or_fallback = default_slot || fallback_block_1$2(ctx);

	return {
		c() {
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(span, "class", "spectrum-Steplist-label");
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label, thisStep*/ 10) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (93:50) {label + ' ' + thisStep}
function fallback_block_1$2(ctx) {
	let t_value = /*label*/ ctx[3] + " " + /*thisStep*/ ctx[1] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label, thisStep*/ 10 && t_value !== (t_value = /*label*/ ctx[3] + " " + /*thisStep*/ ctx[1] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (86:6) {#if label}
function create_if_block_1$K(ctx) {
	let span;
	let current;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	const default_slot_or_fallback = default_slot || fallback_block$e(ctx);

	return {
		c() {
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(span, "class", "spectrum-Steplist-label");
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label, thisStep*/ 10) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (87:52) {label + ' ' + thisStep}
function fallback_block$e(ctx) {
	let t_value = /*label*/ ctx[3] + " " + /*thisStep*/ ctx[1] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label, thisStep*/ 10 && t_value !== (t_value = /*label*/ ctx[3] + " " + /*thisStep*/ ctx[1] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1V(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t;
	let span;
	let current;
	const if_block_creators = [create_if_block$T, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*interactive*/ ctx[7]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			t = space();
			span = element("span");
			attr(span, "class", "spectrum-Steplist-segment");
			attr(div, "class", "spectrum-Steplist-item ");
			attr(div, "role", "listitem");
			attr(div, "aria-posinset", /*thisStep*/ ctx[1]);
			attr(div, "aria-setsize", /*totalStep*/ ctx[0]);
			toggle_class(div, "is-complete", /*isComplete*/ ctx[6]);
			toggle_class(div, "is-selected", /*isSelected*/ ctx[2]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t);
			append(div, span);
			/*div_binding*/ ctx[13](div);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, t);
			}

			if (!current || dirty & /*thisStep*/ 2) {
				attr(div, "aria-posinset", /*thisStep*/ ctx[1]);
			}

			if (!current || dirty & /*totalStep*/ 1) {
				attr(div, "aria-setsize", /*totalStep*/ ctx[0]);
			}

			if (dirty & /*isComplete*/ 64) {
				toggle_class(div, "is-complete", /*isComplete*/ ctx[6]);
			}

			if (dirty & /*isSelected*/ 4) {
				toggle_class(div, "is-selected", /*isSelected*/ ctx[2]);
			}

			if (dirty & /*disabled*/ 16) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			/*div_binding*/ ctx[13](null);
		}
	};
}

function instance$1V($$self, $$props, $$invalidate) {
	let { totalStep = 4 } = $$props;
	let { thisStep = 1 } = $$props;
	let { activeStep = 1 } = $$props;
	let { isSelected = false } = $$props;
	let { label = "Step" } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = false } = $$props;
	let stepItemEl;
	let isComplete = false;
	let interactive = false;
	const eventsListen = getEventsAction(current_component);

	onMount(() => {
		$$invalidate(7, interactive = stepItemEl.parentNode.classList.contains("spectrum-Steplist--interactive"));
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			stepItemEl = $$value;
			$$invalidate(5, stepItemEl);
		});
	}

	$$self.$$set = $$props => {
		if ("totalStep" in $$props) $$invalidate(0, totalStep = $$props.totalStep);
		if ("thisStep" in $$props) $$invalidate(1, thisStep = $$props.thisStep);
		if ("activeStep" in $$props) $$invalidate(9, activeStep = $$props.activeStep);
		if ("isSelected" in $$props) $$invalidate(2, isSelected = $$props.isSelected);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
		if ("tooltip" in $$props) $$invalidate(10, tooltip = $$props.tooltip);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*activeStep, thisStep*/ 514) {
			 if (activeStep > thisStep) {
				$$invalidate(6, isComplete = true);
			}
		}
	};

	return [
		totalStep,
		thisStep,
		isSelected,
		label,
		disabled,
		stepItemEl,
		isComplete,
		interactive,
		eventsListen,
		activeStep,
		tooltip,
		$$scope,
		$$slots,
		div_binding
	];
}

class StepItem extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1cui9oq-style")) add_css$p();

		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {
			totalStep: 0,
			thisStep: 1,
			activeStep: 9,
			isSelected: 2,
			label: 3,
			disabled: 4,
			tooltip: 10
		});
	}
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */



























function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * @desc 解决浮动运算问题，避免小数点后产生多位数和计算精度损失。
 * 问题示例：2.3 + 2.4 = 4.699999999999999，1.0 - 0.9 = 0.09999999999999998
 */
/**
 * 把错误的数据转正
 * strip(0.09999999999999998)=0.1
 */
function strip(num, precision) {
    if (precision === void 0) { precision = 15; }
    return +parseFloat(Number(num).toPrecision(precision));
}
/**
 * Return digits length of a number
 * @param {*number} num Input number
 */
function digitLength(num) {
    // Get digit length of e
    var eSplit = num.toString().split(/[eE]/);
    var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);
    return len > 0 ? len : 0;
}
/**
 * 把小数转成整数，支持科学计数法。如果是小数则放大成整数
 * @param {*number} num 输入数
 */
function float2Fixed(num) {
    if (num.toString().indexOf('e') === -1) {
        return Number(num.toString().replace('.', ''));
    }
    var dLen = digitLength(num);
    return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
}
/**
 * 检测数字是否越界，如果越界给出提示
 * @param {*number} num 输入数
 */
function checkBoundary(num) {
    if (_boundaryCheckingState) {
        if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
            console.warn(num + " is beyond boundary when transfer to integer, the results may not be accurate");
        }
    }
}
/**
 * 精确乘法
 */
function times(num1, num2) {
    var others = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        others[_i - 2] = arguments[_i];
    }
    if (others.length > 0) {
        return times.apply(void 0, __spreadArrays([times(num1, num2), others[0]], others.slice(1)));
    }
    var num1Changed = float2Fixed(num1);
    var num2Changed = float2Fixed(num2);
    var baseNum = digitLength(num1) + digitLength(num2);
    var leftValue = num1Changed * num2Changed;
    checkBoundary(leftValue);
    return leftValue / Math.pow(10, baseNum);
}
/**
 * 精确加法
 */
function plus(num1, num2) {
    var others = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        others[_i - 2] = arguments[_i];
    }
    if (others.length > 0) {
        return plus.apply(void 0, __spreadArrays([plus(num1, num2), others[0]], others.slice(1)));
    }
    var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
    return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
}
/**
 * 精确减法
 */
function minus(num1, num2) {
    var others = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        others[_i - 2] = arguments[_i];
    }
    if (others.length > 0) {
        return minus.apply(void 0, __spreadArrays([minus(num1, num2), others[0]], others.slice(1)));
    }
    var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
    return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
}
/**
 * 精确除法
 */
function divide(num1, num2) {
    var others = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        others[_i - 2] = arguments[_i];
    }
    if (others.length > 0) {
        return divide.apply(void 0, __spreadArrays([divide(num1, num2), others[0]], others.slice(1)));
    }
    var num1Changed = float2Fixed(num1);
    var num2Changed = float2Fixed(num2);
    checkBoundary(num1Changed);
    checkBoundary(num2Changed);
    // fix: 类似 10 ** -4 为 0.00009999999999999999，strip 修正
    return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
}
/**
 * 四舍五入
 */
function round(num, ratio) {
    var base = Math.pow(10, ratio);
    return divide(Math.round(times(num, base)), base);
}
var _boundaryCheckingState = true;
/**
 * 是否进行边界检查，默认开启
 * @param flag 标记开关，true 为开启，false 为关闭，默认为 true
 */
function enableBoundaryChecking(flag) {
    if (flag === void 0) { flag = true; }
    _boundaryCheckingState = flag;
}
var index$1 = {
    strip: strip,
    plus: plus,
    minus: minus,
    times: times,
    divide: divide,
    round: round,
    digitLength: digitLength,
    float2Fixed: float2Fixed,
    enableBoundaryChecking: enableBoundaryChecking,
};

/* src/packages/Stepper/Stepper.svelte generated by Svelte v3.24.1 */

function create_fragment$1W(ctx) {
	let div;
	let textfield;
	let updating_value;
	let t0;
	let span;
	let button0;
	let iconchevronupsmall;
	let button0_class_value;
	let t1;
	let button1;
	let iconchevrondownsmall;
	let button1_class_value;
	let current;
	let mounted;
	let dispose;

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[15].call(null, value);
	}

	let textfield_props = {
		class: "spectrum-Stepper-textfield ",
		resetType: "number",
		inputClass: "spectrum-Textfield-input spectrum-Stepper-input " + (/*focused*/ ctx[8] && ` focus-ring`),
		placeholder: /*value*/ ctx[0],
		min: /*minValue*/ ctx[5],
		max: /*maxValue*/ ctx[6],
		step: /*stepValue*/ ctx[7],
		isQuiet: /*isQuiet*/ ctx[4],
		readonly: /*readonly*/ ctx[1],
		disabled: /*disabled*/ ctx[2]
	};

	if (/*value*/ ctx[0] !== void 0) {
		textfield_props.value = /*value*/ ctx[0];
	}

	textfield = new Textfield({ props: textfield_props });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	iconchevronupsmall = new ChevronUpSmall({
			props: {
				className: "spectrum-UIIcon-ChevronUpSmall",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	iconchevrondownsmall = new ChevronDownSmall({
			props: {
				className: "spectrum-UIIcon-ChevronDownSmall",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(textfield.$$.fragment);
			t0 = space();
			span = element("span");
			button0 = element("button");
			create_component(iconchevronupsmall.$$.fragment);
			t1 = space();
			button1 = element("button");
			create_component(iconchevrondownsmall.$$.fragment);
			attr(button0, "class", button0_class_value = "spectrum-FieldButton " + (/*isQuiet*/ ctx[4] ? "spectrum-FieldButton--quiet" : "") + " spectrum-Stepper-stepUp");
			attr(button0, "tabindex", "-1");
			button0.disabled = /*disabled*/ ctx[2];
			attr(button1, "class", button1_class_value = "spectrum-FieldButton " + (/*isQuiet*/ ctx[4] ? "spectrum-FieldButton--quiet" : "") + " spectrum-Stepper-stepDown");
			attr(button1, "tabindex", "-1");
			button1.disabled = /*disabled*/ ctx[2];
			attr(span, "class", "spectrum-Stepper-buttons");
			attr(div, "class", "spectrum-Stepper");
			toggle_class(div, "spectrum-Stepper--quiet", /*isQuiet*/ ctx[4]);
			toggle_class(div, "is-keyboardFocused", /*keyboardFocused*/ ctx[9]);
			toggle_class(div, "is-focused", /*focused*/ ctx[8]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(textfield, div, null);
			append(div, t0);
			append(div, span);
			append(span, button0);
			mount_component(iconchevronupsmall, button0, null);
			append(span, t1);
			append(span, button1);
			mount_component(iconchevrondownsmall, button1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*increaseAction*/ ctx[12]),
					listen(button1, "click", /*reduceAction*/ ctx[13]),
					listen(div, "keyup", /*testEventDevice*/ ctx[11]),
					listen(div, "mousedown", /*mousedown_handler*/ ctx[16]),
					listen(div, "focusin", /*focusin_handler*/ ctx[17]),
					listen(div, "focusout", /*focusout_handler*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const textfield_changes = {};
			if (dirty & /*focused*/ 256) textfield_changes.inputClass = "spectrum-Textfield-input spectrum-Stepper-input " + (/*focused*/ ctx[8] && ` focus-ring`);
			if (dirty & /*value*/ 1) textfield_changes.placeholder = /*value*/ ctx[0];
			if (dirty & /*minValue*/ 32) textfield_changes.min = /*minValue*/ ctx[5];
			if (dirty & /*maxValue*/ 64) textfield_changes.max = /*maxValue*/ ctx[6];
			if (dirty & /*stepValue*/ 128) textfield_changes.step = /*stepValue*/ ctx[7];
			if (dirty & /*isQuiet*/ 16) textfield_changes.isQuiet = /*isQuiet*/ ctx[4];
			if (dirty & /*readonly*/ 2) textfield_changes.readonly = /*readonly*/ ctx[1];
			if (dirty & /*disabled*/ 4) textfield_changes.disabled = /*disabled*/ ctx[2];

			if (!updating_value && dirty & /*value*/ 1) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (!current || dirty & /*isQuiet*/ 16 && button0_class_value !== (button0_class_value = "spectrum-FieldButton " + (/*isQuiet*/ ctx[4] ? "spectrum-FieldButton--quiet" : "") + " spectrum-Stepper-stepUp")) {
				attr(button0, "class", button0_class_value);
			}

			if (!current || dirty & /*disabled*/ 4) {
				button0.disabled = /*disabled*/ ctx[2];
			}

			if (!current || dirty & /*isQuiet*/ 16 && button1_class_value !== (button1_class_value = "spectrum-FieldButton " + (/*isQuiet*/ ctx[4] ? "spectrum-FieldButton--quiet" : "") + " spectrum-Stepper-stepDown")) {
				attr(button1, "class", button1_class_value);
			}

			if (!current || dirty & /*disabled*/ 4) {
				button1.disabled = /*disabled*/ ctx[2];
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(div, "spectrum-Stepper--quiet", /*isQuiet*/ ctx[4]);
			}

			if (dirty & /*keyboardFocused*/ 512) {
				toggle_class(div, "is-keyboardFocused", /*keyboardFocused*/ ctx[9]);
			}

			if (dirty & /*focused*/ 256) {
				toggle_class(div, "is-focused", /*focused*/ ctx[8]);
			}

			if (dirty & /*isInvalid*/ 8) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			transition_in(iconchevronupsmall.$$.fragment, local);
			transition_in(iconchevrondownsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textfield.$$.fragment, local);
			transition_out(iconchevronupsmall.$$.fragment, local);
			transition_out(iconchevrondownsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(textfield);
			destroy_component(iconchevronupsmall);
			destroy_component(iconchevrondownsmall);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1W($$self, $$props, $$invalidate) {
	let { readonly = false } = $$props;
	let { disabled = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { value = 1 } = $$props;
	let { minValue = -5 } = $$props;
	let { maxValue = 5 } = $$props;
	let { stepValue = 1 } = $$props;
	let focused = false;
	let keyboardFocused = false;
	let isKeyboard = true;

	function testEventDevice(e) {
		if (e.which == 9) {
			$$invalidate(10, isKeyboard = true);
		} else {
			$$invalidate(10, isKeyboard = false);
		}
	}

	function increaseAction(e) {
		if (e.preventDefaulted || readonly || disabled) {
			return;
		}

		if (index$1.plus(value, stepValue) <= maxValue) {
			$$invalidate(0, value = parseFloat(index$1.plus(value, stepValue).toFixed(1)));
		}
	}

	function reduceAction(e) {
		if (e.preventDefaulted || readonly || disabled) {
			return;
		}

		if (index$1.minus(value, stepValue) >= minValue) {
			$$invalidate(0, value = parseFloat(index$1.minus(value, stepValue).toFixed(1)));
		}
	}

	function handleFocusEvent(f) {
		if (f) {
			$$invalidate(8, focused = true);

			if (isKeyboard) {
				$$invalidate(9, keyboardFocused = true);
			}
		} else {
			$$invalidate(8, focused = false);
			$$invalidate(9, keyboardFocused = false);
		}
	}

	function textfield_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	const mousedown_handler = () => {
		$$invalidate(10, isKeyboard = false);
	};

	const focusin_handler = () => handleFocusEvent(true);
	const focusout_handler = () => handleFocusEvent(false);

	$$self.$$set = $$props => {
		if ("readonly" in $$props) $$invalidate(1, readonly = $$props.readonly);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("isInvalid" in $$props) $$invalidate(3, isInvalid = $$props.isInvalid);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("minValue" in $$props) $$invalidate(5, minValue = $$props.minValue);
		if ("maxValue" in $$props) $$invalidate(6, maxValue = $$props.maxValue);
		if ("stepValue" in $$props) $$invalidate(7, stepValue = $$props.stepValue);
	};

	return [
		value,
		readonly,
		disabled,
		isInvalid,
		isQuiet,
		minValue,
		maxValue,
		stepValue,
		focused,
		keyboardFocused,
		isKeyboard,
		testEventDevice,
		increaseAction,
		reduceAction,
		handleFocusEvent,
		textfield_value_binding,
		mousedown_handler,
		focusin_handler,
		focusout_handler
	];
}

class Stepper extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1W, create_fragment$1W, safe_not_equal, {
			readonly: 1,
			disabled: 2,
			isInvalid: 3,
			isQuiet: 4,
			value: 0,
			minValue: 5,
			maxValue: 6,
			stepValue: 7
		});
	}
}

/* src/packages/Switch/Switch.svelte generated by Svelte v3.24.1 */

function add_css$q() {
	var style = element("style");
	style.id = "svelte-1dvr2ao-style";
	style.textContent = ".spectrum-Switch.is-readonly{pointer-events:none}";
	append(document.head, style);
}

// (47:54) {label}
function fallback_block$f(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 32) set_data(t, /*label*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$1X(ctx) {
	let div;
	let input;
	let t0;
	let span;
	let t1;
	let label_1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$f(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			label_1 = element("label");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(input, "type", "checkbox");
			attr(input, "class", "spectrum-Switch-input");
			attr(input, "id", /*id*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[1];
			input.readOnly = /*readonly*/ ctx[4];
			attr(span, "class", "spectrum-Switch-switch");
			attr(label_1, "class", "spectrum-Switch-label");
			attr(label_1, "for", /*id*/ ctx[2]);
			attr(div, "class", "spectrum-Switch");
			toggle_class(div, "spectrum-Switch--emphasized", /*emphasized*/ ctx[3]);
			toggle_class(div, "is-readonly", /*readonly*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			input.checked = /*checked*/ ctx[0];
			append(div, t0);
			append(div, span);
			append(div, t1);
			append(div, label_1);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(label_1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*input_change_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*id*/ 4) {
				attr(input, "id", /*id*/ ctx[2]);
			}

			if (!current || dirty & /*disabled*/ 2) {
				input.disabled = /*disabled*/ ctx[1];
			}

			if (!current || dirty & /*readonly*/ 16) {
				input.readOnly = /*readonly*/ ctx[4];
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 32) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*id*/ 4) {
				attr(label_1, "for", /*id*/ ctx[2]);
			}

			if (dirty & /*emphasized*/ 8) {
				toggle_class(div, "spectrum-Switch--emphasized", /*emphasized*/ ctx[3]);
			}

			if (dirty & /*readonly*/ 16) {
				toggle_class(div, "is-readonly", /*readonly*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1X($$self, $$props, $$invalidate) {
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { id = "switch-" + Math.random().toString(24) } = $$props;
	let { emphasized = false } = $$props;
	let { readonly = false } = $$props;
	let { label = "Switch" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	function input_change_handler() {
		checked = this.checked;
		$$invalidate(0, checked);
	}

	$$self.$$set = $$props => {
		if ("checked" in $$props) $$invalidate(0, checked = $$props.checked);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("emphasized" in $$props) $$invalidate(3, emphasized = $$props.emphasized);
		if ("readonly" in $$props) $$invalidate(4, readonly = $$props.readonly);
		if ("label" in $$props) $$invalidate(5, label = $$props.label);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		checked,
		disabled,
		id,
		emphasized,
		readonly,
		label,
		$$scope,
		$$slots,
		input_change_handler
	];
}

class Switch extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1dvr2ao-style")) add_css$q();

		init(this, options, instance$1X, create_fragment$1X, safe_not_equal, {
			checked: 0,
			disabled: 1,
			id: 2,
			emphasized: 3,
			readonly: 4,
			label: 5
		});
	}
}

/* src/packages/Table/Table.svelte generated by Svelte v3.24.1 */

function create_else_block$d(ctx) {
	let table;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			table = element("table");
			if (default_slot) default_slot.c();
			attr(table, "class", "spectrum-Table");
			toggle_class(table, "spectrum-Table--quiet", /*isQuiet*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, table, anchor);

			if (default_slot) {
				default_slot.m(table, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (dirty & /*isQuiet*/ 1) {
				toggle_class(table, "spectrum-Table--quiet", /*isQuiet*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (56:0) {#if useDivElement}
function create_if_block$U(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Table");
			attr(div, "role", "grid");
			attr(div, "style", /*styleCssText*/ ctx[2]);
			toggle_class(div, "spectrum-Table--quiet", /*isQuiet*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*styleCssText*/ 4) {
				attr(div, "style", /*styleCssText*/ ctx[2]);
			}

			if (dirty & /*isQuiet*/ 1) {
				toggle_class(div, "spectrum-Table--quiet", /*isQuiet*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1Y(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$U, create_else_block$d];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*useDivElement*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1Y($$self, $$props, $$invalidate) {
	let { isQuiet = false } = $$props;
	let { useDivElement = false } = $$props;
	let { multiSelect = false } = $$props;
	let { height = "100%" } = $$props;
	let { width = "auto" } = $$props;
	const rubusTableStaticConfig = writable({ multiSelect, useDivElement });
	setContext("rubusTableStaticConfig", rubusTableStaticConfig);
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("isQuiet" in $$props) $$invalidate(0, isQuiet = $$props.isQuiet);
		if ("useDivElement" in $$props) $$invalidate(1, useDivElement = $$props.useDivElement);
		if ("multiSelect" in $$props) $$invalidate(3, multiSelect = $$props.multiSelect);
		if ("height" in $$props) $$invalidate(4, height = $$props.height);
		if ("width" in $$props) $$invalidate(5, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*height, width*/ 48) {
			 $$invalidate(2, styleCssText = [
				height && height.toString().indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: height.toString().indexOf("%") !== -1
					? `height: ${height};`
					: `height: ${height}px;`,
				width && width.toString().indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: width.toString().indexOf("%") !== -1
					? `width: ${width};`
					: `width: ${width}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		isQuiet,
		useDivElement,
		styleCssText,
		multiSelect,
		height,
		width,
		$$scope,
		$$slots
	];
}

class Table extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1Y, create_fragment$1Y, safe_not_equal, {
			isQuiet: 0,
			useDivElement: 1,
			multiSelect: 3,
			height: 4,
			width: 5
		});
	}
}

/* src/packages/Table/TableBody.svelte generated by Svelte v3.24.1 */

function create_else_block$e(ctx) {
	let tbody;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			tbody = element("tbody");
			if (default_slot) default_slot.c();
			attr(tbody, "class", "spectrum-Table-body");
		},
		m(target, anchor) {
			insert(target, tbody, anchor);

			if (default_slot) {
				default_slot.m(tbody, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tbody);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (39:0) {#if $rubusTableStaticConfig.useDivElement}
function create_if_block$V(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Table-body");
			attr(div, "style", /*styleCssText*/ ctx[1]);
			attr(div, "role", "rowgroup");
			toggle_class(div, "is-drop-target", /*isDropTarget*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "mousedown", /*mousedown_handler*/ ctx[8]),
					listen(div, "mousemove", /*mousemove_handler*/ ctx[9]),
					listen(div, "mouseover", /*mouseover_handler*/ ctx[10]),
					listen(div, "mouseup", /*mouseup_handler*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*styleCssText*/ 2) {
				attr(div, "style", /*styleCssText*/ ctx[1]);
			}

			if (dirty & /*isDropTarget*/ 1) {
				toggle_class(div, "is-drop-target", /*isDropTarget*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$1Z(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$V, create_else_block$e];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$rubusTableStaticConfig*/ ctx[2].useDivElement) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1Z($$self, $$props, $$invalidate) {
	let $rubusTableStaticConfig;
	let { height = "120px" } = $$props;
	let { width = "100%" } = $$props;
	let { isDropTarget = false } = $$props;
	let rubusTableStaticConfig = getContext("rubusTableStaticConfig");
	component_subscribe($$self, rubusTableStaticConfig, value => $$invalidate(2, $rubusTableStaticConfig = value));
	let { $$slots = {}, $$scope } = $$props;

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function mousemove_handler(event) {
		bubble($$self, event);
	}

	function mouseover_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("height" in $$props) $$invalidate(4, height = $$props.height);
		if ("width" in $$props) $$invalidate(5, width = $$props.width);
		if ("isDropTarget" in $$props) $$invalidate(0, isDropTarget = $$props.isDropTarget);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*height, width*/ 48) {
			 $$invalidate(1, styleCssText = [
				height && height.toString().indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: height.toString().indexOf("%") !== -1
					? `height: ${height};`
					: `height: ${height}px;`,
				width && width.toString().indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: width.toString().indexOf("%") !== -1
					? `width: ${width};`
					: `width: ${width}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		isDropTarget,
		styleCssText,
		$rubusTableStaticConfig,
		rubusTableStaticConfig,
		height,
		width,
		$$scope,
		$$slots,
		mousedown_handler,
		mousemove_handler,
		mouseover_handler,
		mouseup_handler
	];
}

class TableBody extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, { height: 4, width: 5, isDropTarget: 0 });
	}
}

/* src/packages/Table/TableHead.svelte generated by Svelte v3.24.1 */

function create_else_block$f(ctx) {
	let thead;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			thead = element("thead");
			if (default_slot) default_slot.c();
			attr(thead, "class", "spectrum-Table-head");
		},
		m(target, anchor) {
			insert(target, thead, anchor);

			if (default_slot) {
				default_slot.m(thead, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(thead);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (7:0) {#if $rubusTableStaticConfig.useDivElement}
function create_if_block$W(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Table-head");
			set_style(div, "display", "flex");
			attr(div, "role", "row");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1_(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$W, create_else_block$f];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$rubusTableStaticConfig*/ ctx[0].useDivElement) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1_($$self, $$props, $$invalidate) {
	let $rubusTableStaticConfig;
	let rubusTableStaticConfig = getContext("rubusTableStaticConfig");
	component_subscribe($$self, rubusTableStaticConfig, value => $$invalidate(0, $rubusTableStaticConfig = value));
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [$rubusTableStaticConfig, rubusTableStaticConfig, $$scope, $$slots];
}

class TableHead extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1_, create_fragment$1_, safe_not_equal, {});
	}
}

/* src/packages/Table/TableTd.svelte generated by Svelte v3.24.1 */

function create_else_block_1$3(ctx) {
	let td;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_2$c, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*isCheckbox*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			td = element("td");
			if_block.c();
			attr(td, "class", "spectrum-Table-cell");
			attr(td, "tabindex", /*tabindex*/ ctx[0]);
			toggle_class(td, "spectrum-Table-cell--divider", /*hasDivider*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, td, anchor);
			if_blocks[current_block_type_index].m(td, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(td, "click", /*click_handler_1*/ ctx[10]),
					listen(td, "keydown", /*keydown_handler_1*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(td, null);
			}

			if (!current || dirty & /*tabindex*/ 1) {
				attr(td, "tabindex", /*tabindex*/ ctx[0]);
			}

			if (dirty & /*hasDivider*/ 8) {
				toggle_class(td, "spectrum-Table-cell--divider", /*hasDivider*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(td);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (38:0) {#if $rubusTableStaticConfig.useDivElement}
function create_if_block$X(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$L, create_else_block$g];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*isCheckbox*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "spectrum-Table-cell");
			set_style(div, "flex", "1");
			attr(div, "role", "gridcell");
			attr(div, "tabindex", /*tabindex*/ ctx[0]);
			toggle_class(div, "spectrum-Table-cell--divider", /*hasDivider*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler*/ ctx[8]),
					listen(div, "keydown", /*keydown_handler*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if (!current || dirty & /*tabindex*/ 1) {
				attr(div, "tabindex", /*tabindex*/ ctx[0]);
			}

			if (dirty & /*hasDivider*/ 8) {
				toggle_class(div, "spectrum-Table-cell--divider", /*hasDivider*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (57:4) {:else}
function create_else_block_2$1(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (55:4) {#if isCheckbox}
function create_if_block_2$c(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding_1(value) {
		/*checkbox_checked_binding_1*/ ctx[13].call(null, value);
	}

	let checkbox_props = {
		class: "spectrum-Table-checkbox",
		isQuiet: true
	};

	if (/*checked*/ ctx[1] !== void 0) {
		checkbox_props.checked = /*checked*/ ctx[1];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*checked*/ 2) {
				updating_checked = true;
				checkbox_changes.checked = /*checked*/ ctx[1];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

// (49:4) {:else}
function create_else_block$g(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (47:4) {#if isCheckbox}
function create_if_block_1$L(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[12].call(null, value);
	}

	let checkbox_props = {
		class: "spectrum-Table-checkbox",
		isQuiet: true
	};

	if (/*checked*/ ctx[1] !== void 0) {
		checkbox_props.checked = /*checked*/ ctx[1];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*checked*/ 2) {
				updating_checked = true;
				checkbox_changes.checked = /*checked*/ ctx[1];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

function create_fragment$1$(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$X, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$rubusTableStaticConfig*/ ctx[4].useDivElement) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1$($$self, $$props, $$invalidate) {
	let $rubusTableStaticConfig;
	let { tabindex = false } = $$props;
	let { isCheckbox = false } = $$props;
	let { checked = false } = $$props;
	let { hasDivider = false } = $$props;
	let rubusTableStaticConfig = getContext("rubusTableStaticConfig");
	component_subscribe($$self, rubusTableStaticConfig, value => $$invalidate(4, $rubusTableStaticConfig = value));

	onMount(() => {
		if (!tabindex && !$rubusTableStaticConfig.multiSelect) {
			$$invalidate(0, tabindex = 0);
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	function keydown_handler_1(event) {
		bubble($$self, event);
	}

	function checkbox_checked_binding(value) {
		checked = value;
		$$invalidate(1, checked);
	}

	function checkbox_checked_binding_1(value) {
		checked = value;
		$$invalidate(1, checked);
	}

	$$self.$$set = $$props => {
		if ("tabindex" in $$props) $$invalidate(0, tabindex = $$props.tabindex);
		if ("isCheckbox" in $$props) $$invalidate(2, isCheckbox = $$props.isCheckbox);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("hasDivider" in $$props) $$invalidate(3, hasDivider = $$props.hasDivider);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		tabindex,
		checked,
		isCheckbox,
		hasDivider,
		$rubusTableStaticConfig,
		rubusTableStaticConfig,
		$$scope,
		$$slots,
		click_handler,
		keydown_handler,
		click_handler_1,
		keydown_handler_1,
		checkbox_checked_binding,
		checkbox_checked_binding_1
	];
}

class TableTd extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1$, create_fragment$1$, safe_not_equal, {
			tabindex: 0,
			isCheckbox: 2,
			checked: 1,
			hasDivider: 3
		});
	}
}

/* src/packages/Table/TableTh.svelte generated by Svelte v3.24.1 */

function create_else_block_1$4(ctx) {
	let th;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_4$6, create_else_block_2$2];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*isCheckbox*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			th = element("th");
			if_block.c();
			attr(th, "class", "spectrum-Table-headCell");
			attr(th, "aria-sort", /*ariaSort*/ ctx[1]);
			attr(th, "tabindex", /*tabindex*/ ctx[0]);
			toggle_class(th, "spectrum-Table-checkboxCell", /*$rubusTableStaticConfig*/ ctx[6].multiSelect);
			toggle_class(th, "is-sortable", /*isSortable*/ ctx[3]);
			toggle_class(th, "is-sorted-desc", /*showSortedIcon*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, th, anchor);
			if_blocks[current_block_type_index].m(th, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(th, "click", /*click_handler_1*/ ctx[12]),
					listen(th, "keydown", /*keydown_handler_1*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(th, null);
			}

			if (!current || dirty & /*ariaSort*/ 2) {
				attr(th, "aria-sort", /*ariaSort*/ ctx[1]);
			}

			if (!current || dirty & /*tabindex*/ 1) {
				attr(th, "tabindex", /*tabindex*/ ctx[0]);
			}

			if (dirty & /*$rubusTableStaticConfig*/ 64) {
				toggle_class(th, "spectrum-Table-checkboxCell", /*$rubusTableStaticConfig*/ ctx[6].multiSelect);
			}

			if (dirty & /*isSortable*/ 8) {
				toggle_class(th, "is-sortable", /*isSortable*/ ctx[3]);
			}

			if (dirty & /*showSortedIcon*/ 16) {
				toggle_class(th, "is-sorted-desc", /*showSortedIcon*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(th);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (53:0) {#if $rubusTableStaticConfig.useDivElement}
function create_if_block$Y(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$M, create_else_block$h];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*isCheckbox*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "spectrum-Table-headCell");
			attr(div, "aria-sort", /*ariaSort*/ ctx[1]);
			attr(div, "tabindex", /*tabindex*/ ctx[0]);
			set_style(div, "flex", "1");
			attr(div, "role", "columnheader");
			toggle_class(div, "spectrum-Table-checkboxCell", /*$rubusTableStaticConfig*/ ctx[6].multiSelect);
			toggle_class(div, "is-sortable", /*isSortable*/ ctx[3]);
			toggle_class(div, "is-sorted-desc", /*showSortedIcon*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler*/ ctx[10]),
					listen(div, "keydown", /*keydown_handler*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if (!current || dirty & /*ariaSort*/ 2) {
				attr(div, "aria-sort", /*ariaSort*/ ctx[1]);
			}

			if (!current || dirty & /*tabindex*/ 1) {
				attr(div, "tabindex", /*tabindex*/ ctx[0]);
			}

			if (dirty & /*$rubusTableStaticConfig*/ 64) {
				toggle_class(div, "spectrum-Table-checkboxCell", /*$rubusTableStaticConfig*/ ctx[6].multiSelect);
			}

			if (dirty & /*isSortable*/ 8) {
				toggle_class(div, "is-sortable", /*isSortable*/ ctx[3]);
			}

			if (dirty & /*showSortedIcon*/ 16) {
				toggle_class(div, "is-sorted-desc", /*showSortedIcon*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (88:4) {:else}
function create_else_block_2$2(ctx) {
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const if_block_creators = [create_if_block_5$4, create_if_block_6$1];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*ariaSort*/ ctx[1] === "ascending") return 0;
		if (/*ariaSort*/ ctx[1] === "descending") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_4(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (86:4) {#if isCheckbox}
function create_if_block_4$6(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding_1(value) {
		/*checkbox_checked_binding_1*/ ctx[15].call(null, value);
	}

	let checkbox_props = {
		class: "spectrum-Table-checkbox",
		isQuiet: true
	};

	if (/*checked*/ ctx[2] !== void 0) {
		checkbox_props.checked = /*checked*/ ctx[2];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*checked*/ 4) {
				updating_checked = true;
				checkbox_changes.checked = /*checked*/ ctx[2];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

// (92:42) 
function create_if_block_6$1(ctx) {
	let iconarrowupsmall;
	let current;

	iconarrowupsmall = new ArrowUpSmall({
			props: {
				className: "spectrum-Table-sortedIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconarrowupsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconarrowupsmall, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconarrowupsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconarrowupsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconarrowupsmall, detaching);
		}
	};
}

// (90:6) {#if ariaSort === 'ascending'}
function create_if_block_5$4(ctx) {
	let iconarrowdownsmall;
	let current;

	iconarrowdownsmall = new ArrowDownSmall({
			props: {
				className: "spectrum-Table-sortedIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconarrowdownsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconarrowdownsmall, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconarrowdownsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconarrowdownsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconarrowdownsmall, detaching);
		}
	};
}

// (67:4) {:else}
function create_else_block$h(ctx) {
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const default_slot_template = /*$$slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const if_block_creators = [create_if_block_2$d, create_if_block_3$9];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*ariaSort*/ ctx[1] === "ascending") return 0;
		if (/*ariaSort*/ ctx[1] === "descending") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (65:4) {#if isCheckbox}
function create_if_block_1$M(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[14].call(null, value);
	}

	let checkbox_props = {
		class: "spectrum-Table-checkbox",
		isQuiet: true
	};

	if (/*checked*/ ctx[2] !== void 0) {
		checkbox_props.checked = /*checked*/ ctx[2];
	}

	checkbox = new Checkbox({ props: checkbox_props });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*checked*/ 4) {
				updating_checked = true;
				checkbox_changes.checked = /*checked*/ ctx[2];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

// (71:42) 
function create_if_block_3$9(ctx) {
	let iconarrowupsmall;
	let current;

	iconarrowupsmall = new ArrowUpSmall({
			props: {
				className: "spectrum-Table-sortedIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconarrowupsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconarrowupsmall, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconarrowupsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconarrowupsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconarrowupsmall, detaching);
		}
	};
}

// (69:6) {#if ariaSort === 'ascending'}
function create_if_block_2$d(ctx) {
	let iconarrowdownsmall;
	let current;

	iconarrowdownsmall = new ArrowDownSmall({
			props: {
				className: "spectrum-Table-sortedIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconarrowdownsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconarrowdownsmall, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconarrowdownsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconarrowdownsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconarrowdownsmall, detaching);
		}
	};
}

function create_fragment$20(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$Y, create_else_block_1$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$rubusTableStaticConfig*/ ctx[6].useDivElement) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$20($$self, $$props, $$invalidate) {
	let $rubusTableStaticConfig;
	let { isSortable = false } = $$props;
	let { showSortedIcon = false } = $$props;
	let { tabindex = false } = $$props;
	let { ariaSort = "none" } = $$props;
	let { isCheckbox = false } = $$props;
	let { checked = false } = $$props;
	let rubusTableStaticConfig = getContext("rubusTableStaticConfig");
	component_subscribe($$self, rubusTableStaticConfig, value => $$invalidate(6, $rubusTableStaticConfig = value));

	onMount(() => {
		if (!tabindex && !$rubusTableStaticConfig.multiSelect) {
			$$invalidate(0, tabindex = 0);
		}

		if (showSortedIcon && ariaSort === "none") {
			$$invalidate(1, ariaSort = "ascending");
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	function keydown_handler_1(event) {
		bubble($$self, event);
	}

	function checkbox_checked_binding(value) {
		checked = value;
		$$invalidate(2, checked);
	}

	function checkbox_checked_binding_1(value) {
		checked = value;
		$$invalidate(2, checked);
	}

	$$self.$$set = $$props => {
		if ("isSortable" in $$props) $$invalidate(3, isSortable = $$props.isSortable);
		if ("showSortedIcon" in $$props) $$invalidate(4, showSortedIcon = $$props.showSortedIcon);
		if ("tabindex" in $$props) $$invalidate(0, tabindex = $$props.tabindex);
		if ("ariaSort" in $$props) $$invalidate(1, ariaSort = $$props.ariaSort);
		if ("isCheckbox" in $$props) $$invalidate(5, isCheckbox = $$props.isCheckbox);
		if ("checked" in $$props) $$invalidate(2, checked = $$props.checked);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		tabindex,
		ariaSort,
		checked,
		isSortable,
		showSortedIcon,
		isCheckbox,
		$rubusTableStaticConfig,
		rubusTableStaticConfig,
		$$scope,
		$$slots,
		click_handler,
		keydown_handler,
		click_handler_1,
		keydown_handler_1,
		checkbox_checked_binding,
		checkbox_checked_binding_1
	];
}

class TableTh extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$20, create_fragment$20, safe_not_equal, {
			isSortable: 3,
			showSortedIcon: 4,
			tabindex: 0,
			ariaSort: 1,
			isCheckbox: 5,
			checked: 2
		});
	}
}

/* src/packages/Table/TableTr.svelte generated by Svelte v3.24.1 */

function create_else_block$i(ctx) {
	let tr;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			tr = element("tr");
			if (default_slot) default_slot.c();
			attr(tr, "tabindex", /*tabindex*/ ctx[0]);
			toggle_class(tr, "spectrum-Table-row", /*inBody*/ ctx[4]);
			toggle_class(tr, "is-selected", /*isSelected*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, tr, anchor);

			if (default_slot) {
				default_slot.m(tr, null);
			}

			/*tr_binding*/ ctx[10](tr);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			if (!current || dirty & /*tabindex*/ 1) {
				attr(tr, "tabindex", /*tabindex*/ ctx[0]);
			}

			if (dirty & /*inBody*/ 16) {
				toggle_class(tr, "spectrum-Table-row", /*inBody*/ ctx[4]);
			}

			if (dirty & /*isSelected*/ 2) {
				toggle_class(tr, "is-selected", /*isSelected*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			if (default_slot) default_slot.d(detaching);
			/*tr_binding*/ ctx[10](null);
		}
	};
}

// (33:0) {#if $rubusTableStaticConfig.useDivElement}
function create_if_block$Z(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "tabindex", /*tabindex*/ ctx[0]);
			set_style(div, "display", "flex");
			attr(div, "role", "row");
			toggle_class(div, "spectrum-Table-row", /*inBody*/ ctx[4]);
			toggle_class(div, "is-selected", /*isSelected*/ ctx[1]);
			toggle_class(div, "is-drop-target", /*isDropTarget*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[9](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			if (!current || dirty & /*tabindex*/ 1) {
				attr(div, "tabindex", /*tabindex*/ ctx[0]);
			}

			if (dirty & /*inBody*/ 16) {
				toggle_class(div, "spectrum-Table-row", /*inBody*/ ctx[4]);
			}

			if (dirty & /*isSelected*/ 2) {
				toggle_class(div, "is-selected", /*isSelected*/ ctx[1]);
			}

			if (dirty & /*isDropTarget*/ 4) {
				toggle_class(div, "is-drop-target", /*isDropTarget*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[9](null);
		}
	};
}

function create_fragment$21(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$Z, create_else_block$i];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$rubusTableStaticConfig*/ ctx[5].useDivElement) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$21($$self, $$props, $$invalidate) {
	let $rubusTableStaticConfig;
	let { tabindex = false } = $$props;
	let { isSelected = false } = $$props;
	let { isDropTarget = false } = $$props;
	let tableThEl;
	let inBody = false;
	let rubusTableStaticConfig = getContext("rubusTableStaticConfig");
	component_subscribe($$self, rubusTableStaticConfig, value => $$invalidate(5, $rubusTableStaticConfig = value));

	onMount(() => {
		if (!tabindex && $rubusTableStaticConfig.multiSelect) {
			$$invalidate(0, tabindex = 0);
		}

		$$invalidate(4, inBody = tableThEl.parentNode.classList.contains("spectrum-Table-body"));
	});

	let { $$slots = {}, $$scope } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tableThEl = $$value;
			$$invalidate(3, tableThEl);
		});
	}

	function tr_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tableThEl = $$value;
			$$invalidate(3, tableThEl);
		});
	}

	$$self.$$set = $$props => {
		if ("tabindex" in $$props) $$invalidate(0, tabindex = $$props.tabindex);
		if ("isSelected" in $$props) $$invalidate(1, isSelected = $$props.isSelected);
		if ("isDropTarget" in $$props) $$invalidate(2, isDropTarget = $$props.isDropTarget);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		tabindex,
		isSelected,
		isDropTarget,
		tableThEl,
		inBody,
		$rubusTableStaticConfig,
		rubusTableStaticConfig,
		$$scope,
		$$slots,
		div_binding,
		tr_binding
	];
}

class TableTr extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$21, create_fragment$21, safe_not_equal, {
			tabindex: 0,
			isSelected: 1,
			isDropTarget: 2
		});
	}
}

/* src/packages/Tabs/Tabs.svelte generated by Svelte v3.24.1 */

function create_fragment$22(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let div1_levels = [
		/*tabsProps*/ ctx[3],
		/*$$restProps*/ ctx[8],
		{ "aria-label": /*ariaLabel*/ ctx[1] },
		{
			"aria-orientation": /*orientation*/ ctx[0]
		}
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			div0 = element("div");
			attr(div0, "class", "spectrum-Tabs-selectionIndicator");
			attr(div0, "style", /*selectionIndicatorSytle*/ ctx[4]);
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(div1, t);
			append(div1, div0);
			/*div1_binding*/ ctx[13](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "resize", /*getStyleAttributeValue*/ ctx[6]),
					listen(div1, "click", /*getPosition*/ ctx[5]),
					listen(div1, "keydown", /*handleKeydown*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			if (!current || dirty & /*selectionIndicatorSytle*/ 16) {
				attr(div0, "style", /*selectionIndicatorSytle*/ ctx[4]);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				dirty & /*tabsProps*/ 8 && /*tabsProps*/ ctx[3],
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*ariaLabel*/ 2) && { "aria-label": /*ariaLabel*/ ctx[1] },
				(!current || dirty & /*orientation*/ 1) && {
					"aria-orientation": /*orientation*/ ctx[0]
				}
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$22($$self, $$props, $$invalidate) {
	const omit_props_names = ["orientation","ariaLabel","isQuiet","isCompact"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { orientation = "horizontal" } = $$props;
	let { ariaLabel = "tabList" } = $$props;
	let { isQuiet = false } = $$props;
	let { isCompact = false } = $$props;
	let selectedItemDimension;
	let tabs;
	let selectionIndicatorOffset;
	const observer = new index(getStyleAttributeValue);

	afterUpdate(() => {
		getStyleAttributeValue();
		throttle$1(500, observer.observe(tabs));
	});

	onDestroy(() => {
		observer.unobserve(tabs);
	});

	function getPosition(e) {
		if (tabs.contains(e.target) && e.target.className.indexOf("spectrum-Tabs-item") != -1) {
			$$invalidate(14, selectedItemDimension = e.target.offsetWidth);
			$$invalidate(15, selectionIndicatorOffset = e.target.offsetLeft);
		}
	}

	function getStyleAttributeValue() {
		if (tabs) {
			const selectedItem = tabs.getElementsByClassName("is-selected");

			if (selectedItem.length == 1) {
				if (orientation == "horizontal") {
					$$invalidate(14, selectedItemDimension = selectedItem[0].offsetWidth);
					$$invalidate(15, selectionIndicatorOffset = selectedItem[0].offsetLeft);
				} else if (orientation == "vertical") {
					$$invalidate(14, selectedItemDimension = selectedItem[0].offsetHeight);
					$$invalidate(15, selectionIndicatorOffset = selectedItem[0].offsetTop);
				}
			}
		}
	}

	function handleKeydown(e) {
		let _e = event ? window.event : e;

		if (_e.keyCode == 13 || _e.keyCode == 32) {
			getPosition(e);
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tabs = $$value;
			$$invalidate(2, tabs);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("orientation" in $$new_props) $$invalidate(0, orientation = $$new_props.orientation);
		if ("ariaLabel" in $$new_props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
		if ("isQuiet" in $$new_props) $$invalidate(9, isQuiet = $$new_props.isQuiet);
		if ("isCompact" in $$new_props) $$invalidate(10, isCompact = $$new_props.isCompact);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	let tabsProps;
	let selectionIndicatorSytle;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*orientation, isQuiet, isCompact*/ 1537) {
			 $$invalidate(3, tabsProps = {
				role: "tabList",
				class: [
					"spectrum-Tabs",
					orientation && `spectrum-Tabs--${orientation}`,
					isQuiet && "spectrum-Tabs--quiet",
					isCompact && "spectrum-Tabs--compact"
				].filter(Boolean).join(" ")
			});
		}

		if ($$self.$$.dirty & /*orientation, selectedItemDimension, selectionIndicatorOffset*/ 49153) {
			 $$invalidate(4, selectionIndicatorSytle = [
				orientation === "vertical" && `height: ${selectedItemDimension}px;`,
				orientation === "horizontal" && `width: ${selectedItemDimension}px;`,
				orientation === "vertical" && `transform:translateY(${selectionIndicatorOffset}px);`,
				orientation === "horizontal" && `transform:translateX(${!selectionIndicatorOffset
				? "var(--spectrum-tabs-focus-ring-padding-x, var(--spectrum-global-dimension-size-100)"
				: selectionIndicatorOffset + "px"});`
			].filter(Boolean).join(" "));
		}
	};

	return [
		orientation,
		ariaLabel,
		tabs,
		tabsProps,
		selectionIndicatorSytle,
		getPosition,
		getStyleAttributeValue,
		handleKeydown,
		$$restProps,
		isQuiet,
		isCompact,
		$$scope,
		$$slots,
		div1_binding
	];
}

class Tabs extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$22, create_fragment$22, safe_not_equal, {
			orientation: 0,
			ariaLabel: 1,
			isQuiet: 9,
			isCompact: 10
		});
	}
}

/* src/packages/Tabs/Tab.svelte generated by Svelte v3.24.1 */

function add_css$r() {
	var style = element("style");
	style.id = "svelte-zq1bqj-style";
	style.textContent = ".spectrum-Tabs-item-disabled{pointer-events:none;color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500))}.spectrum-Tabs-item-disabled .spectrum-Icon{color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500)) !important}.spectrum-Tabs-item-disabled:hover{color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500))}.spectrum-Tabs-item-disabled:active{color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500))}.spectrum-Tabs-item-disabled .spectrum-Tabs-itemLabel{pointer-events:none;color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500))}.spectrum-Tabs-item-disabled .spectrum-Tabs-itemLabel:hover{color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500))}.spectrum-Tabs-item-disabled .spectrum-Tabs-itemLabel:active{color:var(--spectrum-button-secondary-text-color-disabled, var(--spectrum-global-color-gray-500))}";
	append(document.head, style);
}

const get_tab_icon_slot_changes_1 = dirty => ({});
const get_tab_icon_slot_context_1 = ctx => ({});
const get_tab_icon_slot_changes = dirty => ({});
const get_tab_icon_slot_context = ctx => ({});

// (105:0) {:else}
function create_else_block$j(ctx) {
	let div;
	let t;
	let span;
	let div_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const tab_icon_slot_template = /*$$slots*/ ctx[12]["tab-icon"];
	const tab_icon_slot = create_slot(tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], get_tab_icon_slot_context_1);
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let div_levels = [
		/*$$restProps*/ ctx[9],
		{
			class: div_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
			? "not-allowed"
			: "")
		},
		{ tabindex: "0" }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (tab_icon_slot) tab_icon_slot.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();
			attr(span, "class", "spectrum-Tabs-itemLabel");
			set_attributes(div, div_data);
			toggle_class(div, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(div, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (tab_icon_slot) {
				tab_icon_slot.m(div, null);
			}

			append(div, t);
			append(div, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*switchTab*/ ctx[7]),
					listen(div, "keydown", /*handleKeydown*/ ctx[8]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[6].call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (tab_icon_slot) {
				if (tab_icon_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(tab_icon_slot, tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_tab_icon_slot_changes_1, get_tab_icon_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*disabled, notAllowed*/ 12 && div_class_value !== (div_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
				? "not-allowed"
				: ""))) && { class: div_class_value },
				{ tabindex: "0" }
			]));

			toggle_class(div, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(div, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
		},
		i(local) {
			if (current) return;
			transition_in(tab_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(tab_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (tab_icon_slot) tab_icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (88:0) {#if href}
function create_if_block$_(ctx) {
	let a;
	let t;
	let span;
	let a_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const tab_icon_slot_template = /*$$slots*/ ctx[12]["tab-icon"];
	const tab_icon_slot = create_slot(tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], get_tab_icon_slot_context);
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let a_levels = [
		{ href: /*href*/ ctx[4] },
		{ target: /*target*/ ctx[5] },
		/*$$restProps*/ ctx[9],
		{
			class: a_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
			? "not-allowed"
			: "")
		},
		{ tabindex: "0" }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (tab_icon_slot) tab_icon_slot.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();
			attr(span, "class", "spectrum-Tabs-itemLabel");
			set_attributes(a, a_data);
			toggle_class(a, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(a, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (tab_icon_slot) {
				tab_icon_slot.m(a, null);
			}

			append(a, t);
			append(a, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*switchTab*/ ctx[7]),
					listen(a, "keydown", /*handleKeydown*/ ctx[8]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[6].call(null, a))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (tab_icon_slot) {
				if (tab_icon_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(tab_icon_slot, tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_tab_icon_slot_changes, get_tab_icon_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 16) && { href: /*href*/ ctx[4] },
				(!current || dirty & /*target*/ 32) && { target: /*target*/ ctx[5] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*disabled, notAllowed*/ 12 && a_class_value !== (a_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
				? "not-allowed"
				: ""))) && { class: a_class_value },
				{ tabindex: "0" }
			]));

			toggle_class(a, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(a, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
		},
		i(local) {
			if (current) return;
			transition_in(tab_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(tab_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (tab_icon_slot) tab_icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$23(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$_, create_else_block$j];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$23($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"currentTabIndex","selfIndex","tabAutoSwitch","disabled","notAllowed","href","target"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { currentTabIndex = 0 } = $$props;
	let { selfIndex = 0 } = $$props;
	let { tabAutoSwitch = true } = $$props;
	let { disabled = false } = $$props;
	let { notAllowed = false } = $$props;
	let { href = "" } = $$props;
	let { target = "" } = $$props;
	const eventsListen = getEventsAction(current_component);

	function switchTab() {
		if (tabAutoSwitch && !disabled) {
			return $$invalidate(0, currentTabIndex = selfIndex);
		}
	}

	function handleKeydown(e) {
		let _e = event ? window.event : e;

		if (_e.keyCode == 13 || _e.keyCode == 32) {
			switchTab();
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("currentTabIndex" in $$new_props) $$invalidate(0, currentTabIndex = $$new_props.currentTabIndex);
		if ("selfIndex" in $$new_props) $$invalidate(1, selfIndex = $$new_props.selfIndex);
		if ("tabAutoSwitch" in $$new_props) $$invalidate(10, tabAutoSwitch = $$new_props.tabAutoSwitch);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("notAllowed" in $$new_props) $$invalidate(3, notAllowed = $$new_props.notAllowed);
		if ("href" in $$new_props) $$invalidate(4, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(5, target = $$new_props.target);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	return [
		currentTabIndex,
		selfIndex,
		disabled,
		notAllowed,
		href,
		target,
		eventsListen,
		switchTab,
		handleKeydown,
		$$restProps,
		tabAutoSwitch,
		$$scope,
		$$slots
	];
}

class Tab extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-zq1bqj-style")) add_css$r();

		init(this, options, instance$23, create_fragment$23, safe_not_equal, {
			currentTabIndex: 0,
			selfIndex: 1,
			tabAutoSwitch: 10,
			disabled: 2,
			notAllowed: 3,
			href: 4,
			target: 5
		});
	}
}

/* src/packages/Tags/Tags.svelte generated by Svelte v3.24.1 */

function create_fragment$24(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Tags");
			attr(div, "role", "list");
			attr(div, "aria-label", "list");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$24($$self, $$props, $$invalidate) {
	let { editable = false } = $$props;
	setContext("rubusTagsEditable", editable);
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("editable" in $$props) $$invalidate(0, editable = $$props.editable);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [editable, $$scope, $$slots];
}

class Tags extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$24, create_fragment$24, safe_not_equal, { editable: 0 });
	}
}

/* src/packages/Tags/Tag.svelte generated by Svelte v3.24.1 */

function add_css$s() {
	var style = element("style");
	style.id = "svelte-1mabrgf-style";
	style.textContent = ".spectrum-Tags-item>.spectrum-ClearButton.focus-ring>.spectrum-Icon{fill:var(--spectrum-actionbutton-icon-color-key-focus, var(--spectrum-alias-icon-color-focus))}";
	append(document.head, style);
}

// (61:0) {#if showTag}
function create_if_block$$(ctx) {
	let div;
	let t0;
	let t1;
	let span;
	let t2;
	let t3;
	let current;
	let if_block0 = /*avatarUrl*/ ctx[5] && create_if_block_2$e(ctx);
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let if_block1 = /*editable*/ ctx[7] && create_if_block_1$N(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			span = element("span");
			t2 = text(/*label*/ ctx[0]);
			t3 = space();
			if (if_block1) if_block1.c();
			attr(span, "class", "spectrum-Tags-itemLabel");
			attr(div, "class", "spectrum-Tags-item");
			attr(div, "role", "listitem");
			attr(div, "tabindex", /*tabindex*/ ctx[3]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[1]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(div, t1);
			append(div, span);
			append(span, t2);
			append(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*avatarUrl*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*avatarUrl*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$e(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}

			if (!current || dirty & /*label*/ 1) set_data(t2, /*label*/ ctx[0]);

			if (/*editable*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*editable*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$N(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*tabindex*/ 8) {
				attr(div, "tabindex", /*tabindex*/ ctx[3]);
			}

			if (dirty & /*isInvalid*/ 2) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[1]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (63:4) {#if avatarUrl}
function create_if_block_2$e(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				class: "spectrum-Avatar",
				imgAlt: /*avatarAlt*/ ctx[4],
				imgUrl: /*avatarUrl*/ ctx[5]
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*avatarAlt*/ 16) image_changes.imgAlt = /*avatarAlt*/ ctx[4];
			if (dirty & /*avatarUrl*/ 32) image_changes.imgUrl = /*avatarUrl*/ ctx[5];
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (68:4) {#if editable}
function create_if_block_1$N(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				exterior: "clear",
				isSmall: true,
				tabindex: /*tabindex*/ ctx[3],
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[9]);
	button.$on("keydown", /*keydown_handler*/ ctx[10]);
	button.$on("keyup", /*keyup_handler*/ ctx[11]);
	button.$on("mousedown", /*mousedown_handler*/ ctx[12]);
	button.$on("mouseup", /*mouseup_handler*/ ctx[13]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*tabindex*/ 8) button_changes.tabindex = /*tabindex*/ ctx[3];

			if (dirty & /*$$scope*/ 16384) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (69:6) <Button exterior="clear" isSmall on:click on:keydown on:keyup on:mousedown on:mouseup {tabindex}>
function create_default_slot$d(ctx) {
	let iconcrosssmall;
	let current;
	iconcrosssmall = new CrossSmall({});

	return {
		c() {
			create_component(iconcrosssmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcrosssmall, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconcrosssmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcrosssmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcrosssmall, detaching);
		}
	};
}

function create_fragment$25(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*showTag*/ ctx[6] && create_if_block$$(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*showTag*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showTag*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$$(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$25($$self, $$props, $$invalidate) {
	let { label = "Tag" } = $$props;
	let { isInvalid = false } = $$props;
	let { disabled = false } = $$props;
	let { tabindex = false } = $$props;
	let { avatarAlt = "Avatar" } = $$props;
	let { avatarUrl = "" } = $$props;
	let { showTag = true } = $$props;
	let { editable = getContext("rubusTagsEditable") } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("isInvalid" in $$props) $$invalidate(1, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("tabindex" in $$props) $$invalidate(3, tabindex = $$props.tabindex);
		if ("avatarAlt" in $$props) $$invalidate(4, avatarAlt = $$props.avatarAlt);
		if ("avatarUrl" in $$props) $$invalidate(5, avatarUrl = $$props.avatarUrl);
		if ("showTag" in $$props) $$invalidate(6, showTag = $$props.showTag);
		if ("editable" in $$props) $$invalidate(7, editable = $$props.editable);
		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	return [
		label,
		isInvalid,
		disabled,
		tabindex,
		avatarAlt,
		avatarUrl,
		showTag,
		editable,
		$$slots,
		click_handler,
		keydown_handler,
		keyup_handler,
		mousedown_handler,
		mouseup_handler,
		$$scope
	];
}

class Tag extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1mabrgf-style")) add_css$s();

		init(this, options, instance$25, create_fragment$25, safe_not_equal, {
			label: 0,
			isInvalid: 1,
			disabled: 2,
			tabindex: 3,
			avatarAlt: 4,
			avatarUrl: 5,
			showTag: 6,
			editable: 7
		});
	}
}

/* src/packages/TextArea/TextArea.svelte generated by Svelte v3.24.1 */

function add_css$t() {
	var style = element("style");
	style.id = "svelte-1egkz3f-style";
	style.textContent = ".spectrum-Textfield.spectrum-Textfield--multiline.spectrum-Textfield--quiet .spectrum-Textfield-validationIcon{top:calc(\n      var(--spectrum-textfield-icon-frame) / 2 -\n        var(--spectrum-icon-alert-medium-height, var(--spectrum-global-dimension-size-225)) / 2\n    )}";
	append(document.head, style);
}

// (123:2) {#if isValid}
function create_if_block_1$O(ctx) {
	let iconcheckmarkmedium;
	let current;

	iconcheckmarkmedium = new CheckmarkMedium({
			props: {
				className: " spectrum-Textfield-validationIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcheckmarkmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcheckmarkmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconcheckmarkmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcheckmarkmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcheckmarkmedium, detaching);
		}
	};
}

// (126:2) {#if isInvalid}
function create_if_block$10(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: " spectrum-Textfield-validationIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

function create_fragment$26(ctx) {
	let div;
	let t0;
	let t1;
	let textarea;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*isValid*/ ctx[7] && create_if_block_1$O();
	let if_block1 = /*isInvalid*/ ctx[8] && create_if_block$10();

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			textarea = element("textarea");
			attr(textarea, "id", /*id*/ ctx[1]);
			attr(textarea, "class", "spectrum-Textfield-input");
			attr(textarea, "placeholder", /*placeholder*/ ctx[2]);
			attr(textarea, "name", /*name*/ ctx[3]);
			textarea.required = /*required*/ ctx[4];
			textarea.disabled = /*disabled*/ ctx[5];
			attr(textarea, "maxlength", /*maxLength*/ ctx[11]);
			attr(textarea, "minlength", /*minLength*/ ctx[12]);
			attr(div, "class", "spectrum-Textfield spectrum-Textfield--multiline");
			toggle_class(div, "spectrum-Textfield--quiet", /*isQuiet*/ ctx[6]);
			toggle_class(div, "is-valid", /*isValid*/ ctx[7]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[8]);
			toggle_class(div, "is-focused", /*isFocused*/ ctx[9]);
			toggle_class(div, "is-keyboardFocused", /*isKeyboardFocused*/ ctx[10]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			append(div, textarea);
			set_input_value(textarea, /*value*/ ctx[0]);
			/*textarea_binding*/ ctx[18](textarea);
			/*div_binding*/ ctx[21](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(textarea, "input", /*textarea_input_handler*/ ctx[17]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[15].call(null, textarea)),
					listen(div, "focusin", /*focusin_handler*/ ctx[19]),
					listen(div, "focusout", /*focusout_handler*/ ctx[20])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isValid*/ ctx[7]) {
				if (if_block0) {
					if (dirty & /*isValid*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$O();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*isInvalid*/ ctx[8]) {
				if (if_block1) {
					if (dirty & /*isInvalid*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$10();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*id*/ 2) {
				attr(textarea, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*placeholder*/ 4) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty & /*name*/ 8) {
				attr(textarea, "name", /*name*/ ctx[3]);
			}

			if (!current || dirty & /*required*/ 16) {
				textarea.required = /*required*/ ctx[4];
			}

			if (!current || dirty & /*disabled*/ 32) {
				textarea.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*maxLength*/ 2048) {
				attr(textarea, "maxlength", /*maxLength*/ ctx[11]);
			}

			if (!current || dirty & /*minLength*/ 4096) {
				attr(textarea, "minlength", /*minLength*/ ctx[12]);
			}

			if (dirty & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			if (dirty & /*isQuiet*/ 64) {
				toggle_class(div, "spectrum-Textfield--quiet", /*isQuiet*/ ctx[6]);
			}

			if (dirty & /*isValid*/ 128) {
				toggle_class(div, "is-valid", /*isValid*/ ctx[7]);
			}

			if (dirty & /*isInvalid*/ 256) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[8]);
			}

			if (dirty & /*isFocused*/ 512) {
				toggle_class(div, "is-focused", /*isFocused*/ ctx[9]);
			}

			if (dirty & /*isKeyboardFocused*/ 1024) {
				toggle_class(div, "is-keyboardFocused", /*isKeyboardFocused*/ ctx[10]);
			}

			if (dirty & /*disabled*/ 32) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*textarea_binding*/ ctx[18](null);
			/*div_binding*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$26($$self, $$props, $$invalidate) {
	let { id = `textarea-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { placeholder = "" } = $$props;
	let { name = "field" } = $$props;
	let { value = "" } = $$props;
	let { required = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { isValid = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isFocused = false } = $$props;
	let { isKeyboardFocused = false } = $$props;
	let { maxLength = 32 } = $$props;
	let { minLength = 0 } = $$props;
	const eventsListen = getEventsAction(current_component);
	let textareaEl;
	let inputEl;

	function setFocus(focused) {
		var focusClass = inputEl.classList.contains("focus-ring")
		? "is-keyboardFocused"
		: "is-focused";

		if (focused) {
			textareaEl.classList.add(focusClass);
		} else {
			textareaEl.classList.remove("is-keyboardFocused");
			textareaEl.classList.remove("is-focused");
		}
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(14, inputEl);
		});
	}

	const focusin_handler = () => {
		setFocus(true);
	};

	const focusout_handler = () => {
		setFocus(false);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textareaEl = $$value;
			$$invalidate(13, textareaEl);
		});
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("required" in $$props) $$invalidate(4, required = $$props.required);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(6, isQuiet = $$props.isQuiet);
		if ("isValid" in $$props) $$invalidate(7, isValid = $$props.isValid);
		if ("isInvalid" in $$props) $$invalidate(8, isInvalid = $$props.isInvalid);
		if ("isFocused" in $$props) $$invalidate(9, isFocused = $$props.isFocused);
		if ("isKeyboardFocused" in $$props) $$invalidate(10, isKeyboardFocused = $$props.isKeyboardFocused);
		if ("maxLength" in $$props) $$invalidate(11, maxLength = $$props.maxLength);
		if ("minLength" in $$props) $$invalidate(12, minLength = $$props.minLength);
	};

	return [
		value,
		id,
		placeholder,
		name,
		required,
		disabled,
		isQuiet,
		isValid,
		isInvalid,
		isFocused,
		isKeyboardFocused,
		maxLength,
		minLength,
		textareaEl,
		inputEl,
		eventsListen,
		setFocus,
		textarea_input_handler,
		textarea_binding,
		focusin_handler,
		focusout_handler,
		div_binding
	];
}

class TextArea extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1egkz3f-style")) add_css$t();

		init(this, options, instance$26, create_fragment$26, safe_not_equal, {
			id: 1,
			placeholder: 2,
			name: 3,
			value: 0,
			required: 4,
			disabled: 5,
			isQuiet: 6,
			isValid: 7,
			isInvalid: 8,
			isFocused: 9,
			isKeyboardFocused: 10,
			maxLength: 11,
			minLength: 12
		});
	}
}

/* src/packages/Textfield/Textfield.svelte generated by Svelte v3.24.1 */

function create_if_block_1$P(ctx) {
	let iconcheckmarkmedium;
	let current;

	iconcheckmarkmedium = new CheckmarkMedium({
			props: {
				className: "spectrum-Textfield-validationIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcheckmarkmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcheckmarkmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconcheckmarkmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcheckmarkmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcheckmarkmedium, detaching);
		}
	};
}

// (141:2) {#if isInvalid}
function create_if_block$11(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Textfield-validationIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

function create_fragment$27(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let input;
	let input_class_value;
	let input_autocomplete_value;
	let input_min_value;
	let input_max_value;
	let input_step_value;
	let eventsListen_action;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*isValid*/ ctx[7] && create_if_block_1$P();
	let if_block1 = /*isInvalid*/ ctx[8] && create_if_block$11();
	const default_slot_template = /*$$slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			input = element("input");
			attr(input, "id", /*id*/ ctx[1]);
			attr(input, "class", input_class_value = "spectrum-Textfield-input " + /*$$restProps*/ ctx[17].inputClass);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			attr(input, "name", /*name*/ ctx[3]);
			input.required = /*required*/ ctx[4];
			input.disabled = /*disabled*/ ctx[5];
			attr(input, "autocomplete", input_autocomplete_value = /*$$restProps*/ ctx[17].autocomplete);
			attr(input, "min", input_min_value = /*$$restProps*/ ctx[17].min);
			attr(input, "max", input_max_value = /*$$restProps*/ ctx[17].max);
			attr(input, "step", input_step_value = /*$$restProps*/ ctx[17].step);
			attr(input, "maxlength", /*maxLength*/ ctx[11]);
			attr(input, "minlength", /*minLength*/ ctx[12]);
			attr(div, "class", div_class_value = "spectrum-Textfield " + /*$$restProps*/ ctx[17].class);
			toggle_class(div, "spectrum-Textfield--quiet", /*isQuiet*/ ctx[6]);
			toggle_class(div, "is-valid", /*isValid*/ ctx[7]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[8]);
			toggle_class(div, "is-focused", /*isFocused*/ ctx[9]);
			toggle_class(div, "is-keyboardFocused", /*isKeyboardFocused*/ ctx[10]);
			toggle_class(div, "is-disabled", /*disabled*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(div, t2);
			append(div, input);
			/*input_binding*/ ctx[21](input);
			set_input_value(input, /*value*/ ctx[0]);
			/*div_binding*/ ctx[25](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[22]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[15].call(null, input)),
					listen(div, "focusin", /*focusin_handler*/ ctx[23]),
					listen(div, "focusout", /*focusout_handler*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isValid*/ ctx[7]) {
				if (if_block0) {
					if (dirty & /*isValid*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$P();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*isInvalid*/ ctx[8]) {
				if (if_block1) {
					if (dirty & /*isInvalid*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$11();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 2) {
				attr(input, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_class_value !== (input_class_value = "spectrum-Textfield-input " + /*$$restProps*/ ctx[17].inputClass)) {
				attr(input, "class", input_class_value);
			}

			if (!current || dirty & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty & /*name*/ 8) {
				attr(input, "name", /*name*/ ctx[3]);
			}

			if (!current || dirty & /*required*/ 16) {
				input.required = /*required*/ ctx[4];
			}

			if (!current || dirty & /*disabled*/ 32) {
				input.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_autocomplete_value !== (input_autocomplete_value = /*$$restProps*/ ctx[17].autocomplete)) {
				attr(input, "autocomplete", input_autocomplete_value);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_min_value !== (input_min_value = /*$$restProps*/ ctx[17].min)) {
				attr(input, "min", input_min_value);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_max_value !== (input_max_value = /*$$restProps*/ ctx[17].max)) {
				attr(input, "max", input_max_value);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && input_step_value !== (input_step_value = /*$$restProps*/ ctx[17].step)) {
				attr(input, "step", input_step_value);
			}

			if (!current || dirty & /*maxLength*/ 2048) {
				attr(input, "maxlength", /*maxLength*/ ctx[11]);
			}

			if (!current || dirty & /*minLength*/ 4096) {
				attr(input, "minlength", /*minLength*/ ctx[12]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (!current || dirty & /*$$restProps*/ 131072 && div_class_value !== (div_class_value = "spectrum-Textfield " + /*$$restProps*/ ctx[17].class)) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*$$restProps, isQuiet*/ 131136) {
				toggle_class(div, "spectrum-Textfield--quiet", /*isQuiet*/ ctx[6]);
			}

			if (dirty & /*$$restProps, isValid*/ 131200) {
				toggle_class(div, "is-valid", /*isValid*/ ctx[7]);
			}

			if (dirty & /*$$restProps, isInvalid*/ 131328) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[8]);
			}

			if (dirty & /*$$restProps, isFocused*/ 131584) {
				toggle_class(div, "is-focused", /*isFocused*/ ctx[9]);
			}

			if (dirty & /*$$restProps, isKeyboardFocused*/ 132096) {
				toggle_class(div, "is-keyboardFocused", /*isKeyboardFocused*/ ctx[10]);
			}

			if (dirty & /*$$restProps, disabled*/ 131104) {
				toggle_class(div, "is-disabled", /*disabled*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*input_binding*/ ctx[21](null);
			/*div_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$27($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"id","placeholder","name","value","required","disabled","isQuiet","isValid","isInvalid","isFocused","isKeyboardFocused","maxLength","minLength","resetType"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { id = `textfield-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { placeholder = "" } = $$props;
	let { name = "field" } = $$props;
	let { value = "" } = $$props;
	let { required = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { isValid = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isFocused = false } = $$props;
	let { isKeyboardFocused = false } = $$props;
	let { maxLength = 32 } = $$props;
	let { minLength = 0 } = $$props;
	let { resetType = "text" } = $$props;
	const eventsListen = getEventsAction(current_component);
	let textfieldEl;
	let inputEl;

	onMount(() => {
		textfieldEl && addClassName();

		if (textfieldEl && textfieldEl.lastChild.type) {
			$$invalidate(13, textfieldEl.lastChild.type = resetType, textfieldEl);
		}
	});

	function setFocus(focused) {
		var focusClass = inputEl.classList.contains("focus-ring")
		? "is-keyboardFocused"
		: "is-focused";

		if (focused) {
			textfieldEl.classList.add(focusClass);
		} else {
			textfieldEl.classList.remove("is-keyboardFocused");
			textfieldEl.classList.remove("is-focused");
		}
	}

	function addClassName() {
		let fieldIconList = textfieldEl.getElementsByClassName("spectrum-Icon");

		if (fieldIconList.length) {
			for (let index = 0; index < fieldIconList.length; index++) {
				let isUIIcon = fieldIconList[index].classList.contains("spectrum-Textfield-validationIcon");

				if (!isUIIcon) {
					fieldIconList[index].classList.toggle(`spectrum-Textfield-icon`);
				}
			}
		}
	}

	let { $$slots = {}, $$scope } = $$props;

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(14, inputEl);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const focusin_handler = () => {
		setFocus(true);
	};

	const focusout_handler = () => {
		setFocus(false);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textfieldEl = $$value;
			$$invalidate(13, textfieldEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("placeholder" in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);
		if ("name" in $$new_props) $$invalidate(3, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("required" in $$new_props) $$invalidate(4, required = $$new_props.required);
		if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("isQuiet" in $$new_props) $$invalidate(6, isQuiet = $$new_props.isQuiet);
		if ("isValid" in $$new_props) $$invalidate(7, isValid = $$new_props.isValid);
		if ("isInvalid" in $$new_props) $$invalidate(8, isInvalid = $$new_props.isInvalid);
		if ("isFocused" in $$new_props) $$invalidate(9, isFocused = $$new_props.isFocused);
		if ("isKeyboardFocused" in $$new_props) $$invalidate(10, isKeyboardFocused = $$new_props.isKeyboardFocused);
		if ("maxLength" in $$new_props) $$invalidate(11, maxLength = $$new_props.maxLength);
		if ("minLength" in $$new_props) $$invalidate(12, minLength = $$new_props.minLength);
		if ("resetType" in $$new_props) $$invalidate(18, resetType = $$new_props.resetType);
		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	return [
		value,
		id,
		placeholder,
		name,
		required,
		disabled,
		isQuiet,
		isValid,
		isInvalid,
		isFocused,
		isKeyboardFocused,
		maxLength,
		minLength,
		textfieldEl,
		inputEl,
		eventsListen,
		setFocus,
		$$restProps,
		resetType,
		$$scope,
		$$slots,
		input_binding,
		input_input_handler,
		focusin_handler,
		focusout_handler,
		div_binding
	];
}

class Textfield$1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$27, create_fragment$27, safe_not_equal, {
			id: 1,
			placeholder: 2,
			name: 3,
			value: 0,
			required: 4,
			disabled: 5,
			isQuiet: 6,
			isValid: 7,
			isInvalid: 8,
			isFocused: 9,
			isKeyboardFocused: 10,
			maxLength: 11,
			minLength: 12,
			resetType: 18
		});
	}
}

/* src/packages/Thumbnail/Thumbnail.svelte generated by Svelte v3.24.1 */

function create_else_block$k(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "spectrum-Thumbnail-background");
			set_style(div, "background-image", "url(" + /*imgUrl*/ ctx[0] + ")");
			attr(div, "title", /*imgAlt*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*imgUrl*/ 1) {
				set_style(div, "background-image", "url(" + /*imgUrl*/ ctx[0] + ")");
			}

			if (dirty & /*imgAlt*/ 2) {
				attr(div, "title", /*imgAlt*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (49:2) {#if variants === 'foreground'}
function create_if_block$12(ctx) {
	let t;
	let img;
	let img_src_value;
	let if_block = /*backgroundColor*/ ctx[3] && create_if_block_1$Q(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			img = element("img");
			attr(img, "class", "spectrum-Thumbnail-image");
			if (img.src !== (img_src_value = /*imgUrl*/ ctx[0])) attr(img, "src", img_src_value);
			attr(img, "alt", /*imgAlt*/ ctx[1]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (/*backgroundColor*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$Q(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*imgUrl*/ 1 && img.src !== (img_src_value = /*imgUrl*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*imgAlt*/ 2) {
				attr(img, "alt", /*imgAlt*/ ctx[1]);
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(img);
		}
	};
}

// (50:4) {#if backgroundColor}
function create_if_block_1$Q(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "spectrum-Thumbnail-background");
			set_style(div, "background-color", /*backgroundColor*/ ctx[3]);
			attr(div, "title", /*imgAlt*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*backgroundColor*/ 8) {
				set_style(div, "background-color", /*backgroundColor*/ ctx[3]);
			}

			if (dirty & /*imgAlt*/ 2) {
				attr(div, "title", /*imgAlt*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$28(ctx) {
	let div;
	let div_class_value;

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[2] === "foreground") return create_if_block$12;
		return create_else_block$k;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", div_class_value = "spectrum-Thumbnail spectrum-Thumbnail--" + /*scale*/ ctx[6] + " " + /*$$restProps*/ ctx[7].class);
			toggle_class(div, "is-selected", /*isSelected*/ ctx[4]);
			toggle_class(div, "is-focused", /*isFocused*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*scale, $$restProps*/ 192 && div_class_value !== (div_class_value = "spectrum-Thumbnail spectrum-Thumbnail--" + /*scale*/ ctx[6] + " " + /*$$restProps*/ ctx[7].class)) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*scale, $$restProps, isSelected*/ 208) {
				toggle_class(div, "is-selected", /*isSelected*/ ctx[4]);
			}

			if (dirty & /*scale, $$restProps, isFocused*/ 224) {
				toggle_class(div, "is-focused", /*isFocused*/ ctx[5]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$28($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"imgUrl","imgAlt","variants","backgroundColor","isSelected","isFocused","scale"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { imgUrl = "" } = $$props;
	let { imgAlt = "Image" } = $$props;
	let { variants = "foreground" } = $$props;
	let { backgroundColor = "" } = $$props;
	let { isSelected = false } = $$props;
	let { isFocused = false } = $$props;
	let { scale = "M" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("imgUrl" in $$new_props) $$invalidate(0, imgUrl = $$new_props.imgUrl);
		if ("imgAlt" in $$new_props) $$invalidate(1, imgAlt = $$new_props.imgAlt);
		if ("variants" in $$new_props) $$invalidate(2, variants = $$new_props.variants);
		if ("backgroundColor" in $$new_props) $$invalidate(3, backgroundColor = $$new_props.backgroundColor);
		if ("isSelected" in $$new_props) $$invalidate(4, isSelected = $$new_props.isSelected);
		if ("isFocused" in $$new_props) $$invalidate(5, isFocused = $$new_props.isFocused);
		if ("scale" in $$new_props) $$invalidate(6, scale = $$new_props.scale);
	};

	return [
		imgUrl,
		imgAlt,
		variants,
		backgroundColor,
		isSelected,
		isFocused,
		scale,
		$$restProps
	];
}

class Thumbnail extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$28, create_fragment$28, safe_not_equal, {
			imgUrl: 0,
			imgAlt: 1,
			variants: 2,
			backgroundColor: 3,
			isSelected: 4,
			isFocused: 5,
			scale: 6
		});
	}
}

/* src/packages/Toast/Toast.svelte generated by Svelte v3.24.1 */

function create_if_block_2$f(ctx) {
	let iconsuccessmedium;
	let current;

	iconsuccessmedium = new SuccessMedium({
			props: { className: "spectrum-Toast-typeIcon" }
		});

	return {
		c() {
			create_component(iconsuccessmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsuccessmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsuccessmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsuccessmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsuccessmedium, detaching);
		}
	};
}

// (48:86) 
function create_if_block_1$R(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: { className: "spectrum-Toast-typeIcon" }
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (46:2) {#if variants === 'info'}
function create_if_block$13(ctx) {
	let iconinfomedium;
	let current;

	iconinfomedium = new InfoMedium({
			props: { className: "spectrum-Toast-typeIcon" }
		});

	return {
		c() {
			create_component(iconinfomedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconinfomedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconinfomedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconinfomedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconinfomedium, detaching);
		}
	};
}

// (58:4) <Button exterior="clear" variant="overBackground" on:click on:keydown on:keyup on:mousedown on:mouseup>
function create_default_slot$e(ctx) {
	let iconcrossmedium;
	let current;

	iconcrossmedium = new CrossMedium({
			props: {
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconcrossmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconcrossmedium, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconcrossmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconcrossmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconcrossmedium, detaching);
		}
	};
}

function create_fragment$29(ctx) {
	let div3;
	let current_block_type_index;
	let if_block;
	let t0;
	let div1;
	let div0;
	let t1;
	let t2;
	let t3;
	let div2;
	let button;
	let div3_class_value;
	let current;
	const if_block_creators = [create_if_block$13, create_if_block_1$R, create_if_block_2$f];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[1] === "info") return 0;
		if (/*variants*/ ctx[1] === "negative" || /*variants*/ ctx[1] === "error" || /*variants*/ ctx[1] === "warning") return 1;
		if (/*variants*/ ctx[1] === "positive" || /*variants*/ ctx[1] === "success") return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	button = new Button({
			props: {
				exterior: "clear",
				variant: "overBackground",
				$$slots: { default: [create_default_slot$e] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[6]);
	button.$on("keydown", /*keydown_handler*/ ctx[7]);
	button.$on("keyup", /*keyup_handler*/ ctx[8]);
	button.$on("mousedown", /*mousedown_handler*/ ctx[9]);
	button.$on("mouseup", /*mouseup_handler*/ ctx[10]);

	return {
		c() {
			div3 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			t1 = text(/*label*/ ctx[0]);
			t2 = space();
			if (default_slot) default_slot.c();
			t3 = space();
			div2 = element("div");
			create_component(button.$$.fragment);
			attr(div0, "class", "spectrum-Toast-content");
			attr(div1, "class", "spectrum-Toast-body");
			attr(div2, "class", "spectrum-Toast-buttons");
			attr(div3, "class", div3_class_value = "spectrum-Toast spectrum-Toast--" + /*variants*/ ctx[1]);
			attr(div3, "style", /*styleCssText*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div3, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div3, null);
			}

			append(div3, t0);
			append(div3, div1);
			append(div1, div0);
			append(div0, t1);
			append(div1, t2);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(div3, t3);
			append(div3, div2);
			mount_component(button, div2, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div3, t0);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (!current || dirty & /*variants*/ 2 && div3_class_value !== (div3_class_value = "spectrum-Toast spectrum-Toast--" + /*variants*/ ctx[1])) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*styleCssText*/ 4) {
				attr(div3, "style", /*styleCssText*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot) default_slot.d(detaching);
			destroy_component(button);
		}
	};
}

function instance$29($$self, $$props, $$invalidate) {
	let { label = "" } = $$props;
	let { variants = "default" } = $$props;
	let { height = "auto" } = $$props;
	let { width = "auto" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("height" in $$props) $$invalidate(3, height = $$props.height);
		if ("width" in $$props) $$invalidate(4, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*height, width*/ 24) {
			 $$invalidate(2, styleCssText = [
				height && height.toString().indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: height.toString().indexOf("%") !== -1
					? `height: ${height};`
					: `height: ${height}px;`,
				width && width.toString().indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: width.toString().indexOf("%") !== -1
					? `width: ${width};`
					: `width: ${width}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		label,
		variants,
		styleCssText,
		height,
		width,
		$$slots,
		click_handler,
		keydown_handler,
		keyup_handler,
		mousedown_handler,
		mouseup_handler,
		$$scope
	];
}

class Toast extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$29, create_fragment$29, safe_not_equal, {
			label: 0,
			variants: 1,
			height: 3,
			width: 4
		});
	}
}

/* src/packages/Tooltip/Tooltip.svelte generated by Svelte v3.24.1 */

function add_css$u() {
	var style = element("style");
	style.id = "svelte-8h8moi-style";
	style.textContent = ".u-tooltip-showOnEvent{display:inline-block;position:relative}.u-tooltip-showOnEvent .spectrum-Tooltip{position:absolute;white-space:nowrap;visibility:visible !important;transition:transform var(--spectrum-global-animation-duration-100, 130ms) ease-in-out;top:-100%}.u-tooltip-showOnEvent .spectrum-Tooltip-label{max-width:none}.u-tooltip-showOnEvent .spectrum-Tooltip--right,.u-tooltip-showOnEvent .spectrum-Tooltip--left{top:50%}.u-tooltip-showOnEvent .spectrum-Tooltip--right .spectrum-Tooltip-tip,.u-tooltip-showOnEvent .spectrum-Tooltip--left .spectrum-Tooltip-tip{top:50%}.u-tooltip-showOnEvent .spectrum-Tooltip--right{left:100%;transform:translate(0, -50%)}.u-tooltip-showOnEvent .spectrum-Tooltip--left{transform:translate(-100%, -50%)}.u-tooltip-showOnEvent .spectrum-Tooltip--bottom,.u-tooltip-showOnEvent .spectrum-Tooltip--top{left:50%}.u-tooltip-showOnEvent .spectrum-Tooltip--bottom .spectrum-Tooltip-tip,.u-tooltip-showOnEvent .spectrum-Tooltip--top .spectrum-Tooltip-tip{left:50%}.u-tooltip-showOnEvent .spectrum-Tooltip--bottom{top:100%;transform:translate(-50%, calc(-1 * var(--spectrum-tooltip-tip-margin, var(--spectrum-global-dimension-size-50))))}.u-tooltip-showOnEvent .spectrum-Tooltip--top{transform:translate(-50%, var(--spectrum-tooltip-tip-margin, var(--spectrum-global-dimension-size-50)))}.u-tooltip-showOnEvent .spectrum-Tooltip.is-open,.u-tooltip-showOnEvent:focus .spectrum-Tooltip,.u-tooltip-showOnEvent.is-focused .spectrum-Tooltip,.u-tooltip-showOnEvent *:focus .spectrum-Tooltip{opacity:1}.u-tooltip-showOnEvent .spectrum-Tooltip.is-open.spectrum-Tooltip--bottom,.u-tooltip-showOnEvent:focus .spectrum-Tooltip.spectrum-Tooltip--bottom,.u-tooltip-showOnEvent.is-focused .spectrum-Tooltip.spectrum-Tooltip--bottom,.u-tooltip-showOnEvent *:focus .spectrum-Tooltip.spectrum-Tooltip--bottom{transform:translate(-50%, 0)}.u-tooltip-showOnEvent .spectrum-Tooltip.is-open.spectrum-Tooltip--top,.u-tooltip-showOnEvent:focus .spectrum-Tooltip.spectrum-Tooltip--top,.u-tooltip-showOnEvent.is-focused .spectrum-Tooltip.spectrum-Tooltip--top,.u-tooltip-showOnEvent *:focus .spectrum-Tooltip.spectrum-Tooltip--top{transform:translate(-50%, calc(-1 * var(--spectrum-tooltip-tip-margin, var(--spectrum-global-dimension-size-50))))}.u-tooltip-showOnEvent .spectrum-Tooltip.is-open.spectrum-Tooltip--left,.u-tooltip-showOnEvent:focus .spectrum-Tooltip.spectrum-Tooltip--left,.u-tooltip-showOnEvent.is-focused .spectrum-Tooltip.spectrum-Tooltip--left,.u-tooltip-showOnEvent *:focus .spectrum-Tooltip.spectrum-Tooltip--left{transform:translate(\n      calc(-100% - var(--spectrum-tooltip-tip-margin, var(--spectrum-global-dimension-size-50))),\n      -50%\n    )}.u-tooltip-showOnEvent .spectrum-Tooltip.is-open.spectrum-Tooltip--right,.u-tooltip-showOnEvent:focus .spectrum-Tooltip.spectrum-Tooltip--right,.u-tooltip-showOnEvent.is-focused .spectrum-Tooltip.spectrum-Tooltip--right,.u-tooltip-showOnEvent *:focus .spectrum-Tooltip.spectrum-Tooltip--right{transform:translate(var(--spectrum-tooltip-tip-margin, var(--spectrum-global-dimension-size-50)), -50%)}.spectrum-Tooltip-typeIcon{width:var(--spectrum-global-dimension-size-225);height:var(--spectrum-global-dimension-size-225);transform:scale(0.8)}.spectrum-Tooltip--help>.spectrum-Tooltip-typeIcon-help{transform:scale(1)}.spectrum-Tooltip-label{white-space:normal}";
	append(document.head, style);
}

// (211:32) 
function create_if_block_3$a(ctx) {
	let iconhelpsmall;
	let current;

	iconhelpsmall = new HelpSmall({
			props: {
				className: "spectrum-Tooltip-typeIcon spectrum-Tooltip-typeIcon-help",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconhelpsmall.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconhelpsmall, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconhelpsmall.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconhelpsmall.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconhelpsmall, detaching);
		}
	};
}

// (209:36) 
function create_if_block_2$g(ctx) {
	let iconsuccessmedium;
	let current;

	iconsuccessmedium = new SuccessMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconsuccessmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsuccessmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsuccessmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsuccessmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsuccessmedium, detaching);
		}
	};
}

// (207:32) 
function create_if_block_1$S(ctx) {
	let iconinfomedium;
	let current;

	iconinfomedium = new InfoMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconinfomedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconinfomedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconinfomedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconinfomedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconinfomedium, detaching);
		}
	};
}

// (205:2) {#if variants === 'negative'}
function create_if_block$14(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconalertmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};
}

// (217:45) {label}
function fallback_block$g(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data(t, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$2a(ctx) {
	let span2;
	let current_block_type_index;
	let if_block;
	let t0;
	let span0;
	let t1;
	let span1;
	let span2_class_value;
	let span2_resize_listener;
	let current;
	const if_block_creators = [create_if_block$14, create_if_block_1$S, create_if_block_2$g, create_if_block_3$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[2] === "negative") return 0;
		if (/*variants*/ ctx[2] === "info") return 1;
		if (/*variants*/ ctx[2] === "positive") return 2;
		if (/*variants*/ ctx[2] === "help") return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	const default_slot_or_fallback = default_slot || fallback_block$g(ctx);

	return {
		c() {
			span2 = element("span");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t1 = space();
			span1 = element("span");
			attr(span0, "class", "spectrum-Tooltip-label");
			attr(span1, "class", "spectrum-Tooltip-tip");
			attr(span2, "class", span2_class_value = "spectrum-Tooltip spectrum-Tooltip--" + /*variants*/ ctx[2] + " spectrum-Tooltip--" + /*directions*/ ctx[3] + " ");
			attr(span2, "style", /*styleText*/ ctx[5]);
			add_render_callback(() => /*span2_elementresize_handler*/ ctx[12].call(span2));
			toggle_class(span2, "is-open", /*isOpen*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, span2, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(span2, null);
			}

			append(span2, t0);
			append(span2, span0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span0, null);
			}

			append(span2, t1);
			append(span2, span1);
			span2_resize_listener = add_resize_listener(span2, /*span2_elementresize_handler*/ ctx[12].bind(span2));
			/*span2_binding*/ ctx[13](span2);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(span2, t0);
				} else {
					if_block = null;
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*variants, directions*/ 12 && span2_class_value !== (span2_class_value = "spectrum-Tooltip spectrum-Tooltip--" + /*variants*/ ctx[2] + " spectrum-Tooltip--" + /*directions*/ ctx[3] + " ")) {
				attr(span2, "class", span2_class_value);
			}

			if (!current || dirty & /*styleText*/ 32) {
				attr(span2, "style", /*styleText*/ ctx[5]);
			}

			if (dirty & /*variants, directions, isOpen*/ 13) {
				toggle_class(span2, "is-open", /*isOpen*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			span2_resize_listener();
			/*span2_binding*/ ctx[13](null);
		}
	};
}

function instance$2a($$self, $$props, $$invalidate) {
	let { label = "" } = $$props;
	let { variants = "default" } = $$props;
	let { isOpen = false } = $$props;
	let { directions = "top" } = $$props;
	let { induceStartEventName = "mouseover" } = $$props;
	let { induceEndEventName = "mouseout" } = $$props;
	let { width = "size-2000" } = $$props;
	let tooltipEl;
	let styleText = "";
	let tooltipCH;

	onMount(() => {
		if (tooltipEl) {
			tooltipEl.parentNode.classList.toggle("u-tooltip-showOnEvent");

			tooltipEl.parentNode.addEventListener(induceStartEventName, function () {
				$$invalidate(0, isOpen = !isOpen);
			});

			if (induceStartEventName !== induceEndEventName) {
				tooltipEl.parentNode.addEventListener(induceEndEventName, function () {
					if (isOpen) $$invalidate(0, isOpen = false);
				});
			}
		}
	});

	afterUpdate(() => {
		let tooltipWrapHeight = tooltipEl.parentNode.clientHeight;
		let tooltipWrapWidth = tooltipEl.parentNode.clientWidth;

		let widthCss = width && width.toString().indexOf("size") !== -1
		? `width:var(--spectrum-global-dimension-${width});`
		: width.toString().indexOf("%") !== -1
			? `width: ${width};`
			: `width: ${width}px;`;

		switch (directions) {
			case "top":
				$$invalidate(5, styleText = `top:-${tooltipCH + tooltipWrapHeight * 0.5}px;${widthCss}`);
				break;
			case "bottom":
				$$invalidate(5, styleText = `top:calc(var(--spectrum-global-dimension-size-75) + ${tooltipWrapHeight}px);${widthCss}`);
				break;
			case "left":
				$$invalidate(5, styleText = `left:calc(-1 * var(--spectrum-global-dimension-size-75));${widthCss}`);
				break;
			case "right":
				$$invalidate(5, styleText = `left:calc(var(--spectrum-global-dimension-size-75) + ${tooltipWrapWidth}px);${widthCss}`);
				break;
		}
	});

	let { $$slots = {}, $$scope } = $$props;

	function span2_elementresize_handler() {
		tooltipCH = this.clientHeight;
		$$invalidate(6, tooltipCH);
	}

	function span2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tooltipEl = $$value;
			$$invalidate(4, tooltipEl);
		});
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("directions" in $$props) $$invalidate(3, directions = $$props.directions);
		if ("induceStartEventName" in $$props) $$invalidate(7, induceStartEventName = $$props.induceStartEventName);
		if ("induceEndEventName" in $$props) $$invalidate(8, induceEndEventName = $$props.induceEndEventName);
		if ("width" in $$props) $$invalidate(9, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		isOpen,
		label,
		variants,
		directions,
		tooltipEl,
		styleText,
		tooltipCH,
		induceStartEventName,
		induceEndEventName,
		width,
		$$scope,
		$$slots,
		span2_elementresize_handler,
		span2_binding
	];
}

class Tooltip extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-8h8moi-style")) add_css$u();

		init(this, options, instance$2a, create_fragment$2a, safe_not_equal, {
			label: 1,
			variants: 2,
			isOpen: 0,
			directions: 3,
			induceStartEventName: 7,
			induceEndEventName: 8,
			width: 9
		});
	}
}

/* src/packages/Tray/Tray.svelte generated by Svelte v3.24.1 */

function create_default_slot$f(ctx) {
	let section1;
	let div;
	let h1;
	let t0;
	let t1;
	let hr;
	let t2;
	let section0;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			section1 = element("section");
			div = element("div");
			h1 = element("h1");
			t0 = text(/*title*/ ctx[1]);
			t1 = space();
			hr = element("hr");
			t2 = space();
			section0 = element("section");
			if (default_slot) default_slot.c();
			attr(h1, "class", "spectrum-Dialog-heading spectrum-Dialog-heading--noHeader");
			attr(hr, "class", "spectrum-Divider spectrum-Divider--medium spectrum-Divider--horizontal spectrum-Dialog-divider");
			attr(section0, "class", "spectrum-Dialog-content");
			attr(div, "class", "spectrum-Dialog-grid");
			toggle_class(div, "is-open", /*isOpen*/ ctx[0]);
			attr(section1, "class", "spectrum-Dialog spectrum-Dialog--large");
			attr(section1, "role", "dialog");
			attr(section1, "tabindex", "-1");
			attr(section1, "aria-modal", "true");
			set_style(section1, "z-index", +/*zIndex*/ ctx[2] + 1);
			toggle_class(section1, "is-open", /*isOpen*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, section1, anchor);
			append(section1, div);
			append(div, h1);
			append(h1, t0);
			append(div, t1);
			append(div, hr);
			append(div, t2);
			append(div, section0);

			if (default_slot) {
				default_slot.m(section0, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*title*/ 2) set_data(t0, /*title*/ ctx[1]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(div, "is-open", /*isOpen*/ ctx[0]);
			}

			if (!current || dirty & /*zIndex*/ 4) {
				set_style(section1, "z-index", +/*zIndex*/ ctx[2] + 1);
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(section1, "is-open", /*isOpen*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$2b(ctx) {
	let div;
	let t;
	let modal;
	let current;
	let mounted;
	let dispose;

	modal = new Modal({
			props: {
				class: "spectrum-Tray-wrapper",
				zIndex: +/*zIndex*/ ctx[2] + 1,
				innerClass: "spectrum-Tray",
				isOpen: /*isOpen*/ ctx[0],
				innerStyle: /*styleCssText*/ ctx[4],
				$$slots: { default: [create_default_slot$f] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			t = space();
			create_component(modal.$$.fragment);
			attr(div, "class", "spectrum-Underlay");
			set_style(div, "z-index", /*zIndex*/ ctx[2]);
			toggle_class(div, "is-open", /*isOpen*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			insert(target, t, anchor);
			mount_component(modal, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*puncture*/ ctx[3] && /*cancelDialog*/ ctx[5])) (/*puncture*/ ctx[3] && /*cancelDialog*/ ctx[5]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (!current || dirty & /*zIndex*/ 4) {
				set_style(div, "z-index", /*zIndex*/ ctx[2]);
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(div, "is-open", /*isOpen*/ ctx[0]);
			}

			const modal_changes = {};
			if (dirty & /*zIndex*/ 4) modal_changes.zIndex = +/*zIndex*/ ctx[2] + 1;
			if (dirty & /*isOpen*/ 1) modal_changes.isOpen = /*isOpen*/ ctx[0];
			if (dirty & /*styleCssText*/ 16) modal_changes.innerStyle = /*styleCssText*/ ctx[4];

			if (dirty & /*$$scope, zIndex, isOpen, title*/ 263) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching) detach(t);
			destroy_component(modal, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$2b($$self, $$props, $$invalidate) {
	let { title = "" } = $$props;
	let { zIndex = 100 } = $$props;
	let { isOpen = false } = $$props;
	let { puncture = false } = $$props;
	let { maxHeight = 1149 } = $$props;

	function cancelDialog() {
		$$invalidate(0, isOpen = false);
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("zIndex" in $$props) $$invalidate(2, zIndex = $$props.zIndex);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("puncture" in $$props) $$invalidate(3, puncture = $$props.puncture);
		if ("maxHeight" in $$props) $$invalidate(6, maxHeight = $$props.maxHeight);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*maxHeight*/ 64) {
			 $$invalidate(4, styleCssText = [
				maxHeight && maxHeight.toString().indexOf("size") !== -1
				? `max-height:calc(var(--spectrum-global-dimension-${maxHeight}) - var(--spectrum-tray-margin-top));`
				: maxHeight.toString().indexOf("%") !== -1
					? `max-height: calc(${maxHeight} - var(--spectrum-tray-margin-top));`
					: `max-height: calc(${maxHeight}px - var(--spectrum-tray-margin-top));`
			].filter(Boolean).join(" "));
		}
	};

	return [
		isOpen,
		title,
		zIndex,
		puncture,
		styleCssText,
		cancelDialog,
		maxHeight,
		$$slots,
		$$scope
	];
}

class Tray extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2b, create_fragment$2b, safe_not_equal, {
			title: 1,
			zIndex: 2,
			isOpen: 0,
			puncture: 3,
			maxHeight: 6
		});
	}
}

/* src/packages/TreeView/TreeView.svelte generated by Svelte v3.24.1 */

function create_fragment$2c(ctx) {
	let ul;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", "spectrum-TreeView");
			attr(ul, "style", /*styleCssText*/ ctx[2]);
			toggle_class(ul, "spectrum-TreeView--thumbnail", /*hasThumbnail*/ ctx[1]);
			toggle_class(ul, "spectrum-TreeView--quiet", /*isQuiet*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*styleCssText*/ 4) {
				attr(ul, "style", /*styleCssText*/ ctx[2]);
			}

			if (dirty & /*hasThumbnail*/ 2) {
				toggle_class(ul, "spectrum-TreeView--thumbnail", /*hasThumbnail*/ ctx[1]);
			}

			if (dirty & /*isQuiet*/ 1) {
				toggle_class(ul, "spectrum-TreeView--quiet", /*isQuiet*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function furthest(el, selector) {
	var lastMatch = null;

	while (el) {
		if (el.matches && el.matches(selector)) {
			lastMatch = el;
		}

		el = el.parentNode;
	}

	return lastMatch;
}

function initTreeView(event) {
	var treeviewItem = event.target.closest(".spectrum-TreeView-item");

	if (!treeviewItem) {
		return;
	}

	var isDisabled = treeviewItem.classList.contains("is-disabled");

	if (isDisabled) {
		return;
	}

	var el;

	if ((el = event.target.closest(".spectrum-TreeView-itemIndicator")) !== null) {
		treeviewItem.classList.toggle("is-open");
		event.preventDefault();
	} else if ((el = event.target.closest(".spectrum-TreeView-itemLink")) !== null) {
		if (!(event.shiftKey || event.metaKey)) {
			// Remove other selected items
			let outerTreeview = furthest(el, ".spectrum-TreeView");

			if (outerTreeview) {
				Array.prototype.forEach.call(outerTreeview.querySelectorAll(".spectrum-TreeView-item.is-selected"), function (item) {
					if (item != treeviewItem) {
						item.classList.remove("is-selected");
						var thumbnail = item.querySelector(".spectrum-TreeView-itemThumbnail");

						if (thumbnail) {
							thumbnail.classList.remove("is-focused");
						}
					}
				});
			}
		}

		let selected = treeviewItem.classList.toggle("is-selected");
		var thumbnail = treeviewItem.querySelector(".spectrum-TreeView-itemThumbnail");

		if (thumbnail) {
			thumbnail.classList[selected ? "add" : "remove"]("is-focused");
		}

		event.preventDefault();
	}
}

function instance$2c($$self, $$props, $$invalidate) {
	let { height = "auto" } = $$props;
	let { width = 250 } = $$props;
	let { isQuiet = false } = $$props;
	let { hasThumbnail = false } = $$props;
	let { resourceExplorer = false } = $$props;
	setContext("rubusTreeViewConfig", { hasThumbnail, resourceExplorer });

	onMount(() => {
		window.addEventListener("click", initTreeView);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("height" in $$props) $$invalidate(3, height = $$props.height);
		if ("width" in $$props) $$invalidate(4, width = $$props.width);
		if ("isQuiet" in $$props) $$invalidate(0, isQuiet = $$props.isQuiet);
		if ("hasThumbnail" in $$props) $$invalidate(1, hasThumbnail = $$props.hasThumbnail);
		if ("resourceExplorer" in $$props) $$invalidate(5, resourceExplorer = $$props.resourceExplorer);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	let styleCssText;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*height, width*/ 24) {
			 $$invalidate(2, styleCssText = [
				height && height.toString().indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: height.toString().indexOf("%") !== -1
					? `height: ${height};`
					: `height: ${height}px;`,
				width && width.toString().indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: width.toString().indexOf("%") !== -1
					? `width: ${width};`
					: `width: ${width}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		isQuiet,
		hasThumbnail,
		styleCssText,
		height,
		width,
		resourceExplorer,
		$$scope,
		$$slots
	];
}

class TreeView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2c, create_fragment$2c, safe_not_equal, {
			height: 3,
			width: 4,
			isQuiet: 0,
			hasThumbnail: 1,
			resourceExplorer: 5
		});
	}
}

/* src/packages/TreeView/TreeItem.svelte generated by Svelte v3.24.1 */
const get_treeview_icon_slot_changes = dirty => ({});
const get_treeview_icon_slot_context = ctx => ({});

// (79:38) 
function create_if_block_3$b(ctx) {
	let iconchevronrightmedium;
	let current;

	iconchevronrightmedium = new ChevronRightMedium({
			props: {
				className: "spectrum-TreeView-itemIndicator",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconchevronrightmedium.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconchevronrightmedium, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconchevronrightmedium.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconchevronrightmedium.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconchevronrightmedium, detaching);
		}
	};
}

// (77:66) 
function create_if_block_2$h(ctx) {
	let icondocument;
	let current;

	icondocument = new Document({
			props: {
				className: "spectrum-TreeView-itemIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(icondocument.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icondocument, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(icondocument.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icondocument.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icondocument, detaching);
		}
	};
}

// (75:4) {#if rubusTreeViewConfig.resourceExplorer && hasChild && !customIcon}
function create_if_block_1$T(ctx) {
	let iconfolder;
	let current;

	iconfolder = new Folder({
			props: {
				className: "spectrum-TreeView-itemIcon",
				focusable: "false",
				"aria-hidden": "true"
			}
		});

	return {
		c() {
			create_component(iconfolder.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconfolder, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconfolder.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconfolder.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconfolder, detaching);
		}
	};
}

// (82:4) {#if rubusTreeViewConfig.hasThumbnail}
function create_if_block$15(ctx) {
	let thumbnail;
	let current;

	thumbnail = new Thumbnail({
			props: {
				class: "spectrum-TreeView-itemThumbnail",
				imgAlt: /*thumbnailImgAlt*/ ctx[6],
				imgUrl: /*thumbnailImgUrl*/ ctx[5],
				backgroundColor: /*thumbnailBackgroundColor*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(thumbnail.$$.fragment);
		},
		m(target, anchor) {
			mount_component(thumbnail, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const thumbnail_changes = {};
			if (dirty & /*thumbnailImgAlt*/ 64) thumbnail_changes.imgAlt = /*thumbnailImgAlt*/ ctx[6];
			if (dirty & /*thumbnailImgUrl*/ 32) thumbnail_changes.imgUrl = /*thumbnailImgUrl*/ ctx[5];
			if (dirty & /*thumbnailBackgroundColor*/ 16) thumbnail_changes.backgroundColor = /*thumbnailBackgroundColor*/ ctx[4];
			thumbnail.$set(thumbnail_changes);
		},
		i(local) {
			if (current) return;
			transition_in(thumbnail.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(thumbnail.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(thumbnail, detaching);
		}
	};
}

function create_fragment$2d(ctx) {
	let li;
	let a;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let t2;
	let span;
	let t3;
	let t4;
	let current;
	let mounted;
	let dispose;
	const treeview_icon_slot_template = /*$$slots*/ ctx[13]["treeview-icon"];
	const treeview_icon_slot = create_slot(treeview_icon_slot_template, ctx, /*$$scope*/ ctx[12], get_treeview_icon_slot_context);
	const if_block_creators = [create_if_block_1$T, create_if_block_2$h, create_if_block_3$b];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*rubusTreeViewConfig*/ ctx[10].resourceExplorer && /*hasChild*/ ctx[7] && !/*customIcon*/ ctx[3]) return 0;
		if (/*rubusTreeViewConfig*/ ctx[10].resourceExplorer && !/*customIcon*/ ctx[3]) return 1;
		if (/*hasChild*/ ctx[7] && !/*customIcon*/ ctx[3]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block1 = /*rubusTreeViewConfig*/ ctx[10].hasThumbnail && create_if_block$15(ctx);
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			li = element("li");
			a = element("a");
			if (treeview_icon_slot) treeview_icon_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span = element("span");
			t3 = text(/*label*/ ctx[1]);
			t4 = space();
			if (default_slot) default_slot.c();
			attr(span, "class", "spectrum-TreeView-itemLabel");
			attr(a, "class", "spectrum-TreeView-itemLink");
			attr(a, "href", "#all");
			attr(li, "class", "spectrum-TreeView-item");
			toggle_class(li, "is-open", /*isOpen*/ ctx[0]);
			toggle_class(li, "is-drop-target", /*isDropTarget*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);

			if (treeview_icon_slot) {
				treeview_icon_slot.m(a, null);
			}

			append(a, t0);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(a, null);
			}

			append(a, t1);
			if (if_block1) if_block1.m(a, null);
			append(a, t2);
			append(a, span);
			append(span, t3);
			/*a_binding*/ ctx[14](a);
			append(li, t4);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding*/ ctx[15](li);
			current = true;

			if (!mounted) {
				dispose = listen(a, "click", /*cutoverStatus*/ ctx[11]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (treeview_icon_slot) {
				if (treeview_icon_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(treeview_icon_slot, treeview_icon_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_treeview_icon_slot_changes, get_treeview_icon_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block0) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(a, t1);
				} else {
					if_block0 = null;
				}
			}

			if (/*rubusTreeViewConfig*/ ctx[10].hasThumbnail) if_block1.p(ctx, dirty);
			if (!current || dirty & /*label*/ 2) set_data(t3, /*label*/ ctx[1]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}

			if (dirty & /*isOpen*/ 1) {
				toggle_class(li, "is-open", /*isOpen*/ ctx[0]);
			}

			if (dirty & /*isDropTarget*/ 4) {
				toggle_class(li, "is-drop-target", /*isDropTarget*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(treeview_icon_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(treeview_icon_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (treeview_icon_slot) treeview_icon_slot.d(detaching);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block1) if_block1.d();
			/*a_binding*/ ctx[14](null);
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$2d($$self, $$props, $$invalidate) {
	let { label = "Label" } = $$props;
	let { isOpen = false } = $$props;
	let { isDropTarget = false } = $$props;
	let { customIcon = false } = $$props;
	let { thumbnailBackgroundColor = "" } = $$props;
	let { thumbnailImgUrl = "" } = $$props;
	let { thumbnailImgAlt = "Image" } = $$props;
	let rubusTreeViewConfig = getContext("rubusTreeViewConfig");
	let hasChild = false;
	let treeViewItemEl;
	let treeViewItemLinkEl;

	onMount(() => {
		if (treeViewItemEl.childNodes.length > 2 && treeViewItemEl.childNodes[2].classList) {
			$$invalidate(7, hasChild = treeViewItemEl.childNodes[2].classList.contains("spectrum-TreeView"));
		}

		customIcon && treeViewItemLinkEl && advanceAddClassName(treeViewItemLinkEl, "treeview-icon", "spectrum-TreeView-itemIcon");
	});

	function cutoverStatus() {
		$$invalidate(0, isOpen = !isOpen);
	}

	let { $$slots = {}, $$scope } = $$props;

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			treeViewItemLinkEl = $$value;
			$$invalidate(9, treeViewItemLinkEl);
		});
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			treeViewItemEl = $$value;
			$$invalidate(8, treeViewItemEl);
		});
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("isDropTarget" in $$props) $$invalidate(2, isDropTarget = $$props.isDropTarget);
		if ("customIcon" in $$props) $$invalidate(3, customIcon = $$props.customIcon);
		if ("thumbnailBackgroundColor" in $$props) $$invalidate(4, thumbnailBackgroundColor = $$props.thumbnailBackgroundColor);
		if ("thumbnailImgUrl" in $$props) $$invalidate(5, thumbnailImgUrl = $$props.thumbnailImgUrl);
		if ("thumbnailImgAlt" in $$props) $$invalidate(6, thumbnailImgAlt = $$props.thumbnailImgAlt);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	return [
		isOpen,
		label,
		isDropTarget,
		customIcon,
		thumbnailBackgroundColor,
		thumbnailImgUrl,
		thumbnailImgAlt,
		hasChild,
		treeViewItemEl,
		treeViewItemLinkEl,
		rubusTreeViewConfig,
		cutoverStatus,
		$$scope,
		$$slots,
		a_binding,
		li_binding
	];
}

class TreeItem extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2d, create_fragment$2d, safe_not_equal, {
			label: 1,
			isOpen: 0,
			isDropTarget: 2,
			customIcon: 3,
			thumbnailBackgroundColor: 4,
			thumbnailImgUrl: 5,
			thumbnailImgAlt: 6
		});
	}
}

/* src/packages/TreeView/TreeHeading.svelte generated by Svelte v3.24.1 */

function create_fragment$2e(ctx) {
	let div;
	let span;
	let t;

	return {
		c() {
			div = element("div");
			span = element("span");
			t = text(/*label*/ ctx[0]);
			attr(span, "class", "spectrum-TreeView-itemLabel");
			attr(div, "class", "spectrum-TreeView-heading");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			append(span, t);
		},
		p(ctx, [dirty]) {
			if (dirty & /*label*/ 1) set_data(t, /*label*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$2e($$self, $$props, $$invalidate) {
	let { label = "" } = $$props;

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
	};

	return [label];
}

class TreeHeading extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2e, create_fragment$2e, safe_not_equal, { label: 0 });
	}
}

/* src/packages/Typography/TypographyBody.svelte generated by Svelte v3.24.1 */

function create_fragment$2f(ctx) {
	let p;
	let p_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			attr(p, "class", p_class_value = "spectrum-Body spectrum-Body--" + /*scale*/ ctx[0]);
			toggle_class(p, "spectrum-Body--serif", /*isSerif*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale*/ 1 && p_class_value !== (p_class_value = "spectrum-Body spectrum-Body--" + /*scale*/ ctx[0])) {
				attr(p, "class", p_class_value);
			}

			if (dirty & /*scale, isSerif*/ 3) {
				toggle_class(p, "spectrum-Body--serif", /*isSerif*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$2f($$self, $$props, $$invalidate) {
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [scale, isSerif, $$scope, $$slots];
}

class TypographyBody extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2f, create_fragment$2f, safe_not_equal, { scale: 0, isSerif: 1 });
	}
}

/* src/packages/Typography/TypographyCode.svelte generated by Svelte v3.24.1 */

function create_fragment$2g(ctx) {
	let code;
	let code_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			code = element("code");
			if (default_slot) default_slot.c();
			attr(code, "class", code_class_value = "spectrum-Code spectrum-Code--" + /*scale*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, code, anchor);

			if (default_slot) {
				default_slot.m(code, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale*/ 1 && code_class_value !== (code_class_value = "spectrum-Code spectrum-Code--" + /*scale*/ ctx[0])) {
				attr(code, "class", code_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(code);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$2g($$self, $$props, $$invalidate) {
	let { scale = "M" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [scale, $$scope, $$slots];
}

class TypographyCode extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2g, create_fragment$2g, safe_not_equal, { scale: 0 });
	}
}

/* src/packages/Typography/TypographyDetail.svelte generated by Svelte v3.24.1 */

function create_else_block$l(ctx) {
	let p;
	let p_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			attr(p, "class", p_class_value = "spectrum-Detail spectrum-Detail--" + /*scale*/ ctx[0]);
			toggle_class(p, "spectrum-Detail--serif", /*isSerif*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale*/ 1 && p_class_value !== (p_class_value = "spectrum-Detail spectrum-Detail--" + /*scale*/ ctx[0])) {
				attr(p, "class", p_class_value);
			}

			if (dirty & /*scale, isSerif*/ 3) {
				toggle_class(p, "spectrum-Detail--serif", /*isSerif*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (21:0) {#if isLight}
function create_if_block$16(ctx) {
	let p;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			attr(p, "class", "spectrum-Detail--light");
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$2h(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$16, create_else_block$l];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLight*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$2h($$self, $$props, $$invalidate) {
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	let { isLight = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("isLight" in $$props) $$invalidate(2, isLight = $$props.isLight);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [scale, isSerif, isLight, $$scope, $$slots];
}

class TypographyDetail extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2h, create_fragment$2h, safe_not_equal, { scale: 0, isSerif: 1, isLight: 2 });
	}
}

/* src/packages/Typography/TypographyHeading.svelte generated by Svelte v3.24.1 */

function create_fragment$2i(ctx) {
	let h1;
	let h1_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			h1 = element("h1");
			if (default_slot) default_slot.c();
			attr(h1, "class", h1_class_value = "spectrum-Heading spectrum-Heading--" + /*scale*/ ctx[0] + "  spectrum-Heading--" + /*thickness*/ ctx[2]);
			toggle_class(h1, "spectrum-Heading--serif", /*isSerif*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, h1, anchor);

			if (default_slot) {
				default_slot.m(h1, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale, thickness*/ 5 && h1_class_value !== (h1_class_value = "spectrum-Heading spectrum-Heading--" + /*scale*/ ctx[0] + "  spectrum-Heading--" + /*thickness*/ ctx[2])) {
				attr(h1, "class", h1_class_value);
			}

			if (dirty & /*scale, thickness, isSerif*/ 7) {
				toggle_class(h1, "spectrum-Heading--serif", /*isSerif*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$2i($$self, $$props, $$invalidate) {
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	let { thickness = "default" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("thickness" in $$props) $$invalidate(2, thickness = $$props.thickness);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [scale, isSerif, thickness, $$scope, $$slots];
}

class TypographyHeading extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2i, create_fragment$2i, safe_not_equal, { scale: 0, isSerif: 1, thickness: 2 });
	}
}

/* src/packages/Typography/TypographyWrap.svelte generated by Svelte v3.24.1 */

function create_fragment$2j(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "spectrum-Typography");
			attr(div, "lang", /*langContext*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (!current || dirty & /*langContext*/ 1) {
				attr(div, "lang", /*langContext*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$2j($$self, $$props, $$invalidate) {
	let { langContext = "en" } = $$props;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("langContext" in $$props) $$invalidate(0, langContext = $$props.langContext);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [langContext, $$scope, $$slots];
}

class TypographyWrap extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2j, create_fragment$2j, safe_not_equal, { langContext: 0 });
	}
}

/* src/packages/Well/Well.svelte generated by Svelte v3.24.1 */

function create_fragment$2k(ctx) {
	let span;
	let current;
	const default_slot_template = /*$$slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			span = element("span");
			if (default_slot) default_slot.c();
			attr(span, "class", "spectrum-Well");
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$2k($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, $$slots];
}

class Well extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2k, create_fragment$2k, safe_not_equal, {});
	}
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".spectrum-ButtonGroup {\n  display: -ms-flexbox;\n  display: flex;\n}\n\n.spectrum-ButtonGroup .spectrum-ButtonGroup-item {\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n  }\n\n[dir=\"ltr\"] .spectrum-ButtonGroup .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-left: var(--spectrum-buttongroup-button-gap-x, var(--spectrum-global-dimension-static-size-200));\n}\n\n[dir=\"rtl\"] .spectrum-ButtonGroup .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-right: var(--spectrum-buttongroup-button-gap-x, var(--spectrum-global-dimension-static-size-200));\n}\n\n.spectrum-ButtonGroup--vertical {\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n}\n\n[dir=\"ltr\"] .spectrum-ButtonGroup--vertical .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-left: 0;\n}\n\n[dir=\"rtl\"] .spectrum-ButtonGroup--vertical .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-right: 0;\n}\n\n.spectrum-ButtonGroup--vertical .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-top: var(--spectrum-buttongroup-button-gap-y, var(--spectrum-global-dimension-static-size-200));\n  }\n";
var stylesheet=".spectrum-ButtonGroup {\n  display: -ms-flexbox;\n  display: flex;\n}\n\n.spectrum-ButtonGroup .spectrum-ButtonGroup-item {\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n  }\n\n[dir=\"ltr\"] .spectrum-ButtonGroup .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-left: var(--spectrum-buttongroup-button-gap-x, var(--spectrum-global-dimension-static-size-200));\n}\n\n[dir=\"rtl\"] .spectrum-ButtonGroup .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-right: var(--spectrum-buttongroup-button-gap-x, var(--spectrum-global-dimension-static-size-200));\n}\n\n.spectrum-ButtonGroup--vertical {\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n}\n\n[dir=\"ltr\"] .spectrum-ButtonGroup--vertical .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-left: 0;\n}\n\n[dir=\"rtl\"] .spectrum-ButtonGroup--vertical .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-right: 0;\n}\n\n.spectrum-ButtonGroup--vertical .spectrum-ButtonGroup-item + .spectrum-ButtonGroup-item {\n    margin-top: var(--spectrum-buttongroup-button-gap-y, var(--spectrum-global-dimension-static-size-200));\n  }\n";
styleInject(css_248z);

var indexVars = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': css_248z,
    stylesheet: stylesheet
});

/**
 *  Copyright 2018 Adobe. All rights reserved.
 *  This file is licensed to you under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License. You may obtain a copy
 *  of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under
 *  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 *  OF ANY KIND, either express or implied. See the License for the specific language
 *  governing permissions and limitations under the License.
 */

// Provides explicit indication of elements receiving focus through keyboard interaction rather than mouse or touch.
(function (doc) {
  // In case file is imported in SSR context, don't polyfill anything
  if (!doc) {
    return;
  }

  var NAVIGATION_KEYS = [
    "Tab",
    "ArrowUp",
    "ArrowRight",
    "ArrowDown",
    "ArrowLeft",
    "Home",
    "End",
    "PageUp",
    "PageDown",
    "Enter",
    " ",
    "Escape",

    /* IE9 and Firefox < 37 */
    "Up",
    "Right",
    "Down",
    "Left",
    "Esc",
  ];
  var TEXT_INPUT_TYPES = [
    "text",
    "date",
    "datetime-local",
    "email",
    "month",
    "number",
    "password",
    "search",
    "tel",
    "time",
    "url",
    "week",
  ];
  var keyboardFocus = false;
  var elements = doc.getElementsByClassName("focus-ring");

  function onKeydownHandler(event) {
    if (event.ctrlKey || event.altKey || event.metaKey || NAVIGATION_KEYS.indexOf(event.key) === -1) {
      return;
    }
    keyboardFocus = true;

    if (
      doc.activeElement &&
      doc.activeElement !== doc.body &&
      doc.activeElement.tagName !== "TEXTAREA" &&
      !(doc.activeElement.tagName === "INPUT" && TEXT_INPUT_TYPES.indexOf(doc.activeElement.type) !== -1)
    ) {
      doc.activeElement.classList.add("focus-ring");
    }
  }

  function onMousedownHandler() {
    keyboardFocus = false;

    for (var i = 0; i < elements.length; i++) {
      elements[i].classList.remove("focus-ring");
    }
  }

  function onFocusHandler(event) {
    var classList = event.target.classList;
    if (classList && keyboardFocus) {
      classList.add("focus-ring");
    }
  }

  function onBlurHandler(event) {
    var classList = event.target.classList;
    classList && classList.remove("focus-ring");
  }

  doc.addEventListener("keydown", onKeydownHandler, true);
  doc.addEventListener("mousedown", onMousedownHandler, true);
  doc.addEventListener("focus", onFocusHandler, true);
  doc.addEventListener("blur", onBlurHandler, true);
})(typeof window === "undefined" ? undefined : document);

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null
});

export { Accordion, AccordionItem, ActionGroup, ActionMenu, Alert, Asset, AssetList, AssetListItem, Avatar, Banner, BarLoader, Breadcrumbs, BreadcrumbsItem, BreadcrumbsWrap, Button, ButtonGroup, ButtonIconWrap, Calendar, Card, Checkbox, Circleloader as CircleLoader, CoachMark, ColorArea, ColorHandle, ColorLoupe, ColorSlider, Cornerstone, CycleButton, Dial, Dialog, DropIndicator, Dropdown, Dropzone, FieldGroup, FieldLabel, Flex, Form, FormItem, IllustratedError, IllustratedMessage, IllustratedNotFound, IllustratedTimeout, IllustratedUnauthorized, IllustratedUnavailable, IllustratedUpload, Label, Link, Menu, MenuGroup, MenuItem, Meter, MillerColumns, MillerColumnsItem, Modal, Page, PaginationButtonStyle, PaginationButtonStyleNext, PaginationButtonStylePrev, PaginationExplicit, PaginationExplicitNext, PaginationExplicitPrev, PaginationPage, PaginationPageNext, PaginationPagePrev, Picker, Popover, QuickActions, Radio, Rating, Search, SearchWithin, SideNav, SideNavGroup, SideNavItem, Slider, SplitButton, SplitView, StatusLight, StepItem, Steplist, Stepper, Switch, Tab, Table, TableBody, TableHead, TableTd, TableTh, TableTr, Tabs, Tag, Tags, TextArea, Textfield$1 as Textfield, Thumbnail, Toast, Tooltip, Tray, TreeHeading, TreeItem, TreeView, TypographyBody, TypographyCode, TypographyDetail, TypographyHeading, TypographyWrap, View, Well };
