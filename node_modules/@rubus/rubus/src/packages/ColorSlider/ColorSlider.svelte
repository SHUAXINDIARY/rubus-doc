<script>
  import Color from "../utils/color/color.js";
  import { throttle } from "throttle-debounce";
  import { onMount, afterUpdate, beforeUpdate, tick } from "svelte";
  import ColorHandle from "../ColorHandle";

  /**
   * Set to `true` to disable the colorSlider
   * @type {boolean}[disabled=false]
   */
  export let disabled = false;

  /**
   * Final color pick result
   * @type {string}[currentColor = "#fff"]
   */
  export let currentColor = "";

  /**
   * Specify the variants  for the color slider
   * @type {"hue" | "alpha" | "range"}[variants = "hue"
   */
  export let variants = "hue";

  /**
   * Specify the orientation  for the color slider
   * @type {"horizontal" | "vertical"}  [orientation = "horizontal"]
   */
  export let orientation = "horizontal";

  /**
   * Preconditions: variants => "alpha" or "range"
   * Specify the start color value for the color slider
   * @type {string}  [startColor = "rgb(0,0,0)"】
   */

  export let startColor = "rgb(0,0,0)";

  /**
   * Preconditions: variants =>  "range"
   * Specify the end color value for the color slider
   * @type {string}  [endColor = "rgb(255,255,255)"]
   */

  export let endColor = "rgb(255,255,255)";

  /**
   * Preconditions: variants => "alpha"
   * Get current opacity
   * @type {number}  [alpha = 1】
   */
  export let alpha = 1;

  let px = 0;
  let py = 0;
  let colorSliderCanvas;
  $: initColor = currentColor ? Color(currentColor) : Color("rgb(0,0,0)");
  $: hue = initColor.hue();

  function createColorSliderHue(el) {
    const context = el.getContext("2d");
    context.rect(0, 0, el.width, el.height);

    let gradient = context.createLinearGradient(0, 0, el.width, el.height);

    gradient.addColorStop(0.0, "hsl(360,100%,50%)");
    gradient.addColorStop(0.17, "hsl(61.2,100%,50%)");
    gradient.addColorStop(0.33, "hsl(118.8, 100%, 50%)");
    gradient.addColorStop(0.5, "hsl(180, 100%, 50%)");
    gradient.addColorStop(0.67, "hsl(241.2, 100%, 50%)");
    gradient.addColorStop(0.83, "hsl(298.8, 100%, 50%)");
    gradient.addColorStop(1.0, "hsl(0,100%,50%)");

    context.fillStyle = gradient;
    context.fill();
    context.fillRect(0, 0, el.width, el.height);
  }

  function createColorSliderAlpha(el) {
    const context = el.getContext("2d");
    context.rect(0, 0, el.width, el.height);

    let gradient = context.createLinearGradient(0, 0, el.width, el.height);

    gradient.addColorStop(0.0, `rgba(${startColor.r},${startColor.g},${startColor.b},1.0)`);
    gradient.addColorStop(1.0, `rgba(${startColor.r},${startColor.g},${startColor.b},0.0)`);

    context.fillStyle = gradient;
    context.fill();
    context.fillRect(0, 0, el.width, el.height);
    const thisRect = el.getBoundingClientRect();
    orientation === "horizontal" ? (py = thisRect.height * 2) : (px = thisRect.width * 2);
  }

  function createColorSliderRange(el) {
    const context = el.getContext("2d");
    context.rect(0, 0, el.width, el.height);

    let gradient = context.createLinearGradient(0, 0, el.width, el.height);
    let _color = Color(startColor);
    let _color2 = Color(endColor);
    startColor = _color.object();
    endColor = _color2.object();
    gradient.addColorStop(0.0, `rgb(${startColor.r},${startColor.g},${startColor.b})`);
    gradient.addColorStop(1.0, `rgb(${endColor.r},${endColor.g},${endColor.b})`);

    context.fillStyle = gradient;
    context.fill();
    context.fillRect(0, 0, el.width, el.height);
    const thisRect = el.getBoundingClientRect();
    orientation === "horizontal" ? (py = thisRect.height * 2) : (px = thisRect.width * 2);
  }

  function startGetSliderColor(e) {
    getSliderColor(e);
    window.addEventListener("mousemove", getSliderColor);
    window.addEventListener("mouseup", endGetHueColor);
  }
  let colorRangeGroup;
  function getSliderColor(e) {
    e.preventDefault();
    const thisRect = colorSliderCanvas.getBoundingClientRect();
    let _pageP = orientation === "horizontal" ? e.pageX : e.pageY;
    let _orientation = orientation === "horizontal" ? thisRect.left : thisRect.top;
    let _crisscross = orientation === "horizontal" ? thisRect.width : thisRect.height;

    let _p = _pageP - _orientation;
    if (_p > _crisscross) {
      _p = _crisscross;
    }
    if (_p < 0) {
      _p = 0;
    }

    let percent = _p / _crisscross;
    hue = 360 + 360 * percent;
    let colorStr;
    let color;

    switch (variants) {
      case "hue":
        colorStr = `hsl(${hue},100%,50%)`;
        color = Color.hsl(colorStr);
        currentColor = color.rgb().string();
        break;
      case "alpha":
        currentColor = `rgb(${startColor.r},${startColor.g},${startColor.b})`;
        alpha = (1 - _p / _crisscross).toFixed(2);
        break;
      case "range":
        colorRangeGroup = interpolateColors(
          `rgb(${startColor.r},${startColor.g},${startColor.b})`,
          `rgb(${endColor.r},${endColor.g},${endColor.b})`,
          _crisscross
        );
        if (_p == 0) {
          currentColor = `rgb(${startColor.r},${startColor.g},${startColor.b})`;
        } else if (_p == _crisscross) {
          currentColor = `rgb(${endColor.r},${endColor.g},${endColor.b})`;
        } else {
          currentColor = `rgb(${colorRangeGroup[_p][0] || endColor.r},${colorRangeGroup[_p][1] || endColor.g},${
            colorRangeGroup[_p][2] || endColor.b
          })`;
        }

        break;
    }

    orientation === "horizontal" ? (px = (_p / _crisscross) * 100) : (py = (_p / _crisscross) * 100);
  }

  function endGetHueColor(e) {
    window.removeEventListener("mousemove", getSliderColor);
  }

  function interpolateColor(c1, c2, factor) {
    if (arguments.length < 3) {
      factor = 0.5;
    }
    var result = c1.slice();
    for (var i = 0; i < 3; i++) {
      result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]));
    }
    return result;
  }

  function interpolateColors(c1, c2, steps) {
    var stepFactor = 1 / (steps - 1),
      interpolatedColorArray = [];

    if (c1) {
      c1 = c1.match(/\d+/g);
      c1 = c1.map(Number);
    }
    if (c2) {
      c2 = c2.match(/\d+/g);
      c2 = c2.map(Number);
    }

    for (var i = 0; i < steps; i++) {
      interpolatedColorArray.push(interpolateColor(c1, c2, stepFactor * i));
    }

    return interpolatedColorArray;
  }

  function getColorStep(colorRangeGroup2, colorRgb) {
    for (let index = 0; index < colorRangeGroup2.length; index++) {
      if (
        colorRangeGroup2[index][0] == colorRgb.r &&
        colorRangeGroup2[index][1] == colorRgb.g &&
        colorRangeGroup2[index][2] == colorRgb.b
      ) {
        return index;
      }
    }
  }

  function colorToPos(color) {
    const thisRect = colorSliderCanvas.getBoundingClientRect();

    switch (variants) {
      case "hue":
        let _color = Color(color);
        let hsl = _color.hsl().object();
        let hsv = _color.hsv().object();
        let obsNum = hue;
        let referNum = hue;
        hue = hsl.h;
        obsNum = hue;
        if (orientation === "horizontal") {
          if (referNum > obsNum) {
            px = hue === 0 ? 100 : (hue / 360) * 100;
          } else {
            px = hue === 0 ? 0 : (hue / 360) * 100;
          }
        } else {
          if (referNum > obsNum) {
            py = hue === 0 ? 100 : (hue / 360) * 100;
          } else {
            py = hue === 0 ? 0 : (hue / 360) * 100;
          }
        }

        break;
      case "alpha":
        if (+alpha >= 1) {
          alpha = 1;
        }
        if (+alpha <= 0) {
          alpha = 0;
        }
        if (orientation === "horizontal") {
          px = (1 - +alpha) * 100;
        } else {
          py = (1 - +alpha) * 100;
        }
        break;
      case "range":
        const thisRect = colorSliderCanvas.getBoundingClientRect();
        let _crisscross = orientation === "horizontal" ? thisRect.width : thisRect.height;
        let _color2 = Color(color);
        let colorRgb = _color2.object();
        let _step = 0;
        let colorRangeGroup2 = interpolateColors(
          `rgb(${startColor.r},${startColor.g},${startColor.b})`,
          `rgb(${endColor.r},${endColor.g},${endColor.b})`,
          _crisscross
        );

        _step = getColorStep(colorRangeGroup2, colorRgb);

        if (orientation === "horizontal" && _step) {
          px = ((_crisscross - (_crisscross - _step)) / _crisscross) * 100;
          px = px > 99.479 ? 100 : px;
        } else if (_step) {
          py = ((_crisscross - (_crisscross - _step)) / _crisscross) * 100;
          py = py > 99.479 ? 100 : py;
        }
        break;
    }
    orientation === "horizontal" ? (py = thisRect.height * 2) : (px = thisRect.width * 2);
  }

  beforeUpdate(() => {
    if (variants === "hue" && !currentColor) {
      currentColor = "rgb(255,0,0)";
    }
    if (variants === "alpha" && !currentColor) {
      currentColor = "rgb(0,0,0)";
    }
    if (variants === "range" && !currentColor) {
      currentColor = "rgb(0,0,0)";
    }
  });

  onMount(() => {
    colorSliderCanvas.width = colorSliderCanvas.offsetWidth;
    colorSliderCanvas.height = colorSliderCanvas.offsetHeight;

    colorSliderCanvas.addEventListener("mousedown", function (e) {
      startGetSliderColor(e);
    });
    if (variants === "alpha") {
      let _color = currentColor ? Color(currentColor) : Color("rgb(0,0,0)");
      startColor = _color.object();
      throttle(500, createColorSliderAlpha(colorSliderCanvas));
    }
  });

  afterUpdate(() => {
    if (colorSliderCanvas) {
      variants === "hue" && throttle(500, createColorSliderHue(colorSliderCanvas));
      variants === "range" && throttle(500, createColorSliderRange(colorSliderCanvas));
    }
    throttle(500, colorToPos(currentColor));
  });
</script>

<style global>
  .spectrum-ColorSlider-checkerboard:before {
    display: none;
  }
</style>

<div
  class="spectrum-ColorSlider"
  class:spectrum-ColorSlider--vertical={orientation === 'vertical'}
  class:is-disabled={disabled}>
  <div class="spectrum-ColorSlider-checkerboard" role="presentation">
    <canvas class="spectrum-ColorSlider-gradient" role="presentation" bind:this={colorSliderCanvas} />
  </div>

  <ColorHandle class="spectrum-ColorSlider-handle" {px} {py} color={currentColor} {disabled} {orientation} {alpha} />

  <input
    type="range"
    class="spectrum-ColorSlider-slider"
    min="0"
    max="100"
    step={orientation === 'horizontal' ? px : py} />
</div>
