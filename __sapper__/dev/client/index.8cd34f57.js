import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, P as assign, Q as compute_rest_props, v as validate_slots, o as onMount, z as afterUpdate, R as exclude_internal_props, T as svg_element, c as claim_element, a as children, f as detach_dev, U as set_svg_attributes, h as add_location, j as insert_dev, V as get_spread_update, n as noop, G as binding_callbacks, g as attr_dev, W as createCommonjsModule, X as commonjsGlobal, Y as index, Z as onDestroy, A as current_component, B as getEventsAction, L as empty, M as group_outros, u as transition_out, N as check_outros, r as transition_in, x as create_slot, m as create_component, p as claim_component, q as mount_component, w as destroy_component, t as text, b as claim_text, e as element, C as space, D as claim_space, _ as add_render_callback, $ as set_attributes, E as toggle_class, k as append_dev, a0 as listen_dev, F as action_destroyer, a1 as prop_dev, y as update_slot, a2 as run_all, l as set_data_dev, K as validate_each_argument, a3 as getContext, I as validate_store, J as component_subscribe, a4 as globals, O as destroy_each, a5 as query_selector_all } from './client.c3d5d75d.js';

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CheckmarkSmall.svelte generated by Svelte v3.29.4 */
const file = "node_modules/@rubus/svelte-spectrum-icons-ui/src/CheckmarkSmall.svelte";

// (51:26) 
function create_if_block_1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M3.788 9A.999.999 0 013 8.615l-2.288-3a1 1 0 111.576-1.23l1.5 1.991 3.924-4.991a1 1 0 111.576 1.23l-4.712\n    6A.999.999 0 013.788 9z");
			add_location(path_1, file, 51, 4, 1206);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(51:26) ",
		ctx
	});

	return block;
}

// (45:2) {#if scale === 'L'}
function create_if_block(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M4.5 11a.999.999 0 01-.788-.385l-3-4a1 1 0 111.576-1.23L4.5 8.376l5.212-6.99a1 1 0 111.576 1.23l-6 8A.999.999 0\n    014.5 11z");
			add_location(path_1, file, 45, 4, 1009);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(45:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file, 37, 0, 813);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CheckmarkSmall", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CheckmarkSmall" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CheckmarkSmall extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CheckmarkSmall",
			options,
			id: create_fragment.name
		});
	}

	get scale() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/DashSmall.svelte generated by Svelte v3.29.4 */
const file$1 = "node_modules/@rubus/svelte-spectrum-icons-ui/src/DashSmall.svelte";

// (48:26) 
function create_if_block_1$1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M8 4H2a1 1 0 000 2h6a1 1 0 000-2z");
			add_location(path_1, file$1, 48, 4, 1115);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(48:26) ",
		ctx
	});

	return block;
}

// (45:2) {#if scale === 'L'}
function create_if_block$1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M10.99 5H1.01a1 1 0 000 2h9.98a1 1 0 100-2z");
			add_location(path_1, file$1, 45, 4, 1004);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(45:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$1;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$1, 37, 0, 808);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DashSmall", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "DashSmall" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class DashSmall extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DashSmall",
			options,
			id: create_fragment$1.name
		});
	}

	get scale() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var index_umd = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	 factory(exports) ;
}(commonjsGlobal, (function (exports) {
	/* eslint-disable no-undefined,no-param-reassign,no-shadow */

	/**
	 * Throttle execution of a function. Especially useful for rate limiting
	 * execution of handlers on events like resize and scroll.
	 *
	 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
	 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
	 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
	 *                                    the internal counter is reset).
	 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                    to `callback` when the throttled-function is executed.
	 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
	 *                                    schedule `callback` to execute after `delay` ms.
	 *
	 * @returns {Function}  A new, throttled, function.
	 */
	function throttle (delay, noTrailing, callback, debounceMode) {
	  /*
	   * After wrapper has stopped being called, this timeout ensures that
	   * `callback` is executed at the proper times in `throttle` and `end`
	   * debounce modes.
	   */
	  var timeoutID;
	  var cancelled = false; // Keep track of the last time `callback` was executed.

	  var lastExec = 0; // Function to clear existing timeout

	  function clearExistingTimeout() {
	    if (timeoutID) {
	      clearTimeout(timeoutID);
	    }
	  } // Function to cancel next exec


	  function cancel() {
	    clearExistingTimeout();
	    cancelled = true;
	  } // `noTrailing` defaults to falsy.


	  if (typeof noTrailing !== 'boolean') {
	    debounceMode = callback;
	    callback = noTrailing;
	    noTrailing = undefined;
	  }
	  /*
	   * The `wrapper` function encapsulates all of the throttling / debouncing
	   * functionality and when executed will limit the rate at which `callback`
	   * is executed.
	   */


	  function wrapper() {
	    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
	      arguments_[_key] = arguments[_key];
	    }

	    var self = this;
	    var elapsed = Date.now() - lastExec;

	    if (cancelled) {
	      return;
	    } // Execute `callback` and update the `lastExec` timestamp.


	    function exec() {
	      lastExec = Date.now();
	      callback.apply(self, arguments_);
	    }
	    /*
	     * If `debounceMode` is true (at begin) this is used to clear the flag
	     * to allow future `callback` executions.
	     */


	    function clear() {
	      timeoutID = undefined;
	    }

	    if (debounceMode && !timeoutID) {
	      /*
	       * Since `wrapper` is being called for the first time and
	       * `debounceMode` is true (at begin), execute `callback`.
	       */
	      exec();
	    }

	    clearExistingTimeout();

	    if (debounceMode === undefined && elapsed > delay) {
	      /*
	       * In throttle mode, if `delay` time has been exceeded, execute
	       * `callback`.
	       */
	      exec();
	    } else if (noTrailing !== true) {
	      /*
	       * In trailing throttle mode, since `delay` time has not been
	       * exceeded, schedule `callback` to execute `delay` ms after most
	       * recent execution.
	       *
	       * If `debounceMode` is true (at begin), schedule `clear` to execute
	       * after `delay` ms.
	       *
	       * If `debounceMode` is false (at end), schedule `callback` to
	       * execute after `delay` ms.
	       */
	      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
	    }
	  }

	  wrapper.cancel = cancel; // Return the wrapper function.

	  return wrapper;
	}

	/* eslint-disable no-undefined */
	/**
	 * Debounce execution of a function. Debouncing, unlike throttling,
	 * guarantees that a function is only executed a single time, either at the
	 * very beginning of a series of calls, or at the very end.
	 *
	 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
	 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
	 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
	 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                  to `callback` when the debounced-function is executed.
	 *
	 * @returns {Function} A new, debounced function.
	 */

	function debounce (delay, atBegin, callback) {
	  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
	}

	exports.debounce = debounce;
	exports.throttle = throttle;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

});

/* node_modules/@rubus/rubus/src/packages/Checkbox/Checkbox.svelte generated by Svelte v3.29.4 */
const file$2 = "node_modules/@rubus/rubus/src/packages/Checkbox/Checkbox.svelte";

// (144:0) {:else}
function create_else_block(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_4(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_3(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let label_levels = [
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				name: true,
				disabled: true,
				value: true
			});

			t0 = claim_space(label_nodes);
			span0 = claim_element(label_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (if_block0) if_block0.l(span0_nodes);
			t1 = claim_space(span0_nodes);
			if (if_block1) if_block1.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(label_nodes);
			span1 = claim_element(label_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			if (default_slot) default_slot.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "spectrum-Checkbox-input");
			attr_dev(input, "id", /*id*/ ctx[7]);
			attr_dev(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.__value = /*value*/ ctx[8];
			input.value = input.__value;
			if (/*checked*/ ctx[0] === void 0 || /*indeterminate*/ ctx[1] === void 0) add_render_callback(() => /*input_change_handler*/ ctx[19].call(input));
			add_location(input, file$2, 152, 4, 4279);
			attr_dev(span0, "class", "spectrum-Checkbox-box");
			add_location(span0, file$2, 162, 4, 4479);
			attr_dev(span1, "class", "spectrum-Checkbox-label");
			add_location(span1, file$2, 182, 4, 5070);
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
			add_location(label, file$2, 144, 2, 4021);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding_1*/ ctx[18](input);
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			append_dev(label, t0);
			append_dev(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append_dev(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append_dev(label, t2);
			append_dev(label, span1);

			if (default_slot) {
				default_slot.m(span1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[19]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[13].call(null, label))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr_dev(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr_dev(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*value*/ 256) {
				prop_dev(input, "__value", /*value*/ ctx[8]);
				input.value = input.__value;
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*indeterminate*/ 2) {
				input.indeterminate = /*indeterminate*/ ctx[1];
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding_1*/ ctx[18](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(144:0) {:else}",
		ctx
	});

	return block;
}

// (101:0) {#if readonly}
function create_if_block$2(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let current;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_2(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_1$2(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	let label_levels = [
		{ title: /*title*/ ctx[9] },
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { title: true, class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				name: true,
				disabled: true,
				value: true,
				checked: true,
				indeterminate: true
			});

			t0 = claim_space(label_nodes);
			span0 = claim_element(label_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (if_block0) if_block0.l(span0_nodes);
			t1 = claim_space(span0_nodes);
			if (if_block1) if_block1.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(label_nodes);
			span1 = claim_element(label_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			if (default_slot_or_fallback) default_slot_or_fallback.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "spectrum-Checkbox-input");
			attr_dev(input, "id", /*id*/ ctx[7]);
			attr_dev(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.value = /*value*/ ctx[8];
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			add_location(input, file$2, 109, 4, 3136);
			attr_dev(span0, "class", "spectrum-Checkbox-box");
			add_location(span0, file$2, 119, 4, 3330);
			attr_dev(span1, "class", "spectrum-Checkbox-label");
			add_location(span1, file$2, 139, 4, 3921);
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
			add_location(label, file$2, 101, 2, 2878);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding*/ ctx[17](input);
			append_dev(label, t0);
			append_dev(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append_dev(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append_dev(label, t2);
			append_dev(label, span1);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr_dev(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr_dev(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*value*/ 256) {
				prop_dev(input, "value", /*value*/ ctx[8]);
			}

			if (!current || dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (!current || dirty & /*indeterminate*/ 2) {
				prop_dev(input, "indeterminate", /*indeterminate*/ ctx[1]);
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*title*/ 512) && { title: /*title*/ ctx[9] },
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[17](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(101:0) {#if readonly}",
		ctx
	});

	return block;
}

// (164:6) {#if checked}
function create_if_block_4(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcheckmarksmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(164:6) {#if checked}",
		ctx
	});

	return block;
}

// (173:6) {#if indeterminate}
function create_if_block_3(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icondashsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icondashsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(173:6) {#if indeterminate}",
		ctx
	});

	return block;
}

// (121:6) {#if checked}
function create_if_block_2(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcheckmarksmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(121:6) {#if checked}",
		ctx
	});

	return block;
}

// (130:6) {#if indeterminate}
function create_if_block_1$2(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icondashsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icondashsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(130:6) {#if indeterminate}",
		ctx
	});

	return block;
}

// (141:12) Checkbox
function fallback_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Checkbox");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Checkbox");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(141:12) Checkbox",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*readonly*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"checked","disabled","isInvalid","isQuiet","indeterminate","readonly","name","id","value","title"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Checkbox", slots, ['default']);
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { indeterminate = false } = $$props;
	let { readonly = false } = $$props;
	let { name = "" } = $$props;
	let { id = "checkbox-" + Math.random().toString(24) } = $$props;
	let { value = "" } = $$props;
	let { title = "" } = $$props;
	let checkbox;
	let iconSize = 10;
	let large = false;
	const eventsListen = getEventsAction(current_component);
	const observer = new index(getIconScale);

	afterUpdate(() => {
		index_umd.throttle(500, observer.observe(checkbox));
	});

	onDestroy(() => {
		observer.unobserve(checkbox);
	});

	function getIconScale() {
		$$invalidate(11, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-125")));

		if (iconSize == 10) {
			$$invalidate(12, large = false);
		} else {
			$$invalidate(12, large = true);
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_change_handler() {
		checked = this.checked;
		indeterminate = this.indeterminate;
		$$invalidate(0, checked);
		$$invalidate(1, indeterminate);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$new_props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$new_props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$new_props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$new_props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$new_props) $$invalidate(9, title = $$new_props.title);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		IconCheckmarkSmall: CheckmarkSmall,
		IconDashSmall: DashSmall,
		ResizeObserver: index,
		throttle: index_umd.throttle,
		afterUpdate,
		onDestroy,
		current_component,
		getEventsAction,
		checked,
		disabled,
		isInvalid,
		isQuiet,
		indeterminate,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		observer,
		getIconScale
	});

	$$self.$inject_state = $$new_props => {
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$props) $$invalidate(9, title = $$new_props.title);
		if ("checkbox" in $$props) $$invalidate(10, checkbox = $$new_props.checkbox);
		if ("iconSize" in $$props) $$invalidate(11, iconSize = $$new_props.iconSize);
		if ("large" in $$props) $$invalidate(12, large = $$new_props.large);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		checked,
		indeterminate,
		disabled,
		isInvalid,
		isQuiet,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		$$restProps,
		$$scope,
		slots,
		input_binding,
		input_binding_1,
		input_change_handler
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			checked: 0,
			disabled: 2,
			isInvalid: 3,
			isQuiet: 4,
			indeterminate: 1,
			readonly: 5,
			name: 6,
			id: 7,
			value: 8,
			title: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment$2.name
		});
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInvalid() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInvalid(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Radio/Radio.svelte generated by Svelte v3.29.4 */

const file$3 = "node_modules/@rubus/rubus/src/packages/Radio/Radio.svelte";

// (64:53) {value}
function fallback_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*value*/ ctx[6]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*value*/ ctx[6]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 64) set_data_dev(t, /*value*/ ctx[6]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(64:53) {value}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let input;
	let t0;
	let span;
	let t1;
	let label;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			label = element("label");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			input = claim_element(div_nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				id: true,
				checked: true,
				disabled: true,
				value: true,
				readonly: true
			});

			t0 = claim_space(div_nodes);
			span = claim_element(div_nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			t1 = claim_space(div_nodes);
			label = claim_element(div_nodes, "LABEL", { class: true, for: true });
			var label_nodes = children(label);
			if (default_slot_or_fallback) default_slot_or_fallback.l(label_nodes);
			label_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "radio");
			attr_dev(input, "name", /*name*/ ctx[5]);
			attr_dev(input, "class", "spectrum-Radio-input");
			attr_dev(input, "id", /*id*/ ctx[0]);
			input.checked = /*checked*/ ctx[1];
			input.disabled = /*disabled*/ ctx[3];
			input.value = /*value*/ ctx[6];
			input.readOnly = /*readonly*/ ctx[7];
			add_location(input, file$3, 61, 2, 1856);
			attr_dev(span, "class", "spectrum-Radio-button");
			add_location(span, file$3, 62, 2, 1962);
			attr_dev(label, "class", "spectrum-Radio-label");
			attr_dev(label, "for", /*id*/ ctx[0]);
			add_location(label, file$3, 63, 2, 2003);
			attr_dev(div, "class", "spectrum-Radio");
			toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			add_location(div, file$3, 56, 0, 1721);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t0);
			append_dev(div, span);
			append_dev(div, t1);
			append_dev(div, label);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(label, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 32) {
				attr_dev(input, "name", /*name*/ ctx[5]);
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(input, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*checked*/ 2) {
				prop_dev(input, "checked", /*checked*/ ctx[1]);
			}

			if (!current || dirty & /*disabled*/ 8) {
				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*value*/ 64) {
				prop_dev(input, "value", /*value*/ ctx[6]);
			}

			if (!current || dirty & /*readonly*/ 128) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[7]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*value*/ 64) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(label, "for", /*id*/ ctx[0]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			}

			if (dirty & /*isInvalid*/ 4) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			}

			if (dirty & /*readonly*/ 128) {
				toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Radio", slots, ['default']);
	let { id = `radio-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { checked = false } = $$props;
	let { isInvalid = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { name = "radio" } = $$props;
	let { value = "" } = $$props;
	let { readonly = false } = $$props;

	const writable_props = [
		"id",
		"checked",
		"isInvalid",
		"disabled",
		"isQuiet",
		"name",
		"value",
		"readonly"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Radio> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly,
		$$scope,
		slots
	];
}

class Radio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			id: 0,
			checked: 1,
			isInvalid: 2,
			disabled: 3,
			isQuiet: 4,
			name: 5,
			value: 6,
			readonly: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio",
			options,
			id: create_fragment$3.name
		});
	}

	get id() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInvalid() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInvalid(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Typography/TypographyBody.svelte generated by Svelte v3.29.4 */

const file$4 = "node_modules/@rubus/rubus/src/packages/Typography/TypographyBody.svelte";

function create_fragment$4(ctx) {
	let p;
	let p_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			p = element("p");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			if (default_slot) default_slot.l(p_nodes);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", p_class_value = "spectrum-Body spectrum-Body--" + /*scale*/ ctx[0]);
			toggle_class(p, "spectrum-Body--serif", /*isSerif*/ ctx[1]);
			add_location(p, file$4, 14, 0, 302);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale*/ 1 && p_class_value !== (p_class_value = "spectrum-Body spectrum-Body--" + /*scale*/ ctx[0])) {
				attr_dev(p, "class", p_class_value);
			}

			if (dirty & /*scale, isSerif*/ 3) {
				toggle_class(p, "spectrum-Body--serif", /*isSerif*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TypographyBody", slots, ['default']);
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	const writable_props = ["scale", "isSerif"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TypographyBody> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ scale, isSerif });

	$$self.$inject_state = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [scale, isSerif, $$scope, slots];
}

class TypographyBody extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { scale: 0, isSerif: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TypographyBody",
			options,
			id: create_fragment$4.name
		});
	}

	get scale() {
		throw new Error("<TypographyBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<TypographyBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSerif() {
		throw new Error("<TypographyBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSerif(value) {
		throw new Error("<TypographyBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Typography/TypographyHeading.svelte generated by Svelte v3.29.4 */

const file$5 = "node_modules/@rubus/rubus/src/packages/Typography/TypographyHeading.svelte";

function create_fragment$5(ctx) {
	let h1;
	let h1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			h1 = element("h1");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			if (default_slot) default_slot.l(h1_nodes);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", h1_class_value = "spectrum-Heading spectrum-Heading--" + /*scale*/ ctx[0] + "  spectrum-Heading--" + /*thickness*/ ctx[2]);
			toggle_class(h1, "spectrum-Heading--serif", /*isSerif*/ ctx[1]);
			add_location(h1, file$5, 20, 0, 455);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);

			if (default_slot) {
				default_slot.m(h1, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale, thickness*/ 5 && h1_class_value !== (h1_class_value = "spectrum-Heading spectrum-Heading--" + /*scale*/ ctx[0] + "  spectrum-Heading--" + /*thickness*/ ctx[2])) {
				attr_dev(h1, "class", h1_class_value);
			}

			if (dirty & /*scale, thickness, isSerif*/ 7) {
				toggle_class(h1, "spectrum-Heading--serif", /*isSerif*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TypographyHeading", slots, ['default']);
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	let { thickness = "default" } = $$props;
	const writable_props = ["scale", "isSerif", "thickness"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TypographyHeading> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("thickness" in $$props) $$invalidate(2, thickness = $$props.thickness);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ scale, isSerif, thickness });

	$$self.$inject_state = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("thickness" in $$props) $$invalidate(2, thickness = $$props.thickness);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [scale, isSerif, thickness, $$scope, slots];
}

class TypographyHeading extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { scale: 0, isSerif: 1, thickness: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TypographyHeading",
			options,
			id: create_fragment$5.name
		});
	}

	get scale() {
		throw new Error("<TypographyHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<TypographyHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSerif() {
		throw new Error("<TypographyHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSerif(value) {
		throw new Error("<TypographyHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get thickness() {
		throw new Error("<TypographyHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set thickness(value) {
		throw new Error("<TypographyHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var light = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 75",
				code: "#FAFAFA"
			},
			{
				name: "GRAY 100",
				code: "#F5F5F5"
			},
			{
				name: "GRAY 200",
				code: "#EAEAEA"
			},
			{
				name: "GRAY 300",
				code: "#E1E1E1"
			},
			{
				name: "GRAY 400",
				code: "#CACACA"
			},
			{
				name: "GRAY 500",
				code: "#B3B3B3"
			},
			{
				name: "GRAY 600",
				code: "#8E8E8E"
			},
			{
				name: "GRAY 700",
				code: "#6E6E6E"
			},
			{
				name: "GRAY 800",
				code: "#4B4B4B"
			},
			{
				name: "GRAY 900",
				code: "#2C2C2C"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#2680EB"
			},
			{
				name: "BLUE 500",
				code: "#1473E6"
			},
			{
				name: "BLUE 600",
				code: "#0D66D0"
			},
			{
				name: "BLUE 700",
				code: "#095ABA"
			}
		],
		[
			{
				name: "RED 400",
				code: "#E34850"
			},
			{
				name: "RED 500",
				code: "#D7373F"
			},
			{
				name: "RED 600",
				code: "#C9252D"
			},
			{
				name: "RED 700",
				code: "#BB121A"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#E68619"
			},
			{
				name: "ORANGE 500",
				code: "#DA7B11"
			},
			{
				name: "ORANGE 600",
				code: "#CB6F10"
			},
			{
				name: "ORANGE 700",
				code: "#BD640D"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#2D9D78"
			},
			{
				name: "GREEN 500",
				code: "#268E6C"
			},
			{
				name: "GREEN 600",
				code: "#12805C"
			},
			{
				name: "GREEN 700",
				code: "#107154"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var lightest = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 75",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 100",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "GRAY 300",
				code: "#eaeaea"
			},
			{
				name: "GRAY 400",
				code: "#d3d3d3"
			},
			{
				name: "GRAY 500",
				code: "#bcbcbc"
			},
			{
				name: "GRAY 600",
				code: "#959595"
			},
			{
				name: "GRAY 700",
				code: "#747474"
			},
			{
				name: "GRAY 800",
				code: "#505050"
			},
			{
				name: "GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#378ef0"
			},
			{
				name: "BLUE 500",
				code: "#2680eb"
			},
			{
				name: "BLUE 600",
				code: "#1473e6"
			},
			{
				name: "BLUE 700",
				code: "#0d66d0"
			}
		],
		[
			{
				name: "RED 400",
				code: "#ec5b62"
			},
			{
				name: "RED 500",
				code: "#e34850"
			},
			{
				name: "RED 600",
				code: "#d7373f"
			},
			{
				name: "RED 700",
				code: "#c9252d"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#f29423"
			},
			{
				name: "ORANGE 500",
				code: "#e68619"
			},
			{
				name: "ORANGE 600",
				code: "#da7b11"
			},
			{
				name: "ORANGE 700",
				code: "#cb6f10"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#33ab84"
			},
			{
				name: "GREEN 500",
				code: "#2d9d78"
			},
			{
				name: "GREEN 600",
				code: "#268e6c"
			},
			{
				name: "GREEN 700",
				code: "#12805c"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var dark = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#252525"
			},
			{
				name: "GRAY 75",
				code: "#2F2F2F"
			},
			{
				name: "GRAY 100",
				code: "#323232"
			},
			{
				name: "GRAY 200",
				code: "#3E3E3E"
			},
			{
				name: "GRAY 300",
				code: "#4A4A4A"
			},
			{
				name: "GRAY 400",
				code: "#5A5A5A"
			},
			{
				name: "GRAY 500",
				code: "#6E6E6E"
			},
			{
				name: "GRAY 600",
				code: "#909090"
			},
			{
				name: "GRAY 700",
				code: "#B9B9B9"
			},
			{
				name: "GRAY 800",
				code: "#E3E3E3"
			},
			{
				name: "GRAY 900",
				code: "#FFFFFF"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#2680EB"
			},
			{
				name: "BLUE 500",
				code: "#378EF0"
			},
			{
				name: "BLUE 600",
				code: "#4B9CF5"
			},
			{
				name: "BLUE 700",
				code: "#5AA9FA"
			}
		],
		[
			{
				name: "RED 400",
				code: "#E34850"
			},
			{
				name: "RED 500",
				code: "#EC5B62"
			},
			{
				name: "RED 600",
				code: "#F76D74"
			},
			{
				name: "RED 700",
				code: "#FF7B82"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#E68619"
			},
			{
				name: "ORANGE 500",
				code: "#F29423"
			},
			{
				name: "ORANGE 600",
				code: "#F9A43F"
			},
			{
				name: "ORANGE 700",
				code: "#FFB55B"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#2D9D78"
			},
			{
				name: "GREEN 500",
				code: "#33AB84"
			},
			{
				name: "GREEN 600",
				code: "#39B990"
			},
			{
				name: "GREEN 700",
				code: "#3FC89C"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var darkest = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#080808"
			},
			{
				name: "GRAY 75",
				code: "#1a1a1a"
			},
			{
				name: "GRAY 100",
				code: "#1e1e1e"
			},
			{
				name: "GRAY 200",
				code: "#2c2c2c"
			},
			{
				name: "GRAY 300",
				code: "#393939"
			},
			{
				name: "GRAY 400",
				code: "#494949"
			},
			{
				name: "GRAY 500",
				code: "#5c5c5c"
			},
			{
				name: "GRAY 600",
				code: "#7c7c7c"
			},
			{
				name: "GRAY 700",
				code: "#a2a2a2"
			},
			{
				name: "GRAY 800",
				code: "#c8c8c8"
			},
			{
				name: "GRAY 900",
				code: "#efefef"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#1473e6"
			},
			{
				name: "BLUE 500",
				code: "#2680eb"
			},
			{
				name: "BLUE 600",
				code: "#378ef0"
			},
			{
				name: "BLUE 700",
				code: "#4b9cf5"
			}
		],
		[
			{
				name: "RED 400",
				code: "#d7373f"
			},
			{
				name: "RED 500",
				code: "#e34850"
			},
			{
				name: "RED 600",
				code: "#ec5b62"
			},
			{
				name: "RED 700",
				code: "#f76d74"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#da7b11"
			},
			{
				name: "ORANGE 500",
				code: "#e68619"
			},
			{
				name: "ORANGE 600",
				code: "#f29423"
			},
			{
				name: "ORANGE 700",
				code: "#f9a43f"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#268e6c"
			},
			{
				name: "GREEN 500",
				code: "#2d9d78"
			},
			{
				name: "GREEN 600",
				code: "#33ab84"
			},
			{
				name: "GREEN 700",
				code: "#39b990"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var color = {
	light: light,
	lightest: lightest,
	dark: dark,
	darkest: darkest
};

var colorData = /*#__PURE__*/Object.freeze({
  __proto__: null,
  light: light,
  lightest: lightest,
  dark: dark,
  darkest: darkest,
  'default': color
});

/* src/components/color-container/ColorContainer.svelte generated by Svelte v3.29.4 */

const { console: console_1 } = globals;
const file$6 = "src/components/color-container/ColorContainer.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (202:4) <Checkbox checked={staticColorsView} on:click={handleClick}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Static colors");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Static colors");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(202:4) <Checkbox checked={staticColorsView} on:click={handleClick}>",
		ctx
	});

	return block;
}

// (223:6) {#each items as colorItem}
function create_each_block_1(ctx) {
	let div2;
	let div0;
	let t0_value = /*colorItem*/ ctx[14].name + "";
	let t0;
	let t1;
	let div1;

	let t2_value = (/*colorModel*/ ctx[0] == "hex"
	? /*colorItem*/ ctx[14].code.toUpperCase()
	: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()) + "";

	let t2;
	let div2_class_value;
	let div2_style_value;
	let mounted;
	let dispose;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[10](/*colorItem*/ ctx[14], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text(t2_value);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, t2_value);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "color-item-name svelte-1k9vjxr");
			add_location(div0, file$6, 229, 10, 9579);
			attr_dev(div1, "class", "color-item-code svelte-1k9vjxr");
			add_location(div1, file$6, 230, 10, 9641);

			attr_dev(div2, "class", div2_class_value = "color-item " + (/*lightAndDark*/ ctx[7](/*colorItem*/ ctx[14].code)
			? "color-item-dark"
			: "color-item-light") + " svelte-1k9vjxr");

			attr_dev(div2, "style", div2_style_value = `background-color:${/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()}`);

			add_location(div2, file$6, 223, 8, 9234);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);

			if (!mounted) {
				dispose = listen_dev(div2, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$rubusDocConfig, colorDisplay*/ 12 && t0_value !== (t0_value = /*colorItem*/ ctx[14].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*colorModel, $rubusDocConfig, colorDisplay*/ 13 && t2_value !== (t2_value = (/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()) + "")) set_data_dev(t2, t2_value);

			if (dirty & /*$rubusDocConfig, colorDisplay*/ 12 && div2_class_value !== (div2_class_value = "color-item " + (/*lightAndDark*/ ctx[7](/*colorItem*/ ctx[14].code)
			? "color-item-dark"
			: "color-item-light") + " svelte-1k9vjxr")) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*colorModel, $rubusDocConfig, colorDisplay*/ 13 && div2_style_value !== (div2_style_value = `background-color:${/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()}`)) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(223:6) {#each items as colorItem}",
		ctx
	});

	return block;
}

// (221:2) {#each colorData[$rubusDocConfig.theme][colorDisplay] as items}
function create_each_block(ctx) {
	let div;
	let t;
	let each_value_1 = /*items*/ ctx[11];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "color-group svelte-1k9vjxr");
			add_location(div, file$6, 221, 4, 9167);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lightAndDark, colorData, $rubusDocConfig, colorDisplay, colorModel, hexToRGB, copyColor*/ 205) {
				each_value_1 = /*items*/ ctx[11];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(221:2) {#each colorData[$rubusDocConfig.theme][colorDisplay] as items}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div1;
	let form0;
	let checkbox;
	let t0;
	let div0;
	let t1;
	let form1;
	let radio0;
	let t2;
	let radio1;
	let t3;
	let div2;
	let current;

	checkbox = new Checkbox({
			props: {
				checked: /*staticColorsView*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleClick*/ ctx[5]);

	radio0 = new Radio({
			props: {
				value: "Hex",
				checked: /*colorModel*/ ctx[0] == "hex"
			},
			$$inline: true
		});

	radio0.$on("click", /*click_handler*/ ctx[8]);

	radio1 = new Radio({
			props: {
				value: "RGB",
				checked: /*colorModel*/ ctx[0] == "rgb"
			},
			$$inline: true
		});

	radio1.$on("click", /*click_handler_1*/ ctx[9]);
	let each_value = colorData[/*$rubusDocConfig*/ ctx[3].theme][/*colorDisplay*/ ctx[2]];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			form0 = element("form");
			create_component(checkbox.$$.fragment);
			t0 = space();
			div0 = element("div");
			t1 = space();
			form1 = element("form");
			create_component(radio0.$$.fragment);
			t2 = space();
			create_component(radio1.$$.fragment);
			t3 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			form0 = claim_element(div1_nodes, "FORM", { class: true });
			var form0_nodes = children(form0);
			claim_component(checkbox.$$.fragment, form0_nodes);
			form0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			form1 = claim_element(div1_nodes, "FORM", { class: true });
			var form1_nodes = children(form1);
			claim_component(radio0.$$.fragment, form1_nodes);
			t2 = claim_space(form1_nodes);
			claim_component(radio1.$$.fragment, form1_nodes);
			form1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(form0, "class", "svelte-1k9vjxr");
			add_location(form0, file$6, 200, 2, 8625);
			attr_dev(div0, "class", "vertical-line svelte-1k9vjxr");
			add_location(div0, file$6, 203, 2, 8733);
			attr_dev(form1, "class", "color-model svelte-1k9vjxr");
			add_location(form1, file$6, 204, 2, 8765);
			attr_dev(div1, "class", "toolbar svelte-1k9vjxr");
			add_location(div1, file$6, 199, 0, 8601);
			attr_dev(div2, "class", "color-container svelte-1k9vjxr");
			add_location(div2, file$6, 219, 0, 9067);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, form0);
			mount_component(checkbox, form0, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div1, t1);
			append_dev(div1, form1);
			mount_component(radio0, form1, null);
			append_dev(form1, t2);
			mount_component(radio1, form1, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, div2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const checkbox_changes = {};
			if (dirty & /*staticColorsView*/ 2) checkbox_changes.checked = /*staticColorsView*/ ctx[1];

			if (dirty & /*$$scope*/ 131072) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
			const radio0_changes = {};
			if (dirty & /*colorModel*/ 1) radio0_changes.checked = /*colorModel*/ ctx[0] == "hex";
			radio0.$set(radio0_changes);
			const radio1_changes = {};
			if (dirty & /*colorModel*/ 1) radio1_changes.checked = /*colorModel*/ ctx[0] == "rgb";
			radio1.$set(radio1_changes);

			if (dirty & /*colorData, $rubusDocConfig, colorDisplay, lightAndDark, colorModel, hexToRGB, copyColor*/ 205) {
				each_value = colorData[/*$rubusDocConfig*/ ctx[3].theme][/*colorDisplay*/ ctx[2]];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			transition_in(radio0.$$.fragment, local);
			transition_in(radio1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			transition_out(radio0.$$.fragment, local);
			transition_out(radio1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(checkbox);
			destroy_component(radio0);
			destroy_component(radio1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function hexToRGB(h) {
	let r = 0, g = 0, b = 0;

	// 3 digits
	if (h.length == 4) {
		r = "0x" + h[1] + h[1];
		g = "0x" + h[2] + h[2];
		b = "0x" + h[3] + h[3];
	} else if (h.length == 7) {
		r = "0x" + h[1] + h[2]; // 6 digits
		g = "0x" + h[3] + h[4];
		b = "0x" + h[5] + h[6];
	}

	return "rgb(" + +r + "," + +g + "," + +b + ")";
}

function hexToHSL(H) {
	let r = 0, g = 0, b = 0;

	if (H.length == 4) {
		r = "0x" + H[1] + H[1];
		g = "0x" + H[2] + H[2];
		b = "0x" + H[3] + H[3];
	} else if (H.length == 7) {
		r = "0x" + H[1] + H[2];
		g = "0x" + H[3] + H[4];
		b = "0x" + H[5] + H[6];
	}

	// Then to HSL
	r /= 255;

	g /= 255;
	b /= 255;

	let cmin = Math.min(r, g, b),
		cmax = Math.max(r, g, b),
		delta = cmax - cmin,
		h = 0,
		s = 0,
		l = 0;

	if (delta == 0) h = 0; else if (cmax == r) h = (g - b) / delta % 6; else if (cmax == g) h = (b - r) / delta + 2; else h = (r - g) / delta + 4;
	h = Math.round(h * 60);
	if (h < 0) h += 360;
	l = (cmax + cmin) / 2;
	s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
	s = +(s * 100).toFixed(1);
	l = +(l * 100).toFixed(1);
	return [h, s, l];
}

function instance$6($$self, $$props, $$invalidate) {
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ColorContainer", slots, []);
	let colorModel = "hex";
	let staticColorsView = false;
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(3, $rubusDocConfig = value));
	let colorDisplay = "globalColor";

	onMount(() => {
		
	});

	function handleClick() {
		$$invalidate(1, staticColorsView = !staticColorsView);
		$$invalidate(2, colorDisplay = staticColorsView ? "staticColor" : "globalColor");
	}

	async function copyColor(t, c) {
		if (colorModel !== "hex") {
			c = hexToRGB(c);
		}

		let colorCode = staticColorsView
		? `--spectrum-global-color-static-${t.replace(/[^a-zA-Z]/gi, "").toLowerCase()}-${t.replace(/[^0-9]/gi, "")}: ${c}`
		: `--spectrum-global-color-${t.replace(/[^a-zA-Z]/gi, "").toLowerCase()}-${t.replace(/[^0-9]/gi, "")}: ${c}`;

		if (navigator.clipboard) {
			try {
				await navigator.clipboard.writeText(colorCode);
				console.log("Page URL copied to clipboard:" + colorCode);
			} catch(err) {
				console.error("Failed to copy: ", err);
			}
		}
	}

	function lightAndDark(code) {
		let [,,l] = hexToHSL(code);
		let crossover = 50;

		switch ($rubusDocConfig.theme) {
			case "light":
				crossover = 60;
				break;
			case "lightest":
				crossover = 70;
				break;
			case "dark":
				crossover = 38;
				break;
			case "darkest":
				crossover = 35;
				break;
		}

		return l >= crossover ? false : true;
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ColorContainer> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, colorModel = "hex");
	};

	const click_handler_1 = () => {
		$$invalidate(0, colorModel = "rgb");
	};

	const click_handler_2 = colorItem => {
		copyColor(colorItem.name, colorItem.code);
	};

	$$self.$capture_state = () => ({
		Radio,
		Checkbox,
		getContext,
		onMount,
		colorData,
		colorModel,
		staticColorsView,
		rubusDocConfig,
		colorDisplay,
		handleClick,
		copyColor,
		hexToRGB,
		hexToHSL,
		lightAndDark,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("colorModel" in $$props) $$invalidate(0, colorModel = $$props.colorModel);
		if ("staticColorsView" in $$props) $$invalidate(1, staticColorsView = $$props.staticColorsView);
		if ("rubusDocConfig" in $$props) $$invalidate(4, rubusDocConfig = $$props.rubusDocConfig);
		if ("colorDisplay" in $$props) $$invalidate(2, colorDisplay = $$props.colorDisplay);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		colorModel,
		staticColorsView,
		colorDisplay,
		$rubusDocConfig,
		rubusDocConfig,
		handleClick,
		copyColor,
		lightAndDark,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class ColorContainer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ColorContainer",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/docs/csstokens/color/index.svelte generated by Svelte v3.29.4 */
const file$7 = "src/routes/docs/csstokens/color/index.svelte";

// (19:2) <TypographyHeading scale="XL">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("颜色");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "颜色");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(19:2) <TypographyHeading scale=\\\"XL\\\">",
		ctx
	});

	return block;
}

// (20:2) <TypographyBody scale="M" lineHeight="size-400">
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("位于设计系统中的颜色令牌");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "位于设计系统中的颜色令牌");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(20:2) <TypographyBody scale=\\\"M\\\" lineHeight=\\\"size-400\\\">",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let title_value;
	let t0;
	let header;
	let typographyheading;
	let t1;
	let typographybody;
	let t2;
	let main;
	let colorcontainer;
	let current;
	document.title = title_value = "" + (/*$rubusDocConfig*/ ctx[0].name + " 颜色");

	typographyheading = new TypographyHeading({
			props: {
				scale: "XL",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	typographybody = new TypographyBody({
			props: {
				scale: "M",
				lineHeight: "size-400",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	colorcontainer = new ColorContainer({ $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			header = element("header");
			create_component(typographyheading.$$.fragment);
			t1 = space();
			create_component(typographybody.$$.fragment);
			t2 = space();
			main = element("main");
			create_component(colorcontainer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1xk3tor\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			claim_component(typographyheading.$$.fragment, header_nodes);
			t1 = claim_space(header_nodes);
			claim_component(typographybody.$$.fragment, header_nodes);
			header_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			claim_component(colorcontainer.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-145r0l5");
			add_location(header, file$7, 17, 0, 801);
			add_location(main, file$7, 22, 0, 956);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, header, anchor);
			mount_component(typographyheading, header, null);
			append_dev(header, t1);
			mount_component(typographybody, header, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, main, anchor);
			mount_component(colorcontainer, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*$rubusDocConfig*/ 1) && title_value !== (title_value = "" + (/*$rubusDocConfig*/ ctx[0].name + " 颜色"))) {
				document.title = title_value;
			}

			const typographyheading_changes = {};

			if (dirty & /*$$scope*/ 4) {
				typographyheading_changes.$$scope = { dirty, ctx };
			}

			typographyheading.$set(typographyheading_changes);
			const typographybody_changes = {};

			if (dirty & /*$$scope*/ 4) {
				typographybody_changes.$$scope = { dirty, ctx };
			}

			typographybody.$set(typographybody_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typographyheading.$$.fragment, local);
			transition_in(typographybody.$$.fragment, local);
			transition_in(colorcontainer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typographyheading.$$.fragment, local);
			transition_out(typographybody.$$.fragment, local);
			transition_out(colorcontainer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(header);
			destroy_component(typographyheading);
			destroy_component(typographybody);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(main);
			destroy_component(colorcontainer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Color", slots, []);
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(0, $rubusDocConfig = value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Color> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		TypographyHeading,
		TypographyBody,
		getContext,
		ColorContainer,
		rubusDocConfig,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("rubusDocConfig" in $$props) $$invalidate(1, rubusDocConfig = $$props.rubusDocConfig);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$rubusDocConfig, rubusDocConfig];
}

class Color extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Color",
			options,
			id: create_fragment$7.name
		});
	}
}

export default Color;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguOGNkMzRmNTcuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvc3ZlbHRlLXNwZWN0cnVtLWljb25zLXVpL3NyYy9DaGVja21hcmtTbWFsbC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3N2ZWx0ZS1zcGVjdHJ1bS1pY29ucy11aS9zcmMvRGFzaFNtYWxsLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJvdHRsZS1kZWJvdW5jZS9pbmRleC51bWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3J1YnVzL3NyYy9wYWNrYWdlcy9DaGVja2JveC9DaGVja2JveC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3J1YnVzL3NyYy9wYWNrYWdlcy9SYWRpby9SYWRpby5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3J1YnVzL3NyYy9wYWNrYWdlcy9UeXBvZ3JhcGh5L1R5cG9ncmFwaHlCb2R5LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1R5cG9ncmFwaHkvVHlwb2dyYXBoeUhlYWRpbmcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvY29sb3ItY29udGFpbmVyL0NvbG9yQ29udGFpbmVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9jc3N0b2tlbnMvY29sb3IvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBleHBvcnQgbGV0IHNjYWxlID0gXCJNXCI7XG4gIGV4cG9ydCBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgZXhwb3J0IGxldCB3aWR0aCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgaGVpZ2h0ID0gXCJcIjtcbiAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSBcIkNoZWNrbWFya1NtYWxsXCI7XG4gIGxldCBwYXRoO1xuICBsZXQgc3c7XG4gIGxldCBzaDtcblxuICBsZXQgZmxhZyA9IDE0O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFzY2FsZSB8fCBzY2FsZSA9PSBcIk1cIikge1xuICAgICAgbGV0IHJvb3RDbGFzc05hbWUgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgaWYgKHJvb3RDbGFzc05hbWUgJiYgcm9vdENsYXNzTmFtZS5pbmRleE9mKFwic3BlY3RydW0tLWxhcmdlXCIpICE9IC0xKSB7XG4gICAgICAgIHNjYWxlID0gXCJMXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IFwiTVwiO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbjxzdmdcbiAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICB7Li4uJCRyZXN0UHJvcHN9XG4gIHdpZHRoPXt3aWR0aCB8fCBzdyB8fCBmbGFnfVxuICBoZWlnaHQ9e2hlaWdodCB8fCBzaCB8fCBmbGFnfVxuICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgY2xhc3M9XCJzcGVjdHJ1bS1JY29uIHtjbGFzc05hbWV9XCI+XG4gIHsjaWYgc2NhbGUgPT09ICdMJ31cbiAgICA8cGF0aFxuICAgICAgYmluZDp0aGlzPXtwYXRofVxuICAgIGQ9XCJNNC41IDExYS45OTkuOTk5IDAgMDEtLjc4OC0uMzg1bC0zLTRhMSAxIDAgMTExLjU3Ni0xLjIzTDQuNSA4LjM3Nmw1LjIxMi02Ljk5YTEgMSAwIDExMS41NzYgMS4yM2wtNiA4QS45OTkuOTk5IDBcbiAgICAwMTQuNSAxMXpcIlxuLz5cbiAgezplbHNlIGlmIHNjYWxlID09PSAnTSd9XG4gICAgPHBhdGhcbiAgICAgIGJpbmQ6dGhpcz17cGF0aH1cbiAgICBkPVwiTTMuNzg4IDlBLjk5OS45OTkgMCAwMTMgOC42MTVsLTIuMjg4LTNhMSAxIDAgMTExLjU3Ni0xLjIzbDEuNSAxLjk5MSAzLjkyNC00Ljk5MWExIDEgMCAxMTEuNTc2IDEuMjNsLTQuNzEyXG4gICAgNkEuOTk5Ljk5OSAwIDAxMy43ODggOXpcIi8+XG4gIHsvaWZ9XG48L3N2Zz5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBleHBvcnQgbGV0IHNjYWxlID0gXCJNXCI7XG4gIGV4cG9ydCBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgZXhwb3J0IGxldCB3aWR0aCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgaGVpZ2h0ID0gXCJcIjtcbiAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSBcIkRhc2hTbWFsbFwiO1xuICBsZXQgcGF0aDtcbiAgbGV0IHN3O1xuICBsZXQgc2g7XG5cbiAgbGV0IGZsYWcgPSAxNDtcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHN3ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHNoID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHN3ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHNoID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmICghc2NhbGUgfHwgc2NhbGUgPT0gXCJNXCIpIHtcbiAgICAgIGxldCByb290Q2xhc3NOYW1lID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTmFtZTtcbiAgICAgIGlmIChyb290Q2xhc3NOYW1lICYmIHJvb3RDbGFzc05hbWUuaW5kZXhPZihcInNwZWN0cnVtLS1sYXJnZVwiKSAhPSAtMSkge1xuICAgICAgICBzY2FsZSA9IFwiTFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgPSBcIk1cIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG48c3ZnXG4gIGFyaWEtbGFiZWw9e2FyaWFMYWJlbH1cbiAgey4uLiQkcmVzdFByb3BzfVxuICB3aWR0aD17d2lkdGggfHwgc3cgfHwgZmxhZ31cbiAgaGVpZ2h0PXtoZWlnaHQgfHwgc2ggfHwgZmxhZ31cbiAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gIGNsYXNzPVwic3BlY3RydW0tSWNvbiB7Y2xhc3NOYW1lfVwiPlxuICB7I2lmIHNjYWxlID09PSAnTCd9XG4gICAgPHBhdGhcbiAgICAgIGJpbmQ6dGhpcz17cGF0aH0gZD1cIk0xMC45OSA1SDEuMDFhMSAxIDAgMDAwIDJoOS45OGExIDEgMCAxMDAtMnpcIiAvPlxuICB7OmVsc2UgaWYgc2NhbGUgPT09ICdNJ31cbiAgICA8cGF0aFxuICAgICAgYmluZDp0aGlzPXtwYXRofSBkPVwiTTggNEgyYTEgMSAwIDAwMCAyaDZhMSAxIDAgMDAwLTJ6XCIgLz5cbiAgey9pZn1cbjwvc3ZnPlxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRocm90dGxlRGVib3VuY2UgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCxuby1wYXJhbS1yZWFzc2lnbixuby1zaGFkb3cgKi9cblxuXHQvKipcblx0ICogVGhyb3R0bGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIEVzcGVjaWFsbHkgdXNlZnVsIGZvciByYXRlIGxpbWl0aW5nXG5cdCAqIGV4ZWN1dGlvbiBvZiBoYW5kbGVycyBvbiBldmVudHMgbGlrZSByZXNpemUgYW5kIHNjcm9sbC5cblx0ICpcblx0ICogQHBhcmFtICB7bnVtYmVyfSAgICBkZWxheSAtICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuXHQgKiBAcGFyYW0gIHtib29sZWFufSAgIFtub1RyYWlsaW5nXSAtICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub1RyYWlsaW5nIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgb25seSBleGVjdXRlIGV2ZXJ5IGBkZWxheWAgbWlsbGlzZWNvbmRzIHdoaWxlIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlZC1mdW5jdGlvbiBpcyBiZWluZyBjYWxsZWQuIElmIG5vVHJhaWxpbmcgaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25lIGZpbmFsIHRpbWVcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpLlxuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIC0gICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuXHQgKiBAcGFyYW0gIHtib29sZWFufSAgIFtkZWJvdW5jZU1vZGVdIC0gSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy4gSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gIEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gdGhyb3R0bGUgKGRlbGF5LCBub1RyYWlsaW5nLCBjYWxsYmFjaywgZGVib3VuY2VNb2RlKSB7XG5cdCAgLypcblx0ICAgKiBBZnRlciB3cmFwcGVyIGhhcyBzdG9wcGVkIGJlaW5nIGNhbGxlZCwgdGhpcyB0aW1lb3V0IGVuc3VyZXMgdGhhdFxuXHQgICAqIGBjYWxsYmFja2AgaXMgZXhlY3V0ZWQgYXQgdGhlIHByb3BlciB0aW1lcyBpbiBgdGhyb3R0bGVgIGFuZCBgZW5kYFxuXHQgICAqIGRlYm91bmNlIG1vZGVzLlxuXHQgICAqL1xuXHQgIHZhciB0aW1lb3V0SUQ7XG5cdCAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHRpbWUgYGNhbGxiYWNrYCB3YXMgZXhlY3V0ZWQuXG5cblx0ICB2YXIgbGFzdEV4ZWMgPSAwOyAvLyBGdW5jdGlvbiB0byBjbGVhciBleGlzdGluZyB0aW1lb3V0XG5cblx0ICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcblx0ICAgIGlmICh0aW1lb3V0SUQpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG5cdCAgICB9XG5cdCAgfSAvLyBGdW5jdGlvbiB0byBjYW5jZWwgbmV4dCBleGVjXG5cblxuXHQgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcblx0ICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG5cdCAgICBjYW5jZWxsZWQgPSB0cnVlO1xuXHQgIH0gLy8gYG5vVHJhaWxpbmdgIGRlZmF1bHRzIHRvIGZhbHN5LlxuXG5cblx0ICBpZiAodHlwZW9mIG5vVHJhaWxpbmcgIT09ICdib29sZWFuJykge1xuXHQgICAgZGVib3VuY2VNb2RlID0gY2FsbGJhY2s7XG5cdCAgICBjYWxsYmFjayA9IG5vVHJhaWxpbmc7XG5cdCAgICBub1RyYWlsaW5nID0gdW5kZWZpbmVkO1xuXHQgIH1cblx0ICAvKlxuXHQgICAqIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcblx0ICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxuXHQgICAqIGlzIGV4ZWN1dGVkLlxuXHQgICAqL1xuXG5cblx0ICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c18gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3VtZW50c19bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHZhciBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGxhc3RFeGVjO1xuXG5cdCAgICBpZiAoY2FuY2VsbGVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxuXG5cblx0ICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG5cdCAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcblx0ICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzXyk7XG5cdCAgICB9XG5cdCAgICAvKlxuXHQgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xuXHQgICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cblx0ICAgICAqL1xuXG5cblx0ICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuXHQgICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIGlmIChkZWJvdW5jZU1vZGUgJiYgIXRpbWVvdXRJRCkge1xuXHQgICAgICAvKlxuXHQgICAgICAgKiBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcblx0ICAgICAgICogYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG5cdCAgICAgICAqL1xuXHQgICAgICBleGVjKCk7XG5cdCAgICB9XG5cblx0ICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG5cblx0ICAgIGlmIChkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCAmJiBlbGFwc2VkID4gZGVsYXkpIHtcblx0ICAgICAgLypcblx0ICAgICAgICogSW4gdGhyb3R0bGUgbW9kZSwgaWYgYGRlbGF5YCB0aW1lIGhhcyBiZWVuIGV4Y2VlZGVkLCBleGVjdXRlXG5cdCAgICAgICAqIGBjYWxsYmFja2AuXG5cdCAgICAgICAqL1xuXHQgICAgICBleGVjKCk7XG5cdCAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcblx0ICAgICAgLypcblx0ICAgICAgICogSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxuXHQgICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuXHQgICAgICAgKiByZWNlbnQgZXhlY3V0aW9uLlxuXHQgICAgICAgKlxuXHQgICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuXHQgICAgICAgKiBhZnRlciBgZGVsYXlgIG1zLlxuXHQgICAgICAgKlxuXHQgICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuXHQgICAgICAgKiBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG5cdCAgICAgICAqL1xuXHQgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgd3JhcHBlci5jYW5jZWwgPSBjYW5jZWw7IC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cblxuXHQgIHJldHVybiB3cmFwcGVyO1xuXHR9XG5cblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5cdC8qKlxuXHQgKiBEZWJvdW5jZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRGVib3VuY2luZywgdW5saWtlIHRocm90dGxpbmcsXG5cdCAqIGd1YXJhbnRlZXMgdGhhdCBhIGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgYSBzaW5nbGUgdGltZSwgZWl0aGVyIGF0IHRoZVxuXHQgKiB2ZXJ5IGJlZ2lubmluZyBvZiBhIHNlcmllcyBvZiBjYWxscywgb3IgYXQgdGhlIHZlcnkgZW5kLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9ICAgZGVsYXkgLSAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuXHQgKiBAcGFyYW0gIHtib29sZWFufSAgW2F0QmVnaW5dIC0gICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgYXRCZWdpbiBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGBkZWxheWAgbWlsbGlzZWNvbmRzXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBsYXN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLiBJZiBhdEJlZ2luIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25seSBhdCB0aGUgZmlyc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLCB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIGRlYm91bmNlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cblx0ICpcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBkZWJvdW5jZSAoZGVsYXksIGF0QmVnaW4sIGNhbGxiYWNrKSB7XG5cdCAgcmV0dXJuIGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyB0aHJvdHRsZShkZWxheSwgYXRCZWdpbiwgZmFsc2UpIDogdGhyb3R0bGUoZGVsYXksIGNhbGxiYWNrLCBhdEJlZ2luICE9PSBmYWxzZSk7XG5cdH1cblxuXHRleHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XG5cdGV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgudW1kLmpzLm1hcFxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSWNvbkNoZWNrbWFya1NtYWxsLCBJY29uRGFzaFNtYWxsIH0gZnJvbSBcIkBydWJ1cy9zdmVsdGUtc3BlY3RydW0taWNvbnMtdWlcIjtcbiAgaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIjtcbiAgaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tIFwidGhyb3R0bGUtZGVib3VuY2VcIjtcbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUsIG9uRGVzdHJveSB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gIGltcG9ydCB7IGdldEV2ZW50c0FjdGlvbiB9IGZyb20gXCIuLi91dGlscy9nZXQtZXZlbnRzLWFjdGlvbi5qc1wiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGNoZWNrZWRcbiAgICogQHR5cGUge2Jvb2xlYW59IFtjaGVja2VkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBjaGVja2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgY2hlY2tib3hcbiAgICogQHR5cGUge2Jvb2xlYW59IFtkaXNhYmxlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgaW5wdXQgc2hvdWxkIGRpc3BsYXkgaXRzIFwidmFsaWRcIiBvciBcImludmFsaWRcIiB2aXN1YWwgc3R5bGluZy5cbiAgICogQHR5cGUge2Jvb2xlYW59IFtpc0ludmFsaWQ9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGlzIHByb3Agc2V0cyB0aGUgcXVpZXQgc3R5bGUgd2hpY2ggcHJvdmlkZXMgdmlzdWFsIHdlYWtlbi5cbiAgICogQHR5cGUge2Jvb2xlYW59IFtpc1F1aWV0PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1F1aWV0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgY2hlY2tib3ggaXMgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gW2luZGV0ZXJtaW5hdGU9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCBmb3IgdGhlIGNoZWNrYm94IHRvIGJlIHJlYWQtb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gW3JlYWRvbmx5PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCByZWFkb25seSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuYW1lIGZvciB0aGUgaW5wdXQgZWxlbWVudFxuICAgKiBAdHlwZSB7c3RyaW5nfSBbbmFtZT1cIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBuYW1lID0gXCJcIjtcblxuICAvKipcbiAgICogU2V0IGFuIGlkIGZvciB0aGUgaW5wdXQgZWxlbWVudFxuICAgKiBAdHlwZSB7c3RyaW5nfSBbaWQgPSBcImNoZWNrYm94LVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygyNCldXG4gICAqL1xuICBleHBvcnQgbGV0IGlkID0gXCJjaGVja2JveC1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMjQpO1xuXG4gIC8qKlxuICAgKiBTZXQgYW4gaWQgZm9yIHRoZSBpbnB1dCBlbGVtZW50XG4gICAqIEB0eXBlIHtzdHJpbmd9IFt2YWx1ZSA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IHZhbHVlID0gXCJcIjtcblxuICAvKipcbiAgICogU2V0IGFuIHRpdGxlIGZvciB0aGUgaW5wdXQgbGFiYWxcbiAgICogQHR5cGUge3N0cmluZ30gW3RpdGxlID0gXCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgdGl0bGUgPSBcIlwiO1xuXG4gIGxldCBjaGVja2JveDtcbiAgbGV0IGljb25TaXplID0gMTA7XG4gIGxldCBsYXJnZSA9IGZhbHNlO1xuICBjb25zdCBldmVudHNMaXN0ZW4gPSBnZXRFdmVudHNBY3Rpb24oY3VycmVudF9jb21wb25lbnQpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihnZXRJY29uU2NhbGUpO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICB0aHJvdHRsZSg1MDAsIG9ic2VydmVyLm9ic2VydmUoY2hlY2tib3gpKTtcbiAgfSk7XG5cbiAgb25EZXN0cm95KCgpID0+IHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoY2hlY2tib3gpO1xuICB9KTtcblxuICBmdW5jdGlvbiBnZXRJY29uU2NhbGUoKSB7XG4gICAgaWNvblNpemUgPSBwYXJzZUludChcbiAgICAgIGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtMTI1XCIpXG4gICAgKTtcbiAgICBpZiAoaWNvblNpemUgPT0gMTApIHtcbiAgICAgIGxhcmdlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAucmVhZG9ubHkge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuXG57I2lmIHJlYWRvbmx5fVxuICA8bGFiZWxcbiAgICB7dGl0bGV9XG4gICAgey4uLiQkcmVzdFByb3BzfVxuICAgIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3ggcmVhZG9ubHkgeyQkcmVzdFByb3BzLmNsYXNzfVwiXG4gICAgY2xhc3M6aXMtZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgIGNsYXNzOmlzLWluZGV0ZXJtaW5hdGU9e2luZGV0ZXJtaW5hdGV9XG4gICAgY2xhc3M6aXMtaW52YWxpZD17aXNJbnZhbGlkfVxuICAgIGNsYXNzOnNwZWN0cnVtLUNoZWNrYm94LS1xdWlldD17aXNRdWlldH0+XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveC1pbnB1dFwiXG4gICAgICB7aWR9XG4gICAgICB7bmFtZX1cbiAgICAgIHtkaXNhYmxlZH1cbiAgICAgIHt2YWx1ZX1cbiAgICAgIGJpbmQ6dGhpcz17Y2hlY2tib3h9XG4gICAgICB7Y2hlY2tlZH1cbiAgICAgIHtpbmRldGVybWluYXRlfSAvPlxuICAgIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3gtYm94XCI+XG4gICAgICB7I2lmIGNoZWNrZWR9XG4gICAgICAgIDxJY29uQ2hlY2ttYXJrU21hbGxcbiAgICAgICAgICB3aWR0aD17aWNvblNpemUgLSAxfVxuICAgICAgICAgIGhlaWdodD17aWNvblNpemUgLSAxfVxuICAgICAgICAgIHNjYWxlPXtsYXJnZSA/ICdMJyA6ICdNJ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJzcGVjdHJ1bS1DaGVja2JveC1jaGVja21hcmtcIlxuICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICAgICAgey9pZn1cbiAgICAgIHsjaWYgaW5kZXRlcm1pbmF0ZX1cbiAgICAgICAgPEljb25EYXNoU21hbGxcbiAgICAgICAgICB3aWR0aD17aWNvblNpemV9XG4gICAgICAgICAgaGVpZ2h0PXtpY29uU2l6ZX1cbiAgICAgICAgICBzY2FsZT17bGFyZ2UgPyAnTCcgOiAnTSd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwic3BlY3RydW0tQ2hlY2tib3gtcGFydGlhbENoZWNrbWFya1wiXG4gICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gICAgICB7L2lmfVxuICAgIDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94LWxhYmVsXCI+XG4gICAgICA8c2xvdD5DaGVja2JveDwvc2xvdD5cbiAgICA8L3NwYW4+XG4gIDwvbGFiZWw+XG57OmVsc2V9XG4gIDxsYWJlbFxuICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94IHskJHJlc3RQcm9wcy5jbGFzc31cIlxuICAgIGNsYXNzOmlzLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICBjbGFzczppcy1pbmRldGVybWluYXRlPXtpbmRldGVybWluYXRlfVxuICAgIGNsYXNzOmlzLWludmFsaWQ9e2lzSW52YWxpZH1cbiAgICBjbGFzczpzcGVjdHJ1bS1DaGVja2JveC0tcXVpZXQ9e2lzUXVpZXR9XG4gICAgdXNlOmV2ZW50c0xpc3Rlbj5cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94LWlucHV0XCJcbiAgICAgIHtpZH1cbiAgICAgIHtuYW1lfVxuICAgICAge2Rpc2FibGVkfVxuICAgICAge3ZhbHVlfVxuICAgICAgYmluZDp0aGlzPXtjaGVja2JveH1cbiAgICAgIGJpbmQ6Y2hlY2tlZFxuICAgICAgYmluZDppbmRldGVybWluYXRlIC8+XG4gICAgPHNwYW4gY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveC1ib3hcIj5cbiAgICAgIHsjaWYgY2hlY2tlZH1cbiAgICAgICAgPEljb25DaGVja21hcmtTbWFsbFxuICAgICAgICAgIHdpZHRoPXtpY29uU2l6ZSAtIDF9XG4gICAgICAgICAgaGVpZ2h0PXtpY29uU2l6ZSAtIDF9XG4gICAgICAgICAgc2NhbGU9e2xhcmdlID8gJ0wnIDogJ00nfVxuICAgICAgICAgIGNsYXNzTmFtZT1cInNwZWN0cnVtLUNoZWNrYm94LWNoZWNrbWFya1wiXG4gICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gICAgICB7L2lmfVxuICAgICAgeyNpZiBpbmRldGVybWluYXRlfVxuICAgICAgICA8SWNvbkRhc2hTbWFsbFxuICAgICAgICAgIHdpZHRoPXtpY29uU2l6ZX1cbiAgICAgICAgICBoZWlnaHQ9e2ljb25TaXplfVxuICAgICAgICAgIHNjYWxlPXtsYXJnZSA/ICdMJyA6ICdNJ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJzcGVjdHJ1bS1DaGVja2JveC1wYXJ0aWFsQ2hlY2ttYXJrXCJcbiAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cbiAgICAgIHsvaWZ9XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3gtbGFiZWxcIj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9zcGFuPlxuICA8L2xhYmVsPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBUaGUgZWxlbWVudCdzIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgKiBAdHlwZSB7IHN0cmluZyB9W2lkID0gYHJhZGlvLSR7TWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDk5OTk5IC0gMCkpICsgMH1gXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpZCA9IGByYWRpby0ke01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICg5OTk5OSAtIDApKSArIDB9YDtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCB0byBjaGVja2VkIHRoZSByYWRpb1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1bY2hlY2tlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgY2hlY2tlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIHRvIGludmFsaWQgdGhlIHJhZGlvXG4gICAqIEB0eXBlIHtib29sZWFufVtjaGVja2VkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc0ludmFsaWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCB0byBkaXNhYmxlIHRoZSByYWRpb1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1bZGlzYWJsZWQ9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHF1aWV0IG1vZGUgb2YgcmFkaW9cbiAgICogQHR5cGUgeyBib29sZWFuIH0gW2lzUXVpZXQ9IGZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1F1aWV0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSByYWRpbyBidXR0b24sIHVzZWQgd2hlbiBzdWJtaXR0aW5nIGFuIEhUTUwgZm9ybS5cbiAgICogQHR5cGUgeyBzdHJpbmcgfVsgbmFtZSA9IFwicmFkaW9cIiBdXG4gICAqL1xuICBleHBvcnQgbGV0IG5hbWUgPSBcInJhZGlvXCI7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgcmFkaW8gYnV0dG9uLCB1c2VkIHdoZW4gc3VibWl0dGluZyBhbiBIVE1MIGZvcm0uXG4gICAqIEB0eXBlIHsgc3RyaW5nIH1bdmFsdWUgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YWx1ZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHJlYWRvbmx5IG1vZGUgb2YgcmFkaW9cbiAgICogQHR5cGUge2Jvb2xlYW59W3JlYWRvbmx5PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCByZWFkb25seSA9IGZhbHNlO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zcGVjdHJ1bS1SYWRpby5pcy1yZWFkb25seSB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgY2xhc3M9XCJzcGVjdHJ1bS1SYWRpb1wiXG4gIGNsYXNzOnNwZWN0cnVtLVJhZGlvLS1xdWlldD17aXNRdWlldH1cbiAgY2xhc3M6aXMtaW52YWxpZD17aXNJbnZhbGlkfVxuICBjbGFzczppcy1yZWFkb25seT17cmVhZG9ubHl9PlxuICA8aW5wdXQgdHlwZT1cInJhZGlvXCIge25hbWV9IGNsYXNzPVwic3BlY3RydW0tUmFkaW8taW5wdXRcIiB7aWR9IHtjaGVja2VkfSB7ZGlzYWJsZWR9IHt2YWx1ZX0ge3JlYWRvbmx5fSAvPlxuICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLVJhZGlvLWJ1dHRvblwiIC8+XG4gIDxsYWJlbCBjbGFzcz1cInNwZWN0cnVtLVJhZGlvLWxhYmVsXCIgZm9yPXtpZH0+PHNsb3Q+e3ZhbHVlfTwvc2xvdD48L2xhYmVsPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAvKipcbiAgICogU2V0IGJvZHkgc2NhbGUgc3BlY2lmaWNhdGlvbnNcbiAgICogQHR5cGUge1wiWFNcIiB8IFwiU1wiIHwgXCJNXCIgfCBcIkxcIiB8IFwiWExcIiB8IFwiWFhMXCIgfCBcIlhYWExcIn0gW3NjYWxlID0gXCJNXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IHNjYWxlID0gXCJNXCI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIHNlcmlmIGZvbnQgZmFtaWx5IGluIHRoZSBjb250ZXh0XG4gICAqIEB0eXBlIHtib29sZWFufSBbaXNTZXJpZiA9IGZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1NlcmlmID0gZmFsc2U7XG48L3NjcmlwdD5cblxuPHAgY2xhc3M9XCJzcGVjdHJ1bS1Cb2R5IHNwZWN0cnVtLUJvZHktLXtzY2FsZX1cIiBjbGFzczpzcGVjdHJ1bS1Cb2R5LS1zZXJpZj17aXNTZXJpZn0+XG4gIDxzbG90IC8+XG48L3A+XG4iLCI8c2NyaXB0PlxuICAvKipcbiAgICogU2V0IEhlYWRpbmcgc2NhbGUgc3BlY2lmaWNhdGlvbnNcbiAgICogQHR5cGUge1wiWFhTXCIgfCBcIlhTXCIgfCBcIlNcIiB8IFwiTVwiIHwgXCJMXCIgfCBcIlhMXCIgfCBcIlhYTFwiIHwgXCJYWFhMXCJ9IFtzY2FsZSA9IFwiTVwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBzY2FsZSA9IFwiTVwiO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZXJpZiBmb250IGZhbWlseSBpbiB0aGUgY29udGV4dFxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gW2lzU2VyaWYgPSBmYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgaXNTZXJpZiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvbnQgd2VpZ2h0XG4gICAqIEB0eXBlIHtcImhlYXZ5XCIgfCBcImxpZ2h0XCIgfCBcImRlZmF1bHRcIiB9IFt0aGlja25lc3MgPSBcImRlZmF1bHRcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgdGhpY2tuZXNzID0gXCJkZWZhdWx0XCI7XG48L3NjcmlwdD5cblxuPGgxXG4gIGNsYXNzPVwic3BlY3RydW0tSGVhZGluZyBzcGVjdHJ1bS1IZWFkaW5nLS17c2NhbGV9ICBzcGVjdHJ1bS1IZWFkaW5nLS17dGhpY2tuZXNzfVwiXG4gIGNsYXNzOnNwZWN0cnVtLUhlYWRpbmctLXNlcmlmPXtpc1NlcmlmfT5cbiAgPHNsb3QgLz5cbjwvaDE+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBSYWRpbywgQ2hlY2tib3ggfSBmcm9tIFwiQHJ1YnVzL3J1YnVzL3NyY1wiO1xuICBpbXBvcnQgeyBnZXRDb250ZXh0LCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIGltcG9ydCAqIGFzIGNvbG9yRGF0YSBmcm9tIFwiLi9jb2xvci5qc29uXCI7XG5cbiAgbGV0IGNvbG9yTW9kZWwgPSBcImhleFwiO1xuICBsZXQgc3RhdGljQ29sb3JzVmlldyA9IGZhbHNlO1xuICBsZXQgcnVidXNEb2NDb25maWcgPSBnZXRDb250ZXh0KFwicnVidXNEb2NDb25maWdcIik7XG4gIGxldCBjb2xvckRpc3BsYXkgPSBcImdsb2JhbENvbG9yXCI7XG5cbiAgb25Nb3VudCgoKSA9PiB7fSk7XG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKCkge1xuICAgIHN0YXRpY0NvbG9yc1ZpZXcgPSAhc3RhdGljQ29sb3JzVmlldztcbiAgICBjb2xvckRpc3BsYXkgPSBzdGF0aWNDb2xvcnNWaWV3ID8gXCJzdGF0aWNDb2xvclwiIDogXCJnbG9iYWxDb2xvclwiO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY29weUNvbG9yKHQsIGMpIHtcbiAgICBpZiAoY29sb3JNb2RlbCAhPT0gXCJoZXhcIikge1xuICAgICAgYyA9IGhleFRvUkdCKGMpO1xuICAgIH1cbiAgICBsZXQgY29sb3JDb2RlID0gc3RhdGljQ29sb3JzVmlld1xuICAgICAgPyBgLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLSR7dC5yZXBsYWNlKC9bXmEtekEtWl0vZ2ksIFwiXCIpLnRvTG93ZXJDYXNlKCl9LSR7dC5yZXBsYWNlKFxuICAgICAgICAgIC9bXjAtOV0vZ2ksXG4gICAgICAgICAgXCJcIlxuICAgICAgICApfTogJHtjfWBcbiAgICAgIDogYC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLSR7dC5yZXBsYWNlKC9bXmEtekEtWl0vZ2ksIFwiXCIpLnRvTG93ZXJDYXNlKCl9LSR7dC5yZXBsYWNlKC9bXjAtOV0vZ2ksIFwiXCIpfTogJHtjfWA7XG4gICAgaWYgKG5hdmlnYXRvci5jbGlwYm9hcmQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvbG9yQ29kZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUGFnZSBVUkwgY29waWVkIHRvIGNsaXBib2FyZDpcIiArIGNvbG9yQ29kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb3B5OiBcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGV4VG9SR0IoaCkge1xuICAgIGxldCByID0gMCxcbiAgICAgIGcgPSAwLFxuICAgICAgYiA9IDA7XG5cbiAgICAvLyAzIGRpZ2l0c1xuICAgIGlmIChoLmxlbmd0aCA9PSA0KSB7XG4gICAgICByID0gXCIweFwiICsgaFsxXSArIGhbMV07XG4gICAgICBnID0gXCIweFwiICsgaFsyXSArIGhbMl07XG4gICAgICBiID0gXCIweFwiICsgaFszXSArIGhbM107XG5cbiAgICAgIC8vIDYgZGlnaXRzXG4gICAgfSBlbHNlIGlmIChoLmxlbmd0aCA9PSA3KSB7XG4gICAgICByID0gXCIweFwiICsgaFsxXSArIGhbMl07XG4gICAgICBnID0gXCIweFwiICsgaFszXSArIGhbNF07XG4gICAgICBiID0gXCIweFwiICsgaFs1XSArIGhbNl07XG4gICAgfVxuXG4gICAgcmV0dXJuIFwicmdiKFwiICsgK3IgKyBcIixcIiArICtnICsgXCIsXCIgKyArYiArIFwiKVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaGV4VG9IU0woSCkge1xuICAgIGxldCByID0gMCxcbiAgICAgIGcgPSAwLFxuICAgICAgYiA9IDA7XG4gICAgaWYgKEgubGVuZ3RoID09IDQpIHtcbiAgICAgIHIgPSBcIjB4XCIgKyBIWzFdICsgSFsxXTtcbiAgICAgIGcgPSBcIjB4XCIgKyBIWzJdICsgSFsyXTtcbiAgICAgIGIgPSBcIjB4XCIgKyBIWzNdICsgSFszXTtcbiAgICB9IGVsc2UgaWYgKEgubGVuZ3RoID09IDcpIHtcbiAgICAgIHIgPSBcIjB4XCIgKyBIWzFdICsgSFsyXTtcbiAgICAgIGcgPSBcIjB4XCIgKyBIWzNdICsgSFs0XTtcbiAgICAgIGIgPSBcIjB4XCIgKyBIWzVdICsgSFs2XTtcbiAgICB9XG4gICAgLy8gVGhlbiB0byBIU0xcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICBsZXQgY21pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgY21heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBjbWF4IC0gY21pbixcbiAgICAgIGggPSAwLFxuICAgICAgcyA9IDAsXG4gICAgICBsID0gMDtcblxuICAgIGlmIChkZWx0YSA9PSAwKSBoID0gMDtcbiAgICBlbHNlIGlmIChjbWF4ID09IHIpIGggPSAoKGcgLSBiKSAvIGRlbHRhKSAlIDY7XG4gICAgZWxzZSBpZiAoY21heCA9PSBnKSBoID0gKGIgLSByKSAvIGRlbHRhICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gZGVsdGEgKyA0O1xuXG4gICAgaCA9IE1hdGgucm91bmQoaCAqIDYwKTtcblxuICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG5cbiAgICBsID0gKGNtYXggKyBjbWluKSAvIDI7XG4gICAgcyA9IGRlbHRhID09IDAgPyAwIDogZGVsdGEgLyAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpO1xuICAgIHMgPSArKHMgKiAxMDApLnRvRml4ZWQoMSk7XG4gICAgbCA9ICsobCAqIDEwMCkudG9GaXhlZCgxKTtcblxuICAgIHJldHVybiBbaCwgcywgbF07XG4gIH1cblxuICBmdW5jdGlvbiBsaWdodEFuZERhcmsoY29kZSkge1xuICAgIGxldCBbLCAsIGxdID0gaGV4VG9IU0woY29kZSk7XG4gICAgbGV0IGNyb3Nzb3ZlciA9IDUwO1xuICAgIHN3aXRjaCAoJHJ1YnVzRG9jQ29uZmlnLnRoZW1lKSB7XG4gICAgICBjYXNlIFwibGlnaHRcIjpcbiAgICAgICAgY3Jvc3NvdmVyID0gNjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxpZ2h0ZXN0XCI6XG4gICAgICAgIGNyb3Nzb3ZlciA9IDcwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXJrXCI6XG4gICAgICAgIGNyb3Nzb3ZlciA9IDM4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXJrZXN0XCI6XG4gICAgICAgIGNyb3Nzb3ZlciA9IDM1O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGwgPj0gY3Jvc3NvdmVyID8gZmFsc2UgOiB0cnVlO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAudG9vbGJhciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICB3aWR0aDogMzAwcHg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgZm9ybSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgfVxuICAudmVydGljYWwtbGluZSB7XG4gICAgd2lkdGg6IDFweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc3BlY3RydW0tYWxpYXMtYmFja2dyb3VuZC1jb2xvci1kZWZhdWx0KTtcbiAgfVxuICAuY29sb3ItbW9kZWwge1xuICAgIHdpZHRoOiAxMjBweDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIH1cbiAgLmNvbG9yLWNvbnRhaW5lciB7XG4gICAgcGFkZGluZzogOHB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIHBhZGRpbmctdG9wOiAzMnB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTEwMCk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktMzAwKTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIH1cbiAgLmNvbG9yLWdyb3VwIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICBtYXgtd2lkdGg6IDgxNnB4O1xuICAgIG1hcmdpbjogYXV0bztcbiAgICBtYXJnaW4tYm90dG9tOiAzMHB4O1xuICB9XG4gIC5jb2xvci1pdGVtIHtcbiAgICBmbGV4LWJhc2lzOiAyMiU7XG4gICAgaGVpZ2h0OiAxMDBweDtcbiAgICBtYXJnaW46IDEuNSU7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgcGFkZGluZzogMTBweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItZ3JheS0yMDApO1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxMzBtcyBlYXNlLWluLW91dDtcbiAgfVxuICAuY29sb3ItaXRlbTpob3ZlciB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA4KTtcbiAgfVxuICAuY29sb3ItaXRlbS1uYW1lIHtcbiAgICBmb250LXNpemU6IDExcHg7XG4gICAgbGluZS1oZWlnaHQ6IDEuMztcbiAgICBsZXR0ZXItc3BhY2luZzogMC4wM2VtO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG4gIC5jb2xvci1pdGVtLWNvZGUge1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgbGluZS1oZWlnaHQ6IDEuMztcbiAgICBmb250LXNpemU6IDEzcHg7XG4gIH1cbiAgLmNvbG9yLWl0ZW0tbGlnaHQgPiAuY29sb3ItaXRlbS1uYW1lIHtcbiAgICBjb2xvcjogdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLXN0YXRpYy1ncmF5LTgwMCk7XG4gIH1cbiAgLmNvbG9yLWl0ZW0tbGlnaHQgPiAuY29sb3ItaXRlbS1jb2RlIHtcbiAgICBjb2xvcjogdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLXN0YXRpYy1ncmF5LTkwMCk7XG4gIH1cbiAgLmNvbG9yLWl0ZW0tZGFyayA+IC5jb2xvci1pdGVtLW5hbWUge1xuICAgIGNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLWdyYXktMjAwKTtcbiAgfVxuICAuY29sb3ItaXRlbS1kYXJrID4gLmNvbG9yLWl0ZW0tY29kZSB7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1zdGF0aWMtZ3JheS0xMDApO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwidG9vbGJhclwiPlxuICA8Zm9ybT5cbiAgICA8Q2hlY2tib3ggY2hlY2tlZD17c3RhdGljQ29sb3JzVmlld30gb246Y2xpY2s9e2hhbmRsZUNsaWNrfT5TdGF0aWMgY29sb3JzPC9DaGVja2JveD5cbiAgPC9mb3JtPlxuICA8ZGl2IGNsYXNzPVwidmVydGljYWwtbGluZVwiIC8+XG4gIDxmb3JtIGNsYXNzPVwiY29sb3ItbW9kZWxcIj5cbiAgICA8UmFkaW9cbiAgICAgIHZhbHVlPVwiSGV4XCJcbiAgICAgIGNoZWNrZWQ9e2NvbG9yTW9kZWwgPT0gJ2hleCd9XG4gICAgICBvbjpjbGljaz17KCkgPT4ge1xuICAgICAgICBjb2xvck1vZGVsID0gJ2hleCc7XG4gICAgICB9fSAvPlxuICAgIDxSYWRpb1xuICAgICAgdmFsdWU9XCJSR0JcIlxuICAgICAgY2hlY2tlZD17Y29sb3JNb2RlbCA9PSAncmdiJ31cbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGNvbG9yTW9kZWwgPSAncmdiJztcbiAgICAgIH19IC8+XG4gIDwvZm9ybT5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cImNvbG9yLWNvbnRhaW5lclwiPlxuICB7I2VhY2ggY29sb3JEYXRhWyRydWJ1c0RvY0NvbmZpZy50aGVtZV1bY29sb3JEaXNwbGF5XSBhcyBpdGVtc31cbiAgICA8ZGl2IGNsYXNzPVwiY29sb3ItZ3JvdXBcIj5cbiAgICAgIHsjZWFjaCBpdGVtcyBhcyBjb2xvckl0ZW19XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBvbjpjbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgY29weUNvbG9yKGNvbG9ySXRlbS5uYW1lLCBjb2xvckl0ZW0uY29kZSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBjbGFzcz1cImNvbG9yLWl0ZW0ge2xpZ2h0QW5kRGFyayhjb2xvckl0ZW0uY29kZSkgPyAnY29sb3ItaXRlbS1kYXJrJyA6ICdjb2xvci1pdGVtLWxpZ2h0J31cIlxuICAgICAgICAgIHN0eWxlPXtgYmFja2dyb3VuZC1jb2xvcjoke2NvbG9yTW9kZWwgPT0gJ2hleCcgPyBjb2xvckl0ZW0uY29kZS50b1VwcGVyQ2FzZSgpIDogaGV4VG9SR0IoY29sb3JJdGVtLmNvZGUpLnRvVXBwZXJDYXNlKCl9YH0+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbG9yLWl0ZW0tbmFtZVwiPntjb2xvckl0ZW0ubmFtZX08L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sb3ItaXRlbS1jb2RlXCI+XG4gICAgICAgICAgICB7Y29sb3JNb2RlbCA9PSAnaGV4JyA/IGNvbG9ySXRlbS5jb2RlLnRvVXBwZXJDYXNlKCkgOiBoZXhUb1JHQihjb2xvckl0ZW0uY29kZSkudG9VcHBlckNhc2UoKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgVHlwb2dyYXBoeUhlYWRpbmcsIFR5cG9ncmFwaHlCb2R5IH0gZnJvbSBcIkBydWJ1cy9ydWJ1cy9zcmNcIjtcbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IENvbG9yQ29udGFpbmVyIGZyb20gXCIuLi8uLi8uLi8uLi9jb21wb25lbnRzL2NvbG9yLWNvbnRhaW5lclwiO1xuICBsZXQgcnVidXNEb2NDb25maWcgPSBnZXRDb250ZXh0KFwicnVidXNEb2NDb25maWdcIik7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBoZWFkZXIge1xuICAgIG1pbi1oZWlnaHQ6IDEyMHB4O1xuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT57JHJ1YnVzRG9jQ29uZmlnLm5hbWV9IOminOiJsjwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48aGVhZGVyPlxuICA8VHlwb2dyYXBoeUhlYWRpbmcgc2NhbGU9XCJYTFwiPuminOiJsjwvVHlwb2dyYXBoeUhlYWRpbmc+XG4gIDxUeXBvZ3JhcGh5Qm9keSBzY2FsZT1cIk1cIiBsaW5lSGVpZ2h0PVwic2l6ZS00MDBcIj7kvY3kuo7orr7orqHns7vnu5/kuK3nmoTpopzoibLku6TniYw8L1R5cG9ncmFwaHlCb2R5PlxuPC9oZWFkZXI+XG5cbjxtYWluPlxuICA8Q29sb3JDb250YWluZXIgLz5cbjwvbWFpbj5cbiJdLCJuYW1lcyI6WyJ0aGlzIiwiUmVzaXplT2JzZXJ2ZXIiLCJ0aHJvdHRsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBNENPLEdBQUssUUFBSyxHQUFHO2dCQU1SLEdBQUssUUFBSyxHQUFHOzs7Ozs7O2dDQVpYLEdBQVM7a0JBQ2pCLEdBQVc7O3NDQUNSLEdBQUssY0FBSSxHQUFFLGdCQUFJLEdBQUk7Ozt5Q0FDbEIsR0FBTSxjQUFJLEdBQUUsZ0JBQUksR0FBSTs7Ozs2REFFTixHQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OERBTG5CLEdBQVM7bURBQ2pCLEdBQVc7aUZBQ1IsR0FBSyxjQUFJLEdBQUUsZ0JBQUksR0FBSTtzRkFDbEIsR0FBTSxjQUFJLEdBQUUsZ0JBQUksR0FBSTs7dUdBRU4sR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BekNwQixLQUFLLEdBQUcsR0FBRztPQUNYLFNBQVMsR0FBRyxFQUFFO09BQ2QsS0FBSyxHQUFHLEVBQUU7T0FDVixNQUFNLEdBQUcsRUFBRTtPQUNYLFNBQVMsR0FBRyxnQkFBZ0I7S0FDbkMsSUFBSTtLQUNKLEVBQUU7S0FDRixFQUFFO0tBRUYsSUFBSSxHQUFHLEVBQUU7O0NBQ2IsT0FBTztNQUNELElBQUk7bUJBQ04sRUFBRSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLO21CQUN2QyxFQUFFLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixHQUFHLE1BQU07Ozs7Q0FJNUMsV0FBVztNQUNMLElBQUk7bUJB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkNvTk0sR0FBUyxLQUFDLElBQUk7Ozs7O2dDQUV6QyxHQUFVLE9BQUksS0FBSztpQkFBRyxHQUFTLEtBQUMsSUFBSSxDQUFDLFdBQVc7R0FBSyxRQUFRLGVBQUMsR0FBUyxLQUFDLElBQUks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
