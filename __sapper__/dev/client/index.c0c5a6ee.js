import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as create_slot, v as validate_slots, z as afterUpdate, f as element, h as claim_element, j as children, l as detach_dev, p as attr_dev, E as toggle_class, q as add_location, r as insert_dev, y as update_slot, t as transition_in, b as transition_out, G as binding_callbacks, a3 as globals, c as create_component, C as space, a as claim_component, D as claim_space, u as append_dev, m as mount_component, e as destroy_component, g as text, k as claim_text } from './client.819062b1.js';
import { B as ButtonIconWrap, S as Selection, T as Transparency, L as LoupeView, C as Copy } from './Transparency.e955ef3a.js';
import { B as Button } from './Button.d7bca58d.js';
import { T as TypographyHeading, a as TypographyBody } from './TypographyHeading.aded6356.js';
import { C as Code } from './Code.90dabd2a.js';

/* node_modules/@rubus/rubus/src/packages/ActionGroup/ActionGroup.svelte generated by Svelte v3.29.4 */
const file = "node_modules/@rubus/rubus/src/packages/ActionGroup/ActionGroup.svelte";

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "spectrum-ActionGroup");
			attr_dev(div, "style", /*styleCssText*/ ctx[5]);
			toggle_class(div, "spectrum-ActionGroup--justified", /*variants*/ ctx[1] === "justified");
			toggle_class(div, "spectrum-ActionGroup--vertical", /*orientation*/ ctx[0] === "vertical");
			toggle_class(div, "spectrum-ActionGroup--quiet", /*isQuiet*/ ctx[2]);
			toggle_class(div, "spectrum-ActionGroup--compact", /*isCompact*/ ctx[3]);
			add_location(div, file, 97, 0, 2664);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[12](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			if (!current || dirty & /*styleCssText*/ 32) {
				attr_dev(div, "style", /*styleCssText*/ ctx[5]);
			}

			if (dirty & /*variants*/ 2) {
				toggle_class(div, "spectrum-ActionGroup--justified", /*variants*/ ctx[1] === "justified");
			}

			if (dirty & /*orientation*/ 1) {
				toggle_class(div, "spectrum-ActionGroup--vertical", /*orientation*/ ctx[0] === "vertical");
			}

			if (dirty & /*isQuiet*/ 4) {
				toggle_class(div, "spectrum-ActionGroup--quiet", /*isQuiet*/ ctx[2]);
			}

			if (dirty & /*isCompact*/ 8) {
				toggle_class(div, "spectrum-ActionGroup--compact", /*isCompact*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[12](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ActionGroup", slots, ['default']);
	let { orientation = "horizontal" } = $$props;
	let { variants = "general" } = $$props;
	let { dimension = "" } = $$props;
	let { onlyIcon = false } = $$props;
	let { isQuiet = false } = $$props;
	let { isCompact = false } = $$props;
	let { emphasized = false } = $$props;
	let { disabled = false } = $$props;
	let actionGroup;

	function addChildClassName() {
		let buttonClassName = [
			" spectrum-ActionGroup-item",
			isQuiet && "spectrum-ActionButton--quiet",
			emphasized && "spectrum-ActionButton--emphasized"
		].filter(Boolean).join(" ");

		if (actionGroup) {
			const buttonItem = actionGroup.getElementsByClassName("spectrum-ActionButton");

			if (buttonItem.length !== 0) {
				for (let index = 0; index < buttonItem.length; index++) {
					if (disabled) {
						buttonItem[index].setAttribute("disabled", disabled);
					}

					buttonItem[index].className = buttonItem[index].className + buttonClassName;
				}
			}

			if (onlyIcon && variants === "general") {
				const buttonWrapItem = actionGroup.getElementsByClassName("spectrum-Button-wrap");

				if (buttonWrapItem.length !== 0) {
					for (let index = 0; index < buttonWrapItem.length; index++) {
						buttonWrapItem[index].className = buttonWrapItem[index].className + " rubus-button-wrap";
					}
				}
			}
		}
	}

	afterUpdate(() => {
		addChildClassName();
	});

	const writable_props = [
		"orientation",
		"variants",
		"dimension",
		"onlyIcon",
		"isQuiet",
		"isCompact",
		"emphasized",
		"disabled"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ActionGroup> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			actionGroup = $$value;
			$$invalidate(4, actionGroup);
		});
	}

	$$self.$$set = $$props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$props.orientation);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("dimension" in $$props) $$invalidate(6, dimension = $$props.dimension);
		if ("onlyIcon" in $$props) $$invalidate(7, onlyIcon = $$props.onlyIcon);
		if ("isQuiet" in $$props) $$invalidate(2, isQuiet = $$props.isQuiet);
		if ("isCompact" in $$props) $$invalidate(3, isCompact = $$props.isCompact);
		if ("emphasized" in $$props) $$invalidate(8, emphasized = $$props.emphasized);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		orientation,
		variants,
		dimension,
		onlyIcon,
		isQuiet,
		isCompact,
		emphasized,
		disabled,
		actionGroup,
		addChildClassName,
		styleCssText
	});

	$$self.$inject_state = $$props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$props.orientation);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("dimension" in $$props) $$invalidate(6, dimension = $$props.dimension);
		if ("onlyIcon" in $$props) $$invalidate(7, onlyIcon = $$props.onlyIcon);
		if ("isQuiet" in $$props) $$invalidate(2, isQuiet = $$props.isQuiet);
		if ("isCompact" in $$props) $$invalidate(3, isCompact = $$props.isCompact);
		if ("emphasized" in $$props) $$invalidate(8, emphasized = $$props.emphasized);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$props.disabled);
		if ("actionGroup" in $$props) $$invalidate(4, actionGroup = $$props.actionGroup);
		if ("styleCssText" in $$props) $$invalidate(5, styleCssText = $$props.styleCssText);
	};

	let styleCssText;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*variants, orientation, dimension*/ 67) {
			 $$invalidate(5, styleCssText = [
				variants === "justified" && orientation === "horizontal" && `width:var(--spectrum-global-dimension-${dimension}, var(--spectrum-alias-${dimension}))`,
				variants === "justified" && orientation === "vertical" && `height:var(--spectrum-global-dimension-${dimension}, var(--spectrum-alias-${dimension}))`
			].filter(Boolean).join(" "));
		}
	};

	return [
		orientation,
		variants,
		isQuiet,
		isCompact,
		actionGroup,
		styleCssText,
		dimension,
		onlyIcon,
		emphasized,
		disabled,
		$$scope,
		slots,
		div_binding
	];
}

class ActionGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			orientation: 0,
			variants: 1,
			dimension: 6,
			onlyIcon: 7,
			isQuiet: 2,
			isCompact: 3,
			emphasized: 8,
			disabled: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ActionGroup",
			options,
			id: create_fragment.name
		});
	}

	get orientation() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orientation(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variants() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variants(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dimension() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dimension(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onlyIcon() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onlyIcon(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isCompact() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isCompact(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get emphasized() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set emphasized(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<ActionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<ActionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/showcase/showcase.svelte generated by Svelte v3.29.4 */

const { console: console_1 } = globals;
const file$1 = "src/components/showcase/showcase.svelte";

// (67:8) <Button           exterior="action"           isQuiet           isSelected={showWay === 'light-scene'}           on:click={() => {             showWay = 'light-scene';           }}>
function create_default_slot_5(ctx) {
	let iconselection;
	let current;
	iconselection = new Selection({ $$inline: true });

	const block = {
		c: function create() {
			create_component(iconselection.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconselection.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconselection, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconselection.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconselection.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconselection, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(67:8) <Button           exterior=\\\"action\\\"           isQuiet           isSelected={showWay === 'light-scene'}           on:click={() => {             showWay = 'light-scene';           }}>",
		ctx
	});

	return block;
}

// (76:8) <Button           exterior="action"           isQuiet           isSelected={showWay === 'dark-scene'}           on:click={() => {             showWay = 'dark-scene';           }}>
function create_default_slot_4(ctx) {
	let iconloupeview;
	let current;
	iconloupeview = new LoupeView({ $$inline: true });

	const block = {
		c: function create() {
			create_component(iconloupeview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconloupeview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconloupeview, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconloupeview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconloupeview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconloupeview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(76:8) <Button           exterior=\\\"action\\\"           isQuiet           isSelected={showWay === 'dark-scene'}           on:click={() => {             showWay = 'dark-scene';           }}>",
		ctx
	});

	return block;
}

// (85:8) <Button           exterior="action"           isQuiet           isSelected={showWay === 'transparency-scene'}           on:click={() => {             showWay = 'transparency-scene';           }}>
function create_default_slot_3(ctx) {
	let icontransparency;
	let current;
	icontransparency = new Transparency({ $$inline: true });

	const block = {
		c: function create() {
			create_component(icontransparency.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icontransparency.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icontransparency, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icontransparency.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icontransparency.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icontransparency, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(85:8) <Button           exterior=\\\"action\\\"           isQuiet           isSelected={showWay === 'transparency-scene'}           on:click={() => {             showWay = 'transparency-scene';           }}>",
		ctx
	});

	return block;
}

// (66:6) <ActionGroup isCompact onlyIcon>
function create_default_slot_2(ctx) {
	let button0;
	let t0;
	let button1;
	let t1;
	let button2;
	let current;

	button0 = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				isSelected: /*showWay*/ ctx[2] === "light-scene",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[5]);

	button1 = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				isSelected: /*showWay*/ ctx[2] === "dark-scene",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler_1*/ ctx[6]);

	button2 = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				isSelected: /*showWay*/ ctx[2] === "transparency-scene",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button2.$on("click", /*click_handler_2*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			create_component(button2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(button1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(button2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(button1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(button2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};
			if (dirty & /*showWay*/ 4) button0_changes.isSelected = /*showWay*/ ctx[2] === "light-scene";

			if (dirty & /*$$scope*/ 256) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*showWay*/ 4) button1_changes.isSelected = /*showWay*/ ctx[2] === "dark-scene";

			if (dirty & /*$$scope*/ 256) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};
			if (dirty & /*showWay*/ 4) button2_changes.isSelected = /*showWay*/ ctx[2] === "transparency-scene";

			if (dirty & /*$$scope*/ 256) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(button1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(button2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(66:6) <ActionGroup isCompact onlyIcon>",
		ctx
	});

	return block;
}

// (98:8) <ButtonIconWrap onlyIcon>
function create_default_slot_1(ctx) {
	let iconcopy;
	let current;
	iconcopy = new Copy({ $$inline: true });

	const block = {
		c: function create() {
			create_component(iconcopy.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcopy.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcopy, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcopy.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcopy.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcopy, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(98:8) <ButtonIconWrap onlyIcon>",
		ctx
	});

	return block;
}

// (97:6) <Button exterior="action" on:click={copyCode} isQuiet>
function create_default_slot(ctx) {
	let buttoniconwrap;
	let current;

	buttoniconwrap = new ButtonIconWrap({
			props: {
				onlyIcon: true,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(buttoniconwrap.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(buttoniconwrap.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(buttoniconwrap, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const buttoniconwrap_changes = {};

			if (dirty & /*$$scope*/ 256) {
				buttoniconwrap_changes.$$scope = { dirty, ctx };
			}

			buttoniconwrap.$set(buttoniconwrap_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(buttoniconwrap.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(buttoniconwrap.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(buttoniconwrap, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(97:6) <Button exterior=\\\"action\\\" on:click={copyCode} isQuiet>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div4;
	let div2;
	let div0;
	let actiongroup;
	let t0;
	let div1;
	let button;
	let t1;
	let div3;
	let t2;
	let code_1;
	let current;

	actiongroup = new ActionGroup({
			props: {
				isCompact: true,
				onlyIcon: true,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button = new Button({
			props: {
				exterior: "action",
				isQuiet: true,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*copyCode*/ ctx[3]);
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	code_1 = new Code({
			props: {
				language: /*language*/ ctx[0],
				code: /*code*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div4 = element("div");
			div2 = element("div");
			div0 = element("div");
			create_component(actiongroup.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(button.$$.fragment);
			t1 = space();
			div3 = element("div");
			if (default_slot) default_slot.c();
			t2 = space();
			create_component(code_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(actiongroup.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(button.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			if (default_slot) default_slot.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			claim_component(code_1.$$.fragment, div4_nodes);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "button-group svelte-1sewt4b");
			add_location(div0, file$1, 64, 4, 4053);
			attr_dev(div1, "class", "button-group svelte-1sewt4b");
			add_location(div1, file$1, 95, 4, 4878);
			attr_dev(div2, "class", "showcase-toolbar svelte-1sewt4b");
			add_location(div2, file$1, 63, 2, 4018);
			attr_dev(div3, "class", "showcase svelte-1sewt4b");
			toggle_class(div3, "light-scene", /*showWay*/ ctx[2] === "light-scene");
			toggle_class(div3, "dark-scene", /*showWay*/ ctx[2] === "dark-scene");
			toggle_class(div3, "transparency", /*showWay*/ ctx[2] === "transparency-scene");
			add_location(div3, file$1, 103, 2, 5087);
			attr_dev(div4, "class", "showcase-wrap svelte-1sewt4b");
			add_location(div4, file$1, 62, 0, 3988);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div2);
			append_dev(div2, div0);
			mount_component(actiongroup, div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			mount_component(button, div1, null);
			append_dev(div4, t1);
			append_dev(div4, div3);

			if (default_slot) {
				default_slot.m(div3, null);
			}

			append_dev(div4, t2);
			mount_component(code_1, div4, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const actiongroup_changes = {};

			if (dirty & /*$$scope, showWay*/ 260) {
				actiongroup_changes.$$scope = { dirty, ctx };
			}

			actiongroup.$set(actiongroup_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (dirty & /*showWay*/ 4) {
				toggle_class(div3, "light-scene", /*showWay*/ ctx[2] === "light-scene");
			}

			if (dirty & /*showWay*/ 4) {
				toggle_class(div3, "dark-scene", /*showWay*/ ctx[2] === "dark-scene");
			}

			if (dirty & /*showWay*/ 4) {
				toggle_class(div3, "transparency", /*showWay*/ ctx[2] === "transparency-scene");
			}

			const code_1_changes = {};
			if (dirty & /*language*/ 1) code_1_changes.language = /*language*/ ctx[0];
			if (dirty & /*code*/ 2) code_1_changes.code = /*code*/ ctx[1];
			code_1.$set(code_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(actiongroup.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(default_slot, local);
			transition_in(code_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(actiongroup.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(code_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_component(actiongroup);
			destroy_component(button);
			if (default_slot) default_slot.d(detaching);
			destroy_component(code_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Showcase", slots, ['default']);
	let showWay = "light-scene";
	let { language = "js" } = $$props;
	let { code = "" } = $$props;

	async function copyCode(t, c) {
		if (navigator.clipboard) {
			try {
				await navigator.clipboard.writeText(code);
				console.log("Page URL copied to clipboard!");
			} catch(err) {
				console.error("Failed to copy: ", err);
			}
		}
	}

	const writable_props = ["language", "code"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Showcase> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(2, showWay = "light-scene");
	};

	const click_handler_1 = () => {
		$$invalidate(2, showWay = "dark-scene");
	};

	const click_handler_2 = () => {
		$$invalidate(2, showWay = "transparency-scene");
	};

	$$self.$$set = $$props => {
		if ("language" in $$props) $$invalidate(0, language = $$props.language);
		if ("code" in $$props) $$invalidate(1, code = $$props.code);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		ActionGroup,
		Button,
		ButtonIconWrap,
		IconSelection: Selection,
		IconTransparency: Transparency,
		IconLoupeView: LoupeView,
		IconCopy: Copy,
		Code,
		showWay,
		language,
		code,
		copyCode
	});

	$$self.$inject_state = $$props => {
		if ("showWay" in $$props) $$invalidate(2, showWay = $$props.showWay);
		if ("language" in $$props) $$invalidate(0, language = $$props.language);
		if ("code" in $$props) $$invalidate(1, code = $$props.code);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		language,
		code,
		showWay,
		copyCode,
		slots,
		click_handler,
		click_handler_1,
		click_handler_2,
		$$scope
	];
}

class Showcase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { language: 0, code: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Showcase",
			options,
			id: create_fragment$1.name
		});
	}

	get language() {
		throw new Error("<Showcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set language(value) {
		throw new Error("<Showcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get code() {
		throw new Error("<Showcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set code(value) {
		throw new Error("<Showcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/docs/basic/button/usage/index.svelte generated by Svelte v3.29.4 */
const file$2 = "src/routes/docs/basic/button/usage/index.svelte";

// (18:2) <TypographyHeading>
function create_default_slot_2$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("速览");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "速览");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(18:2) <TypographyHeading>",
		ctx
	});

	return block;
}

// (23:2) <Button>
function create_default_slot_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Start");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Start");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(23:2) <Button>",
		ctx
	});

	return block;
}

// (22:0) <Showcase code={previewCode}>
function create_default_slot$1(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 2) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(22:0) <Showcase code={previewCode}>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let typographyheading;
	let t0;
	let typographybody;
	let t1;
	let showcase;
	let current;

	typographyheading = new TypographyHeading({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	typographybody = new TypographyBody({ $$inline: true });

	showcase = new Showcase({
			props: {
				code: /*previewCode*/ ctx[0],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(typographyheading.$$.fragment);
			t0 = space();
			create_component(typographybody.$$.fragment);
			t1 = space();
			create_component(showcase.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(typographyheading.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(typographybody.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(showcase.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "section-title svelte-1umzae0");
			add_location(div, file$2, 16, 0, 765);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(typographyheading, div, null);
			append_dev(div, t0);
			mount_component(typographybody, div, null);
			insert_dev(target, t1, anchor);
			mount_component(showcase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const typographyheading_changes = {};

			if (dirty & /*$$scope*/ 2) {
				typographyheading_changes.$$scope = { dirty, ctx };
			}

			typographyheading.$set(typographyheading_changes);
			const showcase_changes = {};

			if (dirty & /*$$scope*/ 2) {
				showcase_changes.$$scope = { dirty, ctx };
			}

			showcase.$set(showcase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typographyheading.$$.fragment, local);
			transition_in(typographybody.$$.fragment, local);
			transition_in(showcase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typographyheading.$$.fragment, local);
			transition_out(typographybody.$$.fragment, local);
			transition_out(showcase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(typographyheading);
			destroy_component(typographybody);
			if (detaching) detach_dev(t1);
			destroy_component(showcase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Usage", slots, []);

	let previewCode = `\<script\>
  import { Button } from "@rubus/rubus"; 
 \</script\>

  <Button>Start</Button>`;

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Usage> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		TypographyHeading,
		TypographyBody,
		Button,
		Showcase,
		previewCode
	});

	$$self.$inject_state = $$props => {
		if ("previewCode" in $$props) $$invalidate(0, previewCode = $$props.previewCode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [previewCode];
}

class Usage extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Usage",
			options,
			id: create_fragment$2.name
		});
	}
}

export default Usage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYzBjNWE2ZWUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL0FjdGlvbkdyb3VwL0FjdGlvbkdyb3VwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Nob3djYXNlL3Nob3djYXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9iYXNpYy9idXR0b24vdXNhZ2UvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBvcmllbnRhdGlvblxuICAgKiBAdHlwZSB7XCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJ9W29yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB2YXJpYW50cyBvZiBhY3Rpb24gZ3JvdXBcbiAgICogQHR5cGUge1wiZ2VuZXJhbFwiIHwgXCJqdXN0aWZpZWRcIn1bdmFyaWFudHMgPSBcImp1c3RpZmllZFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YXJpYW50cyA9IFwiZ2VuZXJhbFwiO1xuXG4gIC8qKlxuICAgKiBXaGVuIHZhcmlhbnRzPT09XCJqdXN0aWZpZWRcIiwgc2V0IGl0cyBkaW1lbnNpb27jgIJcbiAgICogQHR5cGUge0RpbWVuc2lvbn1bZGltZW5zaW9uID0gXCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgZGltZW5zaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogSXMgaXQgYSBvbmx5IGljb24gb2YgYWN0aW9uIGdyb3VwXG4gICAqIEB0eXBlIHtib29sZWFufVtvbmx5SWNvbj1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgb25seUljb24gPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgYWN0aW9uIGdyb3VwIGlzIGluIHF1aWV0IHN0YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVtpc1F1aWV0PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1F1aWV0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGFjdGlvbiBncm91cCBpcyBpbiBjb21wYWN0IHN0YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVtpc0NvbXBhY3Q9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzQ29tcGFjdCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBlbXBoYXNpemVkIHN0YXR1cyBvZiBidXR0b24gZ3JvdXBcbiAgICogQHR5cGUgeyBib29sZWFuIH0gW2VtcGhhc2l6ZWQ9IGZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBlbXBoYXNpemVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERpc2FibGUgYWxsIGFjdGlvbiBidXR0b25zXG4gICAqIEB0eXBlIHtib29sZWFufVtkaXNhYmxlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcblxuICBsZXQgYWN0aW9uR3JvdXA7XG4gIGZ1bmN0aW9uIGFkZENoaWxkQ2xhc3NOYW1lKCkge1xuICAgIGxldCBidXR0b25DbGFzc05hbWUgPSBbXG4gICAgICBcIiBzcGVjdHJ1bS1BY3Rpb25Hcm91cC1pdGVtXCIsXG4gICAgICBpc1F1aWV0ICYmIFwic3BlY3RydW0tQWN0aW9uQnV0dG9uLS1xdWlldFwiLFxuICAgICAgZW1waGFzaXplZCAmJiBcInNwZWN0cnVtLUFjdGlvbkJ1dHRvbi0tZW1waGFzaXplZFwiLFxuICAgIF1cbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5qb2luKFwiIFwiKTtcbiAgICBpZiAoYWN0aW9uR3JvdXApIHtcbiAgICAgIGNvbnN0IGJ1dHRvbkl0ZW0gPSBhY3Rpb25Hcm91cC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic3BlY3RydW0tQWN0aW9uQnV0dG9uXCIpO1xuICAgICAgaWYgKGJ1dHRvbkl0ZW0ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBidXR0b25JdGVtLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgYnV0dG9uSXRlbVtpbmRleF0uc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgZGlzYWJsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidXR0b25JdGVtW2luZGV4XS5jbGFzc05hbWUgPSBidXR0b25JdGVtW2luZGV4XS5jbGFzc05hbWUgKyBidXR0b25DbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbmx5SWNvbiAmJiB2YXJpYW50cyA9PT0gXCJnZW5lcmFsXCIpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uV3JhcEl0ZW0gPSBhY3Rpb25Hcm91cC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic3BlY3RydW0tQnV0dG9uLXdyYXBcIik7XG4gICAgICAgIGlmIChidXR0b25XcmFwSXRlbS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYnV0dG9uV3JhcEl0ZW0ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBidXR0b25XcmFwSXRlbVtpbmRleF0uY2xhc3NOYW1lID0gYnV0dG9uV3JhcEl0ZW1baW5kZXhdLmNsYXNzTmFtZSArIFwiIHJ1YnVzLWJ1dHRvbi13cmFwXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGFkZENoaWxkQ2xhc3NOYW1lKCk7XG4gIH0pO1xuXG4gICQ6IHN0eWxlQ3NzVGV4dCA9IFtcbiAgICB2YXJpYW50cyA9PT0gXCJqdXN0aWZpZWRcIiAmJlxuICAgICAgb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICYmXG4gICAgICBgd2lkdGg6dmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi0ke2RpbWVuc2lvbn0sIHZhcigtLXNwZWN0cnVtLWFsaWFzLSR7ZGltZW5zaW9ufSkpYCxcbiAgICB2YXJpYW50cyA9PT0gXCJqdXN0aWZpZWRcIiAmJlxuICAgICAgb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiAmJlxuICAgICAgYGhlaWdodDp2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLSR7ZGltZW5zaW9ufSwgdmFyKC0tc3BlY3RydW0tYWxpYXMtJHtkaW1lbnNpb259KSlgLFxuICBdXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiIFwiKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIGNsYXNzPVwic3BlY3RydW0tQWN0aW9uR3JvdXBcIlxuICBzdHlsZT17c3R5bGVDc3NUZXh0fVxuICBjbGFzczpzcGVjdHJ1bS1BY3Rpb25Hcm91cC0tanVzdGlmaWVkPXt2YXJpYW50cyA9PT0gJ2p1c3RpZmllZCd9XG4gIGNsYXNzOnNwZWN0cnVtLUFjdGlvbkdyb3VwLS12ZXJ0aWNhbD17b3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCd9XG4gIGNsYXNzOnNwZWN0cnVtLUFjdGlvbkdyb3VwLS1xdWlldD17aXNRdWlldH1cbiAgY2xhc3M6c3BlY3RydW0tQWN0aW9uR3JvdXAtLWNvbXBhY3Q9e2lzQ29tcGFjdH1cbiAgYmluZDp0aGlzPXthY3Rpb25Hcm91cH0+XG4gIDxzbG90IC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEFjdGlvbkdyb3VwLCBCdXR0b24sIEJ1dHRvbkljb25XcmFwIH0gZnJvbSBcIkBydWJ1cy9ydWJ1cy9zcmNcIjtcbiAgaW1wb3J0IHsgSWNvblNlbGVjdGlvbiwgSWNvblRyYW5zcGFyZW5jeSwgSWNvbkxvdXBlVmlldywgSWNvbkNvcHkgfSBmcm9tIFwiQHJ1YnVzL3N2ZWx0ZS1zcGVjdHJ1bS1pY29ucy13b3JrZmxvd1wiO1xuICBpbXBvcnQgQ29kZSBmcm9tIFwiLi4vY29kZVwiO1xuXG4gIGxldCBzaG93V2F5ID0gXCJsaWdodC1zY2VuZVwiO1xuXG4gIGV4cG9ydCBsZXQgbGFuZ3VhZ2UgPSBcImpzXCI7XG4gIGV4cG9ydCBsZXQgY29kZSA9IFwiXCI7XG5cbiAgYXN5bmMgZnVuY3Rpb24gY29weUNvZGUodCwgYykge1xuICAgIGlmIChuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb2RlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJQYWdlIFVSTCBjb3BpZWQgdG8gY2xpcGJvYXJkIVwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvcHk6IFwiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnNob3djYXNlIHtcbiAgICBwYWRkaW5nOiAxZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW46IDAuNWVtIDA7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgYm9yZGVyLXJhZGl1czogMC4zZW07XG4gIH1cbiAgLnRyYW5zcGFyZW5jeSB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItZ3JheS0zMDApIDI1JSwgdHJhbnNwYXJlbnQgMjUlKSxcbiAgICAgIGxpbmVhci1ncmFkaWVudCgxMzVkZWcsIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTMwMCkgMjUlLCB0cmFuc3BhcmVudCAyNSUpLFxuICAgICAgbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCB0cmFuc3BhcmVudCA3NSUsIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTMwMCkgNzUlKSxcbiAgICAgIGxpbmVhci1ncmFkaWVudCgxMzVkZWcsIHRyYW5zcGFyZW50IDc1JSwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktMzAwKSA3NSUpO1xuICAgIGJhY2tncm91bmQtc2l6ZTogMjBweCAyMHB4O1xuICAgIGJhY2tncm91bmQtcG9zaXRpb246IDBweCAwcHgsIDEwcHggMHB4LCAxMHB4IC0xMHB4LCAwcHggMTBweDtcbiAgfVxuICAuc2hvd2Nhc2Utd3JhcCB7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTIwMCk7XG4gICAgcGFkZGluZzogMTBweCAxMHB4IDEwcHggMjBweDtcbiAgICBib3JkZXItcmFkaXVzOiAwLjNlbTtcbiAgfVxuXG4gIC5zaG93Y2FzZS10b29sYmFyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG4gIC5idXR0b24tZ3JvdXAge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gIH1cbiAgLmxpZ2h0LXNjZW5lIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLWdyYXktNzUpO1xuICB9XG4gIC5kYXJrLXNjZW5lIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLWdyYXktOTAwKTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInNob3djYXNlLXdyYXBcIj5cbiAgPGRpdiBjbGFzcz1cInNob3djYXNlLXRvb2xiYXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uLWdyb3VwXCI+XG4gICAgICA8QWN0aW9uR3JvdXAgaXNDb21wYWN0IG9ubHlJY29uPlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgZXh0ZXJpb3I9XCJhY3Rpb25cIlxuICAgICAgICAgIGlzUXVpZXRcbiAgICAgICAgICBpc1NlbGVjdGVkPXtzaG93V2F5ID09PSAnbGlnaHQtc2NlbmUnfVxuICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICBzaG93V2F5ID0gJ2xpZ2h0LXNjZW5lJztcbiAgICAgICAgICB9fT5cbiAgICAgICAgICA8SWNvblNlbGVjdGlvbiAvPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIGV4dGVyaW9yPVwiYWN0aW9uXCJcbiAgICAgICAgICBpc1F1aWV0XG4gICAgICAgICAgaXNTZWxlY3RlZD17c2hvd1dheSA9PT0gJ2Rhcmstc2NlbmUnfVxuICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICBzaG93V2F5ID0gJ2Rhcmstc2NlbmUnO1xuICAgICAgICAgIH19PlxuICAgICAgICAgIDxJY29uTG91cGVWaWV3IC8+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgZXh0ZXJpb3I9XCJhY3Rpb25cIlxuICAgICAgICAgIGlzUXVpZXRcbiAgICAgICAgICBpc1NlbGVjdGVkPXtzaG93V2F5ID09PSAndHJhbnNwYXJlbmN5LXNjZW5lJ31cbiAgICAgICAgICBvbjpjbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgc2hvd1dheSA9ICd0cmFuc3BhcmVuY3ktc2NlbmUnO1xuICAgICAgICAgIH19PlxuICAgICAgICAgIDxJY29uVHJhbnNwYXJlbmN5IC8+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgPC9BY3Rpb25Hcm91cD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uLWdyb3VwXCI+XG4gICAgICA8QnV0dG9uIGV4dGVyaW9yPVwiYWN0aW9uXCIgb246Y2xpY2s9e2NvcHlDb2RlfSBpc1F1aWV0PlxuICAgICAgICA8QnV0dG9uSWNvbldyYXAgb25seUljb24+XG4gICAgICAgICAgPEljb25Db3B5IC8+XG4gICAgICAgIDwvQnV0dG9uSWNvbldyYXA+XG4gICAgICA8L0J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXZcbiAgICBjbGFzcz1cInNob3djYXNlXCJcbiAgICBjbGFzczpsaWdodC1zY2VuZT17c2hvd1dheSA9PT0gJ2xpZ2h0LXNjZW5lJ31cbiAgICBjbGFzczpkYXJrLXNjZW5lPXtzaG93V2F5ID09PSAnZGFyay1zY2VuZSd9XG4gICAgY2xhc3M6dHJhbnNwYXJlbmN5PXtzaG93V2F5ID09PSAndHJhbnNwYXJlbmN5LXNjZW5lJ30+XG4gICAgPHNsb3QgLz5cbiAgPC9kaXY+XG4gIDxDb2RlIHtsYW5ndWFnZX0ge2NvZGV9IC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IFR5cG9ncmFwaHlIZWFkaW5nLCBUeXBvZ3JhcGh5Qm9keSwgQnV0dG9uIH0gZnJvbSBcIkBydWJ1cy9ydWJ1cy9zcmNcIjtcbiAgaW1wb3J0IHsgU2hvd2Nhc2UgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vY29tcG9uZW50c1wiO1xuICBsZXQgcHJldmlld0NvZGUgPSBgXFw8c2NyaXB0XFw+XG4gIGltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCJAcnVidXMvcnVidXNcIjsgXG4gXFw8L3NjcmlwdFxcPlxuXG4gIDxCdXR0b24+U3RhcnQ8L0J1dHRvbj5gO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnNlY3Rpb24tdGl0bGUge1xuICAgIG1hcmdpbjogMTZweCAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwic2VjdGlvbi10aXRsZVwiPlxuICA8VHlwb2dyYXBoeUhlYWRpbmc+6YCf6KeIPC9UeXBvZ3JhcGh5SGVhZGluZz5cbiAgPFR5cG9ncmFwaHlCb2R5IC8+XG48L2Rpdj5cblxuPFNob3djYXNlIGNvZGU9e3ByZXZpZXdDb2RlfT5cbiAgPEJ1dHRvbj5TdGFydDwvQnV0dG9uPlxuPC9TaG93Y2FzZT5cbiJdLCJu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Ozs7O3VFQVN6QixHQUFPLFFBQUssWUFBWTs7Ozs7Ozs7dUVBU3hCLEdBQU8sUUFBSyxvQkFBb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQVNaLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBUzNCLEdBQU8sUUFBSyxhQUFhO2dEQUMxQixHQUFPLFFBQUssWUFBWTtrREFDdEIsR0FBTyxRQUFLLG9CQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBRmpDLEdBQU8sUUFBSyxhQUFhOzs7O2lEQUMxQixHQUFPLFFBQUssWUFBWTs7OzttREFDdEIsR0FBTyxRQUFLLG9CQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXRHbEQsT0FBTyxHQUFHLGFBQWE7T0FFaEIsUUFBUSxHQUFHLElBQUk7T0FDZixJQUFJLEdBQUcsRUFBRTs7Z0JBRUwsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDO01BQ3RCLFNBQVMsQ0FBQyxTQUFTOztVQUViLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUk7SUFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQywrQkFBK0I7V0FDcEMsR0FBRztJQUNWLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsR0FBRzs7Ozs7Ozs7Ozs7O2tCQXVEakMsT0FBTyxHQUFHLGFBQWE7Ozs7a0JBU3ZCLE9BQU8sR0FBRyxZQUFZOzs7O2tCQVN0QixPQUFPLEdBQUcsb0JBQW9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJDcEUxQixHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBbEJyQixXQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
