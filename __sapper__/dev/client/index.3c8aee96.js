import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, P as assign, Q as compute_rest_props, v as validate_slots, o as onMount, z as afterUpdate, R as exclude_internal_props, T as svg_element, c as claim_element, a as children, f as detach_dev, U as set_svg_attributes, h as add_location, j as insert_dev, V as get_spread_update, n as noop, G as binding_callbacks, g as attr_dev, W as createCommonjsModule, X as commonjsGlobal, Y as index, Z as onDestroy, A as current_component, B as getEventsAction, L as empty, M as group_outros, u as transition_out, N as check_outros, r as transition_in, x as create_slot, m as create_component, p as claim_component, q as mount_component, w as destroy_component, t as text, b as claim_text, e as element, C as space, D as claim_space, _ as add_render_callback, $ as set_attributes, E as toggle_class, k as append_dev, a0 as listen_dev, F as action_destroyer, a1 as prop_dev, y as update_slot, a2 as run_all, l as set_data_dev, a3 as AlertMedium, a4 as add_resize_listener, K as validate_each_argument, a5 as getContext, I as validate_store, J as component_subscribe, a6 as globals, O as destroy_each, a7 as query_selector_all } from './client.54c89fd8.js';

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/CheckmarkSmall.svelte generated by Svelte v3.29.4 */
const file = "node_modules/@rubus/svelte-spectrum-icons-ui/src/CheckmarkSmall.svelte";

// (51:26) 
function create_if_block_1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M3.788 9A.999.999 0 013 8.615l-2.288-3a1 1 0 111.576-1.23l1.5 1.991 3.924-4.991a1 1 0 111.576 1.23l-4.712\n    6A.999.999 0 013.788 9z");
			add_location(path_1, file, 51, 4, 1206);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(51:26) ",
		ctx
	});

	return block;
}

// (45:2) {#if scale === 'L'}
function create_if_block(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M4.5 11a.999.999 0 01-.788-.385l-3-4a1 1 0 111.576-1.23L4.5 8.376l5.212-6.99a1 1 0 111.576 1.23l-6 8A.999.999 0\n    014.5 11z");
			add_location(path_1, file, 45, 4, 1009);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(45:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file, 37, 0, 813);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CheckmarkSmall", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "CheckmarkSmall" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class CheckmarkSmall extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CheckmarkSmall",
			options,
			id: create_fragment.name
		});
	}

	get scale() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<CheckmarkSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<CheckmarkSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/DashSmall.svelte generated by Svelte v3.29.4 */
const file$1 = "node_modules/@rubus/svelte-spectrum-icons-ui/src/DashSmall.svelte";

// (48:26) 
function create_if_block_1$1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M8 4H2a1 1 0 000 2h6a1 1 0 000-2z");
			add_location(path_1, file$1, 48, 4, 1115);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(48:26) ",
		ctx
	});

	return block;
}

// (45:2) {#if scale === 'L'}
function create_if_block$1(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M10.99 5H1.01a1 1 0 000 2h9.98a1 1 0 100-2z");
			add_location(path_1, file$1, 45, 4, 1004);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(45:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$1;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$1, 37, 0, 808);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DashSmall", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "DashSmall" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class DashSmall extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DashSmall",
			options,
			id: create_fragment$1.name
		});
	}

	get scale() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<DashSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<DashSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/HelpSmall.svelte generated by Svelte v3.29.4 */
const file$2 = "node_modules/@rubus/svelte-spectrum-icons-ui/src/HelpSmall.svelte";

// (52:26) 
function create_if_block_1$2(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M7 .778A6.222 6.222 0 1013.222 7 6.222 6.222 0 007 .778zm.018 10.452a1.046 1.046 0 11-.08-2.091q.04-.002.08\n      0a1.019 1.019 0 011.087.946q.003.046.002.092a1.004 1.004 0 01-1.09\n      1.053zm1.387-4.985l-.078.078c-.307.322-.655.687-.655.913a1.078 1.078 0 00.14.525l.056.108-.044.167a.24.24 0\n      01-.221.147H6.56a.338.338 0 01-.252-.091 1.6 1.6 0 01-.329-.982 2.378 2.378 0\n      01.864-1.61c.078-.086.156-.164.224-.234.245-.252.395-.416.395-.59 0-.119 0-.483-.695-.483a2.3 2.3 0\n      00-1.229.357.233.233 0 01-.254-.008l-.092-.066-.022-.175V3.174a.342.342 0 01.156-.319A3.216 3.216 0 017\n      2.425a1.985 1.985 0 012.14 2.051 2.385 2.385 0 01-.735 1.769z");
			add_location(path_1, file$2, 52, 4, 1702);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(52:26) ",
		ctx
	});

	return block;
}

// (43:2) {#if scale === 'L'}
function create_if_block$2(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm.023 13.438a1.345 1.345 0 01-.104-2.688q.052-.002.104 0a1.31 1.31 0 011.397\n      1.217q.004.059.003.118a1.291 1.291 0 01-1.4 1.353zm1.783-6.409l-.1.1c-.395.414-.842.884-.842 1.175a1.386 1.386 0\n      00.179.674l.073.139-.057.215a.308.308 0 01-.284.189H8.436a.434.434 0 01-.325-.117 2.056 2.056 0\n      01-.422-1.262A3.058 3.058 0 018.8 7.071c.1-.11.2-.21.288-.3.314-.325.507-.535.507-.758 0-.154\n      0-.622-.893-.622a2.958 2.958 0 00-1.58.459.3.3 0 01-.327-.01l-.118-.085-.028-.225V4.081a.44.44 0 01.2-.41A4.135\n      4.135 0 019 3.119a2.552 2.552 0 012.751 2.636 3.067 3.067 0 01-.944 2.274z");
			add_location(path_1, file$2, 43, 4, 1002);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(43:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$2;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$2, 35, 0, 806);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("HelpSmall", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "HelpSmall" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class HelpSmall extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HelpSmall",
			options,
			id: create_fragment$2.name
		});
	}

	get scale() {
		throw new Error("<HelpSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<HelpSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<HelpSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<HelpSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<HelpSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<HelpSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<HelpSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<HelpSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<HelpSmall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<HelpSmall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/InfoMedium.svelte generated by Svelte v3.29.4 */
const file$3 = "node_modules/@rubus/svelte-spectrum-icons-ui/src/InfoMedium.svelte";

// (52:26) 
function create_if_block_1$3(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm-.15 2.15a1.359 1.359 0 011.431 1.283q.004.064.001.129A1.332 1.332 0 018.85\n    5.994a1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM11 13.5a.5.5 0 01-.5.5h-3a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5H8V9h-.5a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h2a.5.5 0 01.5.5V12h.5a.5.5 0 01.5.5z");
			add_location(path_1, file$3, 52, 4, 1414);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(52:26) ",
		ctx
	});

	return block;
}

// (45:2) {#if scale === 'L'}
function create_if_block$3(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm-.15 2.65a1.359 1.359 0 011.431 1.283q.004.064.001.129a1.332 1.332 0 01-1.432\n    1.432 1.353 1.353 0 01-1.432-1.433 1.359 1.359 0 011.304-1.412q.064-.002.128.001zM13.5 16a.5.5 0 01-.5.5H9a.5.5 0\n    01-.5-.5v-1a.5.5 0 01.5-.5h1v-4H9a.5.5 0 01-.5-.5V9a.5.5 0 01.5-.5h2.5a.5.5 0 01.5.5v5.5h1a.5.5 0 01.5.5z");
			add_location(path_1, file$3, 45, 4, 1005);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(45:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$3;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$3, 37, 0, 809);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InfoMedium", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "InfoMedium" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class InfoMedium extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InfoMedium",
			options,
			id: create_fragment$3.name
		});
	}

	get scale() {
		throw new Error("<InfoMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<InfoMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<InfoMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<InfoMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<InfoMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<InfoMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<InfoMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<InfoMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<InfoMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<InfoMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/svelte-spectrum-icons-ui/src/SuccessMedium.svelte generated by Svelte v3.29.4 */
const file$4 = "node_modules/@rubus/svelte-spectrum-icons-ui/src/SuccessMedium.svelte";

// (51:26) 
function create_if_block_1$4(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M9 1a8 8 0 108 8 8 8 0 00-8-8zm5.333 4.54l-6.324 8.13a.6.6 0 01-.437.23h-.037a.6.6 0 01-.425-.176l-3.893-3.9a.6.6\n    0 010-.849l.663-.663a.6.6 0 01.848 0L7.4 10.991l5.256-6.754a.6.6 0 01.843-.1l.728.566a.6.6 0 01.106.837z");
			add_location(path_1, file$4, 51, 4, 1277);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding_1*/ ctx[11](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding_1*/ ctx[11](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(51:26) ",
		ctx
	});

	return block;
}

// (45:2) {#if scale === 'L'}
function create_if_block$4(ctx) {
	let path_1;

	const block = {
		c: function create() {
			path_1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path_1 = claim_element(nodes, "path", { d: true }, 1);
			children(path_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path_1, "d", "M11 2a9 9 0 109 9 9 9 0 00-9-9zm5.638 5.609L10.1 15.652a.5.5 0 01-.742.038L5.086 11.5a.5.5 0\n    010-.707l.707-.707a.5.5 0 01.707 0L9.6 13.1l5.486-6.751a.5.5 0 01.7-.073l.776.631a.5.5 0 01.076.702z");
			add_location(path_1, file$4, 45, 4, 1008);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path_1, anchor);
			/*path_1_binding*/ ctx[10](path_1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path_1);
			/*path_1_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(45:2) {#if scale === 'L'}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let svg;
	let svg_width_value;
	let svg_height_value;
	let svg_class_value;

	function select_block_type(ctx, dirty) {
		if (/*scale*/ ctx[0] === "L") return create_if_block$4;
		if (/*scale*/ ctx[0] === "M") return create_if_block_1$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	let svg_levels = [
		{ "aria-label": /*ariaLabel*/ ctx[4] },
		/*$$restProps*/ ctx[9],
		{
			width: svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]
		},
		{
			height: svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]
		},
		{ fill: "currentColor" },
		{
			class: svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]
		}
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					"aria-label": true,
					width: true,
					height: true,
					fill: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$4, 37, 0, 812);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*ariaLabel*/ 16 && { "aria-label": /*ariaLabel*/ ctx[4] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				dirty & /*width, sw*/ 68 && svg_width_value !== (svg_width_value = /*width*/ ctx[2] || /*sw*/ ctx[6] || /*flag*/ ctx[8]) && { width: svg_width_value },
				dirty & /*height, sh*/ 136 && svg_height_value !== (svg_height_value = /*height*/ ctx[3] || /*sh*/ ctx[7] || /*flag*/ ctx[8]) && { height: svg_height_value },
				{ fill: "currentColor" },
				dirty & /*className*/ 2 && svg_class_value !== (svg_class_value = "spectrum-Icon " + /*className*/ ctx[1]) && { class: svg_class_value }
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = ["scale","className","width","height","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SuccessMedium", slots, []);
	let { scale = "M" } = $$props;
	let { className = "" } = $$props;
	let { width = "" } = $$props;
	let { height = "" } = $$props;
	let { ariaLabel = "SuccessMedium" } = $$props;
	let path;
	let sw;
	let sh;
	let flag = 14;

	onMount(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}
	});

	afterUpdate(() => {
		if (path) {
			$$invalidate(6, sw = path.getBoundingClientRect().width);
			$$invalidate(7, sh = path.getBoundingClientRect().height);
		}

		if (!scale || scale == "M") {
			let rootClassName = document && document.documentElement.className;

			if (rootClassName && rootClassName.indexOf("spectrum--large") != -1) {
				$$invalidate(0, scale = "L");
			} else {
				$$invalidate(0, scale = "M");
			}
		}
	});

	function path_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	function path_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			path = $$value;
			$$invalidate(5, path);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("scale" in $$new_props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$new_props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$new_props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$new_props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag
	});

	$$self.$inject_state = $$new_props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$new_props.scale);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(2, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
		if ("ariaLabel" in $$props) $$invalidate(4, ariaLabel = $$new_props.ariaLabel);
		if ("path" in $$props) $$invalidate(5, path = $$new_props.path);
		if ("sw" in $$props) $$invalidate(6, sw = $$new_props.sw);
		if ("sh" in $$props) $$invalidate(7, sh = $$new_props.sh);
		if ("flag" in $$props) $$invalidate(8, flag = $$new_props.flag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		scale,
		className,
		width,
		height,
		ariaLabel,
		path,
		sw,
		sh,
		flag,
		$$restProps,
		path_1_binding,
		path_1_binding_1
	];
}

class SuccessMedium extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			scale: 0,
			className: 1,
			width: 2,
			height: 3,
			ariaLabel: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SuccessMedium",
			options,
			id: create_fragment$4.name
		});
	}

	get scale() {
		throw new Error("<SuccessMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<SuccessMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get className() {
		throw new Error("<SuccessMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set className(value) {
		throw new Error("<SuccessMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<SuccessMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<SuccessMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<SuccessMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<SuccessMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<SuccessMedium>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<SuccessMedium>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var index_umd = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	 factory(exports) ;
}(commonjsGlobal, (function (exports) {
	/* eslint-disable no-undefined,no-param-reassign,no-shadow */

	/**
	 * Throttle execution of a function. Especially useful for rate limiting
	 * execution of handlers on events like resize and scroll.
	 *
	 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
	 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
	 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
	 *                                    the internal counter is reset).
	 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                    to `callback` when the throttled-function is executed.
	 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
	 *                                    schedule `callback` to execute after `delay` ms.
	 *
	 * @returns {Function}  A new, throttled, function.
	 */
	function throttle (delay, noTrailing, callback, debounceMode) {
	  /*
	   * After wrapper has stopped being called, this timeout ensures that
	   * `callback` is executed at the proper times in `throttle` and `end`
	   * debounce modes.
	   */
	  var timeoutID;
	  var cancelled = false; // Keep track of the last time `callback` was executed.

	  var lastExec = 0; // Function to clear existing timeout

	  function clearExistingTimeout() {
	    if (timeoutID) {
	      clearTimeout(timeoutID);
	    }
	  } // Function to cancel next exec


	  function cancel() {
	    clearExistingTimeout();
	    cancelled = true;
	  } // `noTrailing` defaults to falsy.


	  if (typeof noTrailing !== 'boolean') {
	    debounceMode = callback;
	    callback = noTrailing;
	    noTrailing = undefined;
	  }
	  /*
	   * The `wrapper` function encapsulates all of the throttling / debouncing
	   * functionality and when executed will limit the rate at which `callback`
	   * is executed.
	   */


	  function wrapper() {
	    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
	      arguments_[_key] = arguments[_key];
	    }

	    var self = this;
	    var elapsed = Date.now() - lastExec;

	    if (cancelled) {
	      return;
	    } // Execute `callback` and update the `lastExec` timestamp.


	    function exec() {
	      lastExec = Date.now();
	      callback.apply(self, arguments_);
	    }
	    /*
	     * If `debounceMode` is true (at begin) this is used to clear the flag
	     * to allow future `callback` executions.
	     */


	    function clear() {
	      timeoutID = undefined;
	    }

	    if (debounceMode && !timeoutID) {
	      /*
	       * Since `wrapper` is being called for the first time and
	       * `debounceMode` is true (at begin), execute `callback`.
	       */
	      exec();
	    }

	    clearExistingTimeout();

	    if (debounceMode === undefined && elapsed > delay) {
	      /*
	       * In throttle mode, if `delay` time has been exceeded, execute
	       * `callback`.
	       */
	      exec();
	    } else if (noTrailing !== true) {
	      /*
	       * In trailing throttle mode, since `delay` time has not been
	       * exceeded, schedule `callback` to execute `delay` ms after most
	       * recent execution.
	       *
	       * If `debounceMode` is true (at begin), schedule `clear` to execute
	       * after `delay` ms.
	       *
	       * If `debounceMode` is false (at end), schedule `callback` to
	       * execute after `delay` ms.
	       */
	      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
	    }
	  }

	  wrapper.cancel = cancel; // Return the wrapper function.

	  return wrapper;
	}

	/* eslint-disable no-undefined */
	/**
	 * Debounce execution of a function. Debouncing, unlike throttling,
	 * guarantees that a function is only executed a single time, either at the
	 * very beginning of a series of calls, or at the very end.
	 *
	 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
	 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
	 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
	 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                  to `callback` when the debounced-function is executed.
	 *
	 * @returns {Function} A new, debounced function.
	 */

	function debounce (delay, atBegin, callback) {
	  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
	}

	exports.debounce = debounce;
	exports.throttle = throttle;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

});

/* node_modules/@rubus/rubus/src/packages/Checkbox/Checkbox.svelte generated by Svelte v3.29.4 */
const file$5 = "node_modules/@rubus/rubus/src/packages/Checkbox/Checkbox.svelte";

// (144:0) {:else}
function create_else_block(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_4(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_3(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let label_levels = [
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				name: true,
				disabled: true,
				value: true
			});

			t0 = claim_space(label_nodes);
			span0 = claim_element(label_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (if_block0) if_block0.l(span0_nodes);
			t1 = claim_space(span0_nodes);
			if (if_block1) if_block1.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(label_nodes);
			span1 = claim_element(label_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			if (default_slot) default_slot.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "spectrum-Checkbox-input");
			attr_dev(input, "id", /*id*/ ctx[7]);
			attr_dev(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.__value = /*value*/ ctx[8];
			input.value = input.__value;
			if (/*checked*/ ctx[0] === void 0 || /*indeterminate*/ ctx[1] === void 0) add_render_callback(() => /*input_change_handler*/ ctx[19].call(input));
			add_location(input, file$5, 152, 4, 4279);
			attr_dev(span0, "class", "spectrum-Checkbox-box");
			add_location(span0, file$5, 162, 4, 4479);
			attr_dev(span1, "class", "spectrum-Checkbox-label");
			add_location(span1, file$5, 182, 4, 5070);
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
			add_location(label, file$5, 144, 2, 4021);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding_1*/ ctx[18](input);
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			append_dev(label, t0);
			append_dev(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append_dev(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append_dev(label, t2);
			append_dev(label, span1);

			if (default_slot) {
				default_slot.m(span1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[19]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[13].call(null, label))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr_dev(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr_dev(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*value*/ 256) {
				prop_dev(input, "__value", /*value*/ ctx[8]);
				input.value = input.__value;
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*indeterminate*/ 2) {
				input.indeterminate = /*indeterminate*/ ctx[1];
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding_1*/ ctx[18](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(144:0) {:else}",
		ctx
	});

	return block;
}

// (101:0) {#if readonly}
function create_if_block$5(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let current;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_2(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_1$5(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	let label_levels = [
		{ title: /*title*/ ctx[9] },
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { title: true, class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				name: true,
				disabled: true,
				value: true,
				checked: true,
				indeterminate: true
			});

			t0 = claim_space(label_nodes);
			span0 = claim_element(label_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (if_block0) if_block0.l(span0_nodes);
			t1 = claim_space(span0_nodes);
			if (if_block1) if_block1.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(label_nodes);
			span1 = claim_element(label_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			if (default_slot_or_fallback) default_slot_or_fallback.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "spectrum-Checkbox-input");
			attr_dev(input, "id", /*id*/ ctx[7]);
			attr_dev(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.value = /*value*/ ctx[8];
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			add_location(input, file$5, 109, 4, 3136);
			attr_dev(span0, "class", "spectrum-Checkbox-box");
			add_location(span0, file$5, 119, 4, 3330);
			attr_dev(span1, "class", "spectrum-Checkbox-label");
			add_location(span1, file$5, 139, 4, 3921);
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
			add_location(label, file$5, 101, 2, 2878);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding*/ ctx[17](input);
			append_dev(label, t0);
			append_dev(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append_dev(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append_dev(label, t2);
			append_dev(label, span1);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr_dev(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr_dev(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*value*/ 256) {
				prop_dev(input, "value", /*value*/ ctx[8]);
			}

			if (!current || dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (!current || dirty & /*indeterminate*/ 2) {
				prop_dev(input, "indeterminate", /*indeterminate*/ ctx[1]);
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*title*/ 512) && { title: /*title*/ ctx[9] },
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[17](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(101:0) {#if readonly}",
		ctx
	});

	return block;
}

// (164:6) {#if checked}
function create_if_block_4(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcheckmarksmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(164:6) {#if checked}",
		ctx
	});

	return block;
}

// (173:6) {#if indeterminate}
function create_if_block_3(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icondashsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icondashsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(173:6) {#if indeterminate}",
		ctx
	});

	return block;
}

// (121:6) {#if checked}
function create_if_block_2(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcheckmarksmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(121:6) {#if checked}",
		ctx
	});

	return block;
}

// (130:6) {#if indeterminate}
function create_if_block_1$5(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icondashsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icondashsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(130:6) {#if indeterminate}",
		ctx
	});

	return block;
}

// (141:12) Checkbox
function fallback_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Checkbox");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Checkbox");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(141:12) Checkbox",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*readonly*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"checked","disabled","isInvalid","isQuiet","indeterminate","readonly","name","id","value","title"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Checkbox", slots, ['default']);
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { indeterminate = false } = $$props;
	let { readonly = false } = $$props;
	let { name = "" } = $$props;
	let { id = "checkbox-" + Math.random().toString(24) } = $$props;
	let { value = "" } = $$props;
	let { title = "" } = $$props;
	let checkbox;
	let iconSize = 10;
	let large = false;
	const eventsListen = getEventsAction(current_component);
	const observer = new index(getIconScale);

	afterUpdate(() => {
		index_umd.throttle(500, observer.observe(checkbox));
	});

	onDestroy(() => {
		observer.unobserve(checkbox);
	});

	function getIconScale() {
		$$invalidate(11, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-125")));

		if (iconSize == 10) {
			$$invalidate(12, large = false);
		} else {
			$$invalidate(12, large = true);
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_change_handler() {
		checked = this.checked;
		indeterminate = this.indeterminate;
		$$invalidate(0, checked);
		$$invalidate(1, indeterminate);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$new_props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$new_props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$new_props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$new_props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$new_props) $$invalidate(9, title = $$new_props.title);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		IconCheckmarkSmall: CheckmarkSmall,
		IconDashSmall: DashSmall,
		ResizeObserver: index,
		throttle: index_umd.throttle,
		afterUpdate,
		onDestroy,
		current_component,
		getEventsAction,
		checked,
		disabled,
		isInvalid,
		isQuiet,
		indeterminate,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		observer,
		getIconScale
	});

	$$self.$inject_state = $$new_props => {
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$props) $$invalidate(9, title = $$new_props.title);
		if ("checkbox" in $$props) $$invalidate(10, checkbox = $$new_props.checkbox);
		if ("iconSize" in $$props) $$invalidate(11, iconSize = $$new_props.iconSize);
		if ("large" in $$props) $$invalidate(12, large = $$new_props.large);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		checked,
		indeterminate,
		disabled,
		isInvalid,
		isQuiet,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		$$restProps,
		$$scope,
		slots,
		input_binding,
		input_binding_1,
		input_change_handler
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			checked: 0,
			disabled: 2,
			isInvalid: 3,
			isQuiet: 4,
			indeterminate: 1,
			readonly: 5,
			name: 6,
			id: 7,
			value: 8,
			title: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment$5.name
		});
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInvalid() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInvalid(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Radio/Radio.svelte generated by Svelte v3.29.4 */

const file$6 = "node_modules/@rubus/rubus/src/packages/Radio/Radio.svelte";

// (64:53) {value}
function fallback_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*value*/ ctx[6]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*value*/ ctx[6]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 64) set_data_dev(t, /*value*/ ctx[6]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(64:53) {value}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div;
	let input;
	let t0;
	let span;
	let t1;
	let label;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			label = element("label");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			input = claim_element(div_nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				id: true,
				checked: true,
				disabled: true,
				value: true,
				readonly: true
			});

			t0 = claim_space(div_nodes);
			span = claim_element(div_nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			t1 = claim_space(div_nodes);
			label = claim_element(div_nodes, "LABEL", { class: true, for: true });
			var label_nodes = children(label);
			if (default_slot_or_fallback) default_slot_or_fallback.l(label_nodes);
			label_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "radio");
			attr_dev(input, "name", /*name*/ ctx[5]);
			attr_dev(input, "class", "spectrum-Radio-input");
			attr_dev(input, "id", /*id*/ ctx[0]);
			input.checked = /*checked*/ ctx[1];
			input.disabled = /*disabled*/ ctx[3];
			input.value = /*value*/ ctx[6];
			input.readOnly = /*readonly*/ ctx[7];
			add_location(input, file$6, 61, 2, 1856);
			attr_dev(span, "class", "spectrum-Radio-button");
			add_location(span, file$6, 62, 2, 1962);
			attr_dev(label, "class", "spectrum-Radio-label");
			attr_dev(label, "for", /*id*/ ctx[0]);
			add_location(label, file$6, 63, 2, 2003);
			attr_dev(div, "class", "spectrum-Radio");
			toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			add_location(div, file$6, 56, 0, 1721);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t0);
			append_dev(div, span);
			append_dev(div, t1);
			append_dev(div, label);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(label, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 32) {
				attr_dev(input, "name", /*name*/ ctx[5]);
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(input, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*checked*/ 2) {
				prop_dev(input, "checked", /*checked*/ ctx[1]);
			}

			if (!current || dirty & /*disabled*/ 8) {
				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*value*/ 64) {
				prop_dev(input, "value", /*value*/ ctx[6]);
			}

			if (!current || dirty & /*readonly*/ 128) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[7]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*value*/ 64) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(label, "for", /*id*/ ctx[0]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			}

			if (dirty & /*isInvalid*/ 4) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			}

			if (dirty & /*readonly*/ 128) {
				toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Radio", slots, ['default']);
	let { id = `radio-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { checked = false } = $$props;
	let { isInvalid = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { name = "radio" } = $$props;
	let { value = "" } = $$props;
	let { readonly = false } = $$props;

	const writable_props = [
		"id",
		"checked",
		"isInvalid",
		"disabled",
		"isQuiet",
		"name",
		"value",
		"readonly"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Radio> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly,
		$$scope,
		slots
	];
}

class Radio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			id: 0,
			checked: 1,
			isInvalid: 2,
			disabled: 3,
			isQuiet: 4,
			name: 5,
			value: 6,
			readonly: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio",
			options,
			id: create_fragment$6.name
		});
	}

	get id() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInvalid() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInvalid(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Tooltip/Tooltip.svelte generated by Svelte v3.29.4 */
const file$7 = "node_modules/@rubus/rubus/src/packages/Tooltip/Tooltip.svelte";

// (215:32) 
function create_if_block_3$1(ctx) {
	let iconhelpsmall;
	let current;

	iconhelpsmall = new HelpSmall({
			props: {
				className: "spectrum-Tooltip-typeIcon spectrum-Tooltip-typeIcon-help",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconhelpsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconhelpsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconhelpsmall, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconhelpsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconhelpsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconhelpsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(215:32) ",
		ctx
	});

	return block;
}

// (213:36) 
function create_if_block_2$1(ctx) {
	let iconsuccessmedium;
	let current;

	iconsuccessmedium = new SuccessMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconsuccessmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconsuccessmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconsuccessmedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconsuccessmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconsuccessmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconsuccessmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(213:36) ",
		ctx
	});

	return block;
}

// (211:32) 
function create_if_block_1$6(ctx) {
	let iconinfomedium;
	let current;

	iconinfomedium = new InfoMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconinfomedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconinfomedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconinfomedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconinfomedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconinfomedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconinfomedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(211:32) ",
		ctx
	});

	return block;
}

// (209:2) {#if variants === 'negative'}
function create_if_block$6(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconalertmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconalertmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(209:2) {#if variants === 'negative'}",
		ctx
	});

	return block;
}

// (221:45) {label}
function fallback_block$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[1]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*label*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$2.name,
		type: "fallback",
		source: "(221:45) {label}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let span2;
	let current_block_type_index;
	let if_block;
	let t0;
	let span0;
	let t1;
	let span1;
	let span2_class_value;
	let span2_resize_listener;
	let current;
	const if_block_creators = [create_if_block$6, create_if_block_1$6, create_if_block_2$1, create_if_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[2] === "negative") return 0;
		if (/*variants*/ ctx[2] === "info") return 1;
		if (/*variants*/ ctx[2] === "positive") return 2;
		if (/*variants*/ ctx[2] === "help") return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

	const block = {
		c: function create() {
			span2 = element("span");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t1 = space();
			span1 = element("span");
			this.h();
		},
		l: function claim(nodes) {
			span2 = claim_element(nodes, "SPAN", { class: true, style: true });
			var span2_nodes = children(span2);
			if (if_block) if_block.l(span2_nodes);
			t0 = claim_space(span2_nodes);
			span0 = claim_element(span2_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (default_slot_or_fallback) default_slot_or_fallback.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span2_nodes);
			span1 = claim_element(span2_nodes, "SPAN", { class: true });
			children(span1).forEach(detach_dev);
			span2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "spectrum-Tooltip-label");
			add_location(span0, file$7, 220, 2, 14630);
			attr_dev(span1, "class", "spectrum-Tooltip-tip");
			add_location(span1, file$7, 221, 2, 14697);
			attr_dev(span2, "class", span2_class_value = "spectrum-Tooltip spectrum-Tooltip--" + /*variants*/ ctx[2] + " spectrum-Tooltip--" + /*directions*/ ctx[3] + " ");
			attr_dev(span2, "style", /*styleText*/ ctx[5]);
			add_render_callback(() => /*span2_elementresize_handler*/ ctx[12].call(span2));
			toggle_class(span2, "is-open", /*isOpen*/ ctx[0]);
			add_location(span2, file$7, 202, 0, 13845);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span2, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(span2, null);
			}

			append_dev(span2, t0);
			append_dev(span2, span0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span0, null);
			}

			append_dev(span2, t1);
			append_dev(span2, span1);
			span2_resize_listener = add_resize_listener(span2, /*span2_elementresize_handler*/ ctx[12].bind(span2));
			/*span2_binding*/ ctx[13](span2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(span2, t0);
				} else {
					if_block = null;
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*variants, directions*/ 12 && span2_class_value !== (span2_class_value = "spectrum-Tooltip spectrum-Tooltip--" + /*variants*/ ctx[2] + " spectrum-Tooltip--" + /*directions*/ ctx[3] + " ")) {
				attr_dev(span2, "class", span2_class_value);
			}

			if (!current || dirty & /*styleText*/ 32) {
				attr_dev(span2, "style", /*styleText*/ ctx[5]);
			}

			if (dirty & /*variants, directions, isOpen*/ 13) {
				toggle_class(span2, "is-open", /*isOpen*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			span2_resize_listener();
			/*span2_binding*/ ctx[13](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tooltip", slots, ['default']);
	let { label = "" } = $$props;
	let { variants = "default" } = $$props;
	let { isOpen = false } = $$props;
	let { directions = "top" } = $$props;
	let { induceStartEventName = "mouseover" } = $$props;
	let { induceEndEventName = "mouseout" } = $$props;
	let { width = "size-2000" } = $$props;
	let tooltipEl;
	let styleText = "";
	let tooltipCH;

	onMount(() => {
		if (tooltipEl) {
			tooltipEl.parentNode.classList.toggle("u-tooltip-showOnEvent");

			tooltipEl.parentNode.addEventListener(induceStartEventName, function () {
				$$invalidate(0, isOpen = !isOpen);
			});

			if (induceStartEventName !== induceEndEventName) {
				tooltipEl.parentNode.addEventListener(induceEndEventName, function () {
					if (isOpen) $$invalidate(0, isOpen = false);
				});
			}
		}
	});

	afterUpdate(() => {
		let tooltipWrapHeight = tooltipEl.parentNode.clientHeight;
		let tooltipWrapWidth = tooltipEl.parentNode.clientWidth;

		let widthCss = width && width.toString().indexOf("size") !== -1
		? `width:var(--spectrum-global-dimension-${width});`
		: width.toString().indexOf("%") !== -1
			? `width: ${width};`
			: `width: ${width}px;`;

		switch (directions) {
			case "top":
				$$invalidate(5, styleText = `top:-${tooltipCH + tooltipWrapHeight * 0.5}px;${widthCss}`);
				break;
			case "bottom":
				$$invalidate(5, styleText = `top:calc(var(--spectrum-global-dimension-size-75) + ${tooltipWrapHeight}px);${widthCss}`);
				break;
			case "left":
				$$invalidate(5, styleText = `left:calc(-1 * var(--spectrum-global-dimension-size-75));${widthCss}`);
				break;
			case "right":
				$$invalidate(5, styleText = `left:calc(var(--spectrum-global-dimension-size-75) + ${tooltipWrapWidth}px);${widthCss}`);
				break;
		}
	});

	const writable_props = [
		"label",
		"variants",
		"isOpen",
		"directions",
		"induceStartEventName",
		"induceEndEventName",
		"width"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tooltip> was created with unknown prop '${key}'`);
	});

	function span2_elementresize_handler() {
		tooltipCH = this.clientHeight;
		$$invalidate(6, tooltipCH);
	}

	function span2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tooltipEl = $$value;
			$$invalidate(4, tooltipEl);
		});
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("directions" in $$props) $$invalidate(3, directions = $$props.directions);
		if ("induceStartEventName" in $$props) $$invalidate(7, induceStartEventName = $$props.induceStartEventName);
		if ("induceEndEventName" in $$props) $$invalidate(8, induceEndEventName = $$props.induceEndEventName);
		if ("width" in $$props) $$invalidate(9, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		IconInfoMedium: InfoMedium,
		IconAlertMedium: AlertMedium,
		IconSuccessMedium: SuccessMedium,
		IconHelpSmall: HelpSmall,
		afterUpdate,
		onMount,
		label,
		variants,
		isOpen,
		directions,
		induceStartEventName,
		induceEndEventName,
		width,
		tooltipEl,
		styleText,
		tooltipCH
	});

	$$self.$inject_state = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("directions" in $$props) $$invalidate(3, directions = $$props.directions);
		if ("induceStartEventName" in $$props) $$invalidate(7, induceStartEventName = $$props.induceStartEventName);
		if ("induceEndEventName" in $$props) $$invalidate(8, induceEndEventName = $$props.induceEndEventName);
		if ("width" in $$props) $$invalidate(9, width = $$props.width);
		if ("tooltipEl" in $$props) $$invalidate(4, tooltipEl = $$props.tooltipEl);
		if ("styleText" in $$props) $$invalidate(5, styleText = $$props.styleText);
		if ("tooltipCH" in $$props) $$invalidate(6, tooltipCH = $$props.tooltipCH);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		isOpen,
		label,
		variants,
		directions,
		tooltipEl,
		styleText,
		tooltipCH,
		induceStartEventName,
		induceEndEventName,
		width,
		$$scope,
		slots,
		span2_elementresize_handler,
		span2_binding
	];
}

class Tooltip extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			label: 1,
			variants: 2,
			isOpen: 0,
			directions: 3,
			induceStartEventName: 7,
			induceEndEventName: 8,
			width: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tooltip",
			options,
			id: create_fragment$7.name
		});
	}

	get label() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variants() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variants(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get directions() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set directions(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get induceStartEventName() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set induceStartEventName(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get induceEndEventName() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set induceEndEventName(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Typography/TypographyBody.svelte generated by Svelte v3.29.4 */

const file$8 = "node_modules/@rubus/rubus/src/packages/Typography/TypographyBody.svelte";

function create_fragment$8(ctx) {
	let p;
	let p_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			p = element("p");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			if (default_slot) default_slot.l(p_nodes);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", p_class_value = "spectrum-Body spectrum-Body--" + /*scale*/ ctx[0]);
			toggle_class(p, "spectrum-Body--serif", /*isSerif*/ ctx[1]);
			add_location(p, file$8, 14, 0, 302);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale*/ 1 && p_class_value !== (p_class_value = "spectrum-Body spectrum-Body--" + /*scale*/ ctx[0])) {
				attr_dev(p, "class", p_class_value);
			}

			if (dirty & /*scale, isSerif*/ 3) {
				toggle_class(p, "spectrum-Body--serif", /*isSerif*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TypographyBody", slots, ['default']);
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	const writable_props = ["scale", "isSerif"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TypographyBody> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ scale, isSerif });

	$$self.$inject_state = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [scale, isSerif, $$scope, slots];
}

class TypographyBody extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { scale: 0, isSerif: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TypographyBody",
			options,
			id: create_fragment$8.name
		});
	}

	get scale() {
		throw new Error("<TypographyBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<TypographyBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSerif() {
		throw new Error("<TypographyBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSerif(value) {
		throw new Error("<TypographyBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Typography/TypographyHeading.svelte generated by Svelte v3.29.4 */

const file$9 = "node_modules/@rubus/rubus/src/packages/Typography/TypographyHeading.svelte";

function create_fragment$9(ctx) {
	let h1;
	let h1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			h1 = element("h1");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			if (default_slot) default_slot.l(h1_nodes);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", h1_class_value = "spectrum-Heading spectrum-Heading--" + /*scale*/ ctx[0] + "  spectrum-Heading--" + /*thickness*/ ctx[2]);
			toggle_class(h1, "spectrum-Heading--serif", /*isSerif*/ ctx[1]);
			add_location(h1, file$9, 20, 0, 455);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);

			if (default_slot) {
				default_slot.m(h1, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*scale, thickness*/ 5 && h1_class_value !== (h1_class_value = "spectrum-Heading spectrum-Heading--" + /*scale*/ ctx[0] + "  spectrum-Heading--" + /*thickness*/ ctx[2])) {
				attr_dev(h1, "class", h1_class_value);
			}

			if (dirty & /*scale, thickness, isSerif*/ 7) {
				toggle_class(h1, "spectrum-Heading--serif", /*isSerif*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TypographyHeading", slots, ['default']);
	let { scale = "M" } = $$props;
	let { isSerif = false } = $$props;
	let { thickness = "default" } = $$props;
	const writable_props = ["scale", "isSerif", "thickness"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TypographyHeading> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("thickness" in $$props) $$invalidate(2, thickness = $$props.thickness);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ scale, isSerif, thickness });

	$$self.$inject_state = $$props => {
		if ("scale" in $$props) $$invalidate(0, scale = $$props.scale);
		if ("isSerif" in $$props) $$invalidate(1, isSerif = $$props.isSerif);
		if ("thickness" in $$props) $$invalidate(2, thickness = $$props.thickness);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [scale, isSerif, thickness, $$scope, slots];
}

class TypographyHeading extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { scale: 0, isSerif: 1, thickness: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TypographyHeading",
			options,
			id: create_fragment$9.name
		});
	}

	get scale() {
		throw new Error("<TypographyHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<TypographyHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSerif() {
		throw new Error("<TypographyHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSerif(value) {
		throw new Error("<TypographyHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get thickness() {
		throw new Error("<TypographyHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set thickness(value) {
		throw new Error("<TypographyHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var light = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 75",
				code: "#FAFAFA"
			},
			{
				name: "GRAY 100",
				code: "#F5F5F5"
			},
			{
				name: "GRAY 200",
				code: "#EAEAEA"
			},
			{
				name: "GRAY 300",
				code: "#E1E1E1"
			},
			{
				name: "GRAY 400",
				code: "#CACACA"
			},
			{
				name: "GRAY 500",
				code: "#B3B3B3"
			},
			{
				name: "GRAY 600",
				code: "#8E8E8E"
			},
			{
				name: "GRAY 700",
				code: "#6E6E6E"
			},
			{
				name: "GRAY 800",
				code: "#4B4B4B"
			},
			{
				name: "GRAY 900",
				code: "#2C2C2C"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#2680EB"
			},
			{
				name: "BLUE 500",
				code: "#1473E6"
			},
			{
				name: "BLUE 600",
				code: "#0D66D0"
			},
			{
				name: "BLUE 700",
				code: "#095ABA"
			}
		],
		[
			{
				name: "RED 400",
				code: "#E34850"
			},
			{
				name: "RED 500",
				code: "#D7373F"
			},
			{
				name: "RED 600",
				code: "#C9252D"
			},
			{
				name: "RED 700",
				code: "#BB121A"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#E68619"
			},
			{
				name: "ORANGE 500",
				code: "#DA7B11"
			},
			{
				name: "ORANGE 600",
				code: "#CB6F10"
			},
			{
				name: "ORANGE 700",
				code: "#BD640D"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#2D9D78"
			},
			{
				name: "GREEN 500",
				code: "#268E6C"
			},
			{
				name: "GREEN 600",
				code: "#12805C"
			},
			{
				name: "GREEN 700",
				code: "#107154"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var lightest = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 75",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 100",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "GRAY 300",
				code: "#eaeaea"
			},
			{
				name: "GRAY 400",
				code: "#d3d3d3"
			},
			{
				name: "GRAY 500",
				code: "#bcbcbc"
			},
			{
				name: "GRAY 600",
				code: "#959595"
			},
			{
				name: "GRAY 700",
				code: "#747474"
			},
			{
				name: "GRAY 800",
				code: "#505050"
			},
			{
				name: "GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#378ef0"
			},
			{
				name: "BLUE 500",
				code: "#2680eb"
			},
			{
				name: "BLUE 600",
				code: "#1473e6"
			},
			{
				name: "BLUE 700",
				code: "#0d66d0"
			}
		],
		[
			{
				name: "RED 400",
				code: "#ec5b62"
			},
			{
				name: "RED 500",
				code: "#e34850"
			},
			{
				name: "RED 600",
				code: "#d7373f"
			},
			{
				name: "RED 700",
				code: "#c9252d"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#f29423"
			},
			{
				name: "ORANGE 500",
				code: "#e68619"
			},
			{
				name: "ORANGE 600",
				code: "#da7b11"
			},
			{
				name: "ORANGE 700",
				code: "#cb6f10"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#33ab84"
			},
			{
				name: "GREEN 500",
				code: "#2d9d78"
			},
			{
				name: "GREEN 600",
				code: "#268e6c"
			},
			{
				name: "GREEN 700",
				code: "#12805c"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var dark = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#252525"
			},
			{
				name: "GRAY 75",
				code: "#2F2F2F"
			},
			{
				name: "GRAY 100",
				code: "#323232"
			},
			{
				name: "GRAY 200",
				code: "#3E3E3E"
			},
			{
				name: "GRAY 300",
				code: "#4A4A4A"
			},
			{
				name: "GRAY 400",
				code: "#5A5A5A"
			},
			{
				name: "GRAY 500",
				code: "#6E6E6E"
			},
			{
				name: "GRAY 600",
				code: "#909090"
			},
			{
				name: "GRAY 700",
				code: "#B9B9B9"
			},
			{
				name: "GRAY 800",
				code: "#E3E3E3"
			},
			{
				name: "GRAY 900",
				code: "#FFFFFF"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#2680EB"
			},
			{
				name: "BLUE 500",
				code: "#378EF0"
			},
			{
				name: "BLUE 600",
				code: "#4B9CF5"
			},
			{
				name: "BLUE 700",
				code: "#5AA9FA"
			}
		],
		[
			{
				name: "RED 400",
				code: "#E34850"
			},
			{
				name: "RED 500",
				code: "#EC5B62"
			},
			{
				name: "RED 600",
				code: "#F76D74"
			},
			{
				name: "RED 700",
				code: "#FF7B82"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#E68619"
			},
			{
				name: "ORANGE 500",
				code: "#F29423"
			},
			{
				name: "ORANGE 600",
				code: "#F9A43F"
			},
			{
				name: "ORANGE 700",
				code: "#FFB55B"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#2D9D78"
			},
			{
				name: "GREEN 500",
				code: "#33AB84"
			},
			{
				name: "GREEN 600",
				code: "#39B990"
			},
			{
				name: "GREEN 700",
				code: "#3FC89C"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var darkest = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#080808"
			},
			{
				name: "GRAY 75",
				code: "#1a1a1a"
			},
			{
				name: "GRAY 100",
				code: "#1e1e1e"
			},
			{
				name: "GRAY 200",
				code: "#2c2c2c"
			},
			{
				name: "GRAY 300",
				code: "#393939"
			},
			{
				name: "GRAY 400",
				code: "#494949"
			},
			{
				name: "GRAY 500",
				code: "#5c5c5c"
			},
			{
				name: "GRAY 600",
				code: "#7c7c7c"
			},
			{
				name: "GRAY 700",
				code: "#a2a2a2"
			},
			{
				name: "GRAY 800",
				code: "#c8c8c8"
			},
			{
				name: "GRAY 900",
				code: "#efefef"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#1473e6"
			},
			{
				name: "BLUE 500",
				code: "#2680eb"
			},
			{
				name: "BLUE 600",
				code: "#378ef0"
			},
			{
				name: "BLUE 700",
				code: "#4b9cf5"
			}
		],
		[
			{
				name: "RED 400",
				code: "#d7373f"
			},
			{
				name: "RED 500",
				code: "#e34850"
			},
			{
				name: "RED 600",
				code: "#ec5b62"
			},
			{
				name: "RED 700",
				code: "#f76d74"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#da7b11"
			},
			{
				name: "ORANGE 500",
				code: "#e68619"
			},
			{
				name: "ORANGE 600",
				code: "#f29423"
			},
			{
				name: "ORANGE 700",
				code: "#f9a43f"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#268e6c"
			},
			{
				name: "GREEN 500",
				code: "#2d9d78"
			},
			{
				name: "GREEN 600",
				code: "#33ab84"
			},
			{
				name: "GREEN 700",
				code: "#39b990"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var color = {
	light: light,
	lightest: lightest,
	dark: dark,
	darkest: darkest
};

var colorData = /*#__PURE__*/Object.freeze({
  __proto__: null,
  light: light,
  lightest: lightest,
  dark: dark,
  darkest: darkest,
  'default': color
});

/* src/components/color-container/ColorContainer.svelte generated by Svelte v3.29.4 */

const { console: console_1 } = globals;
const file$a = "src/components/color-container/ColorContainer.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (202:4) <Checkbox checked={staticColorsView} on:click={handleClick}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Static colors");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Static colors");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(202:4) <Checkbox checked={staticColorsView} on:click={handleClick}>",
		ctx
	});

	return block;
}

// (223:6) {#each items as colorItem}
function create_each_block_1(ctx) {
	let div2;
	let div0;
	let t0_value = /*colorItem*/ ctx[14].name + "";
	let t0;
	let t1;
	let div1;

	let t2_value = (/*colorModel*/ ctx[0] == "hex"
	? /*colorItem*/ ctx[14].code.toUpperCase()
	: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()) + "";

	let t2;
	let t3;
	let tooltip;
	let div2_class_value;
	let div2_style_value;
	let current;
	let mounted;
	let dispose;

	tooltip = new Tooltip({
			props: {
				label: "点击复制",
				induceStartEventName: "click",
				induceEndEventName: "click"
			},
			$$inline: true
		});

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[10](/*colorItem*/ ctx[14], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text(t2_value);
			t3 = space();
			create_component(tooltip.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, t2_value);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			claim_component(tooltip.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "color-item-name svelte-1k9vjxr");
			add_location(div0, file$a, 229, 10, 9588);
			attr_dev(div1, "class", "color-item-code svelte-1k9vjxr");
			add_location(div1, file$a, 230, 10, 9650);

			attr_dev(div2, "class", div2_class_value = "color-item " + (/*lightAndDark*/ ctx[7](/*colorItem*/ ctx[14].code)
			? "color-item-dark"
			: "color-item-light") + " svelte-1k9vjxr");

			attr_dev(div2, "style", div2_style_value = `background-color:${/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()}`);

			add_location(div2, file$a, 223, 8, 9243);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);
			append_dev(div2, t3);
			mount_component(tooltip, div2, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div2, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*$rubusDocConfig, colorDisplay*/ 12) && t0_value !== (t0_value = /*colorItem*/ ctx[14].name + "")) set_data_dev(t0, t0_value);

			if ((!current || dirty & /*colorModel, $rubusDocConfig, colorDisplay*/ 13) && t2_value !== (t2_value = (/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()) + "")) set_data_dev(t2, t2_value);

			if (!current || dirty & /*$rubusDocConfig, colorDisplay*/ 12 && div2_class_value !== (div2_class_value = "color-item " + (/*lightAndDark*/ ctx[7](/*colorItem*/ ctx[14].code)
			? "color-item-dark"
			: "color-item-light") + " svelte-1k9vjxr")) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*colorModel, $rubusDocConfig, colorDisplay*/ 13 && div2_style_value !== (div2_style_value = `background-color:${/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()}`)) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tooltip.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tooltip.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(tooltip);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(223:6) {#each items as colorItem}",
		ctx
	});

	return block;
}

// (221:2) {#each colorData[$rubusDocConfig.theme][colorDisplay] as items}
function create_each_block(ctx) {
	let div;
	let t;
	let current;
	let each_value_1 = /*items*/ ctx[11];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "color-group svelte-1k9vjxr");
			add_location(div, file$a, 221, 4, 9176);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lightAndDark, colorData, $rubusDocConfig, colorDisplay, colorModel, hexToRGB, copyColor*/ 205) {
				each_value_1 = /*items*/ ctx[11];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(221:2) {#each colorData[$rubusDocConfig.theme][colorDisplay] as items}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let div1;
	let form0;
	let checkbox;
	let t0;
	let div0;
	let t1;
	let form1;
	let radio0;
	let t2;
	let radio1;
	let t3;
	let div2;
	let current;

	checkbox = new Checkbox({
			props: {
				checked: /*staticColorsView*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleClick*/ ctx[5]);

	radio0 = new Radio({
			props: {
				value: "Hex",
				checked: /*colorModel*/ ctx[0] == "hex"
			},
			$$inline: true
		});

	radio0.$on("click", /*click_handler*/ ctx[8]);

	radio1 = new Radio({
			props: {
				value: "RGB",
				checked: /*colorModel*/ ctx[0] == "rgb"
			},
			$$inline: true
		});

	radio1.$on("click", /*click_handler_1*/ ctx[9]);
	let each_value = colorData[/*$rubusDocConfig*/ ctx[3].theme][/*colorDisplay*/ ctx[2]];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div1 = element("div");
			form0 = element("form");
			create_component(checkbox.$$.fragment);
			t0 = space();
			div0 = element("div");
			t1 = space();
			form1 = element("form");
			create_component(radio0.$$.fragment);
			t2 = space();
			create_component(radio1.$$.fragment);
			t3 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			form0 = claim_element(div1_nodes, "FORM", { class: true });
			var form0_nodes = children(form0);
			claim_component(checkbox.$$.fragment, form0_nodes);
			form0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			form1 = claim_element(div1_nodes, "FORM", { class: true });
			var form1_nodes = children(form1);
			claim_component(radio0.$$.fragment, form1_nodes);
			t2 = claim_space(form1_nodes);
			claim_component(radio1.$$.fragment, form1_nodes);
			form1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(form0, "class", "svelte-1k9vjxr");
			add_location(form0, file$a, 200, 2, 8634);
			attr_dev(div0, "class", "vertical-line svelte-1k9vjxr");
			add_location(div0, file$a, 203, 2, 8742);
			attr_dev(form1, "class", "color-model svelte-1k9vjxr");
			add_location(form1, file$a, 204, 2, 8774);
			attr_dev(div1, "class", "toolbar svelte-1k9vjxr");
			add_location(div1, file$a, 199, 0, 8610);
			attr_dev(div2, "class", "color-container svelte-1k9vjxr");
			add_location(div2, file$a, 219, 0, 9076);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, form0);
			mount_component(checkbox, form0, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div1, t1);
			append_dev(div1, form1);
			mount_component(radio0, form1, null);
			append_dev(form1, t2);
			mount_component(radio1, form1, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, div2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const checkbox_changes = {};
			if (dirty & /*staticColorsView*/ 2) checkbox_changes.checked = /*staticColorsView*/ ctx[1];

			if (dirty & /*$$scope*/ 131072) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
			const radio0_changes = {};
			if (dirty & /*colorModel*/ 1) radio0_changes.checked = /*colorModel*/ ctx[0] == "hex";
			radio0.$set(radio0_changes);
			const radio1_changes = {};
			if (dirty & /*colorModel*/ 1) radio1_changes.checked = /*colorModel*/ ctx[0] == "rgb";
			radio1.$set(radio1_changes);

			if (dirty & /*colorData, $rubusDocConfig, colorDisplay, lightAndDark, colorModel, hexToRGB, copyColor*/ 205) {
				each_value = colorData[/*$rubusDocConfig*/ ctx[3].theme][/*colorDisplay*/ ctx[2]];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div2, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			transition_in(radio0.$$.fragment, local);
			transition_in(radio1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			transition_out(radio0.$$.fragment, local);
			transition_out(radio1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(checkbox);
			destroy_component(radio0);
			destroy_component(radio1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function hexToRGB(h) {
	let r = 0, g = 0, b = 0;

	// 3 digits
	if (h.length == 4) {
		r = "0x" + h[1] + h[1];
		g = "0x" + h[2] + h[2];
		b = "0x" + h[3] + h[3];
	} else if (h.length == 7) {
		r = "0x" + h[1] + h[2]; // 6 digits
		g = "0x" + h[3] + h[4];
		b = "0x" + h[5] + h[6];
	}

	return "rgb(" + +r + "," + +g + "," + +b + ")";
}

function hexToHSL(H) {
	let r = 0, g = 0, b = 0;

	if (H.length == 4) {
		r = "0x" + H[1] + H[1];
		g = "0x" + H[2] + H[2];
		b = "0x" + H[3] + H[3];
	} else if (H.length == 7) {
		r = "0x" + H[1] + H[2];
		g = "0x" + H[3] + H[4];
		b = "0x" + H[5] + H[6];
	}

	// Then to HSL
	r /= 255;

	g /= 255;
	b /= 255;

	let cmin = Math.min(r, g, b),
		cmax = Math.max(r, g, b),
		delta = cmax - cmin,
		h = 0,
		s = 0,
		l = 0;

	if (delta == 0) h = 0; else if (cmax == r) h = (g - b) / delta % 6; else if (cmax == g) h = (b - r) / delta + 2; else h = (r - g) / delta + 4;
	h = Math.round(h * 60);
	if (h < 0) h += 360;
	l = (cmax + cmin) / 2;
	s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
	s = +(s * 100).toFixed(1);
	l = +(l * 100).toFixed(1);
	return [h, s, l];
}

function instance$a($$self, $$props, $$invalidate) {
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ColorContainer", slots, []);
	let colorModel = "hex";
	let staticColorsView = false;
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(3, $rubusDocConfig = value));
	let colorDisplay = "globalColor";

	onMount(() => {
		
	});

	function handleClick() {
		$$invalidate(1, staticColorsView = !staticColorsView);
		$$invalidate(2, colorDisplay = staticColorsView ? "staticColor" : "globalColor");
	}

	async function copyColor(t, c) {
		if (colorModel !== "hex") {
			c = hexToRGB(c);
		}

		let colorCode = staticColorsView
		? `--spectrum-global-color-static-${t.replace(/[^a-zA-Z]/gi, "").toLowerCase()}-${t.replace(/[^0-9]/gi, "")}: ${c}`
		: `--spectrum-global-color-${t.replace(/[^a-zA-Z]/gi, "").toLowerCase()}-${t.replace(/[^0-9]/gi, "")}: ${c}`;

		if (navigator.clipboard) {
			try {
				await navigator.clipboard.writeText(colorCode);
				console.log("Page URL copied to clipboard:" + colorCode);
			} catch(err) {
				console.error("Failed to copy: ", err);
			}
		}
	}

	function lightAndDark(code) {
		let [,,l] = hexToHSL(code);
		let crossover = 50;

		switch ($rubusDocConfig.theme) {
			case "light":
				crossover = 60;
				break;
			case "lightest":
				crossover = 70;
				break;
			case "dark":
				crossover = 38;
				break;
			case "darkest":
				crossover = 35;
				break;
		}

		return l >= crossover ? false : true;
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ColorContainer> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, colorModel = "hex");
	};

	const click_handler_1 = () => {
		$$invalidate(0, colorModel = "rgb");
	};

	const click_handler_2 = colorItem => {
		copyColor(colorItem.name, colorItem.code);
	};

	$$self.$capture_state = () => ({
		Radio,
		Checkbox,
		Tooltip,
		getContext,
		onMount,
		colorData,
		colorModel,
		staticColorsView,
		rubusDocConfig,
		colorDisplay,
		handleClick,
		copyColor,
		hexToRGB,
		hexToHSL,
		lightAndDark,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("colorModel" in $$props) $$invalidate(0, colorModel = $$props.colorModel);
		if ("staticColorsView" in $$props) $$invalidate(1, staticColorsView = $$props.staticColorsView);
		if ("rubusDocConfig" in $$props) $$invalidate(4, rubusDocConfig = $$props.rubusDocConfig);
		if ("colorDisplay" in $$props) $$invalidate(2, colorDisplay = $$props.colorDisplay);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		colorModel,
		staticColorsView,
		colorDisplay,
		$rubusDocConfig,
		rubusDocConfig,
		handleClick,
		copyColor,
		lightAndDark,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class ColorContainer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ColorContainer",
			options,
			id: create_fragment$a.name
		});
	}
}

/* src/routes/docs/csstokens/color/index.svelte generated by Svelte v3.29.4 */
const file$b = "src/routes/docs/csstokens/color/index.svelte";

// (19:2) <TypographyHeading scale="XL">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("颜色");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "颜色");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(19:2) <TypographyHeading scale=\\\"XL\\\">",
		ctx
	});

	return block;
}

// (20:2) <TypographyBody scale="M" lineHeight="size-400">
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("位于设计系统中的颜色令牌");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "位于设计系统中的颜色令牌");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(20:2) <TypographyBody scale=\\\"M\\\" lineHeight=\\\"size-400\\\">",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let title_value;
	let t0;
	let header;
	let typographyheading;
	let t1;
	let typographybody;
	let t2;
	let main;
	let colorcontainer;
	let current;
	document.title = title_value = "" + (/*$rubusDocConfig*/ ctx[0].name + " 颜色");

	typographyheading = new TypographyHeading({
			props: {
				scale: "XL",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	typographybody = new TypographyBody({
			props: {
				scale: "M",
				lineHeight: "size-400",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	colorcontainer = new ColorContainer({ $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			header = element("header");
			create_component(typographyheading.$$.fragment);
			t1 = space();
			create_component(typographybody.$$.fragment);
			t2 = space();
			main = element("main");
			create_component(colorcontainer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1xk3tor\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			claim_component(typographyheading.$$.fragment, header_nodes);
			t1 = claim_space(header_nodes);
			claim_component(typographybody.$$.fragment, header_nodes);
			header_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			claim_component(colorcontainer.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-145r0l5");
			add_location(header, file$b, 17, 0, 801);
			add_location(main, file$b, 22, 0, 956);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, header, anchor);
			mount_component(typographyheading, header, null);
			append_dev(header, t1);
			mount_component(typographybody, header, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, main, anchor);
			mount_component(colorcontainer, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*$rubusDocConfig*/ 1) && title_value !== (title_value = "" + (/*$rubusDocConfig*/ ctx[0].name + " 颜色"))) {
				document.title = title_value;
			}

			const typographyheading_changes = {};

			if (dirty & /*$$scope*/ 4) {
				typographyheading_changes.$$scope = { dirty, ctx };
			}

			typographyheading.$set(typographyheading_changes);
			const typographybody_changes = {};

			if (dirty & /*$$scope*/ 4) {
				typographybody_changes.$$scope = { dirty, ctx };
			}

			typographybody.$set(typographybody_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typographyheading.$$.fragment, local);
			transition_in(typographybody.$$.fragment, local);
			transition_in(colorcontainer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typographyheading.$$.fragment, local);
			transition_out(typographybody.$$.fragment, local);
			transition_out(colorcontainer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(header);
			destroy_component(typographyheading);
			destroy_component(typographybody);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(main);
			destroy_component(colorcontainer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Color", slots, []);
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(0, $rubusDocConfig = value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Color> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		TypographyHeading,
		TypographyBody,
		getContext,
		ColorContainer,
		rubusDocConfig,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("rubusDocConfig" in $$props) $$invalidate(1, rubusDocConfig = $$props.rubusDocConfig);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$rubusDocConfig, rubusDocConfig];
}

class Color extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Color",
			options,
			id: create_fragment$b.name
		});
	}
}

export default Color;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguM2M4YWVlOTYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvc3ZlbHRlLXNwZWN0cnVtLWljb25zLXVpL3NyYy9DaGVja21hcmtTbWFsbC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3N2ZWx0ZS1zcGVjdHJ1bS1pY29ucy11aS9zcmMvRGFzaFNtYWxsLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvc3ZlbHRlLXNwZWN0cnVtLWljb25zLXVpL3NyYy9IZWxwU21hbGwuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BydWJ1cy9zdmVsdGUtc3BlY3RydW0taWNvbnMtdWkvc3JjL0luZm9NZWRpdW0uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BydWJ1cy9zdmVsdGUtc3BlY3RydW0taWNvbnMtdWkvc3JjL1N1Y2Nlc3NNZWRpdW0uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2luZGV4LnVtZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL0NoZWNrYm94L0NoZWNrYm94LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1JhZGlvL1JhZGlvLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1Rvb2x0aXAvVG9vbHRpcC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3J1YnVzL3NyYy9wYWNrYWdlcy9UeXBvZ3JhcGh5L1R5cG9ncmFwaHlCb2R5LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1R5cG9ncmFwaHkvVHlwb2dyYXBoeUhlYWRpbmcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvY29sb3ItY29udGFpbmVyL0NvbG9yQ29udGFpbmVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9jc3N0b2tlbnMvY29sb3IvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBleHBvcnQgbGV0IHNjYWxlID0gXCJNXCI7XG4gIGV4cG9ydCBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgZXhwb3J0IGxldCB3aWR0aCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgaGVpZ2h0ID0gXCJcIjtcbiAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSBcIkNoZWNrbWFya1NtYWxsXCI7XG4gIGxldCBwYXRoO1xuICBsZXQgc3c7XG4gIGxldCBzaDtcblxuICBsZXQgZmxhZyA9IDE0O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFzY2FsZSB8fCBzY2FsZSA9PSBcIk1cIikge1xuICAgICAgbGV0IHJvb3RDbGFzc05hbWUgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgaWYgKHJvb3RDbGFzc05hbWUgJiYgcm9vdENsYXNzTmFtZS5pbmRleE9mKFwic3BlY3RydW0tLWxhcmdlXCIpICE9IC0xKSB7XG4gICAgICAgIHNjYWxlID0gXCJMXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IFwiTVwiO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbjxzdmdcbiAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICB7Li4uJCRyZXN0UHJvcHN9XG4gIHdpZHRoPXt3aWR0aCB8fCBzdyB8fCBmbGFnfVxuICBoZWlnaHQ9e2hlaWdodCB8fCBzaCB8fCBmbGFnfVxuICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgY2xhc3M9XCJzcGVjdHJ1bS1JY29uIHtjbGFzc05hbWV9XCI+XG4gIHsjaWYgc2NhbGUgPT09ICdMJ31cbiAgICA8cGF0aFxuICAgICAgYmluZDp0aGlzPXtwYXRofVxuICAgIGQ9XCJNNC41IDExYS45OTkuOTk5IDAgMDEtLjc4OC0uMzg1bC0zLTRhMSAxIDAgMTExLjU3Ni0xLjIzTDQuNSA4LjM3Nmw1LjIxMi02Ljk5YTEgMSAwIDExMS41NzYgMS4yM2wtNiA4QS45OTkuOTk5IDBcbiAgICAwMTQuNSAxMXpcIlxuLz5cbiAgezplbHNlIGlmIHNjYWxlID09PSAnTSd9XG4gICAgPHBhdGhcbiAgICAgIGJpbmQ6dGhpcz17cGF0aH1cbiAgICBkPVwiTTMuNzg4IDlBLjk5OS45OTkgMCAwMTMgOC42MTVsLTIuMjg4LTNhMSAxIDAgMTExLjU3Ni0xLjIzbDEuNSAxLjk5MSAzLjkyNC00Ljk5MWExIDEgMCAxMTEuNTc2IDEuMjNsLTQuNzEyXG4gICAgNkEuOTk5Ljk5OSAwIDAxMy43ODggOXpcIi8+XG4gIHsvaWZ9XG48L3N2Zz5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBleHBvcnQgbGV0IHNjYWxlID0gXCJNXCI7XG4gIGV4cG9ydCBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgZXhwb3J0IGxldCB3aWR0aCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgaGVpZ2h0ID0gXCJcIjtcbiAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSBcIkRhc2hTbWFsbFwiO1xuICBsZXQgcGF0aDtcbiAgbGV0IHN3O1xuICBsZXQgc2g7XG5cbiAgbGV0IGZsYWcgPSAxNDtcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHN3ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHNoID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHN3ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHNoID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmICghc2NhbGUgfHwgc2NhbGUgPT0gXCJNXCIpIHtcbiAgICAgIGxldCByb290Q2xhc3NOYW1lID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTmFtZTtcbiAgICAgIGlmIChyb290Q2xhc3NOYW1lICYmIHJvb3RDbGFzc05hbWUuaW5kZXhPZihcInNwZWN0cnVtLS1sYXJnZVwiKSAhPSAtMSkge1xuICAgICAgICBzY2FsZSA9IFwiTFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgPSBcIk1cIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG48c3ZnXG4gIGFyaWEtbGFiZWw9e2FyaWFMYWJlbH1cbiAgey4uLiQkcmVzdFByb3BzfVxuICB3aWR0aD17d2lkdGggfHwgc3cgfHwgZmxhZ31cbiAgaGVpZ2h0PXtoZWlnaHQgfHwgc2ggfHwgZmxhZ31cbiAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gIGNsYXNzPVwic3BlY3RydW0tSWNvbiB7Y2xhc3NOYW1lfVwiPlxuICB7I2lmIHNjYWxlID09PSAnTCd9XG4gICAgPHBhdGhcbiAgICAgIGJpbmQ6dGhpcz17cGF0aH0gZD1cIk0xMC45OSA1SDEuMDFhMSAxIDAgMDAwIDJoOS45OGExIDEgMCAxMDAtMnpcIiAvPlxuICB7OmVsc2UgaWYgc2NhbGUgPT09ICdNJ31cbiAgICA8cGF0aFxuICAgICAgYmluZDp0aGlzPXtwYXRofSBkPVwiTTggNEgyYTEgMSAwIDAwMCAyaDZhMSAxIDAgMDAwLTJ6XCIgLz5cbiAgey9pZn1cbjwvc3ZnPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGV4cG9ydCBsZXQgc2NhbGUgPSBcIk1cIjtcbiAgZXhwb3J0IGxldCBjbGFzc05hbWUgPSBcIlwiO1xuICBleHBvcnQgbGV0IHdpZHRoID0gXCJcIjtcbiAgZXhwb3J0IGxldCBoZWlnaHQgPSBcIlwiO1xuICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IFwiSGVscFNtYWxsXCI7XG4gIGxldCBwYXRoO1xuICBsZXQgc3c7XG4gIGxldCBzaDtcblxuICBsZXQgZmxhZyA9IDE0O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFzY2FsZSB8fCBzY2FsZSA9PSBcIk1cIikge1xuICAgICAgbGV0IHJvb3RDbGFzc05hbWUgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgaWYgKHJvb3RDbGFzc05hbWUgJiYgcm9vdENsYXNzTmFtZS5pbmRleE9mKFwic3BlY3RydW0tLWxhcmdlXCIpICE9IC0xKSB7XG4gICAgICAgIHNjYWxlID0gXCJMXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IFwiTVwiO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPHN2Z1xuICBhcmlhLWxhYmVsPXthcmlhTGFiZWx9XG4gIHsuLi4kJHJlc3RQcm9wc31cbiAgd2lkdGg9e3dpZHRoIHx8IHN3IHx8IGZsYWd9XG4gIGhlaWdodD17aGVpZ2h0IHx8IHNoIHx8IGZsYWd9XG4gIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICBjbGFzcz1cInNwZWN0cnVtLUljb24ge2NsYXNzTmFtZX1cIj5cbiAgeyNpZiBzY2FsZSA9PT0gJ0wnfVxuICAgIDxwYXRoXG4gICAgICBiaW5kOnRoaXM9e3BhdGh9XG4gICAgICBkPVwiTTkgMWE4IDggMCAxMDggOCA4IDggMCAwMC04LTh6bS4wMjMgMTMuNDM4YTEuMzQ1IDEuMzQ1IDAgMDEtLjEwNC0yLjY4OHEuMDUyLS4wMDIuMTA0IDBhMS4zMSAxLjMxIDAgMDExLjM5N1xuICAgICAgMS4yMTdxLjAwNC4wNTkuMDAzLjExOGExLjI5MSAxLjI5MSAwIDAxLTEuNCAxLjM1M3ptMS43ODMtNi40MDlsLS4xLjFjLS4zOTUuNDE0LS44NDIuODg0LS44NDIgMS4xNzVhMS4zODYgMS4zODYgMFxuICAgICAgMDAuMTc5LjY3NGwuMDczLjEzOS0uMDU3LjIxNWEuMzA4LjMwOCAwIDAxLS4yODQuMTg5SDguNDM2YS40MzQuNDM0IDAgMDEtLjMyNS0uMTE3IDIuMDU2IDIuMDU2IDBcbiAgICAgIDAxLS40MjItMS4yNjJBMy4wNTggMy4wNTggMCAwMTguOCA3LjA3MWMuMS0uMTEuMi0uMjEuMjg4LS4zLjMxNC0uMzI1LjUwNy0uNTM1LjUwNy0uNzU4IDAtLjE1NFxuICAgICAgMC0uNjIyLS44OTMtLjYyMmEyLjk1OCAyLjk1OCAwIDAwLTEuNTguNDU5LjMuMyAwIDAxLS4zMjctLjAxbC0uMTE4LS4wODUtLjAyOC0uMjI1VjQuMDgxYS40NC40NCAwIDAxLjItLjQxQTQuMTM1XG4gICAgICA0LjEzNSAwIDAxOSAzLjExOWEyLjU1MiAyLjU1MiAwIDAxMi43NTEgMi42MzYgMy4wNjcgMy4wNjcgMCAwMS0uOTQ0IDIuMjc0elwiIC8+XG4gIHs6ZWxzZSBpZiBzY2FsZSA9PT0gJ00nfVxuICAgIDxwYXRoXG4gICAgICBiaW5kOnRoaXM9e3BhdGh9XG4gICAgICBkPVwiTTcgLjc3OEE2LjIyMiA2LjIyMiAwIDEwMTMuMjIyIDcgNi4yMjIgNi4yMjIgMCAwMDcgLjc3OHptLjAxOCAxMC40NTJhMS4wNDYgMS4wNDYgMCAxMS0uMDgtMi4wOTFxLjA0LS4wMDIuMDhcbiAgICAgIDBhMS4wMTkgMS4wMTkgMCAwMTEuMDg3Ljk0NnEuMDAzLjA0Ni4wMDIuMDkyYTEuMDA0IDEuMDA0IDAgMDEtMS4wOVxuICAgICAgMS4wNTN6bTEuMzg3LTQuOTg1bC0uMDc4LjA3OGMtLjMwNy4zMjItLjY1NS42ODctLjY1NS45MTNhMS4wNzggMS4wNzggMCAwMC4xNC41MjVsLjA1Ni4xMDgtLjA0NC4xNjdhLjI0LjI0IDBcbiAgICAgIDAxLS4yMjEuMTQ3SDYuNTZhLjMzOC4zMzggMCAwMS0uMjUyLS4wOTEgMS42IDEuNiAwIDAxLS4zMjktLjk4MiAyLjM3OCAyLjM3OCAwXG4gICAgICAwMS44NjQtMS42MWMuMDc4LS4wODYuMTU2LS4xNjQuMjI0LS4yMzQuMjQ1LS4yNTIuMzk1LS40MTYuMzk1LS41OSAwLS4xMTkgMC0uNDgzLS42OTUtLjQ4M2EyLjMgMi4zIDBcbiAgICAgIDAwLTEuMjI5LjM1Ny4yMzMuMjMzIDAgMDEtLjI1NC0uMDA4bC0uMDkyLS4wNjYtLjAyMi0uMTc1VjMuMTc0YS4zNDIuMzQyIDAgMDEuMTU2LS4zMTlBMy4yMTYgMy4yMTYgMCAwMTdcbiAgICAgIDIuNDI1YTEuOTg1IDEuOTg1IDAgMDEyLjE0IDIuMDUxIDIuMzg1IDIuMzg1IDAgMDEtLjczNSAxLjc2OXpcIiAvPlxuICB7L2lmfVxuPC9zdmc+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgZXhwb3J0IGxldCBzY2FsZSA9IFwiTVwiO1xuICBleHBvcnQgbGV0IGNsYXNzTmFtZSA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgd2lkdGggPSBcIlwiO1xuICBleHBvcnQgbGV0IGhlaWdodCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gXCJJbmZvTWVkaXVtXCI7XG4gIGxldCBwYXRoO1xuICBsZXQgc3c7XG4gIGxldCBzaDtcblxuICBsZXQgZmxhZyA9IDE0O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgc3cgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgc2ggPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFzY2FsZSB8fCBzY2FsZSA9PSBcIk1cIikge1xuICAgICAgbGV0IHJvb3RDbGFzc05hbWUgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgaWYgKHJvb3RDbGFzc05hbWUgJiYgcm9vdENsYXNzTmFtZS5pbmRleE9mKFwic3BlY3RydW0tLWxhcmdlXCIpICE9IC0xKSB7XG4gICAgICAgIHNjYWxlID0gXCJMXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IFwiTVwiO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuXG5cbjxzdmdcbiAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICB7Li4uJCRyZXN0UHJvcHN9XG4gIHdpZHRoPXt3aWR0aCB8fCBzdyB8fCBmbGFnfVxuICBoZWlnaHQ9e2hlaWdodCB8fCBzaCB8fCBmbGFnfVxuICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgY2xhc3M9XCJzcGVjdHJ1bS1JY29uIHtjbGFzc05hbWV9XCI+XG4gIHsjaWYgc2NhbGUgPT09ICdMJ31cbiAgICA8cGF0aFxuICAgICAgYmluZDp0aGlzPXtwYXRofVxuICAgIGQ9XCJNMTEgMmE5IDkgMCAxMDkgOSA5IDkgMCAwMC05LTl6bS0uMTUgMi42NWExLjM1OSAxLjM1OSAwIDAxMS40MzEgMS4yODNxLjAwNC4wNjQuMDAxLjEyOWExLjMzMiAxLjMzMiAwIDAxLTEuNDMyXG4gICAgMS40MzIgMS4zNTMgMS4zNTMgMCAwMS0xLjQzMi0xLjQzMyAxLjM1OSAxLjM1OSAwIDAxMS4zMDQtMS40MTJxLjA2NC0uMDAyLjEyOC4wMDF6TTEzLjUgMTZhLjUuNSAwIDAxLS41LjVIOWEuNS41IDBcbiAgICAwMS0uNS0uNXYtMWEuNS41IDAgMDEuNS0uNWgxdi00SDlhLjUuNSAwIDAxLS41LS41VjlhLjUuNSAwIDAxLjUtLjVoMi41YS41LjUgMCAwMS41LjV2NS41aDFhLjUuNSAwIDAxLjUuNXpcIlxuLz5cbiAgezplbHNlIGlmIHNjYWxlID09PSAnTSd9XG4gICAgPHBhdGhcbiAgICAgIGJpbmQ6dGhpcz17cGF0aH1cbiAgICBkPVwiTTkgMWE4IDggMCAxMDggOCA4IDggMCAwMC04LTh6bS0uMTUgMi4xNWExLjM1OSAxLjM1OSAwIDAxMS40MzEgMS4yODNxLjAwNC4wNjQuMDAxLjEyOUExLjMzMiAxLjMzMiAwIDAxOC44NVxuICAgIDUuOTk0YTEuMzUzIDEuMzUzIDAgMDEtMS40MzItMS40MzMgMS4zNTkgMS4zNTkgMCAwMTEuMzA0LTEuNDEycS4wNjQtLjAwMi4xMjguMDAxek0xMSAxMy41YS41LjUgMCAwMS0uNS41aC0zYS41LjUgMFxuICAgIDAxLS41LS41di0xYS41LjUgMCAwMS41LS41SDhWOWgtLjVhLjUuNSAwIDAxLS41LS41di0xYS41LjUgMCAwMS41LS41aDJhLjUuNSAwIDAxLjUuNVYxMmguNWEuNS41IDAgMDEuNS41elwiLz5cbiAgey9pZn1cbjwvc3ZnPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGV4cG9ydCBsZXQgc2NhbGUgPSBcIk1cIjtcbiAgZXhwb3J0IGxldCBjbGFzc05hbWUgPSBcIlwiO1xuICBleHBvcnQgbGV0IHdpZHRoID0gXCJcIjtcbiAgZXhwb3J0IGxldCBoZWlnaHQgPSBcIlwiO1xuICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IFwiU3VjY2Vzc01lZGl1bVwiO1xuICBsZXQgcGF0aDtcbiAgbGV0IHN3O1xuICBsZXQgc2g7XG5cbiAgbGV0IGZsYWcgPSAxNDtcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHN3ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHNoID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHN3ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHNoID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmICghc2NhbGUgfHwgc2NhbGUgPT0gXCJNXCIpIHtcbiAgICAgIGxldCByb290Q2xhc3NOYW1lID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTmFtZTtcbiAgICAgIGlmIChyb290Q2xhc3NOYW1lICYmIHJvb3RDbGFzc05hbWUuaW5kZXhPZihcInNwZWN0cnVtLS1sYXJnZVwiKSAhPSAtMSkge1xuICAgICAgICBzY2FsZSA9IFwiTFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgPSBcIk1cIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cblxuXG48c3ZnXG4gIGFyaWEtbGFiZWw9e2FyaWFMYWJlbH1cbiAgey4uLiQkcmVzdFByb3BzfVxuICB3aWR0aD17d2lkdGggfHwgc3cgfHwgZmxhZ31cbiAgaGVpZ2h0PXtoZWlnaHQgfHwgc2ggfHwgZmxhZ31cbiAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gIGNsYXNzPVwic3BlY3RydW0tSWNvbiB7Y2xhc3NOYW1lfVwiPlxuICB7I2lmIHNjYWxlID09PSAnTCd9XG4gICAgPHBhdGhcbiAgICAgIGJpbmQ6dGhpcz17cGF0aH1cbiAgICBkPVwiTTExIDJhOSA5IDAgMTA5IDkgOSA5IDAgMDAtOS05em01LjYzOCA1LjYwOUwxMC4xIDE1LjY1MmEuNS41IDAgMDEtLjc0Mi4wMzhMNS4wODYgMTEuNWEuNS41IDBcbiAgICAwMTAtLjcwN2wuNzA3LS43MDdhLjUuNSAwIDAxLjcwNyAwTDkuNiAxMy4xbDUuNDg2LTYuNzUxYS41LjUgMCAwMS43LS4wNzNsLjc3Ni42MzFhLjUuNSAwIDAxLjA3Ni43MDJ6XCJcbi8+XG4gIHs6ZWxzZSBpZiBzY2FsZSA9PT0gJ00nfVxuICAgIDxwYXRoXG4gICAgICBiaW5kOnRoaXM9e3BhdGh9XG4gICAgZD1cIk05IDFhOCA4IDAgMTA4IDggOCA4IDAgMDAtOC04em01LjMzMyA0LjU0bC02LjMyNCA4LjEzYS42LjYgMCAwMS0uNDM3LjIzaC0uMDM3YS42LjYgMCAwMS0uNDI1LS4xNzZsLTMuODkzLTMuOWEuNi42XG4gICAgMCAwMTAtLjg0OWwuNjYzLS42NjNhLjYuNiAwIDAxLjg0OCAwTDcuNCAxMC45OTFsNS4yNTYtNi43NTRhLjYuNiAwIDAxLjg0My0uMWwuNzI4LjU2NmEuNi42IDAgMDEuMTA2LjgzN3pcIi8+XG4gIHsvaWZ9XG48L3N2Zz5cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC50aHJvdHRsZURlYm91bmNlID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQsbm8tcGFyYW0tcmVhc3NpZ24sbm8tc2hhZG93ICovXG5cblx0LyoqXG5cdCAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xuXHQgKiBleGVjdXRpb24gb2YgaGFuZGxlcnMgb24gZXZlbnRzIGxpa2UgcmVzaXplIGFuZCBzY3JvbGwuXG5cdCAqXG5cdCAqIEBwYXJhbSAge251bWJlcn0gICAgZGVsYXkgLSAgICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gICBbbm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uZSBmaW5hbCB0aW1lXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cblx0ICogQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAtICAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIHRocm90dGxlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSAtIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIHRocm90dGxlIChkZWxheSwgbm9UcmFpbGluZywgY2FsbGJhY2ssIGRlYm91bmNlTW9kZSkge1xuXHQgIC8qXG5cdCAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcblx0ICAgKiBgY2FsbGJhY2tgIGlzIGV4ZWN1dGVkIGF0IHRoZSBwcm9wZXIgdGltZXMgaW4gYHRocm90dGxlYCBhbmQgYGVuZGBcblx0ICAgKiBkZWJvdW5jZSBtb2Rlcy5cblx0ICAgKi9cblx0ICB2YXIgdGltZW91dElEO1xuXHQgIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG5cdCAgdmFyIGxhc3RFeGVjID0gMDsgLy8gRnVuY3Rpb24gdG8gY2xlYXIgZXhpc3RpbmcgdGltZW91dFxuXG5cdCAgZnVuY3Rpb24gY2xlYXJFeGlzdGluZ1RpbWVvdXQoKSB7XG5cdCAgICBpZiAodGltZW91dElEKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuXHQgICAgfVxuXHQgIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cblx0ICBmdW5jdGlvbiBjYW5jZWwoKSB7XG5cdCAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXHQgICAgY2FuY2VsbGVkID0gdHJ1ZTtcblx0ICB9IC8vIGBub1RyYWlsaW5nYCBkZWZhdWx0cyB0byBmYWxzeS5cblxuXG5cdCAgaWYgKHR5cGVvZiBub1RyYWlsaW5nICE9PSAnYm9vbGVhbicpIHtcblx0ICAgIGRlYm91bmNlTW9kZSA9IGNhbGxiYWNrO1xuXHQgICAgY2FsbGJhY2sgPSBub1RyYWlsaW5nO1xuXHQgICAgbm9UcmFpbGluZyA9IHVuZGVmaW5lZDtcblx0ICB9XG5cdCAgLypcblx0ICAgKiBUaGUgYHdyYXBwZXJgIGZ1bmN0aW9uIGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIHRocm90dGxpbmcgLyBkZWJvdW5jaW5nXG5cdCAgICogZnVuY3Rpb25hbGl0eSBhbmQgd2hlbiBleGVjdXRlZCB3aWxsIGxpbWl0IHRoZSByYXRlIGF0IHdoaWNoIGBjYWxsYmFja2Bcblx0ICAgKiBpcyBleGVjdXRlZC5cblx0ICAgKi9cblxuXG5cdCAgZnVuY3Rpb24gd3JhcHBlcigpIHtcblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNfID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmd1bWVudHNfW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICB2YXIgZWxhcHNlZCA9IERhdGUubm93KCkgLSBsYXN0RXhlYztcblxuXHQgICAgaWYgKGNhbmNlbGxlZCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9IC8vIEV4ZWN1dGUgYGNhbGxiYWNrYCBhbmQgdXBkYXRlIHRoZSBgbGFzdEV4ZWNgIHRpbWVzdGFtcC5cblxuXG5cdCAgICBmdW5jdGlvbiBleGVjKCkge1xuXHQgICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XG5cdCAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50c18pO1xuXHQgICAgfVxuXHQgICAgLypcblx0ICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSB0aGlzIGlzIHVzZWQgdG8gY2xlYXIgdGhlIGZsYWdcblx0ICAgICAqIHRvIGFsbG93IGZ1dHVyZSBgY2FsbGJhY2tgIGV4ZWN1dGlvbnMuXG5cdCAgICAgKi9cblxuXG5cdCAgICBmdW5jdGlvbiBjbGVhcigpIHtcblx0ICAgICAgdGltZW91dElEID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZGVib3VuY2VNb2RlICYmICF0aW1lb3V0SUQpIHtcblx0ICAgICAgLypcblx0ICAgICAgICogU2luY2UgYHdyYXBwZXJgIGlzIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXG5cdCAgICAgICAqIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgLlxuXHQgICAgICAgKi9cblx0ICAgICAgZXhlYygpO1xuXHQgICAgfVxuXG5cdCAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG5cdCAgICBpZiAoZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgJiYgZWxhcHNlZCA+IGRlbGF5KSB7XG5cdCAgICAgIC8qXG5cdCAgICAgICAqIEluIHRocm90dGxlIG1vZGUsIGlmIGBkZWxheWAgdGltZSBoYXMgYmVlbiBleGNlZWRlZCwgZXhlY3V0ZVxuXHQgICAgICAgKiBgY2FsbGJhY2tgLlxuXHQgICAgICAgKi9cblx0ICAgICAgZXhlYygpO1xuXHQgICAgfSBlbHNlIGlmIChub1RyYWlsaW5nICE9PSB0cnVlKSB7XG5cdCAgICAgIC8qXG5cdCAgICAgICAqIEluIHRyYWlsaW5nIHRocm90dGxlIG1vZGUsIHNpbmNlIGBkZWxheWAgdGltZSBoYXMgbm90IGJlZW5cblx0ICAgICAgICogZXhjZWVkZWQsIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBgZGVsYXlgIG1zIGFmdGVyIG1vc3Rcblx0ICAgICAgICogcmVjZW50IGV4ZWN1dGlvbi5cblx0ICAgICAgICpcblx0ICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGVcblx0ICAgICAgICogYWZ0ZXIgYGRlbGF5YCBtcy5cblx0ICAgICAgICpcblx0ICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksIHNjaGVkdWxlIGBjYWxsYmFja2AgdG9cblx0ICAgICAgICogZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuXHQgICAgICAgKi9cblx0ICAgICAgdGltZW91dElEID0gc2V0VGltZW91dChkZWJvdW5jZU1vZGUgPyBjbGVhciA6IGV4ZWMsIGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHdyYXBwZXIuY2FuY2VsID0gY2FuY2VsOyAvLyBSZXR1cm4gdGhlIHdyYXBwZXIgZnVuY3Rpb24uXG5cblx0ICByZXR1cm4gd3JhcHBlcjtcblx0fVxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuXHQvKipcblx0ICogRGVib3VuY2UgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIERlYm91bmNpbmcsIHVubGlrZSB0aHJvdHRsaW5nLFxuXHQgKiBndWFyYW50ZWVzIHRoYXQgYSBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIGEgc2luZ2xlIHRpbWUsIGVpdGhlciBhdCB0aGVcblx0ICogdmVyeSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgY2FsbHMsIG9yIGF0IHRoZSB2ZXJ5IGVuZC5cblx0ICpcblx0ICogQHBhcmFtICB7bnVtYmVyfSAgIGRlbGF5IC0gICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gIFthdEJlZ2luXSAtICAgICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0QmVnaW4gaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRCZWdpbiBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcywgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpLlxuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSBkZWJvdW5jZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcsIGRlYm91bmNlZCBmdW5jdGlvbi5cblx0ICovXG5cblx0ZnVuY3Rpb24gZGVib3VuY2UgKGRlbGF5LCBhdEJlZ2luLCBjYWxsYmFjaykge1xuXHQgIHJldHVybiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gdGhyb3R0bGUoZGVsYXksIGF0QmVnaW4sIGZhbHNlKSA6IHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywgYXRCZWdpbiAhPT0gZmFsc2UpO1xuXHR9XG5cblx0ZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xuXHRleHBvcnRzLnRocm90dGxlID0gdGhyb3R0bGU7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LnVtZC5qcy5tYXBcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEljb25DaGVja21hcmtTbWFsbCwgSWNvbkRhc2hTbWFsbCB9IGZyb20gXCJAcnVidXMvc3ZlbHRlLXNwZWN0cnVtLWljb25zLXVpXCI7XG4gIGltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tIFwicmVzaXplLW9ic2VydmVyLXBvbHlmaWxsXCI7XG4gIGltcG9ydCB7IHRocm90dGxlIH0gZnJvbSBcInRocm90dGxlLWRlYm91bmNlXCI7XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBvbkRlc3Ryb3kgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IGN1cnJlbnRfY29tcG9uZW50IH0gZnJvbSBcInN2ZWx0ZS9pbnRlcm5hbFwiO1xuICBpbXBvcnQgeyBnZXRFdmVudHNBY3Rpb24gfSBmcm9tIFwiLi4vdXRpbHMvZ2V0LWV2ZW50cy1hY3Rpb24uanNcIjtcblxuICAvKipcbiAgICogU3BlY2lmeSB3aGV0aGVyIHRoZSBjaGVja2JveCBpcyBjaGVja2VkXG4gICAqIEB0eXBlIHtib29sZWFufSBbY2hlY2tlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgY2hlY2tlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIHRvIGRpc2FibGUgdGhlIGNoZWNrYm94XG4gICAqIEB0eXBlIHtib29sZWFufSBbZGlzYWJsZWQ9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGlucHV0IHNob3VsZCBkaXNwbGF5IGl0cyBcInZhbGlkXCIgb3IgXCJpbnZhbGlkXCIgdmlzdWFsIHN0eWxpbmcuXG4gICAqIEB0eXBlIHtib29sZWFufSBbaXNJbnZhbGlkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc0ludmFsaWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhpcyBwcm9wIHNldHMgdGhlIHF1aWV0IHN0eWxlIHdoaWNoIHByb3ZpZGVzIHZpc3VhbCB3ZWFrZW4uXG4gICAqIEB0eXBlIHtib29sZWFufSBbaXNRdWlldD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgaXNRdWlldCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge2Jvb2xlYW59IFtpbmRldGVybWluYXRlPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNldCB0byBgdHJ1ZWAgZm9yIHRoZSBjaGVja2JveCB0byBiZSByZWFkLW9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59IFtyZWFkb25seT1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgcmVhZG9ubHkgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IGEgbmFtZSBmb3IgdGhlIGlucHV0IGVsZW1lbnRcbiAgICogQHR5cGUge3N0cmluZ30gW25hbWU9XCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgbmFtZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFNldCBhbiBpZCBmb3IgdGhlIGlucHV0IGVsZW1lbnRcbiAgICogQHR5cGUge3N0cmluZ30gW2lkID0gXCJjaGVja2JveC1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMjQpXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpZCA9IFwiY2hlY2tib3gtXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDI0KTtcblxuICAvKipcbiAgICogU2V0IGFuIGlkIGZvciB0aGUgaW5wdXQgZWxlbWVudFxuICAgKiBAdHlwZSB7c3RyaW5nfSBbdmFsdWUgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YWx1ZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFNldCBhbiB0aXRsZSBmb3IgdGhlIGlucHV0IGxhYmFsXG4gICAqIEB0eXBlIHtzdHJpbmd9IFt0aXRsZSA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IHRpdGxlID0gXCJcIjtcblxuICBsZXQgY2hlY2tib3g7XG4gIGxldCBpY29uU2l6ZSA9IDEwO1xuICBsZXQgbGFyZ2UgPSBmYWxzZTtcbiAgY29uc3QgZXZlbnRzTGlzdGVuID0gZ2V0RXZlbnRzQWN0aW9uKGN1cnJlbnRfY29tcG9uZW50KTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZ2V0SWNvblNjYWxlKTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgdGhyb3R0bGUoNTAwLCBvYnNlcnZlci5vYnNlcnZlKGNoZWNrYm94KSk7XG4gIH0pO1xuXG4gIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGNoZWNrYm94KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0SWNvblNjYWxlKCkge1xuICAgIGljb25TaXplID0gcGFyc2VJbnQoXG4gICAgICBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi1zaXplLTEyNVwiKVxuICAgICk7XG4gICAgaWYgKGljb25TaXplID09IDEwKSB7XG4gICAgICBsYXJnZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXJnZSA9IHRydWU7XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnJlYWRvbmx5IHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuPC9zdHlsZT5cblxueyNpZiByZWFkb25seX1cbiAgPGxhYmVsXG4gICAge3RpdGxlfVxuICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94IHJlYWRvbmx5IHskJHJlc3RQcm9wcy5jbGFzc31cIlxuICAgIGNsYXNzOmlzLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICBjbGFzczppcy1pbmRldGVybWluYXRlPXtpbmRldGVybWluYXRlfVxuICAgIGNsYXNzOmlzLWludmFsaWQ9e2lzSW52YWxpZH1cbiAgICBjbGFzczpzcGVjdHJ1bS1DaGVja2JveC0tcXVpZXQ9e2lzUXVpZXR9PlxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3gtaW5wdXRcIlxuICAgICAge2lkfVxuICAgICAge25hbWV9XG4gICAgICB7ZGlzYWJsZWR9XG4gICAgICB7dmFsdWV9XG4gICAgICBiaW5kOnRoaXM9e2NoZWNrYm94fVxuICAgICAge2NoZWNrZWR9XG4gICAgICB7aW5kZXRlcm1pbmF0ZX0gLz5cbiAgICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94LWJveFwiPlxuICAgICAgeyNpZiBjaGVja2VkfVxuICAgICAgICA8SWNvbkNoZWNrbWFya1NtYWxsXG4gICAgICAgICAgd2lkdGg9e2ljb25TaXplIC0gMX1cbiAgICAgICAgICBoZWlnaHQ9e2ljb25TaXplIC0gMX1cbiAgICAgICAgICBzY2FsZT17bGFyZ2UgPyAnTCcgOiAnTSd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwic3BlY3RydW0tQ2hlY2tib3gtY2hlY2ttYXJrXCJcbiAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cbiAgICAgIHsvaWZ9XG4gICAgICB7I2lmIGluZGV0ZXJtaW5hdGV9XG4gICAgICAgIDxJY29uRGFzaFNtYWxsXG4gICAgICAgICAgd2lkdGg9e2ljb25TaXplfVxuICAgICAgICAgIGhlaWdodD17aWNvblNpemV9XG4gICAgICAgICAgc2NhbGU9e2xhcmdlID8gJ0wnIDogJ00nfVxuICAgICAgICAgIGNsYXNzTmFtZT1cInNwZWN0cnVtLUNoZWNrYm94LXBhcnRpYWxDaGVja21hcmtcIlxuICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICAgICAgey9pZn1cbiAgICA8L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveC1sYWJlbFwiPlxuICAgICAgPHNsb3Q+Q2hlY2tib3g8L3Nsb3Q+XG4gICAgPC9zcGFuPlxuICA8L2xhYmVsPlxuezplbHNlfVxuICA8bGFiZWxcbiAgICB7Li4uJCRyZXN0UHJvcHN9XG4gICAgY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveCB7JCRyZXN0UHJvcHMuY2xhc3N9XCJcbiAgICBjbGFzczppcy1kaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgY2xhc3M6aXMtaW5kZXRlcm1pbmF0ZT17aW5kZXRlcm1pbmF0ZX1cbiAgICBjbGFzczppcy1pbnZhbGlkPXtpc0ludmFsaWR9XG4gICAgY2xhc3M6c3BlY3RydW0tQ2hlY2tib3gtLXF1aWV0PXtpc1F1aWV0fVxuICAgIHVzZTpldmVudHNMaXN0ZW4+XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveC1pbnB1dFwiXG4gICAgICB7aWR9XG4gICAgICB7bmFtZX1cbiAgICAgIHtkaXNhYmxlZH1cbiAgICAgIHt2YWx1ZX1cbiAgICAgIGJpbmQ6dGhpcz17Y2hlY2tib3h9XG4gICAgICBiaW5kOmNoZWNrZWRcbiAgICAgIGJpbmQ6aW5kZXRlcm1pbmF0ZSAvPlxuICAgIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3gtYm94XCI+XG4gICAgICB7I2lmIGNoZWNrZWR9XG4gICAgICAgIDxJY29uQ2hlY2ttYXJrU21hbGxcbiAgICAgICAgICB3aWR0aD17aWNvblNpemUgLSAxfVxuICAgICAgICAgIGhlaWdodD17aWNvblNpemUgLSAxfVxuICAgICAgICAgIHNjYWxlPXtsYXJnZSA/ICdMJyA6ICdNJ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJzcGVjdHJ1bS1DaGVja2JveC1jaGVja21hcmtcIlxuICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICAgICAgey9pZn1cbiAgICAgIHsjaWYgaW5kZXRlcm1pbmF0ZX1cbiAgICAgICAgPEljb25EYXNoU21hbGxcbiAgICAgICAgICB3aWR0aD17aWNvblNpemV9XG4gICAgICAgICAgaGVpZ2h0PXtpY29uU2l6ZX1cbiAgICAgICAgICBzY2FsZT17bGFyZ2UgPyAnTCcgOiAnTSd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwic3BlY3RydW0tQ2hlY2tib3gtcGFydGlhbENoZWNrbWFya1wiXG4gICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gICAgICB7L2lmfVxuICAgIDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94LWxhYmVsXCI+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvc3Bhbj5cbiAgPC9sYWJlbD5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAvKipcbiAgICogVGhlIGVsZW1lbnQncyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICogQHR5cGUgeyBzdHJpbmcgfVtpZCA9IGByYWRpby0ke01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICg5OTk5OSAtIDApKSArIDB9YF1cbiAgICovXG4gIGV4cG9ydCBsZXQgaWQgPSBgcmFkaW8tJHtNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoOTk5OTkgLSAwKSkgKyAwfWA7XG5cbiAgLyoqXG4gICAqIFNldCB0byBgdHJ1ZWAgdG8gY2hlY2tlZCB0aGUgcmFkaW9cbiAgICogQHR5cGUge2Jvb2xlYW59W2NoZWNrZWQ9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGNoZWNrZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCB0byBpbnZhbGlkIHRoZSByYWRpb1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1bY2hlY2tlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgcmFkaW9cbiAgICogQHR5cGUge2Jvb2xlYW59W2Rpc2FibGVkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBxdWlldCBtb2RlIG9mIHJhZGlvXG4gICAqIEB0eXBlIHsgYm9vbGVhbiB9IFtpc1F1aWV0PSBmYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgaXNRdWlldCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcmFkaW8gYnV0dG9uLCB1c2VkIHdoZW4gc3VibWl0dGluZyBhbiBIVE1MIGZvcm0uXG4gICAqIEB0eXBlIHsgc3RyaW5nIH1bIG5hbWUgPSBcInJhZGlvXCIgXVxuICAgKi9cbiAgZXhwb3J0IGxldCBuYW1lID0gXCJyYWRpb1wiO1xuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHJhZGlvIGJ1dHRvbiwgdXNlZCB3aGVuIHN1Ym1pdHRpbmcgYW4gSFRNTCBmb3JtLlxuICAgKiBAdHlwZSB7IHN0cmluZyB9W3ZhbHVlID0gXCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgdmFsdWUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSByZWFkb25seSBtb2RlIG9mIHJhZGlvXG4gICAqIEB0eXBlIHtib29sZWFufVtyZWFkb25seT1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgcmVhZG9ubHkgPSBmYWxzZTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc3BlY3RydW0tUmFkaW8uaXMtcmVhZG9ubHkge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGNsYXNzPVwic3BlY3RydW0tUmFkaW9cIlxuICBjbGFzczpzcGVjdHJ1bS1SYWRpby0tcXVpZXQ9e2lzUXVpZXR9XG4gIGNsYXNzOmlzLWludmFsaWQ9e2lzSW52YWxpZH1cbiAgY2xhc3M6aXMtcmVhZG9ubHk9e3JlYWRvbmx5fT5cbiAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIHtuYW1lfSBjbGFzcz1cInNwZWN0cnVtLVJhZGlvLWlucHV0XCIge2lkfSB7Y2hlY2tlZH0ge2Rpc2FibGVkfSB7dmFsdWV9IHtyZWFkb25seX0gLz5cbiAgPHNwYW4gY2xhc3M9XCJzcGVjdHJ1bS1SYWRpby1idXR0b25cIiAvPlxuICA8bGFiZWwgY2xhc3M9XCJzcGVjdHJ1bS1SYWRpby1sYWJlbFwiIGZvcj17aWR9PjxzbG90Pnt2YWx1ZX08L3Nsb3Q+PC9sYWJlbD5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSWNvbkluZm9NZWRpdW0sIEljb25BbGVydE1lZGl1bSwgSWNvblN1Y2Nlc3NNZWRpdW0sIEljb25IZWxwU21hbGwgfSBmcm9tIFwiQHJ1YnVzL3N2ZWx0ZS1zcGVjdHJ1bS1pY29ucy11aVwiO1xuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAvKipcbiAgICogIFNwZWNpZnkgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSB0b29sdGlwXG4gICAqIEB0eXBlIHtzdHJpbmd9IFtsYWJlbCA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGxhYmVsID0gXCJcIjtcblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgdmFyaWFudHMgIGZvciB0aGUgIHRvb2x0aXBcbiAgICogQHR5cGUge1wiZGVmYXVsdFwiIHwgXCJpbmZvXCIgfCBcIm5lZ2F0aXZlXCIgfCBcInBvc2l0aXZlXCIgfCBcImhlbHBcIiB9IFt2YXJpYW50cyA9IFwiZGVmYXVsdFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YXJpYW50cyA9IFwiZGVmYXVsdFwiO1xuXG4gIC8qKlxuICAgKiAgU3BlY2lmeSB0aGUgb3BlbiBzdGF0dXMgZm9yIHRoZSB0b29sdGlwXG4gICAqIEB0eXBlIHtzdHJpbmd9IFtsYWJlbCA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzT3BlbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBkaXJlY3Rpb25zICBmb3IgdGhlICB0b29sdGlwXG4gICAqIEB0eXBlIHtcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiIH0gW2RpcmVjdGlvbnMgPSBcInRvcFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBkaXJlY3Rpb25zID0gXCJ0b3BcIjtcblxuICAvKipcbiAgICogIFNldCB0aGUgdHJpZ2dlciBldmVudCBuYW1lIHRvIG9wZW4gdGhlIHRvb2x0aXBcbiAgICogQHR5cGUge1wibW91c2VvdmVyXCIgfCBcIm1vdXNlZW50ZXJcIiB8IFwiY2xpY2tcIiB8IFwiY29udGV4dG1lbnVcIiB8IFwiZGJsY2xpY2tcIiB8IFwibW91c2Vkb3duXCIgfCBcIm1vdXNldXBcIiB8IFwic2VsZWN0XCIgfCBcImtleWRvd25cIiB8IFwia2V5cHJlc3NcIiB8IFwia2V5dXBcIn0gW2luZHVjZVN0YXJ0RXZlbnROYW1lID0gXCJtb3VzZW92ZXJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgaW5kdWNlU3RhcnRFdmVudE5hbWUgPSBcIm1vdXNlb3ZlclwiO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyaWdnZXIgZXZlbnQgbmFtZSB0byBjbG9zZSB0aGUgdG9vbHRpcFxuICAgKiBAdHlwZSB7XCJtb3VzZW91dFwiIHwgXCJtb3VzZWxlYXZlXCIgfCBcImNsaWNrXCIgfCBcImNvbnRleHRtZW51XCIgfCBcImRibGNsaWNrXCIgfCBcIm1vdXNlZG93blwiIHwgXCJtb3VzZXVwXCIgfCBcInNlbGVjdFwiIHwgXCJrZXlkb3duXCIgfCBcImtleXByZXNzXCIgfCBcImtleXVwXCJ9IFtpbmR1Y2VFbmRFdmVudE5hbWUgPSBcIm1vdXNlb3V0XCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGluZHVjZUVuZEV2ZW50TmFtZSA9IFwibW91c2VvdXRcIjtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgY3NzIHdpZHRoXG4gICAqIEB0eXBlIHtEaW1lbnNpb25WYWx1ZX0gW3dpZHRoID0gXCJzaXplLTIwMDBcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgd2lkdGggPSBcInNpemUtMjAwMFwiO1xuXG4gIGxldCB0b29sdGlwRWw7XG4gIGxldCBzdHlsZVRleHQgPSBcIlwiO1xuICBsZXQgdG9vbHRpcENIO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGlmICh0b29sdGlwRWwpIHtcbiAgICAgIHRvb2x0aXBFbC5wYXJlbnROb2RlLmNsYXNzTGlzdC50b2dnbGUoXCJ1LXRvb2x0aXAtc2hvd09uRXZlbnRcIik7XG5cbiAgICAgIHRvb2x0aXBFbC5wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoaW5kdWNlU3RhcnRFdmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNPcGVuID0gIWlzT3BlbjtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZHVjZVN0YXJ0RXZlbnROYW1lICE9PSBpbmR1Y2VFbmRFdmVudE5hbWUpIHtcbiAgICAgICAgdG9vbHRpcEVsLnBhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihpbmR1Y2VFbmRFdmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNPcGVuKSBpc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgbGV0IHRvb2x0aXBXcmFwSGVpZ2h0ID0gdG9vbHRpcEVsLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0O1xuICAgIGxldCB0b29sdGlwV3JhcFdpZHRoID0gdG9vbHRpcEVsLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG4gICAgbGV0IHdpZHRoQ3NzID1cbiAgICAgIHdpZHRoICYmIHdpZHRoLnRvU3RyaW5nKCkuaW5kZXhPZihcInNpemVcIikgIT09IC0xXG4gICAgICAgID8gYHdpZHRoOnZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tJHt3aWR0aH0pO2BcbiAgICAgICAgOiB3aWR0aC50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpICE9PSAtMVxuICAgICAgICA/IGB3aWR0aDogJHt3aWR0aH07YFxuICAgICAgICA6IGB3aWR0aDogJHt3aWR0aH1weDtgO1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb25zKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHN0eWxlVGV4dCA9IGB0b3A6LSR7dG9vbHRpcENIICsgdG9vbHRpcFdyYXBIZWlnaHQgKiAwLjV9cHg7JHt3aWR0aENzc31gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgc3R5bGVUZXh0ID0gYHRvcDpjYWxjKHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS03NSkgKyAke3Rvb2x0aXBXcmFwSGVpZ2h0fXB4KTske3dpZHRoQ3NzfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgc3R5bGVUZXh0ID0gYGxlZnQ6Y2FsYygtMSAqIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS03NSkpOyR7d2lkdGhDc3N9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgc3R5bGVUZXh0ID0gYGxlZnQ6Y2FsYyh2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtNzUpICsgJHt0b29sdGlwV3JhcFdpZHRofXB4KTske3dpZHRoQ3NzfWA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWFuaW1hdGlvbi1kdXJhdGlvbi0xMDAsIDEzMG1zKSBlYXNlLWluLW91dDtcbiAgICB0b3A6IC0xMDAlO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC1sYWJlbCB7XG4gICAgbWF4LXdpZHRoOiBub25lO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tcmlnaHQsXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAtLWxlZnQge1xuICAgIHRvcDogNTAlO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tcmlnaHQgLnNwZWN0cnVtLVRvb2x0aXAtdGlwLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1sZWZ0IC5zcGVjdHJ1bS1Ub29sdGlwLXRpcCB7XG4gICAgdG9wOiA1MCU7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1yaWdodCB7XG4gICAgbGVmdDogMTAwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtNTAlKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAtLWxlZnQge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMDAlLCAtNTAlKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tdG9wIHtcbiAgICBsZWZ0OiA1MCU7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1ib3R0b20gLnNwZWN0cnVtLVRvb2x0aXAtdGlwLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS10b3AgLnNwZWN0cnVtLVRvb2x0aXAtdGlwIHtcbiAgICBsZWZ0OiA1MCU7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1ib3R0b20ge1xuICAgIHRvcDogMTAwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCBjYWxjKC0xICogdmFyKC0tc3BlY3RydW0tdG9vbHRpcC10aXAtbWFyZ2luLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtNTApKSkpO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tdG9wIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCB2YXIoLS1zcGVjdHJ1bS10b29sdGlwLXRpcC1tYXJnaW4sIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS01MCkpKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAuaXMtb3BlbixcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudDpmb2N1cyAuc3BlY3RydW0tVG9vbHRpcCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50ICo6Zm9jdXMgLnNwZWN0cnVtLVRvb2x0aXAge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLmlzLW9wZW4uc3BlY3RydW0tVG9vbHRpcC0tYm90dG9tLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50OmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAqOmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCk7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLmlzLW9wZW4uc3BlY3RydW0tVG9vbHRpcC0tdG9wLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50OmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXRvcCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXRvcCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAqOmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXRvcCB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgY2FsYygtMSAqIHZhcigtLXNwZWN0cnVtLXRvb2x0aXAtdGlwLW1hcmdpbiwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi1zaXplLTUwKSkpKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAuaXMtb3Blbi5zcGVjdHJ1bS1Ub29sdGlwLS1sZWZ0LFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50OmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWxlZnQsXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQuaXMtZm9jdXNlZCAuc3BlY3RydW0tVG9vbHRpcC5zcGVjdHJ1bS1Ub29sdGlwLS1sZWZ0LFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50ICo6Zm9jdXMgLnNwZWN0cnVtLVRvb2x0aXAuc3BlY3RydW0tVG9vbHRpcC0tbGVmdCB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoXG4gICAgICBjYWxjKC0xMDAlIC0gdmFyKC0tc3BlY3RydW0tdG9vbHRpcC10aXAtbWFyZ2luLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtNTApKSksXG4gICAgICAtNTAlXG4gICAgKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAuaXMtb3Blbi5zcGVjdHJ1bS1Ub29sdGlwLS1yaWdodCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudDpmb2N1cyAuc3BlY3RydW0tVG9vbHRpcC5zcGVjdHJ1bS1Ub29sdGlwLS1yaWdodCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXJpZ2h0LFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50ICo6Zm9jdXMgLnNwZWN0cnVtLVRvb2x0aXAuc3BlY3RydW0tVG9vbHRpcC0tcmlnaHQge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXNwZWN0cnVtLXRvb2x0aXAtdGlwLW1hcmdpbiwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi1zaXplLTUwKSksIC01MCUpO1xuICB9XG5cbiAgLnNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb24ge1xuICAgIHdpZHRoOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtMjI1KTtcbiAgICBoZWlnaHQ6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS0yMjUpO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44KTtcbiAgfVxuICAuc3BlY3RydW0tVG9vbHRpcC0taGVscCA+IC5zcGVjdHJ1bS1Ub29sdGlwLXR5cGVJY29uLWhlbHAge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gIH1cbiAgLnNwZWN0cnVtLVRvb2x0aXAtbGFiZWwge1xuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XG4gIH1cbiAgLnNwZWN0cnVtLVRvb2x0aXAge1xuICAgIHotaW5kZXg6IDIwMDtcbiAgfVxuPC9zdHlsZT5cblxuPHNwYW5cbiAgY2xhc3M9XCJzcGVjdHJ1bS1Ub29sdGlwIHNwZWN0cnVtLVRvb2x0aXAtLXt2YXJpYW50c30gc3BlY3RydW0tVG9vbHRpcC0te2RpcmVjdGlvbnN9IFwiXG4gIHN0eWxlPXtzdHlsZVRleHR9XG4gIGNsYXNzOmlzLW9wZW49e2lzT3Blbn1cbiAgYmluZDpjbGllbnRIZWlnaHQ9e3Rvb2x0aXBDSH1cbiAgYmluZDp0aGlzPXt0b29sdGlwRWx9PlxuICB7I2lmIHZhcmlhbnRzID09PSAnbmVnYXRpdmUnfVxuICAgIDxJY29uQWxlcnRNZWRpdW0gY2xhc3NOYW1lPVwic3BlY3RydW0tVG9vbHRpcC10eXBlSWNvblwiIGZvY3VzYWJsZT1cImZhbHNlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cbiAgezplbHNlIGlmIHZhcmlhbnRzID09PSAnaW5mbyd9XG4gICAgPEljb25JbmZvTWVkaXVtIGNsYXNzTmFtZT1cInNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb25cIiBmb2N1c2FibGU9XCJmYWxzZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gIHs6ZWxzZSBpZiB2YXJpYW50cyA9PT0gJ3Bvc2l0aXZlJ31cbiAgICA8SWNvblN1Y2Nlc3NNZWRpdW0gY2xhc3NOYW1lPVwic3BlY3RydW0tVG9vbHRpcC10eXBlSWNvblwiIGZvY3VzYWJsZT1cImZhbHNlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cbiAgezplbHNlIGlmIHZhcmlhbnRzID09PSAnaGVscCd9XG4gICAgPEljb25IZWxwU21hbGxcbiAgICAgIGNsYXNzTmFtZT1cInNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb24gc3BlY3RydW0tVG9vbHRpcC10eXBlSWNvbi1oZWxwXCJcbiAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gIHsvaWZ9XG4gIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tVG9vbHRpcC1sYWJlbFwiPjxzbG90PntsYWJlbH08L3Nsb3Q+PC9zcGFuPlxuICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLVRvb2x0aXAtdGlwXCIgLz5cbjwvc3Bhbj5cbiIsIjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBTZXQgYm9keSBzY2FsZSBzcGVjaWZpY2F0aW9uc1xuICAgKiBAdHlwZSB7XCJYU1wiIHwgXCJTXCIgfCBcIk1cIiB8IFwiTFwiIHwgXCJYTFwiIHwgXCJYWExcIiB8IFwiWFhYTFwifSBbc2NhbGUgPSBcIk1cIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgc2NhbGUgPSBcIk1cIjtcblxuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2VyaWYgZm9udCBmYW1pbHkgaW4gdGhlIGNvbnRleHRcbiAgICogQHR5cGUge2Jvb2xlYW59IFtpc1NlcmlmID0gZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzU2VyaWYgPSBmYWxzZTtcbjwvc2NyaXB0PlxuXG48cCBjbGFzcz1cInNwZWN0cnVtLUJvZHkgc3BlY3RydW0tQm9keS0te3NjYWxlfVwiIGNsYXNzOnNwZWN0cnVtLUJvZHktLXNlcmlmPXtpc1NlcmlmfT5cbiAgPHNsb3QgLz5cbjwvcD5cbiIsIjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBTZXQgSGVhZGluZyBzY2FsZSBzcGVjaWZpY2F0aW9uc1xuICAgKiBAdHlwZSB7XCJYWFNcIiB8IFwiWFNcIiB8IFwiU1wiIHwgXCJNXCIgfCBcIkxcIiB8IFwiWExcIiB8IFwiWFhMXCIgfCBcIlhYWExcIn0gW3NjYWxlID0gXCJNXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IHNjYWxlID0gXCJNXCI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIHNlcmlmIGZvbnQgZmFtaWx5IGluIHRoZSBjb250ZXh0XG4gICAqIEB0eXBlIHtib29sZWFufSBbaXNTZXJpZiA9IGZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1NlcmlmID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9udCB3ZWlnaHRcbiAgICogQHR5cGUge1wiaGVhdnlcIiB8IFwibGlnaHRcIiB8IFwiZGVmYXVsdFwiIH0gW3RoaWNrbmVzcyA9IFwiZGVmYXVsdFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB0aGlja25lc3MgPSBcImRlZmF1bHRcIjtcbjwvc2NyaXB0PlxuXG48aDFcbiAgY2xhc3M9XCJzcGVjdHJ1bS1IZWFkaW5nIHNwZWN0cnVtLUhlYWRpbmctLXtzY2FsZX0gIHNwZWN0cnVtLUhlYWRpbmctLXt0aGlja25lc3N9XCJcbiAgY2xhc3M6c3BlY3RydW0tSGVhZGluZy0tc2VyaWY9e2lzU2VyaWZ9PlxuICA8c2xvdCAvPlxuPC9oMT5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IFJhZGlvLCBDaGVja2JveCwgVG9vbHRpcCB9IGZyb20gXCJAcnVidXMvcnVidXMvc3JjXCI7XG4gIGltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgaW1wb3J0ICogYXMgY29sb3JEYXRhIGZyb20gXCIuL2NvbG9yLmpzb25cIjtcblxuICBsZXQgY29sb3JNb2RlbCA9IFwiaGV4XCI7XG4gIGxldCBzdGF0aWNDb2xvcnNWaWV3ID0gZmFsc2U7XG4gIGxldCBydWJ1c0RvY0NvbmZpZyA9IGdldENvbnRleHQoXCJydWJ1c0RvY0NvbmZpZ1wiKTtcbiAgbGV0IGNvbG9yRGlzcGxheSA9IFwiZ2xvYmFsQ29sb3JcIjtcblxuICBvbk1vdW50KCgpID0+IHt9KTtcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgc3RhdGljQ29sb3JzVmlldyA9ICFzdGF0aWNDb2xvcnNWaWV3O1xuICAgIGNvbG9yRGlzcGxheSA9IHN0YXRpY0NvbG9yc1ZpZXcgPyBcInN0YXRpY0NvbG9yXCIgOiBcImdsb2JhbENvbG9yXCI7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjb3B5Q29sb3IodCwgYykge1xuICAgIGlmIChjb2xvck1vZGVsICE9PSBcImhleFwiKSB7XG4gICAgICBjID0gaGV4VG9SR0IoYyk7XG4gICAgfVxuICAgIGxldCBjb2xvckNvZGUgPSBzdGF0aWNDb2xvcnNWaWV3XG4gICAgICA/IGAtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1zdGF0aWMtJHt0LnJlcGxhY2UoL1teYS16QS1aXS9naSwgXCJcIikudG9Mb3dlckNhc2UoKX0tJHt0LnJlcGxhY2UoXG4gICAgICAgICAgL1teMC05XS9naSxcbiAgICAgICAgICBcIlwiXG4gICAgICAgICl9OiAke2N9YFxuICAgICAgOiBgLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItJHt0LnJlcGxhY2UoL1teYS16QS1aXS9naSwgXCJcIikudG9Mb3dlckNhc2UoKX0tJHt0LnJlcGxhY2UoL1teMC05XS9naSwgXCJcIil9OiAke2N9YDtcbiAgICBpZiAobmF2aWdhdG9yLmNsaXBib2FyZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29sb3JDb2RlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJQYWdlIFVSTCBjb3BpZWQgdG8gY2xpcGJvYXJkOlwiICsgY29sb3JDb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvcHk6IFwiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoZXhUb1JHQihoKSB7XG4gICAgbGV0IHIgPSAwLFxuICAgICAgZyA9IDAsXG4gICAgICBiID0gMDtcblxuICAgIC8vIDMgZGlnaXRzXG4gICAgaWYgKGgubGVuZ3RoID09IDQpIHtcbiAgICAgIHIgPSBcIjB4XCIgKyBoWzFdICsgaFsxXTtcbiAgICAgIGcgPSBcIjB4XCIgKyBoWzJdICsgaFsyXTtcbiAgICAgIGIgPSBcIjB4XCIgKyBoWzNdICsgaFszXTtcblxuICAgICAgLy8gNiBkaWdpdHNcbiAgICB9IGVsc2UgaWYgKGgubGVuZ3RoID09IDcpIHtcbiAgICAgIHIgPSBcIjB4XCIgKyBoWzFdICsgaFsyXTtcbiAgICAgIGcgPSBcIjB4XCIgKyBoWzNdICsgaFs0XTtcbiAgICAgIGIgPSBcIjB4XCIgKyBoWzVdICsgaFs2XTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJyZ2IoXCIgKyArciArIFwiLFwiICsgK2cgKyBcIixcIiArICtiICsgXCIpXCI7XG4gIH1cblxuICBmdW5jdGlvbiBoZXhUb0hTTChIKSB7XG4gICAgbGV0IHIgPSAwLFxuICAgICAgZyA9IDAsXG4gICAgICBiID0gMDtcbiAgICBpZiAoSC5sZW5ndGggPT0gNCkge1xuICAgICAgciA9IFwiMHhcIiArIEhbMV0gKyBIWzFdO1xuICAgICAgZyA9IFwiMHhcIiArIEhbMl0gKyBIWzJdO1xuICAgICAgYiA9IFwiMHhcIiArIEhbM10gKyBIWzNdO1xuICAgIH0gZWxzZSBpZiAoSC5sZW5ndGggPT0gNykge1xuICAgICAgciA9IFwiMHhcIiArIEhbMV0gKyBIWzJdO1xuICAgICAgZyA9IFwiMHhcIiArIEhbM10gKyBIWzRdO1xuICAgICAgYiA9IFwiMHhcIiArIEhbNV0gKyBIWzZdO1xuICAgIH1cbiAgICAvLyBUaGVuIHRvIEhTTFxuICAgIHIgLz0gMjU1O1xuICAgIGcgLz0gMjU1O1xuICAgIGIgLz0gMjU1O1xuICAgIGxldCBjbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBjbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IGNtYXggLSBjbWluLFxuICAgICAgaCA9IDAsXG4gICAgICBzID0gMCxcbiAgICAgIGwgPSAwO1xuXG4gICAgaWYgKGRlbHRhID09IDApIGggPSAwO1xuICAgIGVsc2UgaWYgKGNtYXggPT0gcikgaCA9ICgoZyAtIGIpIC8gZGVsdGEpICUgNjtcbiAgICBlbHNlIGlmIChjbWF4ID09IGcpIGggPSAoYiAtIHIpIC8gZGVsdGEgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBkZWx0YSArIDQ7XG5cbiAgICBoID0gTWF0aC5yb3VuZChoICogNjApO1xuXG4gICAgaWYgKGggPCAwKSBoICs9IDM2MDtcblxuICAgIGwgPSAoY21heCArIGNtaW4pIC8gMjtcbiAgICBzID0gZGVsdGEgPT0gMCA/IDAgOiBkZWx0YSAvICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSk7XG4gICAgcyA9ICsocyAqIDEwMCkudG9GaXhlZCgxKTtcbiAgICBsID0gKyhsICogMTAwKS50b0ZpeGVkKDEpO1xuXG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpZ2h0QW5kRGFyayhjb2RlKSB7XG4gICAgbGV0IFssICwgbF0gPSBoZXhUb0hTTChjb2RlKTtcbiAgICBsZXQgY3Jvc3NvdmVyID0gNTA7XG4gICAgc3dpdGNoICgkcnVidXNEb2NDb25maWcudGhlbWUpIHtcbiAgICAgIGNhc2UgXCJsaWdodFwiOlxuICAgICAgICBjcm9zc292ZXIgPSA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGlnaHRlc3RcIjpcbiAgICAgICAgY3Jvc3NvdmVyID0gNzA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRhcmtcIjpcbiAgICAgICAgY3Jvc3NvdmVyID0gMzg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRhcmtlc3RcIjpcbiAgICAgICAgY3Jvc3NvdmVyID0gMzU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbCA+PSBjcm9zc292ZXIgPyBmYWxzZSA6IHRydWU7XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC50b29sYmFyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHdpZHRoOiAzMDBweDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuICBmb3JtIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICB9XG4gIC52ZXJ0aWNhbC1saW5lIHtcbiAgICB3aWR0aDogMXB4O1xuICAgIGhlaWdodDogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1hbGlhcy1iYWNrZ3JvdW5kLWNvbG9yLWRlZmF1bHQpO1xuICB9XG4gIC5jb2xvci1tb2RlbCB7XG4gICAgd2lkdGg6IDEyMHB4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgfVxuICAuY29sb3ItY29udGFpbmVyIHtcbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgcGFkZGluZy10b3A6IDMycHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktMTAwKTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItZ3JheS0zMDApO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgfVxuICAuY29sb3ItZ3JvdXAge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIG1heC13aWR0aDogODE2cHg7XG4gICAgbWFyZ2luOiBhdXRvO1xuICAgIG1hcmdpbi1ib3R0b206IDMwcHg7XG4gIH1cbiAgLmNvbG9yLWl0ZW0ge1xuICAgIGZsZXgtYmFzaXM6IDIyJTtcbiAgICBoZWlnaHQ6IDEwMHB4O1xuICAgIG1hcmdpbjogMS41JTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBwYWRkaW5nOiAxMHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTIwMCk7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDEzMG1zIGVhc2UtaW4tb3V0O1xuICB9XG4gIC5jb2xvci1pdGVtOmhvdmVyIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDgpO1xuICB9XG4gIC5jb2xvci1pdGVtLW5hbWUge1xuICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICBsaW5lLWhlaWdodDogMS4zO1xuICAgIGxldHRlci1zcGFjaW5nOiAwLjAzZW07XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cbiAgLmNvbG9yLWl0ZW0tY29kZSB7XG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICBsaW5lLWhlaWdodDogMS4zO1xuICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgfVxuICAuY29sb3ItaXRlbS1saWdodCA+IC5jb2xvci1pdGVtLW5hbWUge1xuICAgIGNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLWdyYXktODAwKTtcbiAgfVxuICAuY29sb3ItaXRlbS1saWdodCA+IC5jb2xvci1pdGVtLWNvZGUge1xuICAgIGNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLWdyYXktOTAwKTtcbiAgfVxuICAuY29sb3ItaXRlbS1kYXJrID4gLmNvbG9yLWl0ZW0tbmFtZSB7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1zdGF0aWMtZ3JheS0yMDApO1xuICB9XG4gIC5jb2xvci1pdGVtLWRhcmsgPiAuY29sb3ItaXRlbS1jb2RlIHtcbiAgICBjb2xvcjogdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLXN0YXRpYy1ncmF5LTEwMCk7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJ0b29sYmFyXCI+XG4gIDxmb3JtPlxuICAgIDxDaGVja2JveCBjaGVja2VkPXtzdGF0aWNDb2xvcnNWaWV3fSBvbjpjbGljaz17aGFuZGxlQ2xpY2t9PlN0YXRpYyBjb2xvcnM8L0NoZWNrYm94PlxuICA8L2Zvcm0+XG4gIDxkaXYgY2xhc3M9XCJ2ZXJ0aWNhbC1saW5lXCIgLz5cbiAgPGZvcm0gY2xhc3M9XCJjb2xvci1tb2RlbFwiPlxuICAgIDxSYWRpb1xuICAgICAgdmFsdWU9XCJIZXhcIlxuICAgICAgY2hlY2tlZD17Y29sb3JNb2RlbCA9PSAnaGV4J31cbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGNvbG9yTW9kZWwgPSAnaGV4JztcbiAgICAgIH19IC8+XG4gICAgPFJhZGlvXG4gICAgICB2YWx1ZT1cIlJHQlwiXG4gICAgICBjaGVja2VkPXtjb2xvck1vZGVsID09ICdyZ2InfVxuICAgICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgICAgY29sb3JNb2RlbCA9ICdyZ2InO1xuICAgICAgfX0gLz5cbiAgPC9mb3JtPlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwiY29sb3ItY29udGFpbmVyXCI+XG4gIHsjZWFjaCBjb2xvckRhdGFbJHJ1YnVzRG9jQ29uZmlnLnRoZW1lXVtjb2xvckRpc3BsYXldIGFzIGl0ZW1zfVxuICAgIDxkaXYgY2xhc3M9XCJjb2xvci1ncm91cFwiPlxuICAgICAgeyNlYWNoIGl0ZW1zIGFzIGNvbG9ySXRlbX1cbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICBjb3B5Q29sb3IoY29sb3JJdGVtLm5hbWUsIGNvbG9ySXRlbS5jb2RlKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGNsYXNzPVwiY29sb3ItaXRlbSB7bGlnaHRBbmREYXJrKGNvbG9ySXRlbS5jb2RlKSA/ICdjb2xvci1pdGVtLWRhcmsnIDogJ2NvbG9yLWl0ZW0tbGlnaHQnfVwiXG4gICAgICAgICAgc3R5bGU9e2BiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3JNb2RlbCA9PSAnaGV4JyA/IGNvbG9ySXRlbS5jb2RlLnRvVXBwZXJDYXNlKCkgOiBoZXhUb1JHQihjb2xvckl0ZW0uY29kZSkudG9VcHBlckNhc2UoKX1gfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sb3ItaXRlbS1uYW1lXCI+e2NvbG9ySXRlbS5uYW1lfTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2xvci1pdGVtLWNvZGVcIj5cbiAgICAgICAgICAgIHtjb2xvck1vZGVsID09ICdoZXgnID8gY29sb3JJdGVtLmNvZGUudG9VcHBlckNhc2UoKSA6IGhleFRvUkdCKGNvbG9ySXRlbS5jb2RlKS50b1VwcGVyQ2FzZSgpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxUb29sdGlwIGxhYmVsPVwi54K55Ye75aSN5Yi2XCIgaW5kdWNlU3RhcnRFdmVudE5hbWU9XCJjbGlja1wiIGluZHVjZUVuZEV2ZW50TmFtZT1cImNsaWNrXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgVHlwb2dyYXBoeUhlYWRpbmcsIFR5cG9ncmFwaHlCb2R5IH0gZnJvbSBcIkBydWJ1cy9ydWJ1cy9zcmNcIjtcbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IENvbG9yQ29udGFpbmVyIGZyb20gXCIuLi8uLi8uLi8uLi9jb21wb25lbnRzL2NvbG9yLWNvbnRhaW5lclwiO1xuICBsZXQgcnVidXNEb2NDb25maWcgPSBnZXRDb250ZXh0KFwicnVidXNEb2NDb25maWdcIik7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBoZWFkZXIge1xuICAgIG1pbi1oZWlnaHQ6IDEyMHB4O1xuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT57JHJ1YnVzRG9jQ29uZmlnLm5hbWV9IOminOiJsjwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48aGVhZGVyPlxuICA8VHlwb2dyYXBoeUhlYWRpbmcgc2NhbGU9XCJYTFwiPuminOiJsjwvVHlwb2dyYXBoeUhlYWRpbmc+XG4gIDxUeXBvZ3JhcGh5Qm9keSBzY2FsZT1cIk1cIiBsaW5lSGVpZ2h0PVwic2l6ZS00MDBcIj7kvY3kuo7orr7orqHns7vnu5/kuK3nmoTpopzoibLku6TniYw8L1R5cG9ncmFwaHlCb2R5PlxuPC9oZWFkZXI+XG5cbjxtYWluPlxuICA8Q29sb3JDb250YWluZXIgLz5cbjwvbWFpbj5cbiJdLCJuYW1lcyI6WyJ0aGlzIiwiUmVzaXplT2JzZXJ2ZXIiLCJ0aHJvdHRsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBNENPLEdBQUssUUFBSyxHQUFHO2dCQU1SLEdBQUssUUFBSyxHQUFHOzs7Ozs7O2dDQVpYLEdBQVM7a0JBQ2pCLEdBQVc7O3NDQUNSLEdBQUssY0FBSSxHQUFFLGdCQUFJLEdBQUk7Ozt5Q0FDbEIsR0FBTSxjQUFJLEdBQUUsZ0JBQUksR0FBSTs7Ozs2REFFTixHQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OERBTG5CLEdBQVM7bURBQ2pCLEdBQVc7aUZBQ1IsR0FBSyxjQUFJLEdBQUUsZ0JBQUksR0FBSTtzRkFDbEIsR0FBTSxjQUFJLEdBQUUsZ0JBQUksR0FBSTs7dUdBRU4sR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BekNwQixLQUFLLEdBQUcsR0FBRztPQUNYLFNBQVMsR0FBRyxFQUFFO09BQ2QsS0FBSyxHQUFHLEVBQUU7T0FDVixNQUFNLEdBQUcsRUFBRTtPQUNYLFNBQVMsR0FBRyxnQkFBZ0I7S0FDbkMsSUFBSTtLQUNKLEVBQUU7S0FDRixFQUFFO0tBRUYsSUFBSSxHQUFHLEVBQUU7O0NBQ2IsT0FBTztNQUNELElBQUk7bUJBQ04sRUFBRSxHQUFHLElBQUksQ0FBQyxx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
