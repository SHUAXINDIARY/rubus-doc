import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as create_slot, P as compute_rest_props, v as validate_slots, z as afterUpdate, T as assign, U as exclude_internal_props, f as element, h as claim_element, j as children, l as detach_dev, p as attr_dev, q as add_location, r as insert_dev, y as update_slot, t as transition_in, b as transition_out, Q as index, R as onDestroy, C as space, D as claim_space, W as set_attributes, u as append_dev, X as listen_dev, Z as get_spread_update, _ as run_all, G as binding_callbacks, A as current_component, B as getEventsAction, L as empty, M as group_outros, N as check_outros, E as toggle_class, F as action_destroyer, H as stores$1, I as validate_store, J as component_subscribe, a2 as getContext, o as onMount, K as validate_each_argument, c as create_component, a4 as query_selector_all, a as claim_component, m as mount_component, e as destroy_component, g as text, k as claim_text, O as destroy_each, n as noop } from './client.819062b1.js';
import { i as index_umd } from './index.umd.37669cb5.js';
import { T as TypographyHeading, a as TypographyBody } from './TypographyHeading.aded6356.js';

function integrateProps(a) {
  let keys = Object.getOwnPropertyNames(a);
  let arr = [];
  for (let index = 0; index < keys.length; index++) {
    arr[index] = keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() + ":" + a[keys[index]] + ";";
  }
  return arr.filter(Boolean).join("");
}
function integrateDimensionProps(a) {
  let keys = Object.getOwnPropertyNames(a);
  let arr = [];
  for (let index = 0; index < keys.length; index++) {
    arr[index] =
      keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() +
      `:var(--spectrum-global-dimension-${a[keys[index]]}, var(--spectrum-alias-${a[keys[index]]}));`;
  }
  return arr.filter(Boolean).join("");
}

function integrateAutoProps(a) {
  let keys = Object.getOwnPropertyNames(a);
  let arr = [];
  for (let index = 0; index < keys.length; index++) {
    if (typeof a[keys[index]] == "string" && a[keys[index]].search("size") > -1) {
      if (a[keys[index]].search("-size") > -1) {
        arr[index] =
          keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() +
          `:calc(-1 * var(--spectrum-global-dimension-${a[keys[index]]}, var(--spectrum-alias-${a[keys[index]]})));`;
      } else {
        arr[index] =
          keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() +
          `:var(--spectrum-global-dimension-${a[keys[index]]}, var(--spectrum-alias-${a[keys[index]]}));`;
      }
    } else if (typeof a[keys[index]] == "string" && determineMode(a[keys[index]])) {
      arr[index] =
        keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() + `:var(--spectrum-global-color-${a[keys[index]]});`;
    } else {
      arr[index] = keys[index].replace(/([A-Z])/g, "-$1").toLowerCase() + ":" + a[keys[index]] + ";";
    }
  }
  return arr.filter(Boolean).join("");
}

function determineMode(t) {
  let colorKey = [
    "celery",
    "chartreuse",
    "yellow",
    "magenta",
    "fuchsia",
    "purple",
    "indigo",
    "seafoam",
    "red",
    "orange",
    "green",
    "blue",
    "gray",
  ];
  for (let index = 0; index < colorKey.length; index++) {
    if (t.search(colorKey[index]) != -1) {
      return true;
    }
  }
  return false;
}

/* node_modules/@rubus/rubus/src/packages/Layout/Flex.svelte generated by Svelte v3.29.4 */

const file = "node_modules/@rubus/rubus/src/packages/Layout/Flex.svelte";

function create_fragment(ctx) {
	let div;
	let div_style_value;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, style: true, class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", /*id*/ ctx[0]);
			attr_dev(div, "style", div_style_value = /*layoutCssText*/ ctx[1] + /*spacingCssText*/ ctx[2] + /*sizingCssText*/ ctx[3] + /*positioningCssText*/ ctx[4] + /*componentStyle*/ ctx[5]);
			attr_dev(div, "class", div_class_value = /*$$restProps*/ ctx[6].class);
			add_location(div, file, 113, 0, 3100);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*layoutCssText, spacingCssText, sizingCssText, positioningCssText, componentStyle*/ 62 && div_style_value !== (div_style_value = /*layoutCssText*/ ctx[1] + /*spacingCssText*/ ctx[2] + /*sizingCssText*/ ctx[3] + /*positioningCssText*/ ctx[4] + /*componentStyle*/ ctx[5])) {
				attr_dev(div, "style", div_style_value);
			}

			if (!current || dirty & /*$$restProps*/ 64 && div_class_value !== (div_class_value = /*$$restProps*/ ctx[6].class)) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"id","display","direction","wrap","justifyContent","alignContent","alignItems","gap","columnGap","rowGap","layout","spacing","sizing","positioning"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Flex", slots, ['default']);
	let { id = "" } = $$props;
	let { display = "flex" } = $$props;
	let { direction = "row" } = $$props;
	let { wrap = "" } = $$props;
	let { justifyContent = "" } = $$props;
	let { alignContent = "" } = $$props;
	let { alignItems = "" } = $$props;
	let { gap = "" } = $$props;
	let { columnGap = "" } = $$props;
	let { rowGap = "" } = $$props;
	let { layout = {} } = $$props;
	let { spacing = {} } = $$props;
	let { sizing = {} } = $$props;
	let { positioning = {} } = $$props;
	let layoutCssText = "";
	let spacingCssText = "";
	let sizingCssText = "";
	let positioningCssText = "";

	afterUpdate(() => {
		$$invalidate(1, layoutCssText = integrateProps(layout));
		$$invalidate(2, spacingCssText = integrateDimensionProps(spacing));
		$$invalidate(3, sizingCssText = integrateAutoProps(sizing));
		$$invalidate(4, positioningCssText = integrateAutoProps(positioning));
	});

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("display" in $$new_props) $$invalidate(7, display = $$new_props.display);
		if ("direction" in $$new_props) $$invalidate(8, direction = $$new_props.direction);
		if ("wrap" in $$new_props) $$invalidate(9, wrap = $$new_props.wrap);
		if ("justifyContent" in $$new_props) $$invalidate(10, justifyContent = $$new_props.justifyContent);
		if ("alignContent" in $$new_props) $$invalidate(11, alignContent = $$new_props.alignContent);
		if ("alignItems" in $$new_props) $$invalidate(12, alignItems = $$new_props.alignItems);
		if ("gap" in $$new_props) $$invalidate(13, gap = $$new_props.gap);
		if ("columnGap" in $$new_props) $$invalidate(14, columnGap = $$new_props.columnGap);
		if ("rowGap" in $$new_props) $$invalidate(15, rowGap = $$new_props.rowGap);
		if ("layout" in $$new_props) $$invalidate(16, layout = $$new_props.layout);
		if ("spacing" in $$new_props) $$invalidate(17, spacing = $$new_props.spacing);
		if ("sizing" in $$new_props) $$invalidate(18, sizing = $$new_props.sizing);
		if ("positioning" in $$new_props) $$invalidate(19, positioning = $$new_props.positioning);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		integrateProps,
		integrateAutoProps,
		integrateDimensionProps,
		id,
		display,
		direction,
		wrap,
		justifyContent,
		alignContent,
		alignItems,
		gap,
		columnGap,
		rowGap,
		layout,
		spacing,
		sizing,
		positioning,
		layoutCssText,
		spacingCssText,
		sizingCssText,
		positioningCssText,
		componentStyle
	});

	$$self.$inject_state = $$new_props => {
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("display" in $$props) $$invalidate(7, display = $$new_props.display);
		if ("direction" in $$props) $$invalidate(8, direction = $$new_props.direction);
		if ("wrap" in $$props) $$invalidate(9, wrap = $$new_props.wrap);
		if ("justifyContent" in $$props) $$invalidate(10, justifyContent = $$new_props.justifyContent);
		if ("alignContent" in $$props) $$invalidate(11, alignContent = $$new_props.alignContent);
		if ("alignItems" in $$props) $$invalidate(12, alignItems = $$new_props.alignItems);
		if ("gap" in $$props) $$invalidate(13, gap = $$new_props.gap);
		if ("columnGap" in $$props) $$invalidate(14, columnGap = $$new_props.columnGap);
		if ("rowGap" in $$props) $$invalidate(15, rowGap = $$new_props.rowGap);
		if ("layout" in $$props) $$invalidate(16, layout = $$new_props.layout);
		if ("spacing" in $$props) $$invalidate(17, spacing = $$new_props.spacing);
		if ("sizing" in $$props) $$invalidate(18, sizing = $$new_props.sizing);
		if ("positioning" in $$props) $$invalidate(19, positioning = $$new_props.positioning);
		if ("layoutCssText" in $$props) $$invalidate(1, layoutCssText = $$new_props.layoutCssText);
		if ("spacingCssText" in $$props) $$invalidate(2, spacingCssText = $$new_props.spacingCssText);
		if ("sizingCssText" in $$props) $$invalidate(3, sizingCssText = $$new_props.sizingCssText);
		if ("positioningCssText" in $$props) $$invalidate(4, positioningCssText = $$new_props.positioningCssText);
		if ("componentStyle" in $$props) $$invalidate(5, componentStyle = $$new_props.componentStyle);
	};

	let componentStyle;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*display, direction, wrap, justifyContent, alignContent, alignItems, gap, columnGap, rowGap*/ 65408) {
			 $$invalidate(5, componentStyle = [
				`display:${display};`,
				direction && `flex-direction:${direction};`,
				wrap && `flex-wrap:${wrap};`,
				justifyContent && `justify-content:${justifyContent};`,
				alignContent && `align-content:${alignContent}`,
				alignItems && `align-items:${alignItems}`,
				gap && `gap:var(--spectrum-global-dimension-${gap}, var(--spectrum-alias-${gap}));"`,
				columnGap && `column-gap:var(--spectrum-global-dimension-${columnGap}, var(--spectrum-alias-${columnGap}));"`,
				rowGap && `row-gap:var(--spectrum-global-dimension-${rowGap}, var(--spectrum-alias-${rowGap}));"`
			].filter(Boolean).join(""));
		}
	};

	return [
		id,
		layoutCssText,
		spacingCssText,
		sizingCssText,
		positioningCssText,
		componentStyle,
		$$restProps,
		display,
		direction,
		wrap,
		justifyContent,
		alignContent,
		alignItems,
		gap,
		columnGap,
		rowGap,
		layout,
		spacing,
		sizing,
		positioning,
		$$scope,
		slots
	];
}

class Flex extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			id: 0,
			display: 7,
			direction: 8,
			wrap: 9,
			justifyContent: 10,
			alignContent: 11,
			alignItems: 12,
			gap: 13,
			columnGap: 14,
			rowGap: 15,
			layout: 16,
			spacing: 17,
			sizing: 18,
			positioning: 19
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Flex",
			options,
			id: create_fragment.name
		});
	}

	get id() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get display() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set display(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrap() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrap(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get justifyContent() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set justifyContent(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alignContent() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alignContent(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alignItems() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alignItems(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gap() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gap(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get columnGap() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set columnGap(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rowGap() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rowGap(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set layout(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spacing() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spacing(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sizing() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sizing(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get positioning() {
		throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set positioning(value) {
		throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Tabs/Tabs.svelte generated by Svelte v3.29.4 */
const file$1 = "node_modules/@rubus/rubus/src/packages/Tabs/Tabs.svelte";

function create_fragment$1(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let div1_levels = [
		/*tabsProps*/ ctx[3],
		/*$$restProps*/ ctx[8],
		{ "aria-label": /*ariaLabel*/ ctx[1] },
		{
			"aria-orientation": /*orientation*/ ctx[0]
		}
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			div0 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", {
				"aria-label": true,
				"aria-orientation": true
			});

			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			children(div0).forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "spectrum-Tabs-selectionIndicator");
			attr_dev(div0, "style", /*selectionIndicatorSytle*/ ctx[4]);
			add_location(div0, file$1, 111, 2, 3096);
			set_attributes(div1, div1_data);
			add_location(div1, file$1, 101, 0, 2873);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div1, t);
			append_dev(div1, div0);
			/*div1_binding*/ ctx[13](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div1, "resize", /*getStyleAttributeValue*/ ctx[6], false, false, false),
					listen_dev(div1, "click", /*getPosition*/ ctx[5], false, false, false),
					listen_dev(div1, "keydown", /*handleKeydown*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			if (!current || dirty & /*selectionIndicatorSytle*/ 16) {
				attr_dev(div0, "style", /*selectionIndicatorSytle*/ ctx[4]);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				dirty & /*tabsProps*/ 8 && /*tabsProps*/ ctx[3],
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*ariaLabel*/ 2) && { "aria-label": /*ariaLabel*/ ctx[1] },
				(!current || dirty & /*orientation*/ 1) && {
					"aria-orientation": /*orientation*/ ctx[0]
				}
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["orientation","ariaLabel","isQuiet","isCompact"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tabs", slots, ['default']);
	let { orientation = "horizontal" } = $$props;
	let { ariaLabel = "tabList" } = $$props;
	let { isQuiet = false } = $$props;
	let { isCompact = false } = $$props;
	let selectedItemDimension;
	let tabs;
	let selectionIndicatorOffset;
	const observer = new index(getStyleAttributeValue);

	afterUpdate(() => {
		getStyleAttributeValue();
		index_umd.throttle(500, observer.observe(tabs));
	});

	onDestroy(() => {
		observer.unobserve(tabs);
	});

	function getPosition(e) {
		if (tabs.contains(e.target) && e.target.className.indexOf("spectrum-Tabs-item") != -1) {
			$$invalidate(14, selectedItemDimension = e.target.offsetWidth);
			$$invalidate(15, selectionIndicatorOffset = e.target.offsetLeft);
		}
	}

	function getStyleAttributeValue() {
		if (tabs) {
			const selectedItem = tabs.getElementsByClassName("is-selected");

			if (selectedItem.length == 1) {
				if (orientation == "horizontal") {
					$$invalidate(14, selectedItemDimension = selectedItem[0].offsetWidth);
					$$invalidate(15, selectionIndicatorOffset = selectedItem[0].offsetLeft);
				} else if (orientation == "vertical") {
					$$invalidate(14, selectedItemDimension = selectedItem[0].offsetHeight);
					$$invalidate(15, selectionIndicatorOffset = selectedItem[0].offsetTop);
				}
			}
		}
	}

	function handleKeydown(e) {
		let _e = event ? window.event : e;

		if (_e.keyCode == 13 || _e.keyCode == 32) {
			getPosition(e);
		}
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tabs = $$value;
			$$invalidate(2, tabs);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("orientation" in $$new_props) $$invalidate(0, orientation = $$new_props.orientation);
		if ("ariaLabel" in $$new_props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
		if ("isQuiet" in $$new_props) $$invalidate(9, isQuiet = $$new_props.isQuiet);
		if ("isCompact" in $$new_props) $$invalidate(10, isCompact = $$new_props.isCompact);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		ResizeObserver: index,
		throttle: index_umd.throttle,
		afterUpdate,
		onDestroy,
		orientation,
		ariaLabel,
		isQuiet,
		isCompact,
		selectedItemDimension,
		tabs,
		selectionIndicatorOffset,
		observer,
		getPosition,
		getStyleAttributeValue,
		handleKeydown,
		tabsProps,
		selectionIndicatorSytle
	});

	$$self.$inject_state = $$new_props => {
		if ("orientation" in $$props) $$invalidate(0, orientation = $$new_props.orientation);
		if ("ariaLabel" in $$props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
		if ("isQuiet" in $$props) $$invalidate(9, isQuiet = $$new_props.isQuiet);
		if ("isCompact" in $$props) $$invalidate(10, isCompact = $$new_props.isCompact);
		if ("selectedItemDimension" in $$props) $$invalidate(14, selectedItemDimension = $$new_props.selectedItemDimension);
		if ("tabs" in $$props) $$invalidate(2, tabs = $$new_props.tabs);
		if ("selectionIndicatorOffset" in $$props) $$invalidate(15, selectionIndicatorOffset = $$new_props.selectionIndicatorOffset);
		if ("tabsProps" in $$props) $$invalidate(3, tabsProps = $$new_props.tabsProps);
		if ("selectionIndicatorSytle" in $$props) $$invalidate(4, selectionIndicatorSytle = $$new_props.selectionIndicatorSytle);
	};

	let tabsProps;
	let selectionIndicatorSytle;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*orientation, isQuiet, isCompact*/ 1537) {
			 $$invalidate(3, tabsProps = {
				role: "tabList",
				class: [
					"spectrum-Tabs",
					orientation && `spectrum-Tabs--${orientation}`,
					isQuiet && "spectrum-Tabs--quiet",
					isCompact && "spectrum-Tabs--compact"
				].filter(Boolean).join(" ")
			});
		}

		if ($$self.$$.dirty & /*orientation, selectedItemDimension, selectionIndicatorOffset*/ 49153) {
			 $$invalidate(4, selectionIndicatorSytle = [
				orientation === "vertical" && `height: ${selectedItemDimension}px;`,
				orientation === "horizontal" && `width: ${selectedItemDimension}px;`,
				orientation === "vertical" && `transform:translateY(${selectionIndicatorOffset}px);`,
				orientation === "horizontal" && `transform:translateX(${!selectionIndicatorOffset
				? "var(--spectrum-tabs-focus-ring-padding-x, var(--spectrum-global-dimension-size-100)"
				: selectionIndicatorOffset + "px"});`
			].filter(Boolean).join(" "));
		}
	};

	return [
		orientation,
		ariaLabel,
		tabs,
		tabsProps,
		selectionIndicatorSytle,
		getPosition,
		getStyleAttributeValue,
		handleKeydown,
		$$restProps,
		isQuiet,
		isCompact,
		$$scope,
		slots,
		div1_binding
	];
}

class Tabs extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			orientation: 0,
			ariaLabel: 1,
			isQuiet: 9,
			isCompact: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tabs",
			options,
			id: create_fragment$1.name
		});
	}

	get orientation() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orientation(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isCompact() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isCompact(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Tabs/Tab.svelte generated by Svelte v3.29.4 */
const file$2 = "node_modules/@rubus/rubus/src/packages/Tabs/Tab.svelte";
const get_tab_icon_slot_changes_1 = dirty => ({});
const get_tab_icon_slot_context_1 = ctx => ({});
const get_tab_icon_slot_changes = dirty => ({});
const get_tab_icon_slot_context = ctx => ({});

// (106:0) {:else}
function create_else_block(ctx) {
	let div;
	let t;
	let span;
	let div_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const tab_icon_slot_template = /*#slots*/ ctx[12]["tab-icon"];
	const tab_icon_slot = create_slot(tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], get_tab_icon_slot_context_1);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let div_levels = [
		/*$$restProps*/ ctx[9],
		{
			class: div_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
			? "not-allowed"
			: "")
		},
		{ tabindex: "0" }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (tab_icon_slot) tab_icon_slot.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, tabindex: true });
			var div_nodes = children(div);
			if (tab_icon_slot) tab_icon_slot.l(div_nodes);
			t = claim_space(div_nodes);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "spectrum-Tabs-itemLabel");
			add_location(span, file$2, 116, 4, 5728);
			set_attributes(div, div_data);
			toggle_class(div, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(div, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
			add_location(div, file$2, 106, 2, 5392);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (tab_icon_slot) {
				tab_icon_slot.m(div, null);
			}

			append_dev(div, t);
			append_dev(div, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "click", /*switchTab*/ ctx[7], false, false, false),
					listen_dev(div, "keydown", /*handleKeydown*/ ctx[8], false, false, false),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[6].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (tab_icon_slot) {
				if (tab_icon_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(tab_icon_slot, tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_tab_icon_slot_changes_1, get_tab_icon_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*disabled, notAllowed*/ 12 && div_class_value !== (div_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
				? "not-allowed"
				: ""))) && { class: div_class_value },
				{ tabindex: "0" }
			]));

			toggle_class(div, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(div, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (tab_icon_slot) tab_icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(106:0) {:else}",
		ctx
	});

	return block;
}

// (89:0) {#if href}
function create_if_block(ctx) {
	let a;
	let t;
	let span;
	let a_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const tab_icon_slot_template = /*#slots*/ ctx[12]["tab-icon"];
	const tab_icon_slot = create_slot(tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], get_tab_icon_slot_context);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let a_levels = [
		{ href: /*href*/ ctx[4] },
		{ target: /*target*/ ctx[5] },
		/*$$restProps*/ ctx[9],
		{
			class: a_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
			? "not-allowed"
			: "")
		},
		{ tabindex: "0" }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (tab_icon_slot) tab_icon_slot.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", {
				href: true,
				target: true,
				class: true,
				tabindex: true
			});

			var a_nodes = children(a);
			if (tab_icon_slot) tab_icon_slot.l(a_nodes);
			t = claim_space(a_nodes);
			span = claim_element(a_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "spectrum-Tabs-itemLabel");
			add_location(span, file$2, 101, 4, 5309);
			set_attributes(a, a_data);
			toggle_class(a, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(a, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
			add_location(a, file$2, 89, 2, 4951);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (tab_icon_slot) {
				tab_icon_slot.m(a, null);
			}

			append_dev(a, t);
			append_dev(a, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a, "click", /*switchTab*/ ctx[7], false, false, false),
					listen_dev(a, "keydown", /*handleKeydown*/ ctx[8], false, false, false),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[6].call(null, a))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (tab_icon_slot) {
				if (tab_icon_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(tab_icon_slot, tab_icon_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_tab_icon_slot_changes, get_tab_icon_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 16) && { href: /*href*/ ctx[4] },
				(!current || dirty & /*target*/ 32) && { target: /*target*/ ctx[5] },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*disabled, notAllowed*/ 12 && a_class_value !== (a_class_value = "spectrum-Tabs-item " + (/*disabled*/ ctx[2] && /*notAllowed*/ ctx[3]
				? "not-allowed"
				: ""))) && { class: a_class_value },
				{ tabindex: "0" }
			]));

			toggle_class(a, "spectrum-Tabs-item-disabled", /*disabled*/ ctx[2]);
			toggle_class(a, "is-selected", +/*selfIndex*/ ctx[1] === +/*currentTabIndex*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (tab_icon_slot) tab_icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(89:0) {#if href}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"currentTabIndex","selfIndex","tabAutoSwitch","disabled","notAllowed","href","target"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tab", slots, ['tab-icon','default']);
	let { currentTabIndex = 0 } = $$props;
	let { selfIndex = 0 } = $$props;
	let { tabAutoSwitch = true } = $$props;
	let { disabled = false } = $$props;
	let { notAllowed = false } = $$props;
	let { href = "" } = $$props;
	let { target = "" } = $$props;
	const eventsListen = getEventsAction(current_component);

	function switchTab() {
		if (tabAutoSwitch && !disabled) {
			return $$invalidate(0, currentTabIndex = selfIndex);
		}
	}

	function handleKeydown(e) {
		let _e = event ? window.event : e;

		if (_e.keyCode == 13 || _e.keyCode == 32) {
			switchTab();
		}
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("currentTabIndex" in $$new_props) $$invalidate(0, currentTabIndex = $$new_props.currentTabIndex);
		if ("selfIndex" in $$new_props) $$invalidate(1, selfIndex = $$new_props.selfIndex);
		if ("tabAutoSwitch" in $$new_props) $$invalidate(10, tabAutoSwitch = $$new_props.tabAutoSwitch);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("notAllowed" in $$new_props) $$invalidate(3, notAllowed = $$new_props.notAllowed);
		if ("href" in $$new_props) $$invalidate(4, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(5, target = $$new_props.target);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		current_component,
		getEventsAction,
		currentTabIndex,
		selfIndex,
		tabAutoSwitch,
		disabled,
		notAllowed,
		href,
		target,
		eventsListen,
		switchTab,
		handleKeydown
	});

	$$self.$inject_state = $$new_props => {
		if ("currentTabIndex" in $$props) $$invalidate(0, currentTabIndex = $$new_props.currentTabIndex);
		if ("selfIndex" in $$props) $$invalidate(1, selfIndex = $$new_props.selfIndex);
		if ("tabAutoSwitch" in $$props) $$invalidate(10, tabAutoSwitch = $$new_props.tabAutoSwitch);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("notAllowed" in $$props) $$invalidate(3, notAllowed = $$new_props.notAllowed);
		if ("href" in $$props) $$invalidate(4, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(5, target = $$new_props.target);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		currentTabIndex,
		selfIndex,
		disabled,
		notAllowed,
		href,
		target,
		eventsListen,
		switchTab,
		handleKeydown,
		$$restProps,
		tabAutoSwitch,
		$$scope,
		slots
	];
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			currentTabIndex: 0,
			selfIndex: 1,
			tabAutoSwitch: 10,
			disabled: 2,
			notAllowed: 3,
			href: 4,
			target: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tab",
			options,
			id: create_fragment$2.name
		});
	}

	get currentTabIndex() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentTabIndex(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selfIndex() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selfIndex(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabAutoSwitch() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabAutoSwitch(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get notAllowed() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set notAllowed(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/docs/basic/button/_layout.svelte generated by Svelte v3.29.4 */
const file$3 = "src/routes/docs/basic/button/_layout.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

// (45:2) <TypographyHeading scale="XL">
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Button");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Button");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(45:2) <TypographyHeading scale=\\\"XL\\\">",
		ctx
	});

	return block;
}

// (47:4) <TypographyBody scale="M">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("常规按钮组件，一般用于给定用户操作提供选项");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "常规按钮组件，一般用于给定用户操作提供选项");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(47:4) <TypographyBody scale=\\\"M\\\">",
		ctx
	});

	return block;
}

// (46:2) <Flex spacing={{ height: 'size-600' }} alignItems="center">
function create_default_slot_2(ctx) {
	let typographybody;
	let current;

	typographybody = new TypographyBody({
			props: {
				scale: "M",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(typographybody.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(typographybody.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(typographybody, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const typographybody_changes = {};

			if (dirty & /*$$scope*/ 256) {
				typographybody_changes.$$scope = { dirty, ctx };
			}

			typographybody.$set(typographybody_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typographybody.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typographybody.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(typographybody, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(46:2) <Flex spacing={{ height: 'size-600' }} alignItems=\\\"center\\\">",
		ctx
	});

	return block;
}

// (53:6) <Tab         selfIndex={i}         {currentTabIndex}         href={tab.url}         on:click={() => {           currentTabIndex = i;         }}>
function create_default_slot_1(ctx) {
	let t0_value = /*tab*/ ctx[11].name + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(53:6) <Tab         selfIndex={i}         {currentTabIndex}         href={tab.url}         on:click={() => {           currentTabIndex = i;         }}>",
		ctx
	});

	return block;
}

// (52:4) {#each tabList as tab, i}
function create_each_block(ctx) {
	let tab;
	let current;

	function click_handler(...args) {
		return /*click_handler*/ ctx[7](/*i*/ ctx[13], ...args);
	}

	tab = new Tab({
			props: {
				selfIndex: /*i*/ ctx[13],
				currentTabIndex: /*currentTabIndex*/ ctx[0],
				href: /*tab*/ ctx[11].url,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	tab.$on("click", click_handler);

	const block = {
		c: function create() {
			create_component(tab.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(tab.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(tab, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const tab_changes = {};
			if (dirty & /*currentTabIndex*/ 1) tab_changes.currentTabIndex = /*currentTabIndex*/ ctx[0];

			if (dirty & /*$$scope*/ 256) {
				tab_changes.$$scope = { dirty, ctx };
			}

			tab.$set(tab_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tab, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(52:4) {#each tabList as tab, i}",
		ctx
	});

	return block;
}

// (51:2) <Tabs>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*tabList*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currentTabIndex, tabList*/ 17) {
				each_value = /*tabList*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(51:2) <Tabs>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let title_value;
	let t0;
	let header;
	let typographyheading;
	let t1;
	let flex;
	let t2;
	let nav;
	let tabs;
	let t3;
	let main;
	let current;
	document.title = title_value = "" + (/*$rubusDocConfig*/ ctx[1].name + " Button");

	typographyheading = new TypographyHeading({
			props: {
				scale: "XL",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	flex = new Flex({
			props: {
				spacing: { height: "size-600" },
				alignItems: "center",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	tabs = new Tabs({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	const block = {
		c: function create() {
			t0 = space();
			header = element("header");
			create_component(typographyheading.$$.fragment);
			t1 = space();
			create_component(flex.$$.fragment);
			t2 = space();
			nav = element("nav");
			create_component(tabs.$$.fragment);
			t3 = space();
			main = element("main");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-an9x59\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			claim_component(typographyheading.$$.fragment, header_nodes);
			t1 = claim_space(header_nodes);
			claim_component(flex.$$.fragment, header_nodes);
			header_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			claim_component(tabs.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			if (default_slot) default_slot.l(main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-1f9x9sc");
			add_location(header, file$3, 43, 0, 1481);
			add_location(nav, file$3, 49, 0, 1700);
			attr_dev(main, "class", "svelte-1f9x9sc");
			add_location(main, file$3, 65, 0, 1958);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, header, anchor);
			mount_component(typographyheading, header, null);
			append_dev(header, t1);
			mount_component(flex, header, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, nav, anchor);
			mount_component(tabs, nav, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, main, anchor);

			if (default_slot) {
				default_slot.m(main, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*$rubusDocConfig*/ 2) && title_value !== (title_value = "" + (/*$rubusDocConfig*/ ctx[1].name + " Button"))) {
				document.title = title_value;
			}

			const typographyheading_changes = {};

			if (dirty & /*$$scope*/ 256) {
				typographyheading_changes.$$scope = { dirty, ctx };
			}

			typographyheading.$set(typographyheading_changes);
			const flex_changes = {};

			if (dirty & /*$$scope*/ 256) {
				flex_changes.$$scope = { dirty, ctx };
			}

			flex.$set(flex_changes);
			const tabs_changes = {};

			if (dirty & /*$$scope, currentTabIndex*/ 257) {
				tabs_changes.$$scope = { dirty, ctx };
			}

			tabs.$set(tabs_changes);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typographyheading.$$.fragment, local);
			transition_in(flex.$$.fragment, local);
			transition_in(tabs.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typographyheading.$$.fragment, local);
			transition_out(flex.$$.fragment, local);
			transition_out(tabs.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(header);
			destroy_component(typographyheading);
			destroy_component(flex);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(nav);
			destroy_component(tabs);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(main);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $page;
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Layout", slots, ['default']);
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(9, $page = value));
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(1, $rubusDocConfig = value));
	let { segment } = $$props;

	let tabList = [
		{
			name: "用法",
			url: "docs/basic/button/usage"
		},
		{
			name: "Props",
			url: "docs/basic/button/props"
		},
		{
			name: "用例",
			url: "docs/basic/button/examples"
		},
		{
			name: "问题",
			url: "docs/basic/button/issues"
		}
	];

	let currentTabIndex = 0;

	function tabCurrentTabIndex() {
		for (let index = 0; index < tabList.length; index++) {
			if ($page.path.substr(1) == tabList[index].url) {
				$$invalidate(0, currentTabIndex = index);
			}
		}
	}

	onMount(() => {
		tabCurrentTabIndex();
	});

	const writable_props = ["segment"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	const click_handler = i => {
		$$invalidate(0, currentTabIndex = i);
	};

	$$self.$$set = $$props => {
		if ("segment" in $$props) $$invalidate(5, segment = $$props.segment);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		TypographyHeading,
		Flex,
		TypographyBody,
		Tab,
		Tabs,
		onMount,
		getContext,
		stores: stores$1,
		page,
		rubusDocConfig,
		segment,
		tabList,
		currentTabIndex,
		tabCurrentTabIndex,
		$page,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("rubusDocConfig" in $$props) $$invalidate(3, rubusDocConfig = $$props.rubusDocConfig);
		if ("segment" in $$props) $$invalidate(5, segment = $$props.segment);
		if ("tabList" in $$props) $$invalidate(4, tabList = $$props.tabList);
		if ("currentTabIndex" in $$props) $$invalidate(0, currentTabIndex = $$props.currentTabIndex);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		currentTabIndex,
		$rubusDocConfig,
		page,
		rubusDocConfig,
		tabList,
		segment,
		slots,
		click_handler,
		$$scope
	];
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { segment: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*segment*/ ctx[5] === undefined && !("segment" in props)) {
			console.warn("<Layout> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Layout;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2xheW91dC5iNDk2YjVjNS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BydWJ1cy9ydWJ1cy9zcmMvcGFja2FnZXMvdXRpbHMvaW50ZWdyYXRlLXN0eWxlLXByb3BzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BydWJ1cy9ydWJ1cy9zcmMvcGFja2FnZXMvTGF5b3V0L0ZsZXguc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BydWJ1cy9ydWJ1cy9zcmMvcGFja2FnZXMvVGFicy9UYWJzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1RhYnMvVGFiLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9iYXNpYy9idXR0b24vX2xheW91dC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaW50ZWdyYXRlUHJvcHMoYSkge1xuICBsZXQga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGEpO1xuICBsZXQgYXJyID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBrZXlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGFycltpbmRleF0gPSBrZXlzW2luZGV4XS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkgKyBcIjpcIiArIGFba2V5c1tpbmRleF1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGFyci5maWx0ZXIoQm9vbGVhbikuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGludGVncmF0ZURpbWVuc2lvblByb3BzKGEpIHtcbiAgbGV0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhKTtcbiAgbGV0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwga2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBhcnJbaW5kZXhdID1cbiAgICAgIGtleXNbaW5kZXhdLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSArXG4gICAgICBgOnZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tJHthW2tleXNbaW5kZXhdXX0sIHZhcigtLXNwZWN0cnVtLWFsaWFzLSR7YVtrZXlzW2luZGV4XV19KSk7YDtcbiAgfVxuICByZXR1cm4gYXJyLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBpbnRlZ3JhdGVBdXRvUHJvcHMoYSkge1xuICBsZXQga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGEpO1xuICBsZXQgYXJyID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBrZXlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmICh0eXBlb2YgYVtrZXlzW2luZGV4XV0gPT0gXCJzdHJpbmdcIiAmJiBhW2tleXNbaW5kZXhdXS5zZWFyY2goXCJzaXplXCIpID4gLTEpIHtcbiAgICAgIGlmIChhW2tleXNbaW5kZXhdXS5zZWFyY2goXCItc2l6ZVwiKSA+IC0xKSB7XG4gICAgICAgIGFycltpbmRleF0gPVxuICAgICAgICAgIGtleXNbaW5kZXhdLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgYDpjYWxjKC0xICogdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi0ke2Fba2V5c1tpbmRleF1dfSwgdmFyKC0tc3BlY3RydW0tYWxpYXMtJHthW2tleXNbaW5kZXhdXX0pKSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycltpbmRleF0gPVxuICAgICAgICAgIGtleXNbaW5kZXhdLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgYDp2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLSR7YVtrZXlzW2luZGV4XV19LCB2YXIoLS1zcGVjdHJ1bS1hbGlhcy0ke2Fba2V5c1tpbmRleF1dfSkpO2A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYVtrZXlzW2luZGV4XV0gPT0gXCJzdHJpbmdcIiAmJiBkZXRlcm1pbmVNb2RlKGFba2V5c1tpbmRleF1dKSkge1xuICAgICAgYXJyW2luZGV4XSA9XG4gICAgICAgIGtleXNbaW5kZXhdLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSArIGA6dmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLSR7YVtrZXlzW2luZGV4XV19KTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJbaW5kZXhdID0ga2V5c1tpbmRleF0ucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpICsgXCI6XCIgKyBhW2tleXNbaW5kZXhdXSArIFwiO1wiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNb2RlKHQpIHtcbiAgbGV0IGNvbG9yS2V5ID0gW1xuICAgIFwiY2VsZXJ5XCIsXG4gICAgXCJjaGFydHJldXNlXCIsXG4gICAgXCJ5ZWxsb3dcIixcbiAgICBcIm1hZ2VudGFcIixcbiAgICBcImZ1Y2hzaWFcIixcbiAgICBcInB1cnBsZVwiLFxuICAgIFwiaW5kaWdvXCIsXG4gICAgXCJzZWFmb2FtXCIsXG4gICAgXCJyZWRcIixcbiAgICBcIm9yYW5nZVwiLFxuICAgIFwiZ3JlZW5cIixcbiAgICBcImJsdWVcIixcbiAgICBcImdyYXlcIixcbiAgXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbG9yS2V5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmICh0LnNlYXJjaChjb2xvcktleVtpbmRleF0pICE9IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IHsgaW50ZWdyYXRlUHJvcHMsIGludGVncmF0ZUF1dG9Qcm9wcywgaW50ZWdyYXRlRGltZW5zaW9uUHJvcHMgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBpbnRlZ3JhdGVQcm9wcywgaW50ZWdyYXRlQXV0b1Byb3BzLCBpbnRlZ3JhdGVEaW1lbnNpb25Qcm9wcyB9IGZyb20gXCIuLi91dGlscy9pbnRlZ3JhdGUtc3R5bGUtcHJvcHMuanNcIjtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQncyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICogQHR5cGUgeyBzdHJpbmcgfSBbaWQ9XCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBUaGUgZGlzcGxheSBDU1MgcHJvcGVydHkgc2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgdHJlYXRlZCBhcyBhIGJsb2NrIG9yIGlubGluZSBlbGVtZW50IGFuZCB0aGUgbGF5b3V0IHVzZWQgZm9yIGl0cyBjaGlsZHJlblxuICAgKiBAdHlwZSB7IEZsZXhEaXNwbGF5IH0gW2Rpc3BsYXk9XCJmbGV4XCJdXG4gICAqICoqL1xuICBleHBvcnQgbGV0IGRpc3BsYXkgPSBcImZsZXhcIjtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gbGF5b3V0IGNoaWxkcmVuLlxuICAgKiBAdHlwZSB7IEZsZXhEaXJlY3Rpb24gfSBbZGlyZWN0aW9uPVwicm93XCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGRpcmVjdGlvbiA9IFwicm93XCI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd3JhcCBpdGVtcyBvbnRvIG11bHRpcGxlIGxpbmVzLlxuICAgKiBAdHlwZSB7IEZsZXhXcmFwIH0gW3dyYXAgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB3cmFwID0gXCJcIjtcblxuICAvKipcbiAgICogVGhlIGRpc3RyaWJ1dGlvbiBvZiBzcGFjZSBhcm91bmQgaXRlbXMgYWxvbmcgdGhlIG1haW4gYXhpcy5cbiAgICogQHR5cGUgeyBGbGV4SnVzdGlmeUNvbnRlbnQgfSBbanVzdGlmeUNvbnRlbnQgPSBcInN0YXJ0XCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGp1c3RpZnlDb250ZW50ID0gXCJcIjtcblxuICAvKipcbiAgICogVGhlIGRpc3RyaWJ1dGlvbiBvZiBzcGFjZSBhcm91bmQgY2hpbGQgaXRlbXMgYWxvbmcgdGhlIGNyb3NzIGF4aXNcbiAgICogQHR5cGUgeyBGbGV4QWxpZ25Db250ZW50IH0gW2FsaWduQ29udGVudCA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGFsaWduQ29udGVudCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFRoZSBhbGlnbm1lbnQgb2YgY2hpbGRyZW4gd2l0aGluIHRoZWlyIGNvbnRhaW5lci5cbiAgICogQHR5cGUgeyBGbGV4QWxpZ25JdGVtcyB9IFthbGlnbkl0ZW1zID0gXCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgYWxpZ25JdGVtcyA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd3JhcCBpdGVtcyBvbnRvIG11bHRpcGxlIGxpbmVzLlxuICAgKiBAdHlwZSB7IERpbWVuc2lvblZhbHVlIH0gW2dhcCA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGdhcCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFRoZSBzcGFjZSB0byBkaXNwbGF5IGJldHdlZW4gY29sdW1ucy5cbiAgICogQHR5cGUgeyBEaW1lbnNpb25WYWx1ZSB9IFtjb2x1bW5HYXAgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBjb2x1bW5HYXAgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBUaGUgc3BhY2UgdG8gZGlzcGxheSBiZXR3ZWVuIHJvdy5cbiAgICogQHR5cGUgeyBEaW1lbnNpb25WYWx1ZSB9IFtyb3dHYXAgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCByb3dHYXAgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGxheW91dCByZWxhdGVkIHN0eWxlLlxuICAgKiBAdHlwZSB7IElMYXlvdXQgfSBbbGF5b3V0ID0ge31dXG4gICAqL1xuICBleHBvcnQgbGV0IGxheW91dCA9IHt9O1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIHNwYWNpbmcgcmVsYXRlZCBzdHlsZS5cbiAgICogQHR5cGUgeyBJU3BhY2luZyB9IFtzcGFjaW5nID0ge31dXG4gICAqL1xuICBleHBvcnQgbGV0IHNwYWNpbmcgPSB7fTtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBzaXppbmcgcmVsYXRlZCBzdHlsZS5cbiAgICogQHR5cGUgeyBJU2l6ZSB9IFtzaXppbmcgPSB7fV1cbiAgICovXG4gIGV4cG9ydCBsZXQgc2l6aW5nID0ge307XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgcG9zaXRpb25pbmcgcmVsYXRlZCBzdHlsZS5cbiAgICogQHR5cGUgeyBJUG9zaXRpb24gfSBbcG9zaXRpb25pbmcgPSB7fV1cbiAgICovXG4gIGV4cG9ydCBsZXQgcG9zaXRpb25pbmcgPSB7fTtcblxuICBsZXQgbGF5b3V0Q3NzVGV4dCA9IFwiXCI7XG4gIGxldCBzcGFjaW5nQ3NzVGV4dCA9IFwiXCI7XG4gIGxldCBzaXppbmdDc3NUZXh0ID0gXCJcIjtcbiAgbGV0IHBvc2l0aW9uaW5nQ3NzVGV4dCA9IFwiXCI7XG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBsYXlvdXRDc3NUZXh0ID0gaW50ZWdyYXRlUHJvcHMobGF5b3V0KTtcbiAgICBzcGFjaW5nQ3NzVGV4dCA9IGludGVncmF0ZURpbWVuc2lvblByb3BzKHNwYWNpbmcpO1xuICAgIHNpemluZ0Nzc1RleHQgPSBpbnRlZ3JhdGVBdXRvUHJvcHMoc2l6aW5nKTtcbiAgICBwb3NpdGlvbmluZ0Nzc1RleHQgPSBpbnRlZ3JhdGVBdXRvUHJvcHMocG9zaXRpb25pbmcpO1xuICB9KTtcblxuICAkOiBjb21wb25lbnRTdHlsZSA9IFtcbiAgICBgZGlzcGxheToke2Rpc3BsYXl9O2AsXG4gICAgZGlyZWN0aW9uICYmIGBmbGV4LWRpcmVjdGlvbjoke2RpcmVjdGlvbn07YCxcbiAgICB3cmFwICYmIGBmbGV4LXdyYXA6JHt3cmFwfTtgLFxuICAgIGp1c3RpZnlDb250ZW50ICYmIGBqdXN0aWZ5LWNvbnRlbnQ6JHtqdXN0aWZ5Q29udGVudH07YCxcbiAgICBhbGlnbkNvbnRlbnQgJiYgYGFsaWduLWNvbnRlbnQ6JHthbGlnbkNvbnRlbnR9YCxcbiAgICBhbGlnbkl0ZW1zICYmIGBhbGlnbi1pdGVtczoke2FsaWduSXRlbXN9YCxcbiAgICBnYXAgJiYgYGdhcDp2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLSR7Z2FwfSwgdmFyKC0tc3BlY3RydW0tYWxpYXMtJHtnYXB9KSk7XCJgLFxuICAgIGNvbHVtbkdhcCAmJiBgY29sdW1uLWdhcDp2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLSR7Y29sdW1uR2FwfSwgdmFyKC0tc3BlY3RydW0tYWxpYXMtJHtjb2x1bW5HYXB9KSk7XCJgLFxuICAgIHJvd0dhcCAmJiBgcm93LWdhcDp2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLSR7cm93R2FwfSwgdmFyKC0tc3BlY3RydW0tYWxpYXMtJHtyb3dHYXB9KSk7XCJgLFxuICBdXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiXCIpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAge2lkfVxuICBzdHlsZT17bGF5b3V0Q3NzVGV4dCArIHNwYWNpbmdDc3NUZXh0ICsgc2l6aW5nQ3NzVGV4dCArIHBvc2l0aW9uaW5nQ3NzVGV4dCArIGNvbXBvbmVudFN0eWxlfVxuICBjbGFzcz17JCRyZXN0UHJvcHMuY2xhc3N9PlxuICA8c2xvdCAvPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSBcInJlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbFwiO1xuICBpbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gXCJ0aHJvdHRsZS1kZWJvdW5jZVwiO1xuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgb25EZXN0cm95IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBvcmllbnRhdGlvbiAgZm9yIHRoZSB0YWJzXG4gICAqIEB0eXBlIHtcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIn0gIFtvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBhcmlhLWxhYmVsXG4gICAqIEB0eXBlIHtzdHJpbmd9IFthcmlhLWxhYmVsPVwidGFiTGlzdFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSBcInRhYkxpc3RcIjtcblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcXVpZXQgbW9kZSBvZiB0YWJcbiAgICogQHR5cGUgeyBib29sZWFuIH0gICBbaXNRdWlldD0gZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzUXVpZXQgPSBmYWxzZTtcblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgY29tcGFjdCBtb2RlIG9mIHRhYlxuICAgKiBDb21wYWN0IHRhYnMgc2hvdWxkIG5ldmVyIGJlIHVzZWQgd2l0aG91dCB0aGUgcXVpZXQgdmFyaWF0aW9uLiBQbGVhc2UgdXNlIFF1aWV0IENvbXBhY3QgVGFicyBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7IGJvb2xlYW4gfSAgIFtpc1F1aWV0PSBmYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgaXNDb21wYWN0ID0gZmFsc2U7XG5cbiAgbGV0IHNlbGVjdGVkSXRlbURpbWVuc2lvbjtcbiAgbGV0IHRhYnM7XG4gIGxldCBzZWxlY3Rpb25JbmRpY2F0b3JPZmZzZXQ7XG5cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZ2V0U3R5bGVBdHRyaWJ1dGVWYWx1ZSk7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGdldFN0eWxlQXR0cmlidXRlVmFsdWUoKTtcbiAgICB0aHJvdHRsZSg1MDAsIG9ic2VydmVyLm9ic2VydmUodGFicykpO1xuICB9KTtcblxuICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSh0YWJzKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZSkge1xuICAgIGlmICh0YWJzLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiBlLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihcInNwZWN0cnVtLVRhYnMtaXRlbVwiKSAhPSAtMSkge1xuICAgICAgc2VsZWN0ZWRJdGVtRGltZW5zaW9uID0gZS50YXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICBzZWxlY3Rpb25JbmRpY2F0b3JPZmZzZXQgPSBlLnRhcmdldC5vZmZzZXRMZWZ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0eWxlQXR0cmlidXRlVmFsdWUoKSB7XG4gICAgaWYgKHRhYnMpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkSXRlbSA9IHRhYnMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImlzLXNlbGVjdGVkXCIpO1xuICAgICAgaWYgKHNlbGVjdGVkSXRlbS5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICBzZWxlY3RlZEl0ZW1EaW1lbnNpb24gPSBzZWxlY3RlZEl0ZW1bMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgc2VsZWN0aW9uSW5kaWNhdG9yT2Zmc2V0ID0gc2VsZWN0ZWRJdGVtWzBdLm9mZnNldExlZnQ7XG4gICAgICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgc2VsZWN0ZWRJdGVtRGltZW5zaW9uID0gc2VsZWN0ZWRJdGVtWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICBzZWxlY3Rpb25JbmRpY2F0b3JPZmZzZXQgPSBzZWxlY3RlZEl0ZW1bMF0ub2Zmc2V0VG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5ZG93bihlKSB7XG4gICAgbGV0IF9lID0gZXZlbnQgPyB3aW5kb3cuZXZlbnQgOiBlO1xuICAgIGlmIChfZS5rZXlDb2RlID09IDEzIHx8IF9lLmtleUNvZGUgPT0gMzIpIHtcbiAgICAgIGdldFBvc2l0aW9uKGUpO1xuICAgIH1cbiAgfVxuXG4gICQ6IHRhYnNQcm9wcyA9IHtcbiAgICByb2xlOiBcInRhYkxpc3RcIixcbiAgICBjbGFzczogW1xuICAgICAgXCJzcGVjdHJ1bS1UYWJzXCIsXG4gICAgICBvcmllbnRhdGlvbiAmJiBgc3BlY3RydW0tVGFicy0tJHtvcmllbnRhdGlvbn1gLFxuICAgICAgaXNRdWlldCAmJiBcInNwZWN0cnVtLVRhYnMtLXF1aWV0XCIsXG4gICAgICBpc0NvbXBhY3QgJiYgXCJzcGVjdHJ1bS1UYWJzLS1jb21wYWN0XCIsXG4gICAgXVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLmpvaW4oXCIgXCIpLFxuICB9O1xuXG4gICQ6IHNlbGVjdGlvbkluZGljYXRvclN5dGxlID0gW1xuICAgIG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgJiYgYGhlaWdodDogJHtzZWxlY3RlZEl0ZW1EaW1lbnNpb259cHg7YCxcbiAgICBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgJiYgYHdpZHRoOiAke3NlbGVjdGVkSXRlbURpbWVuc2lvbn1weDtgLFxuICAgIG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgJiYgYHRyYW5zZm9ybTp0cmFuc2xhdGVZKCR7c2VsZWN0aW9uSW5kaWNhdG9yT2Zmc2V0fXB4KTtgLFxuICAgIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJlxuICAgICAgYHRyYW5zZm9ybTp0cmFuc2xhdGVYKCR7XG4gICAgICAgICFzZWxlY3Rpb25JbmRpY2F0b3JPZmZzZXRcbiAgICAgICAgICA/IFwidmFyKC0tc3BlY3RydW0tdGFicy1mb2N1cy1yaW5nLXBhZGRpbmcteCwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi1zaXplLTEwMClcIlxuICAgICAgICAgIDogc2VsZWN0aW9uSW5kaWNhdG9yT2Zmc2V0ICsgXCJweFwiXG4gICAgICB9KTtgLFxuICBdXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiIFwiKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIHsuLi50YWJzUHJvcHN9XG4gIHsuLi4kJHJlc3RQcm9wc31cbiAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICBhcmlhLW9yaWVudGF0aW9uPXtvcmllbnRhdGlvbn1cbiAgYmluZDp0aGlzPXt0YWJzfVxuICBvbjpyZXNpemU9e2dldFN0eWxlQXR0cmlidXRlVmFsdWV9XG4gIG9uOmNsaWNrPXtnZXRQb3NpdGlvbn1cbiAgb246a2V5ZG93bj17aGFuZGxlS2V5ZG93bn0+XG4gIDxzbG90IC8+XG4gIDxkaXYgY2xhc3M9XCJzcGVjdHJ1bS1UYWJzLXNlbGVjdGlvbkluZGljYXRvclwiIHN0eWxlPXtzZWxlY3Rpb25JbmRpY2F0b3JTeXRsZX0gLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gIGltcG9ydCB7IGdldEV2ZW50c0FjdGlvbiB9IGZyb20gXCIuLi91dGlscy9nZXQtZXZlbnRzLWFjdGlvbi5qc1wiO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgY3VycmVudCBpbmRleCBmb3IgdGhlIHRhYnNcbiAgICogQHR5cGUge251bWJlcn0gW2N1cnJlbnRUYWJJbmRleCA9IDBdXG4gICAqL1xuICBleHBvcnQgbGV0IGN1cnJlbnRUYWJJbmRleCA9IDA7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHVuaXF1ZSBpbmRleCBmb3IgdGhlIHRhYlxuICAgKiBAdHlwZSB7bnVtYmVyfSBbdHNlbGZJbmRleCA9IDBdXG4gICAqL1xuICBleHBvcnQgbGV0IHNlbGZJbmRleCA9IDA7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBjaGFuZ2UgdGhlIGluZGV4IHZhbHVlXG4gICAqIEB0eXBlIHtib29sZWFufSBbdGFiQXV0b1N3aXRjaCA9IHRydWVdXG4gICAqL1xuICBleHBvcnQgbGV0IHRhYkF1dG9Td2l0Y2ggPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIHRvIGRpc2FibGUgdGhlIHRhYlxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gW2Rpc2FibGVkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQcmVjb25kaXRpb25zOiBkaXNhYmxlZCA9PT0gdHJ1ZVxuICAgKiBDdXJzb3Igbm90LWFsbG93ZWQgd2hlbiB0aGUgdGFiIGlzIGRpc2FibGVkXG4gICAqIEB0eXBlIHsgYm9vbGVhbiB9ICBbbm90QWxsb3dlZD0gZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IG5vdEFsbG93ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRoZSBgaHJlZmAgdG8gdXNlIGFuIGFuY2hvciBsaW5rXG4gICAqIEB0eXBlIHtzdHJpbmd9IFtocmVmID0gXCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgaHJlZiA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFByZWNvbmRpdGlvbnM6IGhyZWZcbiAgICogV2hlcmUgdG8gZGlzcGxheSB0aGUgbGlua2VkIFVSTFxuICAgKiBAdHlwZSB7XCJfc2VsZlwiIHwgXCJfYmxhbmtcIiB8IFwiX3BhcmVudFwiIHwgXCJfdG9wXCJ9IFt0YXJnZXQgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB0YXJnZXQgPSBcIlwiO1xuXG4gIGNvbnN0IGV2ZW50c0xpc3RlbiA9IGdldEV2ZW50c0FjdGlvbihjdXJyZW50X2NvbXBvbmVudCk7XG4gIGZ1bmN0aW9uIHN3aXRjaFRhYigpIHtcbiAgICBpZiAodGFiQXV0b1N3aXRjaCAmJiAhZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiAoY3VycmVudFRhYkluZGV4ID0gc2VsZkluZGV4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVLZXlkb3duKGUpIHtcbiAgICBsZXQgX2UgPSBldmVudCA/IHdpbmRvdy5ldmVudCA6IGU7XG4gICAgaWYgKF9lLmtleUNvZGUgPT0gMTMgfHwgX2Uua2V5Q29kZSA9PSAzMikge1xuICAgICAgc3dpdGNoVGFiKCk7XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNwZWN0cnVtLVRhYnMtaXRlbS1kaXNhYmxlZCB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWJ1dHRvbi1zZWNvbmRhcnktdGV4dC1jb2xvci1kaXNhYmxlZCwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktNTAwKSk7XG4gIH1cbiAgLnNwZWN0cnVtLVRhYnMtaXRlbS1kaXNhYmxlZCAuc3BlY3RydW0tSWNvbiB7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWJ1dHRvbi1zZWNvbmRhcnktdGV4dC1jb2xvci1kaXNhYmxlZCwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktNTAwKSkgIWltcG9ydGFudDtcbiAgfVxuICAuc3BlY3RydW0tVGFicy1pdGVtLWRpc2FibGVkOmhvdmVyIHtcbiAgICBjb2xvcjogdmFyKC0tc3BlY3RydW0tYnV0dG9uLXNlY29uZGFyeS10ZXh0LWNvbG9yLWRpc2FibGVkLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItZ3JheS01MDApKTtcbiAgfVxuICAuc3BlY3RydW0tVGFicy1pdGVtLWRpc2FibGVkOmFjdGl2ZSB7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWJ1dHRvbi1zZWNvbmRhcnktdGV4dC1jb2xvci1kaXNhYmxlZCwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktNTAwKSk7XG4gIH1cbiAgLnNwZWN0cnVtLVRhYnMtaXRlbS1kaXNhYmxlZCAuc3BlY3RydW0tVGFicy1pdGVtTGFiZWwge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIGNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1idXR0b24tc2Vjb25kYXJ5LXRleHQtY29sb3ItZGlzYWJsZWQsIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTUwMCkpO1xuICB9XG4gIC5zcGVjdHJ1bS1UYWJzLWl0ZW0tZGlzYWJsZWQgLnNwZWN0cnVtLVRhYnMtaXRlbUxhYmVsOmhvdmVyIHtcbiAgICBjb2xvcjogdmFyKC0tc3BlY3RydW0tYnV0dG9uLXNlY29uZGFyeS10ZXh0LWNvbG9yLWRpc2FibGVkLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItZ3JheS01MDApKTtcbiAgfVxuICAuc3BlY3RydW0tVGFicy1pdGVtLWRpc2FibGVkIC5zcGVjdHJ1bS1UYWJzLWl0ZW1MYWJlbDphY3RpdmUge1xuICAgIGNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1idXR0b24tc2Vjb25kYXJ5LXRleHQtY29sb3ItZGlzYWJsZWQsIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTUwMCkpO1xuICB9XG48L3N0eWxlPlxuXG57I2lmIGhyZWZ9XG4gIDxhXG4gICAge2hyZWZ9XG4gICAge3RhcmdldH1cbiAgICB7Li4uJCRyZXN0UHJvcHN9XG4gICAgY2xhc3M9XCJzcGVjdHJ1bS1UYWJzLWl0ZW0ge2Rpc2FibGVkICYmIG5vdEFsbG93ZWQgPyAnbm90LWFsbG93ZWQnIDogJyd9XCJcbiAgICBjbGFzczpzcGVjdHJ1bS1UYWJzLWl0ZW0tZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgIGNsYXNzOmlzLXNlbGVjdGVkPXsrc2VsZkluZGV4ID09PSArY3VycmVudFRhYkluZGV4fVxuICAgIHRhYmluZGV4PVwiMFwiXG4gICAgb246Y2xpY2s9e3N3aXRjaFRhYn1cbiAgICBvbjprZXlkb3duPXtoYW5kbGVLZXlkb3dufVxuICAgIHVzZTpldmVudHNMaXN0ZW4+XG4gICAgPHNsb3QgbmFtZT1cInRhYi1pY29uXCIgLz5cbiAgICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLVRhYnMtaXRlbUxhYmVsXCI+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvc3Bhbj5cbiAgPC9hPlxuezplbHNlfVxuICA8ZGl2XG4gICAgey4uLiQkcmVzdFByb3BzfVxuICAgIGNsYXNzPVwic3BlY3RydW0tVGFicy1pdGVtIHtkaXNhYmxlZCAmJiBub3RBbGxvd2VkID8gJ25vdC1hbGxvd2VkJyA6ICcnfVwiXG4gICAgY2xhc3M6c3BlY3RydW0tVGFicy1pdGVtLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICBjbGFzczppcy1zZWxlY3RlZD17K3NlbGZJbmRleCA9PT0gK2N1cnJlbnRUYWJJbmRleH1cbiAgICB0YWJpbmRleD1cIjBcIlxuICAgIG9uOmNsaWNrPXtzd2l0Y2hUYWJ9XG4gICAgb246a2V5ZG93bj17aGFuZGxlS2V5ZG93bn1cbiAgICB1c2U6ZXZlbnRzTGlzdGVuPlxuICAgIDxzbG90IG5hbWU9XCJ0YWItaWNvblwiIC8+XG4gICAgPHNwYW4gY2xhc3M9XCJzcGVjdHJ1bS1UYWJzLWl0ZW1MYWJlbFwiPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L3NwYW4+XG4gIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IFR5cG9ncmFwaHlIZWFkaW5nLCBGbGV4LCBUeXBvZ3JhcGh5Qm9keSwgVGFiLCBUYWJzIH0gZnJvbSBcIkBydWJ1cy9ydWJ1cy9zcmNcIjtcbiAgaW1wb3J0IHsgb25Nb3VudCwgZ2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgc3RvcmVzIH0gZnJvbSBcIkBzYXBwZXIvYXBwXCI7XG4gIGNvbnN0IHsgcGFnZSB9ID0gc3RvcmVzKCk7XG4gIGxldCBydWJ1c0RvY0NvbmZpZyA9IGdldENvbnRleHQoXCJydWJ1c0RvY0NvbmZpZ1wiKTtcbiAgZXhwb3J0IGxldCBzZWdtZW50O1xuICBzZWdtZW50O1xuXG4gIGxldCB0YWJMaXN0ID0gW1xuICAgIHsgbmFtZTogXCLnlKjms5VcIiwgdXJsOiBcImRvY3MvYmFzaWMvYnV0dG9uL3VzYWdlXCIgfSxcbiAgICB7IG5hbWU6IFwiUHJvcHNcIiwgdXJsOiBcImRvY3MvYmFzaWMvYnV0dG9uL3Byb3BzXCIgfSxcbiAgICB7IG5hbWU6IFwi55So5L6LXCIsIHVybDogXCJkb2NzL2Jhc2ljL2J1dHRvbi9leGFtcGxlc1wiIH0sXG4gICAgeyBuYW1lOiBcIumXrumimFwiLCB1cmw6IFwiZG9jcy9iYXNpYy9idXR0b24vaXNzdWVzXCIgfSxcbiAgXTtcbiAgbGV0IGN1cnJlbnRUYWJJbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gdGFiQ3VycmVudFRhYkluZGV4KCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJMaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKCRwYWdlLnBhdGguc3Vic3RyKDEpID09IHRhYkxpc3RbaW5kZXhdLnVybCkge1xuICAgICAgICBjdXJyZW50VGFiSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICB0YWJDdXJyZW50VGFiSW5kZXgoKTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBoZWFkZXIge1xuICAgIG1pbi1oZWlnaHQ6IDE1MHB4O1xuICB9XG4gIG1haW4ge1xuICAgIG1hcmdpbjogMzVweCAwO1xuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT57JHJ1YnVzRG9jQ29uZmlnLm5hbWV9IEJ1dHRvbjwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48aGVhZGVyPlxuICA8VHlwb2dyYXBoeUhlYWRpbmcgc2NhbGU9XCJYTFwiPkJ1dHRvbjwvVHlwb2dyYXBoeUhlYWRpbmc+XG4gIDxGbGV4IHNwYWNpbmc9e3sgaGVpZ2h0OiAnc2l6ZS02MDAnIH19IGFsaWduSXRlbXM9XCJjZW50ZXJcIj5cbiAgICA8VHlwb2dyYXBoeUJvZHkgc2NhbGU9XCJNXCI+5bi46KeE5oyJ6ZKu57uE5Lu277yM5LiA6Iis55So5LqO57uZ5a6a55So5oi35pON5L2c5o+Q5L6b6YCJ6aG5PC9UeXBvZ3JhcGh5Qm9keT5cbiAgPC9GbGV4PlxuPC9oZWFkZXI+XG48bmF2PlxuICA8VGFicz5cbiAgICB7I2VhY2ggdGFiTGlzdCBhcyB0YWIsIGl9XG4gICAgICA8VGFiXG4gICAgICAgIHNlbGZJbmRleD17aX1cbiAgICAgICAge2N1cnJlbnRUYWJJbmRleH1cbiAgICAgICAgaHJlZj17dGFiLnVybH1cbiAgICAgICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgICAgICBjdXJyZW50VGFiSW5kZXggPSBpO1xuICAgICAgICB9fT5cbiAgICAgICAge3RhYi5uYW1lfVxuICAgICAgPC9UYWI+XG4gICAgey9lYWNofVxuICA8L1RhYnM+XG48L25hdj5cblxuPG1haW4+XG4gIDxzbG90IC8+XG48L21haW4+XG4iXSwibmFtZXMiOlsiUmVzaXplT2JzZXJ2ZXIiLCJ0aHJvdHRsZSIsInN0b3JlcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVMsY0FBYyxDQUFDLENBQUMsRUFBRTtBQUMzQixFQUFFLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQyxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNmLEVBQUUsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUU7QUFDcEQsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDbkcs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
