import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, P as compute_rest_props, v as validate_slots, Q as index, z as afterUpdate, R as onDestroy, T as assign, U as exclude_internal_props, A as current_component, B as getEventsAction, L as empty, r as insert_dev, M as group_outros, b as transition_out, N as check_outros, t as transition_in, l as detach_dev, G as binding_callbacks, x as create_slot, c as create_component, a as claim_component, m as mount_component, e as destroy_component, g as text, k as claim_text, f as element, C as space, h as claim_element, j as children, D as claim_space, p as attr_dev, V as add_render_callback, q as add_location, W as set_attributes, E as toggle_class, u as append_dev, X as listen_dev, F as action_destroyer, Y as prop_dev, y as update_slot, Z as get_spread_update, _ as run_all, w as set_data_dev, $ as bubble, a0 as AlertMedium, n as noop, o as onMount, a1 as add_resize_listener, K as validate_each_argument, a2 as getContext, I as validate_store, J as component_subscribe, a3 as globals, O as destroy_each, a4 as query_selector_all } from './client.819062b1.js';
import { C as CheckmarkSmall, D as DashSmall, a as CrossMedium, I as InfoMedium, S as SuccessMedium, H as HelpSmall } from './SuccessMedium.82443d5f.js';
import { i as index_umd } from './index.umd.37669cb5.js';
import { B as Button } from './Button.d7bca58d.js';
import { T as TypographyHeading, a as TypographyBody } from './TypographyHeading.aded6356.js';

/* node_modules/@rubus/rubus/src/packages/Checkbox/Checkbox.svelte generated by Svelte v3.29.4 */
const file = "node_modules/@rubus/rubus/src/packages/Checkbox/Checkbox.svelte";

// (144:0) {:else}
function create_else_block(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_4(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_3(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let label_levels = [
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				name: true,
				disabled: true,
				value: true
			});

			t0 = claim_space(label_nodes);
			span0 = claim_element(label_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (if_block0) if_block0.l(span0_nodes);
			t1 = claim_space(span0_nodes);
			if (if_block1) if_block1.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(label_nodes);
			span1 = claim_element(label_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			if (default_slot) default_slot.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "spectrum-Checkbox-input");
			attr_dev(input, "id", /*id*/ ctx[7]);
			attr_dev(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.__value = /*value*/ ctx[8];
			input.value = input.__value;
			if (/*checked*/ ctx[0] === void 0 || /*indeterminate*/ ctx[1] === void 0) add_render_callback(() => /*input_change_handler*/ ctx[19].call(input));
			add_location(input, file, 152, 4, 4279);
			attr_dev(span0, "class", "spectrum-Checkbox-box");
			add_location(span0, file, 162, 4, 4479);
			attr_dev(span1, "class", "spectrum-Checkbox-label");
			add_location(span1, file, 182, 4, 5070);
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
			add_location(label, file, 144, 2, 4021);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding_1*/ ctx[18](input);
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			append_dev(label, t0);
			append_dev(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append_dev(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append_dev(label, t2);
			append_dev(label, span1);

			if (default_slot) {
				default_slot.m(span1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[19]),
					action_destroyer(eventsListen_action = /*eventsListen*/ ctx[13].call(null, label))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr_dev(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr_dev(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*value*/ 256) {
				prop_dev(input, "__value", /*value*/ ctx[8]);
				input.value = input.__value;
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*indeterminate*/ 2) {
				input.indeterminate = /*indeterminate*/ ctx[1];
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding_1*/ ctx[18](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(144:0) {:else}",
		ctx
	});

	return block;
}

// (101:0) {#if readonly}
function create_if_block(ctx) {
	let label;
	let input;
	let t0;
	let span0;
	let t1;
	let t2;
	let span1;
	let label_class_value;
	let current;
	let if_block0 = /*checked*/ ctx[0] && create_if_block_2(ctx);
	let if_block1 = /*indeterminate*/ ctx[1] && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	let label_levels = [
		{ title: /*title*/ ctx[9] },
		/*$$restProps*/ ctx[14],
		{
			class: label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class
		}
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			span0 = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			span1 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { title: true, class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				name: true,
				disabled: true,
				value: true,
				checked: true,
				indeterminate: true
			});

			t0 = claim_space(label_nodes);
			span0 = claim_element(label_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (if_block0) if_block0.l(span0_nodes);
			t1 = claim_space(span0_nodes);
			if (if_block1) if_block1.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(label_nodes);
			span1 = claim_element(label_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			if (default_slot_or_fallback) default_slot_or_fallback.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "spectrum-Checkbox-input");
			attr_dev(input, "id", /*id*/ ctx[7]);
			attr_dev(input, "name", /*name*/ ctx[6]);
			input.disabled = /*disabled*/ ctx[2];
			input.value = /*value*/ ctx[8];
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			add_location(input, file, 109, 4, 3136);
			attr_dev(span0, "class", "spectrum-Checkbox-box");
			add_location(span0, file, 119, 4, 3330);
			attr_dev(span1, "class", "spectrum-Checkbox-label");
			add_location(span1, file, 139, 4, 3921);
			set_attributes(label, label_data);
			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
			add_location(label, file, 101, 2, 2878);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding*/ ctx[17](input);
			append_dev(label, t0);
			append_dev(label, span0);
			if (if_block0) if_block0.m(span0, null);
			append_dev(span0, t1);
			if (if_block1) if_block1.m(span0, null);
			append_dev(label, t2);
			append_dev(label, span1);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*id*/ 128) {
				attr_dev(input, "id", /*id*/ ctx[7]);
			}

			if (!current || dirty & /*name*/ 64) {
				attr_dev(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*value*/ 256) {
				prop_dev(input, "value", /*value*/ ctx[8]);
			}

			if (!current || dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (!current || dirty & /*indeterminate*/ 2) {
				prop_dev(input, "indeterminate", /*indeterminate*/ ctx[1]);
			}

			if (/*checked*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*checked*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*indeterminate*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*indeterminate*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(span0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*title*/ 512) && { title: /*title*/ ctx[9] },
				dirty & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty & /*$$restProps*/ 16384 && label_class_value !== (label_class_value = "spectrum-Checkbox readonly " + /*$$restProps*/ ctx[14].class)) && { class: label_class_value }
			]));

			toggle_class(label, "is-disabled", /*disabled*/ ctx[2]);
			toggle_class(label, "is-indeterminate", /*indeterminate*/ ctx[1]);
			toggle_class(label, "is-invalid", /*isInvalid*/ ctx[3]);
			toggle_class(label, "spectrum-Checkbox--quiet", /*isQuiet*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[17](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(101:0) {#if readonly}",
		ctx
	});

	return block;
}

// (164:6) {#if checked}
function create_if_block_4(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcheckmarksmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(164:6) {#if checked}",
		ctx
	});

	return block;
}

// (173:6) {#if indeterminate}
function create_if_block_3(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icondashsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icondashsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(173:6) {#if indeterminate}",
		ctx
	});

	return block;
}

// (121:6) {#if checked}
function create_if_block_2(ctx) {
	let iconcheckmarksmall;
	let current;

	iconcheckmarksmall = new CheckmarkSmall({
			props: {
				width: /*iconSize*/ ctx[11] - 1,
				height: /*iconSize*/ ctx[11] - 1,
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-checkmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcheckmarksmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcheckmarksmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcheckmarksmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconcheckmarksmall_changes = {};
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.width = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*iconSize*/ 2048) iconcheckmarksmall_changes.height = /*iconSize*/ ctx[11] - 1;
			if (dirty & /*large*/ 4096) iconcheckmarksmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			iconcheckmarksmall.$set(iconcheckmarksmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconcheckmarksmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcheckmarksmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcheckmarksmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(121:6) {#if checked}",
		ctx
	});

	return block;
}

// (130:6) {#if indeterminate}
function create_if_block_1(ctx) {
	let icondashsmall;
	let current;

	icondashsmall = new DashSmall({
			props: {
				width: /*iconSize*/ ctx[11],
				height: /*iconSize*/ ctx[11],
				scale: /*large*/ ctx[12] ? "L" : "M",
				className: "spectrum-Checkbox-partialCheckmark",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icondashsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icondashsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icondashsmall, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icondashsmall_changes = {};
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.width = /*iconSize*/ ctx[11];
			if (dirty & /*iconSize*/ 2048) icondashsmall_changes.height = /*iconSize*/ ctx[11];
			if (dirty & /*large*/ 4096) icondashsmall_changes.scale = /*large*/ ctx[12] ? "L" : "M";
			icondashsmall.$set(icondashsmall_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icondashsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icondashsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icondashsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(130:6) {#if indeterminate}",
		ctx
	});

	return block;
}

// (141:12) Checkbox
function fallback_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Checkbox");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Checkbox");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(141:12) Checkbox",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*readonly*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"checked","disabled","isInvalid","isQuiet","indeterminate","readonly","name","id","value","title"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Checkbox", slots, ['default']);
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { isInvalid = false } = $$props;
	let { isQuiet = false } = $$props;
	let { indeterminate = false } = $$props;
	let { readonly = false } = $$props;
	let { name = "" } = $$props;
	let { id = "checkbox-" + Math.random().toString(24) } = $$props;
	let { value = "" } = $$props;
	let { title = "" } = $$props;
	let checkbox;
	let iconSize = 10;
	let large = false;
	const eventsListen = getEventsAction(current_component);
	const observer = new index(getIconScale);

	afterUpdate(() => {
		index_umd.throttle(500, observer.observe(checkbox));
	});

	onDestroy(() => {
		observer.unobserve(checkbox);
	});

	function getIconScale() {
		$$invalidate(11, iconSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spectrum-global-dimension-size-125")));

		if (iconSize == 10) {
			$$invalidate(12, large = false);
		} else {
			$$invalidate(12, large = true);
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			checkbox = $$value;
			$$invalidate(10, checkbox);
		});
	}

	function input_change_handler() {
		checked = this.checked;
		indeterminate = this.indeterminate;
		$$invalidate(0, checked);
		$$invalidate(1, indeterminate);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$new_props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$new_props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$new_props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$new_props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$new_props) $$invalidate(9, title = $$new_props.title);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		IconCheckmarkSmall: CheckmarkSmall,
		IconDashSmall: DashSmall,
		ResizeObserver: index,
		throttle: index_umd.throttle,
		afterUpdate,
		onDestroy,
		current_component,
		getEventsAction,
		checked,
		disabled,
		isInvalid,
		isQuiet,
		indeterminate,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		observer,
		getIconScale
	});

	$$self.$inject_state = $$new_props => {
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("isInvalid" in $$props) $$invalidate(3, isInvalid = $$new_props.isInvalid);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$new_props.isQuiet);
		if ("indeterminate" in $$props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ("readonly" in $$props) $$invalidate(5, readonly = $$new_props.readonly);
		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
		if ("id" in $$props) $$invalidate(7, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(8, value = $$new_props.value);
		if ("title" in $$props) $$invalidate(9, title = $$new_props.title);
		if ("checkbox" in $$props) $$invalidate(10, checkbox = $$new_props.checkbox);
		if ("iconSize" in $$props) $$invalidate(11, iconSize = $$new_props.iconSize);
		if ("large" in $$props) $$invalidate(12, large = $$new_props.large);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		checked,
		indeterminate,
		disabled,
		isInvalid,
		isQuiet,
		readonly,
		name,
		id,
		value,
		title,
		checkbox,
		iconSize,
		large,
		eventsListen,
		$$restProps,
		$$scope,
		slots,
		input_binding,
		input_binding_1,
		input_change_handler
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			checked: 0,
			disabled: 2,
			isInvalid: 3,
			isQuiet: 4,
			indeterminate: 1,
			readonly: 5,
			name: 6,
			id: 7,
			value: 8,
			title: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment.name
		});
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInvalid() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInvalid(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Radio/Radio.svelte generated by Svelte v3.29.4 */

const file$1 = "node_modules/@rubus/rubus/src/packages/Radio/Radio.svelte";

// (69:53) {value}
function fallback_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*value*/ ctx[6]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*value*/ ctx[6]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 64) set_data_dev(t, /*value*/ ctx[6]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(69:53) {value}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let input;
	let t0;
	let span;
	let t1;
	let label;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			label = element("label");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			input = claim_element(div_nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				id: true,
				checked: true,
				disabled: true,
				value: true,
				readonly: true
			});

			t0 = claim_space(div_nodes);
			span = claim_element(div_nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			t1 = claim_space(div_nodes);
			label = claim_element(div_nodes, "LABEL", { class: true, for: true });
			var label_nodes = children(label);
			if (default_slot_or_fallback) default_slot_or_fallback.l(label_nodes);
			label_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "radio");
			attr_dev(input, "name", /*name*/ ctx[5]);
			attr_dev(input, "class", "spectrum-Radio-input");
			attr_dev(input, "id", /*id*/ ctx[0]);
			input.checked = /*checked*/ ctx[1];
			input.disabled = /*disabled*/ ctx[3];
			input.value = /*value*/ ctx[6];
			input.readOnly = /*readonly*/ ctx[7];
			add_location(input, file$1, 66, 2, 1919);
			attr_dev(span, "class", "spectrum-Radio-button");
			add_location(span, file$1, 67, 2, 2025);
			attr_dev(label, "class", "spectrum-Radio-label");
			attr_dev(label, "for", /*id*/ ctx[0]);
			add_location(label, file$1, 68, 2, 2066);
			attr_dev(div, "class", "spectrum-Radio");
			toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			add_location(div, file$1, 56, 0, 1721);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t0);
			append_dev(div, span);
			append_dev(div, t1);
			append_dev(div, label);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "click", /*click_handler*/ ctx[10], false, false, false),
					listen_dev(div, "keydown", /*keydown_handler*/ ctx[11], false, false, false),
					listen_dev(div, "keyup", /*keyup_handler*/ ctx[12], false, false, false),
					listen_dev(div, "keypress", /*keypress_handler*/ ctx[13], false, false, false),
					listen_dev(div, "dblclick", /*dblclick_handler*/ ctx[14], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 32) {
				attr_dev(input, "name", /*name*/ ctx[5]);
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(input, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*checked*/ 2) {
				prop_dev(input, "checked", /*checked*/ ctx[1]);
			}

			if (!current || dirty & /*disabled*/ 8) {
				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*value*/ 64) {
				prop_dev(input, "value", /*value*/ ctx[6]);
			}

			if (!current || dirty & /*readonly*/ 128) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[7]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*value*/ 64) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(label, "for", /*id*/ ctx[0]);
			}

			if (dirty & /*isQuiet*/ 16) {
				toggle_class(div, "spectrum-Radio--quiet", /*isQuiet*/ ctx[4]);
			}

			if (dirty & /*isInvalid*/ 4) {
				toggle_class(div, "is-invalid", /*isInvalid*/ ctx[2]);
			}

			if (dirty & /*readonly*/ 128) {
				toggle_class(div, "is-readonly", /*readonly*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Radio", slots, ['default']);
	let { id = `radio-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	let { checked = false } = $$props;
	let { isInvalid = false } = $$props;
	let { disabled = false } = $$props;
	let { isQuiet = false } = $$props;
	let { name = "radio" } = $$props;
	let { value = "" } = $$props;
	let { readonly = false } = $$props;

	const writable_props = [
		"id",
		"checked",
		"isInvalid",
		"disabled",
		"isQuiet",
		"name",
		"value",
		"readonly"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Radio> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function keypress_handler(event) {
		bubble($$self, event);
	}

	function dblclick_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("isQuiet" in $$props) $$invalidate(4, isQuiet = $$props.isQuiet);
		if ("name" in $$props) $$invalidate(5, name = $$props.name);
		if ("value" in $$props) $$invalidate(6, value = $$props.value);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$props.readonly);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		checked,
		isInvalid,
		disabled,
		isQuiet,
		name,
		value,
		readonly,
		$$scope,
		slots,
		click_handler,
		keydown_handler,
		keyup_handler,
		keypress_handler,
		dblclick_handler
	];
}

class Radio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			id: 0,
			checked: 1,
			isInvalid: 2,
			disabled: 3,
			isQuiet: 4,
			name: 5,
			value: 6,
			readonly: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio",
			options,
			id: create_fragment$1.name
		});
	}

	get id() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInvalid() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInvalid(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isQuiet() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isQuiet(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Toast/Toast.svelte generated by Svelte v3.29.4 */

const file$2 = "node_modules/@rubus/rubus/src/packages/Toast/Toast.svelte";

// (50:62) 
function create_if_block_2$1(ctx) {
	let iconsuccessmedium;
	let current;

	iconsuccessmedium = new SuccessMedium({
			props: { className: "spectrum-Toast-typeIcon" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconsuccessmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconsuccessmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconsuccessmedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconsuccessmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconsuccessmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconsuccessmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(50:62) ",
		ctx
	});

	return block;
}

// (48:86) 
function create_if_block_1$1(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: { className: "spectrum-Toast-typeIcon" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconalertmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconalertmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(48:86) ",
		ctx
	});

	return block;
}

// (46:2) {#if variants === 'info'}
function create_if_block$1(ctx) {
	let iconinfomedium;
	let current;

	iconinfomedium = new InfoMedium({
			props: { className: "spectrum-Toast-typeIcon" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconinfomedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconinfomedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconinfomedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconinfomedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconinfomedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconinfomedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(46:2) {#if variants === 'info'}",
		ctx
	});

	return block;
}

// (58:4) <Button exterior="clear" variant="overBackground" on:click on:keydown on:keyup on:mousedown on:mouseup>
function create_default_slot(ctx) {
	let iconcrossmedium;
	let current;

	iconcrossmedium = new CrossMedium({
			props: {
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconcrossmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconcrossmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconcrossmedium, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(iconcrossmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconcrossmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconcrossmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(58:4) <Button exterior=\\\"clear\\\" variant=\\\"overBackground\\\" on:click on:keydown on:keyup on:mousedown on:mouseup>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div3;
	let current_block_type_index;
	let if_block;
	let t0;
	let div1;
	let div0;
	let t1;
	let t2;
	let t3;
	let div2;
	let button;
	let div3_class_value;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_1$1, create_if_block_2$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[1] === "info") return 0;
		if (/*variants*/ ctx[1] === "negative" || /*variants*/ ctx[1] === "error" || /*variants*/ ctx[1] === "warning") return 1;
		if (/*variants*/ ctx[1] === "positive" || /*variants*/ ctx[1] === "success") return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	button = new Button({
			props: {
				exterior: "clear",
				variant: "overBackground",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[6]);
	button.$on("keydown", /*keydown_handler*/ ctx[7]);
	button.$on("keyup", /*keyup_handler*/ ctx[8]);
	button.$on("mousedown", /*mousedown_handler*/ ctx[9]);
	button.$on("mouseup", /*mouseup_handler*/ ctx[10]);

	const block = {
		c: function create() {
			div3 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			t1 = text(/*label*/ ctx[0]);
			t2 = space();
			if (default_slot) default_slot.c();
			t3 = space();
			div2 = element("div");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, style: true });
			var div3_nodes = children(div3);
			if (if_block) if_block.l(div3_nodes);
			t0 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t1 = claim_text(div0_nodes, /*label*/ ctx[0]);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(button.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "spectrum-Toast-content");
			add_location(div0, file$2, 53, 4, 1710);
			attr_dev(div1, "class", "spectrum-Toast-body");
			add_location(div1, file$2, 52, 2, 1672);
			attr_dev(div2, "class", "spectrum-Toast-buttons");
			add_location(div2, file$2, 56, 2, 1784);
			attr_dev(div3, "class", div3_class_value = "spectrum-Toast spectrum-Toast--" + /*variants*/ ctx[1]);
			attr_dev(div3, "style", /*styleCssText*/ ctx[2]);
			add_location(div3, file$2, 44, 0, 1226);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div3, null);
			}

			append_dev(div3, t0);
			append_dev(div3, div1);
			append_dev(div1, div0);
			append_dev(div0, t1);
			append_dev(div1, t2);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div3, t3);
			append_dev(div3, div2);
			mount_component(button, div2, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div3, t0);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty & /*label*/ 1) set_data_dev(t1, /*label*/ ctx[0]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (!current || dirty & /*variants*/ 2 && div3_class_value !== (div3_class_value = "spectrum-Toast spectrum-Toast--" + /*variants*/ ctx[1])) {
				attr_dev(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*styleCssText*/ 4) {
				attr_dev(div3, "style", /*styleCssText*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot) default_slot.d(detaching);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Toast", slots, ['default']);
	let { label = "" } = $$props;
	let { variants = "default" } = $$props;
	let { height = "auto" } = $$props;
	let { width = "auto" } = $$props;
	const writable_props = ["label", "variants", "height", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Toast> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("height" in $$props) $$invalidate(3, height = $$props.height);
		if ("width" in $$props) $$invalidate(4, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Button,
		IconCrossMedium: CrossMedium,
		IconInfoMedium: InfoMedium,
		IconAlertMedium: AlertMedium,
		IconSuccessMedium: SuccessMedium,
		label,
		variants,
		height,
		width,
		styleCssText
	});

	$$self.$inject_state = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("variants" in $$props) $$invalidate(1, variants = $$props.variants);
		if ("height" in $$props) $$invalidate(3, height = $$props.height);
		if ("width" in $$props) $$invalidate(4, width = $$props.width);
		if ("styleCssText" in $$props) $$invalidate(2, styleCssText = $$props.styleCssText);
	};

	let styleCssText;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*height, width*/ 24) {
			 $$invalidate(2, styleCssText = [
				height && height.toString().indexOf("size") !== -1
				? `height:var(--spectrum-global-dimension-${height});`
				: height.toString().indexOf("%") !== -1
					? `height: ${height};`
					: `height: ${height}px;`,
				width && width.toString().indexOf("size") !== -1
				? `width:var(--spectrum-global-dimension-${width});`
				: width.toString().indexOf("%") !== -1
					? `width: ${width};`
					: `width: ${width}px;`
			].filter(Boolean).join(" "));
		}
	};

	return [
		label,
		variants,
		styleCssText,
		height,
		width,
		slots,
		click_handler,
		keydown_handler,
		keyup_handler,
		mousedown_handler,
		mouseup_handler,
		$$scope
	];
}

class Toast extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			label: 0,
			variants: 1,
			height: 3,
			width: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toast",
			options,
			id: create_fragment$2.name
		});
	}

	get label() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variants() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variants(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/Tooltip/Tooltip.svelte generated by Svelte v3.29.4 */
const file$3 = "node_modules/@rubus/rubus/src/packages/Tooltip/Tooltip.svelte";

// (212:32) 
function create_if_block_3$1(ctx) {
	let iconhelpsmall;
	let current;

	iconhelpsmall = new HelpSmall({
			props: {
				className: "spectrum-Tooltip-typeIcon spectrum-Tooltip-typeIcon-help",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconhelpsmall.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconhelpsmall.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconhelpsmall, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconhelpsmall.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconhelpsmall.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconhelpsmall, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(212:32) ",
		ctx
	});

	return block;
}

// (210:36) 
function create_if_block_2$2(ctx) {
	let iconsuccessmedium;
	let current;

	iconsuccessmedium = new SuccessMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconsuccessmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconsuccessmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconsuccessmedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconsuccessmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconsuccessmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconsuccessmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(210:36) ",
		ctx
	});

	return block;
}

// (208:32) 
function create_if_block_1$2(ctx) {
	let iconinfomedium;
	let current;

	iconinfomedium = new InfoMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconinfomedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconinfomedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconinfomedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconinfomedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconinfomedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconinfomedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(208:32) ",
		ctx
	});

	return block;
}

// (206:2) {#if variants === 'negative'}
function create_if_block$2(ctx) {
	let iconalertmedium;
	let current;

	iconalertmedium = new AlertMedium({
			props: {
				className: "spectrum-Tooltip-typeIcon",
				focusable: "false",
				"aria-hidden": "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconalertmedium.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconalertmedium.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconalertmedium, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconalertmedium.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconalertmedium.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconalertmedium, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(206:2) {#if variants === 'negative'}",
		ctx
	});

	return block;
}

// (218:45) {label}
function fallback_block$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[1]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*label*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$2.name,
		type: "fallback",
		source: "(218:45) {label}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let span2;
	let current_block_type_index;
	let if_block;
	let t0;
	let span0;
	let t1;
	let span1;
	let span2_class_value;
	let span2_resize_listener;
	let current;
	const if_block_creators = [create_if_block$2, create_if_block_1$2, create_if_block_2$2, create_if_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variants*/ ctx[2] === "negative") return 0;
		if (/*variants*/ ctx[2] === "info") return 1;
		if (/*variants*/ ctx[2] === "positive") return 2;
		if (/*variants*/ ctx[2] === "help") return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

	const block = {
		c: function create() {
			span2 = element("span");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t1 = space();
			span1 = element("span");
			this.h();
		},
		l: function claim(nodes) {
			span2 = claim_element(nodes, "SPAN", { class: true, style: true });
			var span2_nodes = children(span2);
			if (if_block) if_block.l(span2_nodes);
			t0 = claim_space(span2_nodes);
			span0 = claim_element(span2_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			if (default_slot_or_fallback) default_slot_or_fallback.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span2_nodes);
			span1 = claim_element(span2_nodes, "SPAN", { class: true });
			children(span1).forEach(detach_dev);
			span2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "spectrum-Tooltip-label");
			add_location(span0, file$3, 217, 2, 14489);
			attr_dev(span1, "class", "spectrum-Tooltip-tip");
			add_location(span1, file$3, 218, 2, 14556);
			attr_dev(span2, "class", span2_class_value = "spectrum-Tooltip spectrum-Tooltip--" + /*variants*/ ctx[2] + " spectrum-Tooltip--" + /*directions*/ ctx[3] + " ");
			attr_dev(span2, "style", /*styleText*/ ctx[5]);
			add_render_callback(() => /*span2_elementresize_handler*/ ctx[12].call(span2));
			toggle_class(span2, "is-open", /*isOpen*/ ctx[0]);
			add_location(span2, file$3, 199, 0, 13704);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span2, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(span2, null);
			}

			append_dev(span2, t0);
			append_dev(span2, span0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span0, null);
			}

			append_dev(span2, t1);
			append_dev(span2, span1);
			span2_resize_listener = add_resize_listener(span2, /*span2_elementresize_handler*/ ctx[12].bind(span2));
			/*span2_binding*/ ctx[13](span2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(span2, t0);
				} else {
					if_block = null;
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*variants, directions*/ 12 && span2_class_value !== (span2_class_value = "spectrum-Tooltip spectrum-Tooltip--" + /*variants*/ ctx[2] + " spectrum-Tooltip--" + /*directions*/ ctx[3] + " ")) {
				attr_dev(span2, "class", span2_class_value);
			}

			if (!current || dirty & /*styleText*/ 32) {
				attr_dev(span2, "style", /*styleText*/ ctx[5]);
			}

			if (dirty & /*variants, directions, isOpen*/ 13) {
				toggle_class(span2, "is-open", /*isOpen*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			span2_resize_listener();
			/*span2_binding*/ ctx[13](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tooltip", slots, ['default']);
	let { label = "" } = $$props;
	let { variants = "default" } = $$props;
	let { isOpen = false } = $$props;
	let { directions = "top" } = $$props;
	let { induceStartEventName = "mouseover" } = $$props;
	let { induceEndEventName = "mouseout" } = $$props;
	let { width = "size-2000" } = $$props;
	let tooltipEl;
	let styleText = "";
	let tooltipCH;

	onMount(() => {
		if (tooltipEl) {
			tooltipEl.parentNode.classList.toggle("u-tooltip-showOnEvent");

			tooltipEl.parentNode.addEventListener(induceStartEventName, function () {
				$$invalidate(0, isOpen = !isOpen);
			});

			if (induceStartEventName !== induceEndEventName) {
				tooltipEl.parentNode.addEventListener(induceEndEventName, function () {
					if (isOpen) $$invalidate(0, isOpen = false);
				});
			}
		}
	});

	afterUpdate(() => {
		let tooltipWrapHeight = tooltipEl.parentNode.clientHeight;
		let tooltipWrapWidth = tooltipEl.parentNode.clientWidth;

		let widthCss = width && width.toString().indexOf("size") !== -1
		? `width:var(--spectrum-global-dimension-${width});`
		: width.toString().indexOf("%") !== -1
			? `width: ${width};`
			: `width: ${width}px;`;

		switch (directions) {
			case "top":
				$$invalidate(5, styleText = `top:-${tooltipCH + tooltipWrapHeight * 0.5}px;${widthCss}`);
				break;
			case "bottom":
				$$invalidate(5, styleText = `top:calc(var(--spectrum-global-dimension-size-75) + ${tooltipWrapHeight}px);${widthCss}`);
				break;
			case "left":
				$$invalidate(5, styleText = `left:calc(-1 * var(--spectrum-global-dimension-size-75));${widthCss}`);
				break;
			case "right":
				$$invalidate(5, styleText = `left:calc(var(--spectrum-global-dimension-size-75) + ${tooltipWrapWidth}px);${widthCss}`);
				break;
		}
	});

	const writable_props = [
		"label",
		"variants",
		"isOpen",
		"directions",
		"induceStartEventName",
		"induceEndEventName",
		"width"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tooltip> was created with unknown prop '${key}'`);
	});

	function span2_elementresize_handler() {
		tooltipCH = this.clientHeight;
		$$invalidate(6, tooltipCH);
	}

	function span2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tooltipEl = $$value;
			$$invalidate(4, tooltipEl);
		});
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("directions" in $$props) $$invalidate(3, directions = $$props.directions);
		if ("induceStartEventName" in $$props) $$invalidate(7, induceStartEventName = $$props.induceStartEventName);
		if ("induceEndEventName" in $$props) $$invalidate(8, induceEndEventName = $$props.induceEndEventName);
		if ("width" in $$props) $$invalidate(9, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		IconInfoMedium: InfoMedium,
		IconAlertMedium: AlertMedium,
		IconSuccessMedium: SuccessMedium,
		IconHelpSmall: HelpSmall,
		afterUpdate,
		onMount,
		label,
		variants,
		isOpen,
		directions,
		induceStartEventName,
		induceEndEventName,
		width,
		tooltipEl,
		styleText,
		tooltipCH
	});

	$$self.$inject_state = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("variants" in $$props) $$invalidate(2, variants = $$props.variants);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("directions" in $$props) $$invalidate(3, directions = $$props.directions);
		if ("induceStartEventName" in $$props) $$invalidate(7, induceStartEventName = $$props.induceStartEventName);
		if ("induceEndEventName" in $$props) $$invalidate(8, induceEndEventName = $$props.induceEndEventName);
		if ("width" in $$props) $$invalidate(9, width = $$props.width);
		if ("tooltipEl" in $$props) $$invalidate(4, tooltipEl = $$props.tooltipEl);
		if ("styleText" in $$props) $$invalidate(5, styleText = $$props.styleText);
		if ("tooltipCH" in $$props) $$invalidate(6, tooltipCH = $$props.tooltipCH);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		isOpen,
		label,
		variants,
		directions,
		tooltipEl,
		styleText,
		tooltipCH,
		induceStartEventName,
		induceEndEventName,
		width,
		$$scope,
		slots,
		span2_elementresize_handler,
		span2_binding
	];
}

class Tooltip extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			label: 1,
			variants: 2,
			isOpen: 0,
			directions: 3,
			induceStartEventName: 7,
			induceEndEventName: 8,
			width: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tooltip",
			options,
			id: create_fragment$3.name
		});
	}

	get label() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variants() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variants(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get directions() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set directions(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get induceStartEventName() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set induceStartEventName(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get induceEndEventName() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set induceEndEventName(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var light = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 75",
				code: "#FAFAFA"
			},
			{
				name: "GRAY 100",
				code: "#F5F5F5"
			},
			{
				name: "GRAY 200",
				code: "#EAEAEA"
			},
			{
				name: "GRAY 300",
				code: "#E1E1E1"
			},
			{
				name: "GRAY 400",
				code: "#CACACA"
			},
			{
				name: "GRAY 500",
				code: "#B3B3B3"
			},
			{
				name: "GRAY 600",
				code: "#8E8E8E"
			},
			{
				name: "GRAY 700",
				code: "#6E6E6E"
			},
			{
				name: "GRAY 800",
				code: "#4B4B4B"
			},
			{
				name: "GRAY 900",
				code: "#2C2C2C"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#2680EB"
			},
			{
				name: "BLUE 500",
				code: "#1473E6"
			},
			{
				name: "BLUE 600",
				code: "#0D66D0"
			},
			{
				name: "BLUE 700",
				code: "#095ABA"
			}
		],
		[
			{
				name: "RED 400",
				code: "#E34850"
			},
			{
				name: "RED 500",
				code: "#D7373F"
			},
			{
				name: "RED 600",
				code: "#C9252D"
			},
			{
				name: "RED 700",
				code: "#BB121A"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#E68619"
			},
			{
				name: "ORANGE 500",
				code: "#DA7B11"
			},
			{
				name: "ORANGE 600",
				code: "#CB6F10"
			},
			{
				name: "ORANGE 700",
				code: "#BD640D"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#2D9D78"
			},
			{
				name: "GREEN 500",
				code: "#268E6C"
			},
			{
				name: "GREEN 600",
				code: "#12805C"
			},
			{
				name: "GREEN 700",
				code: "#107154"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var lightest = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 75",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 100",
				code: "#FFFFFF"
			},
			{
				name: "GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "GRAY 300",
				code: "#eaeaea"
			},
			{
				name: "GRAY 400",
				code: "#d3d3d3"
			},
			{
				name: "GRAY 500",
				code: "#bcbcbc"
			},
			{
				name: "GRAY 600",
				code: "#959595"
			},
			{
				name: "GRAY 700",
				code: "#747474"
			},
			{
				name: "GRAY 800",
				code: "#505050"
			},
			{
				name: "GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#378ef0"
			},
			{
				name: "BLUE 500",
				code: "#2680eb"
			},
			{
				name: "BLUE 600",
				code: "#1473e6"
			},
			{
				name: "BLUE 700",
				code: "#0d66d0"
			}
		],
		[
			{
				name: "RED 400",
				code: "#ec5b62"
			},
			{
				name: "RED 500",
				code: "#e34850"
			},
			{
				name: "RED 600",
				code: "#d7373f"
			},
			{
				name: "RED 700",
				code: "#c9252d"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#f29423"
			},
			{
				name: "ORANGE 500",
				code: "#e68619"
			},
			{
				name: "ORANGE 600",
				code: "#da7b11"
			},
			{
				name: "ORANGE 700",
				code: "#cb6f10"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#33ab84"
			},
			{
				name: "GREEN 500",
				code: "#2d9d78"
			},
			{
				name: "GREEN 600",
				code: "#268e6c"
			},
			{
				name: "GREEN 700",
				code: "#12805c"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var dark = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#252525"
			},
			{
				name: "GRAY 75",
				code: "#2F2F2F"
			},
			{
				name: "GRAY 100",
				code: "#323232"
			},
			{
				name: "GRAY 200",
				code: "#3E3E3E"
			},
			{
				name: "GRAY 300",
				code: "#4A4A4A"
			},
			{
				name: "GRAY 400",
				code: "#5A5A5A"
			},
			{
				name: "GRAY 500",
				code: "#6E6E6E"
			},
			{
				name: "GRAY 600",
				code: "#909090"
			},
			{
				name: "GRAY 700",
				code: "#B9B9B9"
			},
			{
				name: "GRAY 800",
				code: "#E3E3E3"
			},
			{
				name: "GRAY 900",
				code: "#FFFFFF"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#2680EB"
			},
			{
				name: "BLUE 500",
				code: "#378EF0"
			},
			{
				name: "BLUE 600",
				code: "#4B9CF5"
			},
			{
				name: "BLUE 700",
				code: "#5AA9FA"
			}
		],
		[
			{
				name: "RED 400",
				code: "#E34850"
			},
			{
				name: "RED 500",
				code: "#EC5B62"
			},
			{
				name: "RED 600",
				code: "#F76D74"
			},
			{
				name: "RED 700",
				code: "#FF7B82"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#E68619"
			},
			{
				name: "ORANGE 500",
				code: "#F29423"
			},
			{
				name: "ORANGE 600",
				code: "#F9A43F"
			},
			{
				name: "ORANGE 700",
				code: "#FFB55B"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#2D9D78"
			},
			{
				name: "GREEN 500",
				code: "#33AB84"
			},
			{
				name: "GREEN 600",
				code: "#39B990"
			},
			{
				name: "GREEN 700",
				code: "#3FC89C"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var darkest = {
	globalColor: [
		[
			{
				name: "GRAY 50",
				code: "#080808"
			},
			{
				name: "GRAY 75",
				code: "#1a1a1a"
			},
			{
				name: "GRAY 100",
				code: "#1e1e1e"
			},
			{
				name: "GRAY 200",
				code: "#2c2c2c"
			},
			{
				name: "GRAY 300",
				code: "#393939"
			},
			{
				name: "GRAY 400",
				code: "#494949"
			},
			{
				name: "GRAY 500",
				code: "#5c5c5c"
			},
			{
				name: "GRAY 600",
				code: "#7c7c7c"
			},
			{
				name: "GRAY 700",
				code: "#a2a2a2"
			},
			{
				name: "GRAY 800",
				code: "#c8c8c8"
			},
			{
				name: "GRAY 900",
				code: "#efefef"
			}
		],
		[
			{
				name: "BLUE 400",
				code: "#1473e6"
			},
			{
				name: "BLUE 500",
				code: "#2680eb"
			},
			{
				name: "BLUE 600",
				code: "#378ef0"
			},
			{
				name: "BLUE 700",
				code: "#4b9cf5"
			}
		],
		[
			{
				name: "RED 400",
				code: "#d7373f"
			},
			{
				name: "RED 500",
				code: "#e34850"
			},
			{
				name: "RED 600",
				code: "#ec5b62"
			},
			{
				name: "RED 700",
				code: "#f76d74"
			}
		],
		[
			{
				name: "ORANGE 400",
				code: "#da7b11"
			},
			{
				name: "ORANGE 500",
				code: "#e68619"
			},
			{
				name: "ORANGE 600",
				code: "#f29423"
			},
			{
				name: "ORANGE 700",
				code: "#f9a43f"
			}
		],
		[
			{
				name: "GREEN 400",
				code: "#268e6c"
			},
			{
				name: "GREEN 500",
				code: "#2d9d78"
			},
			{
				name: "GREEN 600",
				code: "#33ab84"
			},
			{
				name: "GREEN 700",
				code: "#39b990"
			}
		]
	],
	staticColor: [
		[
			{
				name: "STATIC WHITE",
				code: "#FFFFFF"
			},
			{
				name: "STATIC BLACK",
				code: "#000000"
			}
		],
		[
			{
				name: "STATIC GRAY 200",
				code: "#F4F4F4"
			},
			{
				name: "STATIC GRAY 300",
				code: "#EAEAEA"
			},
			{
				name: "STATIC GRAY 400",
				code: "#D3D3D3"
			},
			{
				name: "STATIC GRAY 500",
				code: "#BCBCBC"
			},
			{
				name: "STATIC GRAY 600",
				code: "#959595"
			},
			{
				name: "STATIC GRAY 700",
				code: "#747474"
			},
			{
				name: "STATIC GRAY 800",
				code: "#505050"
			},
			{
				name: "STATIC GRAY 900",
				code: "#323232"
			}
		],
		[
			{
				name: "STATIC BLUE 400",
				code: "#378EF0"
			},
			{
				name: "STATIC BLUE 500",
				code: "#2680EB"
			},
			{
				name: "STATIC BLUE 600",
				code: "#1473E6"
			},
			{
				name: "STATIC BLUE 700",
				code: "#0D66D0"
			}
		],
		[
			{
				name: "STATIC RED 400",
				code: "#EC5B62"
			},
			{
				name: "STATIC RED 500",
				code: "#E34850"
			},
			{
				name: "STATIC RED 600",
				code: "#D7373F"
			},
			{
				name: "STATIC RED 700",
				code: "#C9252D"
			}
		],
		[
			{
				name: "STATIC ORANGE 400",
				code: "#F29423"
			},
			{
				name: "STATIC ORANGE 500",
				code: "#E68619"
			},
			{
				name: "STATIC ORANGE 600",
				code: "#DA7B11"
			},
			{
				name: "STATIC ORANGE 700",
				code: "#CB6F10"
			}
		],
		[
			{
				name: "STATIC GREEN 400",
				code: "#33ABB4"
			},
			{
				name: "STATIC GREEN 500",
				code: "#2D9D78"
			},
			{
				name: "STATIC GREEN 600",
				code: "#268E6C"
			},
			{
				name: "STATIC GREEN 400",
				code: "#12805C"
			}
		]
	]
};
var color = {
	light: light,
	lightest: lightest,
	dark: dark,
	darkest: darkest
};

var colorData = /*#__PURE__*/Object.freeze({
  __proto__: null,
  light: light,
  lightest: lightest,
  dark: dark,
  darkest: darkest,
  'default': color
});

/* src/components/color-container/ColorContainer.svelte generated by Svelte v3.29.4 */

const { console: console_1 } = globals;
const file$4 = "src/components/color-container/ColorContainer.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (202:4) <Checkbox checked={staticColorsView} on:click={handleClick}>
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Static colors");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Static colors");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(202:4) <Checkbox checked={staticColorsView} on:click={handleClick}>",
		ctx
	});

	return block;
}

// (223:6) {#each items as colorItem}
function create_each_block_1(ctx) {
	let div2;
	let div0;
	let t0_value = /*colorItem*/ ctx[14].name + "";
	let t0;
	let t1;
	let div1;

	let t2_value = (/*colorModel*/ ctx[0] == "hex"
	? /*colorItem*/ ctx[14].code.toUpperCase()
	: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()) + "";

	let t2;
	let t3;
	let tooltip;
	let div2_class_value;
	let div2_style_value;
	let current;
	let mounted;
	let dispose;

	tooltip = new Tooltip({
			props: {
				width: "size-600",
				directions: "bottom",
				label: "复制"
			},
			$$inline: true
		});

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[10](/*colorItem*/ ctx[14], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text(t2_value);
			t3 = space();
			create_component(tooltip.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, t2_value);
			t3 = claim_space(div1_nodes);
			claim_component(tooltip.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "color-item-name svelte-rdoezz");
			add_location(div0, file$4, 229, 10, 9530);
			attr_dev(div1, "class", "color-item-code svelte-rdoezz");
			add_location(div1, file$4, 230, 10, 9592);

			attr_dev(div2, "class", div2_class_value = "color-item " + (/*lightAndDark*/ ctx[7](/*colorItem*/ ctx[14].code)
			? "color-item-dark"
			: "color-item-light") + " svelte-rdoezz");

			attr_dev(div2, "style", div2_style_value = `background-color:${/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()}`);

			add_location(div2, file$4, 223, 8, 9185);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);
			append_dev(div1, t3);
			mount_component(tooltip, div1, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div2, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*$rubusDocConfig, colorDisplay*/ 12) && t0_value !== (t0_value = /*colorItem*/ ctx[14].name + "")) set_data_dev(t0, t0_value);

			if ((!current || dirty & /*colorModel, $rubusDocConfig, colorDisplay*/ 13) && t2_value !== (t2_value = (/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()) + "")) set_data_dev(t2, t2_value);

			if (!current || dirty & /*$rubusDocConfig, colorDisplay*/ 12 && div2_class_value !== (div2_class_value = "color-item " + (/*lightAndDark*/ ctx[7](/*colorItem*/ ctx[14].code)
			? "color-item-dark"
			: "color-item-light") + " svelte-rdoezz")) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*colorModel, $rubusDocConfig, colorDisplay*/ 13 && div2_style_value !== (div2_style_value = `background-color:${/*colorModel*/ ctx[0] == "hex"
			? /*colorItem*/ ctx[14].code.toUpperCase()
			: hexToRGB(/*colorItem*/ ctx[14].code).toUpperCase()}`)) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tooltip.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tooltip.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(tooltip);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(223:6) {#each items as colorItem}",
		ctx
	});

	return block;
}

// (221:2) {#each colorData[$rubusDocConfig.theme][colorDisplay] as items}
function create_each_block(ctx) {
	let div;
	let t;
	let current;
	let each_value_1 = /*items*/ ctx[11];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "color-group svelte-rdoezz");
			add_location(div, file$4, 221, 4, 9118);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lightAndDark, colorData, $rubusDocConfig, colorDisplay, colorModel, hexToRGB, copyColor*/ 205) {
				each_value_1 = /*items*/ ctx[11];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(221:2) {#each colorData[$rubusDocConfig.theme][colorDisplay] as items}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div1;
	let form0;
	let checkbox;
	let t0;
	let div0;
	let t1;
	let form1;
	let radio0;
	let t2;
	let radio1;
	let t3;
	let div2;
	let t4;
	let toast;
	let current;

	checkbox = new Checkbox({
			props: {
				checked: /*staticColorsView*/ ctx[1],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleClick*/ ctx[5]);

	radio0 = new Radio({
			props: {
				value: "Hex",
				checked: /*colorModel*/ ctx[0] == "hex"
			},
			$$inline: true
		});

	radio0.$on("click", /*click_handler*/ ctx[8]);

	radio1 = new Radio({
			props: {
				value: "RGB",
				checked: /*colorModel*/ ctx[0] == "rgb"
			},
			$$inline: true
		});

	radio1.$on("click", /*click_handler_1*/ ctx[9]);
	let each_value = colorData[/*$rubusDocConfig*/ ctx[3].theme][/*colorDisplay*/ ctx[2]];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	toast = new Toast({
			props: { label: "复制成功", variants: "success" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			form0 = element("form");
			create_component(checkbox.$$.fragment);
			t0 = space();
			div0 = element("div");
			t1 = space();
			form1 = element("form");
			create_component(radio0.$$.fragment);
			t2 = space();
			create_component(radio1.$$.fragment);
			t3 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			create_component(toast.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			form0 = claim_element(div1_nodes, "FORM", { class: true });
			var form0_nodes = children(form0);
			claim_component(checkbox.$$.fragment, form0_nodes);
			form0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			form1 = claim_element(div1_nodes, "FORM", { class: true });
			var form1_nodes = children(form1);
			claim_component(radio0.$$.fragment, form1_nodes);
			t2 = claim_space(form1_nodes);
			claim_component(radio1.$$.fragment, form1_nodes);
			form1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			claim_component(toast.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(form0, "class", "svelte-rdoezz");
			add_location(form0, file$4, 200, 2, 8576);
			attr_dev(div0, "class", "vertical-line svelte-rdoezz");
			add_location(div0, file$4, 203, 2, 8684);
			attr_dev(form1, "class", "color-model svelte-rdoezz");
			add_location(form1, file$4, 204, 2, 8716);
			attr_dev(div1, "class", "toolbar svelte-rdoezz");
			add_location(div1, file$4, 199, 0, 8552);
			attr_dev(div2, "class", "color-container svelte-rdoezz");
			add_location(div2, file$4, 219, 0, 9018);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, form0);
			mount_component(checkbox, form0, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div1, t1);
			append_dev(div1, form1);
			mount_component(radio0, form1, null);
			append_dev(form1, t2);
			mount_component(radio1, form1, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, div2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			insert_dev(target, t4, anchor);
			mount_component(toast, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const checkbox_changes = {};
			if (dirty & /*staticColorsView*/ 2) checkbox_changes.checked = /*staticColorsView*/ ctx[1];

			if (dirty & /*$$scope*/ 131072) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
			const radio0_changes = {};
			if (dirty & /*colorModel*/ 1) radio0_changes.checked = /*colorModel*/ ctx[0] == "hex";
			radio0.$set(radio0_changes);
			const radio1_changes = {};
			if (dirty & /*colorModel*/ 1) radio1_changes.checked = /*colorModel*/ ctx[0] == "rgb";
			radio1.$set(radio1_changes);

			if (dirty & /*colorData, $rubusDocConfig, colorDisplay, lightAndDark, colorModel, hexToRGB, copyColor*/ 205) {
				each_value = colorData[/*$rubusDocConfig*/ ctx[3].theme][/*colorDisplay*/ ctx[2]];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div2, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			transition_in(radio0.$$.fragment, local);
			transition_in(radio1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(toast.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			transition_out(radio0.$$.fragment, local);
			transition_out(radio1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(toast.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(checkbox);
			destroy_component(radio0);
			destroy_component(radio1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(toast, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function hexToRGB(h) {
	let r = 0, g = 0, b = 0;

	// 3 digits
	if (h.length == 4) {
		r = "0x" + h[1] + h[1];
		g = "0x" + h[2] + h[2];
		b = "0x" + h[3] + h[3];
	} else if (h.length == 7) {
		r = "0x" + h[1] + h[2]; // 6 digits
		g = "0x" + h[3] + h[4];
		b = "0x" + h[5] + h[6];
	}

	return "rgb(" + +r + "," + +g + "," + +b + ")";
}

function hexToHSL(H) {
	let r = 0, g = 0, b = 0;

	if (H.length == 4) {
		r = "0x" + H[1] + H[1];
		g = "0x" + H[2] + H[2];
		b = "0x" + H[3] + H[3];
	} else if (H.length == 7) {
		r = "0x" + H[1] + H[2];
		g = "0x" + H[3] + H[4];
		b = "0x" + H[5] + H[6];
	}

	// Then to HSL
	r /= 255;

	g /= 255;
	b /= 255;

	let cmin = Math.min(r, g, b),
		cmax = Math.max(r, g, b),
		delta = cmax - cmin,
		h = 0,
		s = 0,
		l = 0;

	if (delta == 0) h = 0; else if (cmax == r) h = (g - b) / delta % 6; else if (cmax == g) h = (b - r) / delta + 2; else h = (r - g) / delta + 4;
	h = Math.round(h * 60);
	if (h < 0) h += 360;
	l = (cmax + cmin) / 2;
	s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
	s = +(s * 100).toFixed(1);
	l = +(l * 100).toFixed(1);
	return [h, s, l];
}

function instance$4($$self, $$props, $$invalidate) {
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ColorContainer", slots, []);
	let colorModel = "hex";
	let staticColorsView = false;
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(3, $rubusDocConfig = value));
	let colorDisplay = "globalColor";

	onMount(() => {
		
	});

	function handleClick() {
		$$invalidate(1, staticColorsView = !staticColorsView);
		$$invalidate(2, colorDisplay = staticColorsView ? "staticColor" : "globalColor");
	}

	async function copyColor(t, c) {
		if (colorModel !== "hex") {
			c = hexToRGB(c);
		}

		let colorCode = staticColorsView
		? `--spectrum-global-color-static-${t.replace(/[^a-zA-Z]/gi, "").toLowerCase()}-${t.replace(/[^0-9]/gi, "")}: ${c}`
		: `--spectrum-global-color-${t.replace(/[^a-zA-Z]/gi, "").toLowerCase()}-${t.replace(/[^0-9]/gi, "")}: ${c}`;

		if (navigator.clipboard) {
			try {
				await navigator.clipboard.writeText(colorCode);
				console.log("Page URL copied to clipboard:" + colorCode);
			} catch(err) {
				console.error("Failed to copy: ", err);
			}
		}
	}

	function lightAndDark(code) {
		let [,,l] = hexToHSL(code);
		let crossover = 50;

		switch ($rubusDocConfig.theme) {
			case "light":
				crossover = 60;
				break;
			case "lightest":
				crossover = 70;
				break;
			case "dark":
				crossover = 38;
				break;
			case "darkest":
				crossover = 35;
				break;
		}

		return l >= crossover ? false : true;
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ColorContainer> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, colorModel = "hex");
	};

	const click_handler_1 = () => {
		$$invalidate(0, colorModel = "rgb");
	};

	const click_handler_2 = colorItem => {
		copyColor(colorItem.name, colorItem.code);
	};

	$$self.$capture_state = () => ({
		Radio,
		Checkbox,
		Tooltip,
		Toast,
		getContext,
		onMount,
		colorData,
		colorModel,
		staticColorsView,
		rubusDocConfig,
		colorDisplay,
		handleClick,
		copyColor,
		hexToRGB,
		hexToHSL,
		lightAndDark,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("colorModel" in $$props) $$invalidate(0, colorModel = $$props.colorModel);
		if ("staticColorsView" in $$props) $$invalidate(1, staticColorsView = $$props.staticColorsView);
		if ("rubusDocConfig" in $$props) $$invalidate(4, rubusDocConfig = $$props.rubusDocConfig);
		if ("colorDisplay" in $$props) $$invalidate(2, colorDisplay = $$props.colorDisplay);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		colorModel,
		staticColorsView,
		colorDisplay,
		$rubusDocConfig,
		rubusDocConfig,
		handleClick,
		copyColor,
		lightAndDark,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class ColorContainer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ColorContainer",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/docs/csstokens/color/index.svelte generated by Svelte v3.29.4 */
const file$5 = "src/routes/docs/csstokens/color/index.svelte";

// (19:2) <TypographyHeading scale="XL">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("颜色");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "颜色");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(19:2) <TypographyHeading scale=\\\"XL\\\">",
		ctx
	});

	return block;
}

// (20:2) <TypographyBody scale="M">
function create_default_slot$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("位于设计系统中的颜色令牌");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "位于设计系统中的颜色令牌");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(20:2) <TypographyBody scale=\\\"M\\\">",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let title_value;
	let t0;
	let header;
	let typographyheading;
	let t1;
	let typographybody;
	let t2;
	let main;
	let colorcontainer;
	let current;
	document.title = title_value = "" + (/*$rubusDocConfig*/ ctx[0].name + " 颜色");

	typographyheading = new TypographyHeading({
			props: {
				scale: "XL",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	typographybody = new TypographyBody({
			props: {
				scale: "M",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	colorcontainer = new ColorContainer({ $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			header = element("header");
			create_component(typographyheading.$$.fragment);
			t1 = space();
			create_component(typographybody.$$.fragment);
			t2 = space();
			main = element("main");
			create_component(colorcontainer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1xk3tor\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			claim_component(typographyheading.$$.fragment, header_nodes);
			t1 = claim_space(header_nodes);
			claim_component(typographybody.$$.fragment, header_nodes);
			header_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			claim_component(colorcontainer.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-145r0l5");
			add_location(header, file$5, 17, 0, 801);
			add_location(main, file$5, 22, 0, 934);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, header, anchor);
			mount_component(typographyheading, header, null);
			append_dev(header, t1);
			mount_component(typographybody, header, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, main, anchor);
			mount_component(colorcontainer, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*$rubusDocConfig*/ 1) && title_value !== (title_value = "" + (/*$rubusDocConfig*/ ctx[0].name + " 颜色"))) {
				document.title = title_value;
			}

			const typographyheading_changes = {};

			if (dirty & /*$$scope*/ 4) {
				typographyheading_changes.$$scope = { dirty, ctx };
			}

			typographyheading.$set(typographyheading_changes);
			const typographybody_changes = {};

			if (dirty & /*$$scope*/ 4) {
				typographybody_changes.$$scope = { dirty, ctx };
			}

			typographybody.$set(typographybody_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typographyheading.$$.fragment, local);
			transition_in(typographybody.$$.fragment, local);
			transition_in(colorcontainer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typographyheading.$$.fragment, local);
			transition_out(typographybody.$$.fragment, local);
			transition_out(colorcontainer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(header);
			destroy_component(typographyheading);
			destroy_component(typographybody);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(main);
			destroy_component(colorcontainer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let $rubusDocConfig;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Color", slots, []);
	let rubusDocConfig = getContext("rubusDocConfig");
	validate_store(rubusDocConfig, "rubusDocConfig");
	component_subscribe($$self, rubusDocConfig, value => $$invalidate(0, $rubusDocConfig = value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Color> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		TypographyHeading,
		TypographyBody,
		getContext,
		ColorContainer,
		rubusDocConfig,
		$rubusDocConfig
	});

	$$self.$inject_state = $$props => {
		if ("rubusDocConfig" in $$props) $$invalidate(1, rubusDocConfig = $$props.rubusDocConfig);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$rubusDocConfig, rubusDocConfig];
}

class Color extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Color",
			options,
			id: create_fragment$5.name
		});
	}
}

export default Color;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYTdiNzc4OTIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL0NoZWNrYm94L0NoZWNrYm94LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1JhZGlvL1JhZGlvLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1RvYXN0L1RvYXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcnVidXMvcnVidXMvc3JjL3BhY2thZ2VzL1Rvb2x0aXAvVG9vbHRpcC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9jb2xvci1jb250YWluZXIvQ29sb3JDb250YWluZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kb2NzL2Nzc3Rva2Vucy9jb2xvci9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSWNvbkNoZWNrbWFya1NtYWxsLCBJY29uRGFzaFNtYWxsIH0gZnJvbSBcIkBydWJ1cy9zdmVsdGUtc3BlY3RydW0taWNvbnMtdWlcIjtcbiAgaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIjtcbiAgaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tIFwidGhyb3R0bGUtZGVib3VuY2VcIjtcbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUsIG9uRGVzdHJveSB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gIGltcG9ydCB7IGdldEV2ZW50c0FjdGlvbiB9IGZyb20gXCIuLi91dGlscy9nZXQtZXZlbnRzLWFjdGlvbi5qc1wiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGNoZWNrZWRcbiAgICogQHR5cGUge2Jvb2xlYW59IFtjaGVja2VkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBjaGVja2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgY2hlY2tib3hcbiAgICogQHR5cGUge2Jvb2xlYW59IFtkaXNhYmxlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgaW5wdXQgc2hvdWxkIGRpc3BsYXkgaXRzIFwidmFsaWRcIiBvciBcImludmFsaWRcIiB2aXN1YWwgc3R5bGluZy5cbiAgICogQHR5cGUge2Jvb2xlYW59IFtpc0ludmFsaWQ9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGlzIHByb3Agc2V0cyB0aGUgcXVpZXQgc3R5bGUgd2hpY2ggcHJvdmlkZXMgdmlzdWFsIHdlYWtlbi5cbiAgICogQHR5cGUge2Jvb2xlYW59IFtpc1F1aWV0PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1F1aWV0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgd2hldGhlciB0aGUgY2hlY2tib3ggaXMgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gW2luZGV0ZXJtaW5hdGU9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCBmb3IgdGhlIGNoZWNrYm94IHRvIGJlIHJlYWQtb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gW3JlYWRvbmx5PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCByZWFkb25seSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuYW1lIGZvciB0aGUgaW5wdXQgZWxlbWVudFxuICAgKiBAdHlwZSB7c3RyaW5nfSBbbmFtZT1cIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBuYW1lID0gXCJcIjtcblxuICAvKipcbiAgICogU2V0IGFuIGlkIGZvciB0aGUgaW5wdXQgZWxlbWVudFxuICAgKiBAdHlwZSB7c3RyaW5nfSBbaWQgPSBcImNoZWNrYm94LVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygyNCldXG4gICAqL1xuICBleHBvcnQgbGV0IGlkID0gXCJjaGVja2JveC1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMjQpO1xuXG4gIC8qKlxuICAgKiBTZXQgYW4gaWQgZm9yIHRoZSBpbnB1dCBlbGVtZW50XG4gICAqIEB0eXBlIHtzdHJpbmd9IFt2YWx1ZSA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IHZhbHVlID0gXCJcIjtcblxuICAvKipcbiAgICogU2V0IGFuIHRpdGxlIGZvciB0aGUgaW5wdXQgbGFiYWxcbiAgICogQHR5cGUge3N0cmluZ30gW3RpdGxlID0gXCJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgdGl0bGUgPSBcIlwiO1xuXG4gIGxldCBjaGVja2JveDtcbiAgbGV0IGljb25TaXplID0gMTA7XG4gIGxldCBsYXJnZSA9IGZhbHNlO1xuICBjb25zdCBldmVudHNMaXN0ZW4gPSBnZXRFdmVudHNBY3Rpb24oY3VycmVudF9jb21wb25lbnQpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihnZXRJY29uU2NhbGUpO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICB0aHJvdHRsZSg1MDAsIG9ic2VydmVyLm9ic2VydmUoY2hlY2tib3gpKTtcbiAgfSk7XG5cbiAgb25EZXN0cm95KCgpID0+IHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoY2hlY2tib3gpO1xuICB9KTtcblxuICBmdW5jdGlvbiBnZXRJY29uU2NhbGUoKSB7XG4gICAgaWNvblNpemUgPSBwYXJzZUludChcbiAgICAgIGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtMTI1XCIpXG4gICAgKTtcbiAgICBpZiAoaWNvblNpemUgPT0gMTApIHtcbiAgICAgIGxhcmdlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAucmVhZG9ubHkge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuXG57I2lmIHJlYWRvbmx5fVxuICA8bGFiZWxcbiAgICB7dGl0bGV9XG4gICAgey4uLiQkcmVzdFByb3BzfVxuICAgIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3ggcmVhZG9ubHkgeyQkcmVzdFByb3BzLmNsYXNzfVwiXG4gICAgY2xhc3M6aXMtZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgIGNsYXNzOmlzLWluZGV0ZXJtaW5hdGU9e2luZGV0ZXJtaW5hdGV9XG4gICAgY2xhc3M6aXMtaW52YWxpZD17aXNJbnZhbGlkfVxuICAgIGNsYXNzOnNwZWN0cnVtLUNoZWNrYm94LS1xdWlldD17aXNRdWlldH0+XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveC1pbnB1dFwiXG4gICAgICB7aWR9XG4gICAgICB7bmFtZX1cbiAgICAgIHtkaXNhYmxlZH1cbiAgICAgIHt2YWx1ZX1cbiAgICAgIGJpbmQ6dGhpcz17Y2hlY2tib3h9XG4gICAgICB7Y2hlY2tlZH1cbiAgICAgIHtpbmRldGVybWluYXRlfSAvPlxuICAgIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3gtYm94XCI+XG4gICAgICB7I2lmIGNoZWNrZWR9XG4gICAgICAgIDxJY29uQ2hlY2ttYXJrU21hbGxcbiAgICAgICAgICB3aWR0aD17aWNvblNpemUgLSAxfVxuICAgICAgICAgIGhlaWdodD17aWNvblNpemUgLSAxfVxuICAgICAgICAgIHNjYWxlPXtsYXJnZSA/ICdMJyA6ICdNJ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJzcGVjdHJ1bS1DaGVja2JveC1jaGVja21hcmtcIlxuICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICAgICAgey9pZn1cbiAgICAgIHsjaWYgaW5kZXRlcm1pbmF0ZX1cbiAgICAgICAgPEljb25EYXNoU21hbGxcbiAgICAgICAgICB3aWR0aD17aWNvblNpemV9XG4gICAgICAgICAgaGVpZ2h0PXtpY29uU2l6ZX1cbiAgICAgICAgICBzY2FsZT17bGFyZ2UgPyAnTCcgOiAnTSd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwic3BlY3RydW0tQ2hlY2tib3gtcGFydGlhbENoZWNrbWFya1wiXG4gICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gICAgICB7L2lmfVxuICAgIDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94LWxhYmVsXCI+XG4gICAgICA8c2xvdD5DaGVja2JveDwvc2xvdD5cbiAgICA8L3NwYW4+XG4gIDwvbGFiZWw+XG57OmVsc2V9XG4gIDxsYWJlbFxuICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94IHskJHJlc3RQcm9wcy5jbGFzc31cIlxuICAgIGNsYXNzOmlzLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICBjbGFzczppcy1pbmRldGVybWluYXRlPXtpbmRldGVybWluYXRlfVxuICAgIGNsYXNzOmlzLWludmFsaWQ9e2lzSW52YWxpZH1cbiAgICBjbGFzczpzcGVjdHJ1bS1DaGVja2JveC0tcXVpZXQ9e2lzUXVpZXR9XG4gICAgdXNlOmV2ZW50c0xpc3Rlbj5cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICBjbGFzcz1cInNwZWN0cnVtLUNoZWNrYm94LWlucHV0XCJcbiAgICAgIHtpZH1cbiAgICAgIHtuYW1lfVxuICAgICAge2Rpc2FibGVkfVxuICAgICAge3ZhbHVlfVxuICAgICAgYmluZDp0aGlzPXtjaGVja2JveH1cbiAgICAgIGJpbmQ6Y2hlY2tlZFxuICAgICAgYmluZDppbmRldGVybWluYXRlIC8+XG4gICAgPHNwYW4gY2xhc3M9XCJzcGVjdHJ1bS1DaGVja2JveC1ib3hcIj5cbiAgICAgIHsjaWYgY2hlY2tlZH1cbiAgICAgICAgPEljb25DaGVja21hcmtTbWFsbFxuICAgICAgICAgIHdpZHRoPXtpY29uU2l6ZSAtIDF9XG4gICAgICAgICAgaGVpZ2h0PXtpY29uU2l6ZSAtIDF9XG4gICAgICAgICAgc2NhbGU9e2xhcmdlID8gJ0wnIDogJ00nfVxuICAgICAgICAgIGNsYXNzTmFtZT1cInNwZWN0cnVtLUNoZWNrYm94LWNoZWNrbWFya1wiXG4gICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gICAgICB7L2lmfVxuICAgICAgeyNpZiBpbmRldGVybWluYXRlfVxuICAgICAgICA8SWNvbkRhc2hTbWFsbFxuICAgICAgICAgIHdpZHRoPXtpY29uU2l6ZX1cbiAgICAgICAgICBoZWlnaHQ9e2ljb25TaXplfVxuICAgICAgICAgIHNjYWxlPXtsYXJnZSA/ICdMJyA6ICdNJ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJzcGVjdHJ1bS1DaGVja2JveC1wYXJ0aWFsQ2hlY2ttYXJrXCJcbiAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cbiAgICAgIHsvaWZ9XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tQ2hlY2tib3gtbGFiZWxcIj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9zcGFuPlxuICA8L2xhYmVsPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gIC8qKlxuICAgKiBUaGUgZWxlbWVudCdzIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgKiBAdHlwZSB7IHN0cmluZyB9W2lkID0gYHJhZGlvLSR7TWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDk5OTk5IC0gMCkpICsgMH1gXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpZCA9IGByYWRpby0ke01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICg5OTk5OSAtIDApKSArIDB9YDtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCB0byBjaGVja2VkIHRoZSByYWRpb1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1bY2hlY2tlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgY2hlY2tlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIHRvIGludmFsaWQgdGhlIHJhZGlvXG4gICAqIEB0eXBlIHtib29sZWFufVtjaGVja2VkPWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc0ludmFsaWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCB0byBkaXNhYmxlIHRoZSByYWRpb1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1bZGlzYWJsZWQ9ZmFsc2VdXG4gICAqL1xuICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHF1aWV0IG1vZGUgb2YgcmFkaW9cbiAgICogQHR5cGUgeyBib29sZWFuIH0gW2lzUXVpZXQ9IGZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpc1F1aWV0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSByYWRpbyBidXR0b24sIHVzZWQgd2hlbiBzdWJtaXR0aW5nIGFuIEhUTUwgZm9ybS5cbiAgICogQHR5cGUgeyBzdHJpbmcgfVsgbmFtZSA9IFwicmFkaW9cIiBdXG4gICAqL1xuICBleHBvcnQgbGV0IG5hbWUgPSBcInJhZGlvXCI7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgcmFkaW8gYnV0dG9uLCB1c2VkIHdoZW4gc3VibWl0dGluZyBhbiBIVE1MIGZvcm0uXG4gICAqIEB0eXBlIHsgc3RyaW5nIH1bdmFsdWUgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YWx1ZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHJlYWRvbmx5IG1vZGUgb2YgcmFkaW9cbiAgICogQHR5cGUge2Jvb2xlYW59W3JlYWRvbmx5PWZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCByZWFkb25seSA9IGZhbHNlO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zcGVjdHJ1bS1SYWRpby5pcy1yZWFkb25seSB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgY2xhc3M9XCJzcGVjdHJ1bS1SYWRpb1wiXG4gIGNsYXNzOnNwZWN0cnVtLVJhZGlvLS1xdWlldD17aXNRdWlldH1cbiAgY2xhc3M6aXMtaW52YWxpZD17aXNJbnZhbGlkfVxuICBjbGFzczppcy1yZWFkb25seT17cmVhZG9ubHl9XG4gIG9uOmNsaWNrXG4gIG9uOmtleWRvd25cbiAgb246a2V5dXBcbiAgb246a2V5cHJlc3NcbiAgb246ZGJsY2xpY2s+XG4gIDxpbnB1dCB0eXBlPVwicmFkaW9cIiB7bmFtZX0gY2xhc3M9XCJzcGVjdHJ1bS1SYWRpby1pbnB1dFwiIHtpZH0ge2NoZWNrZWR9IHtkaXNhYmxlZH0ge3ZhbHVlfSB7cmVhZG9ubHl9IC8+XG4gIDxzcGFuIGNsYXNzPVwic3BlY3RydW0tUmFkaW8tYnV0dG9uXCIgLz5cbiAgPGxhYmVsIGNsYXNzPVwic3BlY3RydW0tUmFkaW8tbGFiZWxcIiBmb3I9e2lkfT48c2xvdD57dmFsdWV9PC9zbG90PjwvbGFiZWw+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBCdXR0b24gZnJvbSBcIi4uL0J1dHRvblwiO1xuICBpbXBvcnQgeyBJY29uQ3Jvc3NNZWRpdW0sIEljb25JbmZvTWVkaXVtLCBJY29uQWxlcnRNZWRpdW0sIEljb25TdWNjZXNzTWVkaXVtIH0gZnJvbSBcIkBydWJ1cy9zdmVsdGUtc3BlY3RydW0taWNvbnMtdWlcIjtcblxuICAvKipcbiAgICogIFNwZWNpZnkgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSB0b2FzdFxuICAgKiBAdHlwZSB7c3RyaW5nfSBbbGFiZWwgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBsYWJlbCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHZhcmlhbnRzICBmb3IgdGhlICB0b2FzdFxuICAgKiBAdHlwZSB7XCJkZWZhdWx0XCIgfCBcImluZm9cIiB8IFwibmVnYXRpdmVcIiB8IFwicG9zaXRpdmVcIiB8IFwiZXJyb3JcIiB8IFwid2FybmluZ1wiIHwgXCJzdWNjZXNzXCJ9IFt2YXJpYW50cyA9IFwiZGVmYXVsdFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YXJpYW50cyA9IFwiZGVmYXVsdFwiO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxlbWVudCBjc3MgaGVpZ2h0XG4gICAqIEB0eXBlIHtEaW1lbnNpb25WYWx1ZX0gW2hlaWdodCA9IFwiMTAwJVwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBoZWlnaHQgPSBcImF1dG9cIjtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgY3NzIHdpZHRoXG4gICAqIEB0eXBlIHtEaW1lbnNpb25WYWx1ZX0gW3dpZHRoID0gXCJhdXRvXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IHdpZHRoID0gXCJhdXRvXCI7XG5cbiAgJDogc3R5bGVDc3NUZXh0ID0gW1xuICAgIGhlaWdodCAmJiBoZWlnaHQudG9TdHJpbmcoKS5pbmRleE9mKFwic2l6ZVwiKSAhPT0gLTFcbiAgICAgID8gYGhlaWdodDp2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLSR7aGVpZ2h0fSk7YFxuICAgICAgOiBoZWlnaHQudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKSAhPT0gLTFcbiAgICAgID8gYGhlaWdodDogJHtoZWlnaHR9O2BcbiAgICAgIDogYGhlaWdodDogJHtoZWlnaHR9cHg7YCxcbiAgICB3aWR0aCAmJiB3aWR0aC50b1N0cmluZygpLmluZGV4T2YoXCJzaXplXCIpICE9PSAtMVxuICAgICAgPyBgd2lkdGg6dmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi0ke3dpZHRofSk7YFxuICAgICAgOiB3aWR0aC50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpICE9PSAtMVxuICAgICAgPyBgd2lkdGg6ICR7d2lkdGh9O2BcbiAgICAgIDogYHdpZHRoOiAke3dpZHRofXB4O2AsXG4gIF1cbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oXCIgXCIpO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJzcGVjdHJ1bS1Ub2FzdCBzcGVjdHJ1bS1Ub2FzdC0te3ZhcmlhbnRzfVwiIHN0eWxlPXtzdHlsZUNzc1RleHR9PlxuICB7I2lmIHZhcmlhbnRzID09PSAnaW5mbyd9XG4gICAgPEljb25JbmZvTWVkaXVtIGNsYXNzTmFtZT1cInNwZWN0cnVtLVRvYXN0LXR5cGVJY29uXCIgLz5cbiAgezplbHNlIGlmIHZhcmlhbnRzID09PSAnbmVnYXRpdmUnIHx8IHZhcmlhbnRzID09PSAnZXJyb3InIHx8IHZhcmlhbnRzID09PSAnd2FybmluZyd9XG4gICAgPEljb25BbGVydE1lZGl1bSBjbGFzc05hbWU9XCJzcGVjdHJ1bS1Ub2FzdC10eXBlSWNvblwiIC8+XG4gIHs6ZWxzZSBpZiB2YXJpYW50cyA9PT0gJ3Bvc2l0aXZlJyB8fCB2YXJpYW50cyA9PT0gJ3N1Y2Nlc3MnfVxuICAgIDxJY29uU3VjY2Vzc01lZGl1bSBjbGFzc05hbWU9XCJzcGVjdHJ1bS1Ub2FzdC10eXBlSWNvblwiIC8+XG4gIHsvaWZ9XG4gIDxkaXYgY2xhc3M9XCJzcGVjdHJ1bS1Ub2FzdC1ib2R5XCI+XG4gICAgPGRpdiBjbGFzcz1cInNwZWN0cnVtLVRvYXN0LWNvbnRlbnRcIj57bGFiZWx9PC9kaXY+XG4gICAgPHNsb3QgLz5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJzcGVjdHJ1bS1Ub2FzdC1idXR0b25zXCI+XG4gICAgPEJ1dHRvbiBleHRlcmlvcj1cImNsZWFyXCIgdmFyaWFudD1cIm92ZXJCYWNrZ3JvdW5kXCIgb246Y2xpY2sgb246a2V5ZG93biBvbjprZXl1cCBvbjptb3VzZWRvd24gb246bW91c2V1cD5cbiAgICAgIDxJY29uQ3Jvc3NNZWRpdW0gZm9jdXNhYmxlPVwiZmFsc2VcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICAgIDwvQnV0dG9uPlxuICA8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSWNvbkluZm9NZWRpdW0sIEljb25BbGVydE1lZGl1bSwgSWNvblN1Y2Nlc3NNZWRpdW0sIEljb25IZWxwU21hbGwgfSBmcm9tIFwiQHJ1YnVzL3N2ZWx0ZS1zcGVjdHJ1bS1pY29ucy11aVwiO1xuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAvKipcbiAgICogIFNwZWNpZnkgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSB0b29sdGlwXG4gICAqIEB0eXBlIHtzdHJpbmd9IFtsYWJlbCA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGxhYmVsID0gXCJcIjtcblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgdmFyaWFudHMgIGZvciB0aGUgIHRvb2x0aXBcbiAgICogQHR5cGUge1wiZGVmYXVsdFwiIHwgXCJpbmZvXCIgfCBcIm5lZ2F0aXZlXCIgfCBcInBvc2l0aXZlXCIgfCBcImhlbHBcIiB9IFt2YXJpYW50cyA9IFwiZGVmYXVsdFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCB2YXJpYW50cyA9IFwiZGVmYXVsdFwiO1xuXG4gIC8qKlxuICAgKiAgU3BlY2lmeSB0aGUgb3BlbiBzdGF0dXMgZm9yIHRoZSB0b29sdGlwXG4gICAqIEB0eXBlIHtzdHJpbmd9IFtsYWJlbCA9IFwiXCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGlzT3BlbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBkaXJlY3Rpb25zICBmb3IgdGhlICB0b29sdGlwXG4gICAqIEB0eXBlIHtcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiIH0gW2RpcmVjdGlvbnMgPSBcInRvcFwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBkaXJlY3Rpb25zID0gXCJ0b3BcIjtcblxuICAvKipcbiAgICogIFNldCB0aGUgdHJpZ2dlciBldmVudCBuYW1lIHRvIG9wZW4gdGhlIHRvb2x0aXBcbiAgICogQHR5cGUge1wibW91c2VvdmVyXCIgfCBcIm1vdXNlZW50ZXJcIiB8IFwiY2xpY2tcIiB8IFwiY29udGV4dG1lbnVcIiB8IFwiZGJsY2xpY2tcIiB8IFwibW91c2Vkb3duXCIgfCBcIm1vdXNldXBcIiB8IFwic2VsZWN0XCIgfCBcImtleWRvd25cIiB8IFwia2V5cHJlc3NcIiB8IFwia2V5dXBcIn0gW2luZHVjZVN0YXJ0RXZlbnROYW1lID0gXCJtb3VzZW92ZXJcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgaW5kdWNlU3RhcnRFdmVudE5hbWUgPSBcIm1vdXNlb3ZlclwiO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyaWdnZXIgZXZlbnQgbmFtZSB0byBjbG9zZSB0aGUgdG9vbHRpcFxuICAgKiBAdHlwZSB7XCJtb3VzZW91dFwiIHwgXCJtb3VzZWxlYXZlXCIgfCBcImNsaWNrXCIgfCBcImNvbnRleHRtZW51XCIgfCBcImRibGNsaWNrXCIgfCBcIm1vdXNlZG93blwiIHwgXCJtb3VzZXVwXCIgfCBcInNlbGVjdFwiIHwgXCJrZXlkb3duXCIgfCBcImtleXByZXNzXCIgfCBcImtleXVwXCJ9IFtpbmR1Y2VFbmRFdmVudE5hbWUgPSBcIm1vdXNlb3V0XCJdXG4gICAqL1xuICBleHBvcnQgbGV0IGluZHVjZUVuZEV2ZW50TmFtZSA9IFwibW91c2VvdXRcIjtcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgY3NzIHdpZHRoXG4gICAqIEB0eXBlIHtEaW1lbnNpb25WYWx1ZX0gW3dpZHRoID0gXCJzaXplLTIwMDBcIl1cbiAgICovXG4gIGV4cG9ydCBsZXQgd2lkdGggPSBcInNpemUtMjAwMFwiO1xuXG4gIGxldCB0b29sdGlwRWw7XG4gIGxldCBzdHlsZVRleHQgPSBcIlwiO1xuICBsZXQgdG9vbHRpcENIO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGlmICh0b29sdGlwRWwpIHtcbiAgICAgIHRvb2x0aXBFbC5wYXJlbnROb2RlLmNsYXNzTGlzdC50b2dnbGUoXCJ1LXRvb2x0aXAtc2hvd09uRXZlbnRcIik7XG5cbiAgICAgIHRvb2x0aXBFbC5wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoaW5kdWNlU3RhcnRFdmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNPcGVuID0gIWlzT3BlbjtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZHVjZVN0YXJ0RXZlbnROYW1lICE9PSBpbmR1Y2VFbmRFdmVudE5hbWUpIHtcbiAgICAgICAgdG9vbHRpcEVsLnBhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihpbmR1Y2VFbmRFdmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNPcGVuKSBpc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgbGV0IHRvb2x0aXBXcmFwSGVpZ2h0ID0gdG9vbHRpcEVsLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0O1xuICAgIGxldCB0b29sdGlwV3JhcFdpZHRoID0gdG9vbHRpcEVsLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG4gICAgbGV0IHdpZHRoQ3NzID1cbiAgICAgIHdpZHRoICYmIHdpZHRoLnRvU3RyaW5nKCkuaW5kZXhPZihcInNpemVcIikgIT09IC0xXG4gICAgICAgID8gYHdpZHRoOnZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tJHt3aWR0aH0pO2BcbiAgICAgICAgOiB3aWR0aC50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpICE9PSAtMVxuICAgICAgICA/IGB3aWR0aDogJHt3aWR0aH07YFxuICAgICAgICA6IGB3aWR0aDogJHt3aWR0aH1weDtgO1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb25zKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHN0eWxlVGV4dCA9IGB0b3A6LSR7dG9vbHRpcENIICsgdG9vbHRpcFdyYXBIZWlnaHQgKiAwLjV9cHg7JHt3aWR0aENzc31gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgc3R5bGVUZXh0ID0gYHRvcDpjYWxjKHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS03NSkgKyAke3Rvb2x0aXBXcmFwSGVpZ2h0fXB4KTske3dpZHRoQ3NzfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgc3R5bGVUZXh0ID0gYGxlZnQ6Y2FsYygtMSAqIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS03NSkpOyR7d2lkdGhDc3N9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgc3R5bGVUZXh0ID0gYGxlZnQ6Y2FsYyh2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtNzUpICsgJHt0b29sdGlwV3JhcFdpZHRofXB4KTske3dpZHRoQ3NzfWA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWFuaW1hdGlvbi1kdXJhdGlvbi0xMDAsIDEzMG1zKSBlYXNlLWluLW91dDtcbiAgICB0b3A6IC0xMDAlO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC1sYWJlbCB7XG4gICAgbWF4LXdpZHRoOiBub25lO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tcmlnaHQsXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAtLWxlZnQge1xuICAgIHRvcDogNTAlO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tcmlnaHQgLnNwZWN0cnVtLVRvb2x0aXAtdGlwLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1sZWZ0IC5zcGVjdHJ1bS1Ub29sdGlwLXRpcCB7XG4gICAgdG9wOiA1MCU7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1yaWdodCB7XG4gICAgbGVmdDogMTAwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtNTAlKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAtLWxlZnQge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMDAlLCAtNTAlKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tdG9wIHtcbiAgICBsZWZ0OiA1MCU7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1ib3R0b20gLnNwZWN0cnVtLVRvb2x0aXAtdGlwLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS10b3AgLnNwZWN0cnVtLVRvb2x0aXAtdGlwIHtcbiAgICBsZWZ0OiA1MCU7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLS1ib3R0b20ge1xuICAgIHRvcDogMTAwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCBjYWxjKC0xICogdmFyKC0tc3BlY3RydW0tdG9vbHRpcC10aXAtbWFyZ2luLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtNTApKSkpO1xuICB9XG5cbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAuc3BlY3RydW0tVG9vbHRpcC0tdG9wIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCB2YXIoLS1zcGVjdHJ1bS10b29sdGlwLXRpcC1tYXJnaW4sIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS01MCkpKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAuaXMtb3BlbixcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudDpmb2N1cyAuc3BlY3RydW0tVG9vbHRpcCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50ICo6Zm9jdXMgLnNwZWN0cnVtLVRvb2x0aXAge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLmlzLW9wZW4uc3BlY3RydW0tVG9vbHRpcC0tYm90dG9tLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50OmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAqOmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWJvdHRvbSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCk7XG4gIH1cblxuICAudS10b29sdGlwLXNob3dPbkV2ZW50IC5zcGVjdHJ1bS1Ub29sdGlwLmlzLW9wZW4uc3BlY3RydW0tVG9vbHRpcC0tdG9wLFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50OmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXRvcCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXRvcCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudCAqOmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXRvcCB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgY2FsYygtMSAqIHZhcigtLXNwZWN0cnVtLXRvb2x0aXAtdGlwLW1hcmdpbiwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi1zaXplLTUwKSkpKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAuaXMtb3Blbi5zcGVjdHJ1bS1Ub29sdGlwLS1sZWZ0LFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50OmZvY3VzIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLWxlZnQsXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQuaXMtZm9jdXNlZCAuc3BlY3RydW0tVG9vbHRpcC5zcGVjdHJ1bS1Ub29sdGlwLS1sZWZ0LFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50ICo6Zm9jdXMgLnNwZWN0cnVtLVRvb2x0aXAuc3BlY3RydW0tVG9vbHRpcC0tbGVmdCB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoXG4gICAgICBjYWxjKC0xMDAlIC0gdmFyKC0tc3BlY3RydW0tdG9vbHRpcC10aXAtbWFyZ2luLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtNTApKSksXG4gICAgICAtNTAlXG4gICAgKTtcbiAgfVxuXG4gIC51LXRvb2x0aXAtc2hvd09uRXZlbnQgLnNwZWN0cnVtLVRvb2x0aXAuaXMtb3Blbi5zcGVjdHJ1bS1Ub29sdGlwLS1yaWdodCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudDpmb2N1cyAuc3BlY3RydW0tVG9vbHRpcC5zcGVjdHJ1bS1Ub29sdGlwLS1yaWdodCxcbiAgLnUtdG9vbHRpcC1zaG93T25FdmVudC5pcy1mb2N1c2VkIC5zcGVjdHJ1bS1Ub29sdGlwLnNwZWN0cnVtLVRvb2x0aXAtLXJpZ2h0LFxuICAudS10b29sdGlwLXNob3dPbkV2ZW50ICo6Zm9jdXMgLnNwZWN0cnVtLVRvb2x0aXAuc3BlY3RydW0tVG9vbHRpcC0tcmlnaHQge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXNwZWN0cnVtLXRvb2x0aXAtdGlwLW1hcmdpbiwgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWRpbWVuc2lvbi1zaXplLTUwKSksIC01MCUpO1xuICB9XG5cbiAgLnNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb24ge1xuICAgIHdpZHRoOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtMjI1KTtcbiAgICBoZWlnaHQ6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1kaW1lbnNpb24tc2l6ZS0yMjUpO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44KTtcbiAgfVxuICAuc3BlY3RydW0tVG9vbHRpcC0taGVscCA+IC5zcGVjdHJ1bS1Ub29sdGlwLXR5cGVJY29uLWhlbHAge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gIH1cbiAgLnNwZWN0cnVtLVRvb2x0aXAtbGFiZWwge1xuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XG4gIH1cbjwvc3R5bGU+XG5cbjxzcGFuXG4gIGNsYXNzPVwic3BlY3RydW0tVG9vbHRpcCBzcGVjdHJ1bS1Ub29sdGlwLS17dmFyaWFudHN9IHNwZWN0cnVtLVRvb2x0aXAtLXtkaXJlY3Rpb25zfSBcIlxuICBzdHlsZT17c3R5bGVUZXh0fVxuICBjbGFzczppcy1vcGVuPXtpc09wZW59XG4gIGJpbmQ6Y2xpZW50SGVpZ2h0PXt0b29sdGlwQ0h9XG4gIGJpbmQ6dGhpcz17dG9vbHRpcEVsfT5cbiAgeyNpZiB2YXJpYW50cyA9PT0gJ25lZ2F0aXZlJ31cbiAgICA8SWNvbkFsZXJ0TWVkaXVtIGNsYXNzTmFtZT1cInNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb25cIiBmb2N1c2FibGU9XCJmYWxzZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gIHs6ZWxzZSBpZiB2YXJpYW50cyA9PT0gJ2luZm8nfVxuICAgIDxJY29uSW5mb01lZGl1bSBjbGFzc05hbWU9XCJzcGVjdHJ1bS1Ub29sdGlwLXR5cGVJY29uXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICB7OmVsc2UgaWYgdmFyaWFudHMgPT09ICdwb3NpdGl2ZSd9XG4gICAgPEljb25TdWNjZXNzTWVkaXVtIGNsYXNzTmFtZT1cInNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb25cIiBmb2N1c2FibGU9XCJmYWxzZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gIHs6ZWxzZSBpZiB2YXJpYW50cyA9PT0gJ2hlbHAnfVxuICAgIDxJY29uSGVscFNtYWxsXG4gICAgICBjbGFzc05hbWU9XCJzcGVjdHJ1bS1Ub29sdGlwLXR5cGVJY29uIHNwZWN0cnVtLVRvb2x0aXAtdHlwZUljb24taGVscFwiXG4gICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuICB7L2lmfVxuICA8c3BhbiBjbGFzcz1cInNwZWN0cnVtLVRvb2x0aXAtbGFiZWxcIj48c2xvdD57bGFiZWx9PC9zbG90Pjwvc3Bhbj5cbiAgPHNwYW4gY2xhc3M9XCJzcGVjdHJ1bS1Ub29sdGlwLXRpcFwiIC8+XG48L3NwYW4+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBSYWRpbywgQ2hlY2tib3gsIFRvb2x0aXAsIFRvYXN0IH0gZnJvbSBcIkBydWJ1cy9ydWJ1cy9zcmNcIjtcbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBpbXBvcnQgKiBhcyBjb2xvckRhdGEgZnJvbSBcIi4vY29sb3IuanNvblwiO1xuXG4gIGxldCBjb2xvck1vZGVsID0gXCJoZXhcIjtcbiAgbGV0IHN0YXRpY0NvbG9yc1ZpZXcgPSBmYWxzZTtcbiAgbGV0IHJ1YnVzRG9jQ29uZmlnID0gZ2V0Q29udGV4dChcInJ1YnVzRG9jQ29uZmlnXCIpO1xuICBsZXQgY29sb3JEaXNwbGF5ID0gXCJnbG9iYWxDb2xvclwiO1xuXG4gIG9uTW91bnQoKCkgPT4ge30pO1xuICBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICBzdGF0aWNDb2xvcnNWaWV3ID0gIXN0YXRpY0NvbG9yc1ZpZXc7XG4gICAgY29sb3JEaXNwbGF5ID0gc3RhdGljQ29sb3JzVmlldyA/IFwic3RhdGljQ29sb3JcIiA6IFwiZ2xvYmFsQ29sb3JcIjtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNvcHlDb2xvcih0LCBjKSB7XG4gICAgaWYgKGNvbG9yTW9kZWwgIT09IFwiaGV4XCIpIHtcbiAgICAgIGMgPSBoZXhUb1JHQihjKTtcbiAgICB9XG4gICAgbGV0IGNvbG9yQ29kZSA9IHN0YXRpY0NvbG9yc1ZpZXdcbiAgICAgID8gYC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLXN0YXRpYy0ke3QucmVwbGFjZSgvW15hLXpBLVpdL2dpLCBcIlwiKS50b0xvd2VyQ2FzZSgpfS0ke3QucmVwbGFjZShcbiAgICAgICAgICAvW14wLTldL2dpLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKX06ICR7Y31gXG4gICAgICA6IGAtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci0ke3QucmVwbGFjZSgvW15hLXpBLVpdL2dpLCBcIlwiKS50b0xvd2VyQ2FzZSgpfS0ke3QucmVwbGFjZSgvW14wLTldL2dpLCBcIlwiKX06ICR7Y31gO1xuICAgIGlmIChuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb2xvckNvZGUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlBhZ2UgVVJMIGNvcGllZCB0byBjbGlwYm9hcmQ6XCIgKyBjb2xvckNvZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29weTogXCIsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhleFRvUkdCKGgpIHtcbiAgICBsZXQgciA9IDAsXG4gICAgICBnID0gMCxcbiAgICAgIGIgPSAwO1xuXG4gICAgLy8gMyBkaWdpdHNcbiAgICBpZiAoaC5sZW5ndGggPT0gNCkge1xuICAgICAgciA9IFwiMHhcIiArIGhbMV0gKyBoWzFdO1xuICAgICAgZyA9IFwiMHhcIiArIGhbMl0gKyBoWzJdO1xuICAgICAgYiA9IFwiMHhcIiArIGhbM10gKyBoWzNdO1xuXG4gICAgICAvLyA2IGRpZ2l0c1xuICAgIH0gZWxzZSBpZiAoaC5sZW5ndGggPT0gNykge1xuICAgICAgciA9IFwiMHhcIiArIGhbMV0gKyBoWzJdO1xuICAgICAgZyA9IFwiMHhcIiArIGhbM10gKyBoWzRdO1xuICAgICAgYiA9IFwiMHhcIiArIGhbNV0gKyBoWzZdO1xuICAgIH1cblxuICAgIHJldHVybiBcInJnYihcIiArICtyICsgXCIsXCIgKyArZyArIFwiLFwiICsgK2IgKyBcIilcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhleFRvSFNMKEgpIHtcbiAgICBsZXQgciA9IDAsXG4gICAgICBnID0gMCxcbiAgICAgIGIgPSAwO1xuICAgIGlmIChILmxlbmd0aCA9PSA0KSB7XG4gICAgICByID0gXCIweFwiICsgSFsxXSArIEhbMV07XG4gICAgICBnID0gXCIweFwiICsgSFsyXSArIEhbMl07XG4gICAgICBiID0gXCIweFwiICsgSFszXSArIEhbM107XG4gICAgfSBlbHNlIGlmIChILmxlbmd0aCA9PSA3KSB7XG4gICAgICByID0gXCIweFwiICsgSFsxXSArIEhbMl07XG4gICAgICBnID0gXCIweFwiICsgSFszXSArIEhbNF07XG4gICAgICBiID0gXCIweFwiICsgSFs1XSArIEhbNl07XG4gICAgfVxuICAgIC8vIFRoZW4gdG8gSFNMXG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgbGV0IGNtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIGNtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gY21heCAtIGNtaW4sXG4gICAgICBoID0gMCxcbiAgICAgIHMgPSAwLFxuICAgICAgbCA9IDA7XG5cbiAgICBpZiAoZGVsdGEgPT0gMCkgaCA9IDA7XG4gICAgZWxzZSBpZiAoY21heCA9PSByKSBoID0gKChnIC0gYikgLyBkZWx0YSkgJSA2O1xuICAgIGVsc2UgaWYgKGNtYXggPT0gZykgaCA9IChiIC0gcikgLyBkZWx0YSArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIGRlbHRhICsgNDtcblxuICAgIGggPSBNYXRoLnJvdW5kKGggKiA2MCk7XG5cbiAgICBpZiAoaCA8IDApIGggKz0gMzYwO1xuXG4gICAgbCA9IChjbWF4ICsgY21pbikgLyAyO1xuICAgIHMgPSBkZWx0YSA9PSAwID8gMCA6IGRlbHRhIC8gKDEgLSBNYXRoLmFicygyICogbCAtIDEpKTtcbiAgICBzID0gKyhzICogMTAwKS50b0ZpeGVkKDEpO1xuICAgIGwgPSArKGwgKiAxMDApLnRvRml4ZWQoMSk7XG5cbiAgICByZXR1cm4gW2gsIHMsIGxdO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlnaHRBbmREYXJrKGNvZGUpIHtcbiAgICBsZXQgWywgLCBsXSA9IGhleFRvSFNMKGNvZGUpO1xuICAgIGxldCBjcm9zc292ZXIgPSA1MDtcbiAgICBzd2l0Y2ggKCRydWJ1c0RvY0NvbmZpZy50aGVtZSkge1xuICAgICAgY2FzZSBcImxpZ2h0XCI6XG4gICAgICAgIGNyb3Nzb3ZlciA9IDYwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsaWdodGVzdFwiOlxuICAgICAgICBjcm9zc292ZXIgPSA3MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGFya1wiOlxuICAgICAgICBjcm9zc292ZXIgPSAzODtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGFya2VzdFwiOlxuICAgICAgICBjcm9zc292ZXIgPSAzNTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsID49IGNyb3Nzb3ZlciA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnRvb2xiYXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgd2lkdGg6IDMwMHB4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG4gIGZvcm0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gIH1cbiAgLnZlcnRpY2FsLWxpbmUge1xuICAgIHdpZHRoOiAxcHg7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNwZWN0cnVtLWFsaWFzLWJhY2tncm91bmQtY29sb3ItZGVmYXVsdCk7XG4gIH1cbiAgLmNvbG9yLW1vZGVsIHtcbiAgICB3aWR0aDogMTIwcHg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG4gIC5jb2xvci1jb250YWluZXIge1xuICAgIHBhZGRpbmc6IDhweDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3ItZ3JheS0xMDApO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1ncmF5LTMwMCk7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICB9XG4gIC5jb2xvci1ncm91cCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgbWF4LXdpZHRoOiA4MTZweDtcbiAgICBtYXJnaW46IGF1dG87XG4gICAgbWFyZ2luLWJvdHRvbTogMzBweDtcbiAgfVxuICAuY29sb3ItaXRlbSB7XG4gICAgZmxleC1iYXNpczogMjIlO1xuICAgIGhlaWdodDogMTAwcHg7XG4gICAgbWFyZ2luOiAxLjUlO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLWdyYXktMjAwKTtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTMwbXMgZWFzZS1pbi1vdXQ7XG4gIH1cbiAgLmNvbG9yLWl0ZW06aG92ZXIge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wOCk7XG4gIH1cbiAgLmNvbG9yLWl0ZW0tbmFtZSB7XG4gICAgZm9udC1zaXplOiAxMXB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxLjM7XG4gICAgbGV0dGVyLXNwYWNpbmc6IDAuMDNlbTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIG1hcmdpbi10b3A6IDA7XG4gICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgfVxuICAuY29sb3ItaXRlbS1jb2RlIHtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGxpbmUtaGVpZ2h0OiAxLjM7XG4gICAgZm9udC1zaXplOiAxM3B4O1xuICB9XG4gIC5jb2xvci1pdGVtLWxpZ2h0ID4gLmNvbG9yLWl0ZW0tbmFtZSB7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1zdGF0aWMtZ3JheS04MDApO1xuICB9XG4gIC5jb2xvci1pdGVtLWxpZ2h0ID4gLmNvbG9yLWl0ZW0tY29kZSB7XG4gICAgY29sb3I6IHZhcigtLXNwZWN0cnVtLWdsb2JhbC1jb2xvci1zdGF0aWMtZ3JheS05MDApO1xuICB9XG4gIC5jb2xvci1pdGVtLWRhcmsgPiAuY29sb3ItaXRlbS1uYW1lIHtcbiAgICBjb2xvcjogdmFyKC0tc3BlY3RydW0tZ2xvYmFsLWNvbG9yLXN0YXRpYy1ncmF5LTIwMCk7XG4gIH1cbiAgLmNvbG9yLWl0ZW0tZGFyayA+IC5jb2xvci1pdGVtLWNvZGUge1xuICAgIGNvbG9yOiB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtY29sb3Itc3RhdGljLWdyYXktMTAwKTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInRvb2xiYXJcIj5cbiAgPGZvcm0+XG4gICAgPENoZWNrYm94IGNoZWNrZWQ9e3N0YXRpY0NvbG9yc1ZpZXd9IG9uOmNsaWNrPXtoYW5kbGVDbGlja30+U3RhdGljIGNvbG9yczwvQ2hlY2tib3g+XG4gIDwvZm9ybT5cbiAgPGRpdiBjbGFzcz1cInZlcnRpY2FsLWxpbmVcIiAvPlxuICA8Zm9ybSBjbGFzcz1cImNvbG9yLW1vZGVsXCI+XG4gICAgPFJhZGlvXG4gICAgICB2YWx1ZT1cIkhleFwiXG4gICAgICBjaGVja2VkPXtjb2xvck1vZGVsID09ICdoZXgnfVxuICAgICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgICAgY29sb3JNb2RlbCA9ICdoZXgnO1xuICAgICAgfX0gLz5cbiAgICA8UmFkaW9cbiAgICAgIHZhbHVlPVwiUkdCXCJcbiAgICAgIGNoZWNrZWQ9e2NvbG9yTW9kZWwgPT0gJ3JnYid9XG4gICAgICBvbjpjbGljaz17KCkgPT4ge1xuICAgICAgICBjb2xvck1vZGVsID0gJ3JnYic7XG4gICAgICB9fSAvPlxuICA8L2Zvcm0+XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJjb2xvci1jb250YWluZXJcIj5cbiAgeyNlYWNoIGNvbG9yRGF0YVskcnVidXNEb2NDb25maWcudGhlbWVdW2NvbG9yRGlzcGxheV0gYXMgaXRlbXN9XG4gICAgPGRpdiBjbGFzcz1cImNvbG9yLWdyb3VwXCI+XG4gICAgICB7I2VhY2ggaXRlbXMgYXMgY29sb3JJdGVtfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgIGNvcHlDb2xvcihjb2xvckl0ZW0ubmFtZSwgY29sb3JJdGVtLmNvZGUpO1xuICAgICAgICAgIH19XG4gICAgICAgICAgY2xhc3M9XCJjb2xvci1pdGVtIHtsaWdodEFuZERhcmsoY29sb3JJdGVtLmNvZGUpID8gJ2NvbG9yLWl0ZW0tZGFyaycgOiAnY29sb3ItaXRlbS1saWdodCd9XCJcbiAgICAgICAgICBzdHlsZT17YGJhY2tncm91bmQtY29sb3I6JHtjb2xvck1vZGVsID09ICdoZXgnID8gY29sb3JJdGVtLmNvZGUudG9VcHBlckNhc2UoKSA6IGhleFRvUkdCKGNvbG9ySXRlbS5jb2RlKS50b1VwcGVyQ2FzZSgpfWB9PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2xvci1pdGVtLW5hbWVcIj57Y29sb3JJdGVtLm5hbWV9PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbG9yLWl0ZW0tY29kZVwiPlxuICAgICAgICAgICAge2NvbG9yTW9kZWwgPT0gJ2hleCcgPyBjb2xvckl0ZW0uY29kZS50b1VwcGVyQ2FzZSgpIDogaGV4VG9SR0IoY29sb3JJdGVtLmNvZGUpLnRvVXBwZXJDYXNlKCl9XG4gICAgICAgICAgICA8VG9vbHRpcCB3aWR0aD1cInNpemUtNjAwXCIgZGlyZWN0aW9ucz1cImJvdHRvbVwiIGxhYmVsPVwi5aSN5Yi2XCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuPFRvYXN0IGxhYmVsPVwi5aSN5Yi25oiQ5YqfXCIgdmFyaWFudHM9XCJzdWNjZXNzXCIgLz5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IFR5cG9ncmFwaHlIZWFkaW5nLCBUeXBvZ3JhcGh5Qm9keSB9IGZyb20gXCJAcnVidXMvcnVidXMvc3JjXCI7XG4gIGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCBDb2xvckNvbnRhaW5lciBmcm9tIFwiLi4vLi4vLi4vLi4vY29tcG9uZW50cy9jb2xvci1jb250YWluZXJcIjtcbiAgbGV0IHJ1YnVzRG9jQ29uZmlnID0gZ2V0Q29udGV4dChcInJ1YnVzRG9jQ29uZmlnXCIpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgaGVhZGVyIHtcbiAgICBtaW4taGVpZ2h0OiAxMjBweDtcbiAgfVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTpoZWFkPlxuICA8dGl0bGU+eyRydWJ1c0RvY0NvbmZpZy5uYW1lfSDpopzoibI8L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPGhlYWRlcj5cbiAgPFR5cG9ncmFwaHlIZWFkaW5nIHNjYWxlPVwiWExcIj7popzoibI8L1R5cG9ncmFwaHlIZWFkaW5nPlxuICA8VHlwb2dyYXBoeUJvZHkgc2NhbGU9XCJNXCI+5L2N5LqO6K6+6K6h57O757uf5Lit55qE6aKc6Imy5Luk54mMPC9UeXBvZ3JhcGh5Qm9keT5cbjwvaGVhZGVyPlxuXG48bWFpbj5cbiAgPENvbG9yQ29udGFpbmVyIC8+XG48L21haW4+XG4iXSwibmFtZXMiOlsiUmVzaXplT2JzZXJ2ZXIiLCJ0aHJvdHRsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBbUtXLEdBQU87bUNBU1AsR0FBYTs7Ozs7a0JBM0JoQixHQUFXOztxRUFDVyxHQUFXLEtBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttREFDeEIsR0FBUTs2REFDSCxHQUFhO21EQUNuQixHQUFTOytEQUNLLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBYWhDLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQVNQLEdBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREEzQmhCLEdBQVc7b0lBQ1csR0FBVyxLQUFDLEtBQUs7OzttREFDeEIsR0FBUTs2REFDSCxHQUFhO21EQUNuQixHQUFTOytEQUNLLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkE5QmhDLEdBQU87bUNBU1AsR0FBYTs7Ozs7OztrQkExQmhCLEdBQVc7OzhFQUNvQixHQUFXLEtBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21EQUNqQyxHQUFROzZEQUNILEdBQWE7bURBQ25CLEdBQVM7K0RBQ0ssR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFZaEMsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBU1AsR0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREExQmhCLEdBQVc7NklBQ29CLEdBQVcsS0FBQyxLQUFLOzs7bURBQ2pDLEdBQVE7NkRBQ0gsR0FBYTttREFDbkIsR0FBUzsrREFDSyxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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SSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDckIsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7UUFHaEIsTUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRzs7O1NBR3ZDLFFBQVEsQ0FBQyxDQUFDO0tBQ2IsQ0FBQyxHQUFHLENBQUMsRUFDUCxDQUFDLEdBQUcsQ0FBQyxFQUNMLENBQUMsR0FBRyxDQUFDOztLQUNILENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQztFQUNmLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUNyQixDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDckIsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ1osQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDO0VBQ3RCLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUNyQixDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDckIsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7O0NBR3ZCLENBQUMsSUFBSSxHQUFHOztDQUNSLENBQUMsSUFBSSxHQUFHO0NBQ1IsQ0FBQyxJQUFJLEdBQUc7O0tBQ0osSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0VBQ3pCLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztFQUN2QixLQUFLLEdBQUcsSUFBSSxHQUFHLElB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
