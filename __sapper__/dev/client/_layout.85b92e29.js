import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as create_slot, v as validate_slots, e as element, c as claim_element, a as children, f as detach_dev, h as add_location, j as insert_dev, y as update_slot, r as transition_in, u as transition_out, z as afterUpdate, A as current_component, B as getEventsAction, t as text, b as claim_text, l as set_data_dev, C as space, D as claim_space, g as attr_dev, E as toggle_class, k as append_dev, F as action_destroyer, G as binding_callbacks, H as stores$1, I as validate_store, J as component_subscribe, K as globals, L as validate_each_argument, m as create_component, p as claim_component, q as mount_component, w as destroy_component, M as empty, N as group_outros, O as check_outros, P as destroy_each, n as noop } from './client.9d3d0048.js';

/* node_modules/@rubus/rubus/src/packages/SideNav/SideNav.svelte generated by Svelte v3.29.4 */

const file = "node_modules/@rubus/rubus/src/packages/SideNav/SideNav.svelte";

function create_fragment(ctx) {
	let nav;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	const block = {
		c: function create() {
			nav = element("nav");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			if (default_slot) default_slot.l(nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(nav, file, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);

			if (default_slot) {
				default_slot.m(nav, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SideNav", slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SideNav> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class SideNav extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SideNav",
			options,
			id: create_fragment.name
		});
	}
}

/* node_modules/@rubus/rubus/src/packages/SideNav/SideNavItem.svelte generated by Svelte v3.29.4 */
const file$1 = "node_modules/@rubus/rubus/src/packages/SideNav/SideNavItem.svelte";
const get_sidenav_child_slot_changes = dirty => ({});
const get_sidenav_child_slot_context = ctx => ({});

// (46:88) {label}
function fallback_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[0]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*label*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(46:88) {label}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let li;
	let a;
	let a_aria_current_value;
	let t;
	let eventsListen_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);
	const sidenav_child_slot_template = /*#slots*/ ctx[7]["sidenav-child"];
	const sidenav_child_slot = create_slot(sidenav_child_slot_template, ctx, /*$$scope*/ ctx[6], get_sidenav_child_slot_context);

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			if (sidenav_child_slot) sidenav_child_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", {
				href: true,
				class: true,
				"aria-current": true
			});

			var a_nodes = children(a);
			if (default_slot_or_fallback) default_slot_or_fallback.l(a_nodes);
			a_nodes.forEach(detach_dev);
			t = claim_space(li_nodes);
			if (sidenav_child_slot) sidenav_child_slot.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", /*href*/ ctx[3]);
			attr_dev(a, "class", "spectrum-SideNav-itemLink");
			attr_dev(a, "aria-current", a_aria_current_value = /*isSelected*/ ctx[1] && "page");
			add_location(a, file$1, 45, 2, 1176);
			attr_dev(li, "class", "spectrum-SideNav-item");
			toggle_class(li, "is-selected", /*isSelected*/ ctx[1]);
			toggle_class(li, "is-disabled", /*disabled*/ ctx[2]);
			add_location(li, file$1, 39, 0, 1026);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(a, null);
			}

			append_dev(li, t);

			if (sidenav_child_slot) {
				sidenav_child_slot.m(li, null);
			}

			/*li_binding*/ ctx[8](li);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(eventsListen_action = /*eventsListen*/ ctx[5].call(null, li));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 1) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*href*/ 8) {
				attr_dev(a, "href", /*href*/ ctx[3]);
			}

			if (!current || dirty & /*isSelected*/ 2 && a_aria_current_value !== (a_aria_current_value = /*isSelected*/ ctx[1] && "page")) {
				attr_dev(a, "aria-current", a_aria_current_value);
			}

			if (sidenav_child_slot) {
				if (sidenav_child_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(sidenav_child_slot, sidenav_child_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_sidenav_child_slot_changes, get_sidenav_child_slot_context);
				}
			}

			if (dirty & /*isSelected*/ 2) {
				toggle_class(li, "is-selected", /*isSelected*/ ctx[1]);
			}

			if (dirty & /*disabled*/ 4) {
				toggle_class(li, "is-disabled", /*disabled*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			transition_in(sidenav_child_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			transition_out(sidenav_child_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (sidenav_child_slot) sidenav_child_slot.d(detaching);
			/*li_binding*/ ctx[8](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SideNavItem", slots, ['default','sidenav-child']);
	let { label = "" } = $$props;
	let { isSelected = false } = $$props;
	let { disabled = false } = $$props;
	let { href = "#" } = $$props;
	let sideNavItemEl;
	const eventsListen = getEventsAction(current_component);

	afterUpdate(() => {
		if (sideNavItemEl && sideNavItemEl.getElementsByTagName("svg").length) {
			let sideNavItemIcon = sideNavItemEl && sideNavItemEl.getElementsByTagName("svg")[0];
			sideNavItemIcon.classList.toggle("spectrum-SideNav-itemIcon");
		}
	});

	const writable_props = ["label", "isSelected", "disabled", "href"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SideNavItem> was created with unknown prop '${key}'`);
	});

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			sideNavItemEl = $$value;
			$$invalidate(4, sideNavItemEl);
		});
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("isSelected" in $$props) $$invalidate(1, isSelected = $$props.isSelected);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("href" in $$props) $$invalidate(3, href = $$props.href);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		current_component,
		getEventsAction,
		label,
		isSelected,
		disabled,
		href,
		sideNavItemEl,
		eventsListen
	});

	$$self.$inject_state = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("isSelected" in $$props) $$invalidate(1, isSelected = $$props.isSelected);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("href" in $$props) $$invalidate(3, href = $$props.href);
		if ("sideNavItemEl" in $$props) $$invalidate(4, sideNavItemEl = $$props.sideNavItemEl);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		label,
		isSelected,
		disabled,
		href,
		sideNavItemEl,
		eventsListen,
		$$scope,
		slots,
		li_binding
	];
}

class SideNavItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			label: 0,
			isSelected: 1,
			disabled: 2,
			href: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SideNavItem",
			options,
			id: create_fragment$1.name
		});
	}

	get label() {
		throw new Error("<SideNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<SideNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isSelected() {
		throw new Error("<SideNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isSelected(value) {
		throw new Error("<SideNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<SideNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<SideNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<SideNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<SideNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@rubus/rubus/src/packages/SideNav/SideNavGroup.svelte generated by Svelte v3.29.4 */

const file$2 = "node_modules/@rubus/rubus/src/packages/SideNav/SideNavGroup.svelte";

// (21:0) {#if title}
function create_if_block(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(/*title*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true, id: true });
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "spectrum-SideNav-heading");
			attr_dev(h2, "id", /*id*/ ctx[2]);
			add_location(h2, file$2, 21, 2, 505);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data_dev(t, /*title*/ ctx[1]);

			if (dirty & /*id*/ 4) {
				attr_dev(h2, "id", /*id*/ ctx[2]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(21:0) {#if title}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let t;
	let ul;
	let ul_aria_labelledby_value;
	let current;
	let if_block = /*title*/ ctx[1] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			ul = element("ul");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true, "aria-labelledby": true });
			var ul_nodes = children(ul);
			if (default_slot) default_slot.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "spectrum-SideNav");
			attr_dev(ul, "aria-labelledby", ul_aria_labelledby_value = /*title*/ ctx[1] && /*id*/ ctx[2]);
			toggle_class(ul, "spectrum-SideNav--multiLevel", /*multiLevel*/ ctx[0]);
			add_location(ul, file$2, 24, 0, 567);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*title*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*title, id*/ 6 && ul_aria_labelledby_value !== (ul_aria_labelledby_value = /*title*/ ctx[1] && /*id*/ ctx[2])) {
				attr_dev(ul, "aria-labelledby", ul_aria_labelledby_value);
			}

			if (dirty & /*multiLevel*/ 1) {
				toggle_class(ul, "spectrum-SideNav--multiLevel", /*multiLevel*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SideNavGroup", slots, ['default']);
	let { multiLevel = false } = $$props;
	let { title = "" } = $$props;
	let { id = `nav-heading-${Math.round(Math.random() * (99999 - 0)) + 0}` } = $$props;
	const writable_props = ["multiLevel", "title", "id"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SideNavGroup> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("multiLevel" in $$props) $$invalidate(0, multiLevel = $$props.multiLevel);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ multiLevel, title, id });

	$$self.$inject_state = $$props => {
		if ("multiLevel" in $$props) $$invalidate(0, multiLevel = $$props.multiLevel);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [multiLevel, title, id, $$scope, slots];
}

class SideNavGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { multiLevel: 0, title: 1, id: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SideNavGroup",
			options,
			id: create_fragment$2.name
		});
	}

	get multiLevel() {
		throw new Error("<SideNavGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiLevel(value) {
		throw new Error("<SideNavGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<SideNavGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<SideNavGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<SideNavGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<SideNavGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/nav-menu/navMenu.svelte generated by Svelte v3.29.4 */

const { console: console_1 } = globals;
const file$3 = "src/components/nav-menu/navMenu.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

// (44:10) <SideNavItem href={_router.url} isSelected={_router.url.replace('./', '').indexOf('color')}>
function create_default_slot_2(ctx) {
	let t_value = /*_router*/ ctx[6].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(44:10) <SideNavItem href={_router.url} isSelected={_router.url.replace('./', '').indexOf('color')}>",
		ctx
	});

	return block;
}

// (43:8) {#each item.router as _router}
function create_each_block_1(ctx) {
	let sidenavitem;
	let current;

	sidenavitem = new SideNavItem({
			props: {
				href: /*_router*/ ctx[6].url,
				isSelected: /*_router*/ ctx[6].url.replace("./", "").indexOf("color"),
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(sidenavitem.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(sidenavitem.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(sidenavitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sidenavitem_changes = {};

			if (dirty & /*$$scope*/ 512) {
				sidenavitem_changes.$$scope = { dirty, ctx };
			}

			sidenavitem.$set(sidenavitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sidenavitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sidenavitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sidenavitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(43:8) {#each item.router as _router}",
		ctx
	});

	return block;
}

// (42:6) <SideNavGroup title={item.title}>
function create_default_slot_1(ctx) {
	let t;
	let current;
	let each_value_1 = /*item*/ ctx[3].router;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*routers*/ 2) {
				each_value_1 = /*item*/ ctx[3].router;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t.parentNode, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(42:6) <SideNavGroup title={item.title}>",
		ctx
	});

	return block;
}

// (41:4) {#each routers as item, i}
function create_each_block(ctx) {
	let sidenavgroup;
	let current;

	sidenavgroup = new SideNavGroup({
			props: {
				title: /*item*/ ctx[3].title,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(sidenavgroup.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(sidenavgroup.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(sidenavgroup, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sidenavgroup_changes = {};

			if (dirty & /*$$scope*/ 512) {
				sidenavgroup_changes.$$scope = { dirty, ctx };
			}

			sidenavgroup.$set(sidenavgroup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sidenavgroup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sidenavgroup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sidenavgroup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(41:4) {#each routers as item, i}",
		ctx
	});

	return block;
}

// (40:2) <SideNav>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*routers*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*routers*/ 2) {
				each_value = /*routers*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(40:2) <SideNav>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let nav;
	let sidenav;
	let current;

	sidenav = new SideNav({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			create_component(sidenav.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(sidenav.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-7zrp5u");
			add_location(nav, file$3, 38, 0, 721);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			mount_component(sidenav, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const sidenav_changes = {};

			if (dirty & /*$$scope*/ 512) {
				sidenav_changes.$$scope = { dirty, ctx };
			}

			sidenav.$set(sidenav_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sidenav.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sidenav.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(sidenav);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $page;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NavMenu", slots, []);
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(2, $page = value));

	let routers = [
		{
			title: "Token",
			router: [
				{
					url: "./docs/csstokens/color",
					name: "颜色"
				},
				{ url: "csstokens", name: "尺寸" }
			]
		},
		{
			title: "Asset",
			router: [{ url: "Token", name: "图标" }, { url: "Token", name: "插画" }]
		},
		{
			title: "Basic",
			router: [{ url: "Token", name: "Button 按钮" }, { url: "Token", name: "Link 链接" }]
		}
	];

	console.log($page.path);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<NavMenu> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		SideNav,
		SideNavGroup,
		SideNavItem,
		stores: stores$1,
		page,
		routers,
		$page
	});

	$$self.$inject_state = $$props => {
		if ("routers" in $$props) $$invalidate(1, routers = $$props.routers);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [page, routers];
}

class NavMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavMenu",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/docs/_layout.svelte generated by Svelte v3.29.4 */
const file$4 = "src/routes/docs/_layout.svelte";

function create_fragment$4(ctx) {
	let navmenu;
	let t;
	let div;
	let current;
	navmenu = new NavMenu({ $$inline: true });
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			create_component(navmenu.$$.fragment);
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			claim_component(navmenu.$$.fragment, nodes);
			t = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "content svelte-6krwl2");
			add_location(div, file$4, 17, 0, 287);
		},
		m: function mount(target, anchor) {
			mount_component(navmenu, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navmenu.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navmenu.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navmenu, detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Layout", slots, ['default']);
	let { segment } = $$props;
	const writable_props = ["segment"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ NavMenu, segment });

	$$self.$inject_state = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [segment, $$scope, slots];
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { segment: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*segment*/ ctx[0] === undefined && !("segment" in props)) {
			console.warn("<Layout> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Layout;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2xheW91dC44NWI5MmUyOS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BydWJ1cy9ydWJ1cy9zcmMvcGFja2FnZXMvU2lkZU5hdi9TaWRlTmF2SXRlbS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJ1YnVzL3J1YnVzL3NyYy9wYWNrYWdlcy9TaWRlTmF2L1NpZGVOYXZHcm91cC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9uYXYtbWVudS9uYXZNZW51LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9fbGF5b3V0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gIGltcG9ydCB7IGdldEV2ZW50c0FjdGlvbiB9IGZyb20gXCIuLi91dGlscy9nZXQtZXZlbnRzLWFjdGlvbi5qc1wiO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsYWJlbCB0ZXh0IG9mIFNpZGVOYXYgaXRlbVxuICAgKiBAdHlwZSB7IHN0cmluZyB9WyB0aXRsZSA9IFwiXCIgXVxuICAgKi9cbiAgZXhwb3J0IGxldCBsYWJlbCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIFNpZGVOYXYgaXRlbSBpcyBzZWxlY3RlZFxuICAgKiBAdHlwZSB7IGJvb2xlYW4gfVsgaXNTZWxlY3RlZCA9IGZhbHNlIF1cbiAgICovXG4gIGV4cG9ydCBsZXQgaXNTZWxlY3RlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIHRvIGRpc2FibGUgdGhlICBTaWRlTmF2IGl0ZW1cbiAgICogQHR5cGUge2Jvb2xlYW59IFtkaXNhYmxlZD1mYWxzZV1cbiAgICovXG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IHRoZSBgaHJlZmAgdG8gdXNlIGFuIGFuY2hvciBsaW5rXG4gICAqIEB0eXBlIHtzdHJpbmd9W2hyZWYgPSBcIlwiXVxuICAgKi9cbiAgZXhwb3J0IGxldCBocmVmID0gXCIjXCI7XG5cbiAgbGV0IHNpZGVOYXZJdGVtRWw7XG4gIGNvbnN0IGV2ZW50c0xpc3RlbiA9IGdldEV2ZW50c0FjdGlvbihjdXJyZW50X2NvbXBvbmVudCk7XG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAoc2lkZU5hdkl0ZW1FbCAmJiBzaWRlTmF2SXRlbUVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpLmxlbmd0aCkge1xuICAgICAgbGV0IHNpZGVOYXZJdGVtSWNvbiA9IHNpZGVOYXZJdGVtRWwgJiYgc2lkZU5hdkl0ZW1FbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICAgIHNpZGVOYXZJdGVtSWNvbi5jbGFzc0xpc3QudG9nZ2xlKFwic3BlY3RydW0tU2lkZU5hdi1pdGVtSWNvblwiKTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxsaVxuICBjbGFzcz1cInNwZWN0cnVtLVNpZGVOYXYtaXRlbVwiXG4gIGNsYXNzOmlzLXNlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICBjbGFzczppcy1kaXNhYmxlZD17ZGlzYWJsZWR9XG4gIGJpbmQ6dGhpcz17c2lkZU5hdkl0ZW1FbH1cbiAgdXNlOmV2ZW50c0xpc3Rlbj5cbiAgPGEge2hyZWZ9IGNsYXNzPVwic3BlY3RydW0tU2lkZU5hdi1pdGVtTGlua1wiIGFyaWEtY3VycmVudD17aXNTZWxlY3RlZCAmJiAncGFnZSd9PjxzbG90PntsYWJlbH08L3Nsb3Q+PC9hPlxuICA8c2xvdCBuYW1lPVwic2lkZW5hdi1jaGlsZFwiIC8+XG48L2xpPlxuIiwiPHNjcmlwdD5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlICBtdWx0aUxldmVsIG1vZGUgIG9mIFNpZGVOYXZcbiAgICogQHR5cGUgeyBib29sZWFuIH1bbXVsdGlMZXZlbCA9IGZhbHNlXVxuICAgKi9cbiAgZXhwb3J0IGxldCBtdWx0aUxldmVsID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGhlYWRpbmcgdGl0bGUgb2YgU2lkZU5hdlxuICAgKiBAdHlwZSB7IHN0cmluZyB9WyB0aXRsZSA9IFwiXCIgXVxuICAgKi9cbiAgZXhwb3J0IGxldCB0aXRsZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGVtZW50J3MgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAqIEB0eXBlIHsgc3RyaW5nIH1bIGlkID0gYG5hdi1oZWFkaW5nLSR7TWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDk5OTk5IC0gMCkpICsgMH0gXVxuICAgKi9cbiAgZXhwb3J0IGxldCBpZCA9IGBuYXYtaGVhZGluZy0ke01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICg5OTk5OSAtIDApKSArIDB9YDtcbjwvc2NyaXB0PlxuXG57I2lmIHRpdGxlfVxuICA8aDIgY2xhc3M9XCJzcGVjdHJ1bS1TaWRlTmF2LWhlYWRpbmdcIiB7aWR9Pnt0aXRsZX08L2gyPlxuey9pZn1cblxuPHVsIGNsYXNzPVwic3BlY3RydW0tU2lkZU5hdlwiIGNsYXNzOnNwZWN0cnVtLVNpZGVOYXYtLW11bHRpTGV2ZWw9e211bHRpTGV2ZWx9IGFyaWEtbGFiZWxsZWRieT17dGl0bGUgJiYgaWR9PlxuICA8c2xvdCAvPlxuPC91bD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IFNpZGVOYXYsIFNpZGVOYXZHcm91cCwgU2lkZU5hdkl0ZW0gfSBmcm9tIFwiQHJ1YnVzL3J1YnVzL3NyY1wiO1xuICBpbXBvcnQgeyBzdG9yZXMgfSBmcm9tIFwiQHNhcHBlci9hcHBcIjtcbiAgY29uc3QgeyBwYWdlIH0gPSBzdG9yZXMoKTtcblxuICBsZXQgcm91dGVycyA9IFtcbiAgICB7XG4gICAgICB0aXRsZTogXCJUb2tlblwiLFxuICAgICAgcm91dGVyOiBbXG4gICAgICAgIHsgdXJsOiBcIi4vZG9jcy9jc3N0b2tlbnMvY29sb3JcIiwgbmFtZTogXCLpopzoibJcIiB9LFxuICAgICAgICB7IHVybDogXCJjc3N0b2tlbnNcIiwgbmFtZTogXCLlsLrlr7hcIiB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiBcIkFzc2V0XCIsXG4gICAgICByb3V0ZXI6IFtcbiAgICAgICAgeyB1cmw6IFwiVG9rZW5cIiwgbmFtZTogXCLlm77moIdcIiB9LFxuICAgICAgICB7IHVybDogXCJUb2tlblwiLCBuYW1lOiBcIuaPkueUu1wiIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6IFwiQmFzaWNcIixcbiAgICAgIHJvdXRlcjogW1xuICAgICAgICB7IHVybDogXCJUb2tlblwiLCBuYW1lOiBcIkJ1dHRvbiDmjInpkq5cIiB9LFxuICAgICAgICB7IHVybDogXCJUb2tlblwiLCBuYW1lOiBcIkxpbmsg6ZO+5o6lXCIgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgXTtcbiAgY29uc29sZS5sb2coJHBhZ2UucGF0aCk7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBuYXYge1xuICAgIHdpZHRoOiAyMDBweDtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICB9XG48L3N0eWxlPlxuXG48bmF2PlxuICA8U2lkZU5hdj5cbiAgICB7I2VhY2ggcm91dGVycyBhcyBpdGVtLCBpfVxuICAgICAgPFNpZGVOYXZHcm91cCB0aXRsZT17aXRlbS50aXRsZX0+XG4gICAgICAgIHsjZWFjaCBpdGVtLnJvdXRlciBhcyBfcm91dGVyfVxuICAgICAgICAgIDxTaWRlTmF2SXRlbSBocmVmPXtfcm91dGVyLnVybH0gaXNTZWxlY3RlZD17X3JvdXRlci51cmwucmVwbGFjZSgnLi8nLCAnJykuaW5kZXhPZignY29sb3InKX0+XG4gICAgICAgICAgICB7X3JvdXRlci5uYW1lfVxuICAgICAgICAgIDwvU2lkZU5hdkl0ZW0+XG4gICAgICAgIHsvZWFjaH1cbiAgICAgIDwvU2lkZU5hdkdyb3VwPlxuICAgIHsvZWFjaH1cbiAgPC9TaWRlTmF2PlxuPC9uYXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBOYXZNZW51IH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudHNcIjtcblxuICBleHBvcnQgbGV0IHNlZ21lbnQ7XG4gIHNlZ21lbnQ7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAuY29udGVudCB7XG4gICAgd2lkdGg6IDEwMDBweDtcblxuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwZWN0cnVtLXNpZGVuYXYtaGVhZGluZy1nYXAtdG9wLCB2YXIoLS1zcGVjdHJ1bS1nbG9iYWwtZGltZW5zaW9uLXNpemUtMjAwKSk7XG4gIH1cbjwvc3R5bGU+XG5cbjxOYXZNZW51IC8+XG48ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICA8c2xvdCAvPlxuPC9kaXY+XG4iXSwibmFtZXMiOlsic3RvcmVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBNkN5RixHQUFLOzs7bUNBQUwsR0FBSzs7Ozs7O3NEQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxRUFBbEMsR0FBVSxPQUFJLE1BQU07OztrREFKM0QsR0FBVTtnREFDVixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytHQUcrQixHQUFVLE9BQUksTUFBTTs7Ozs7Ozs7Ozs7bURBSjNELEdBQVU7Ozs7aURBQ1YsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FqQ2hCLEtBQUssR0FBRyxFQUFFO09BTVYsVUFBVSxHQUFHLEtBQUs7T0FNbEIsUUFBUSxHQUFHLEtBQUs7T0FNaEIsSUFBSSxHQUFHLEdBQUc7S0FF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
